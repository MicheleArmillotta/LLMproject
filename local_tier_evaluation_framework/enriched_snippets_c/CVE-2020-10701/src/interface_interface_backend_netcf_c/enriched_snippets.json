[
  {
    "function_name": "netcfIfaceRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "1245-1254",
    "snippet": "int netcfIfaceRegister(void)\n{\n    if (virRegisterConnectDriver(&interfaceConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedInterfaceDriver(&interfaceDriver) < 0)\n        return -1;\n    if (virRegisterStateDriver(&interfaceStateDriver) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virInterfaceDriver interfaceDriver = {\n    .name = INTERFACE_DRIVER_NAME,\n    .connectNumOfInterfaces = netcfConnectNumOfInterfaces, /* 0.7.0 */\n    .connectListInterfaces = netcfConnectListInterfaces, /* 0.7.0 */\n    .connectNumOfDefinedInterfaces = netcfConnectNumOfDefinedInterfaces, /* 0.7.0 */\n    .connectListDefinedInterfaces = netcfConnectListDefinedInterfaces, /* 0.7.0 */\n    .connectListAllInterfaces = netcfConnectListAllInterfaces, /* 0.10.2 */\n    .interfaceLookupByName = netcfInterfaceLookupByName, /* 0.7.0 */\n    .interfaceLookupByMACString = netcfInterfaceLookupByMACString, /* 0.7.0 */\n    .interfaceGetXMLDesc = netcfInterfaceGetXMLDesc, /* 0.7.0 */\n    .interfaceDefineXML = netcfInterfaceDefineXML, /* 0.7.0 */\n    .interfaceUndefine = netcfInterfaceUndefine, /* 0.7.0 */\n    .interfaceCreate = netcfInterfaceCreate, /* 0.7.0 */\n    .interfaceDestroy = netcfInterfaceDestroy, /* 0.7.0 */\n    .interfaceIsActive = netcfInterfaceIsActive, /* 0.7.3 */\n    .interfaceChangeBegin = netcfInterfaceChangeBegin, /* 0.9.2 */\n    .interfaceChangeCommit = netcfInterfaceChangeCommit, /* 0.9.2 */\n    .interfaceChangeRollback = netcfInterfaceChangeRollback, /* 0.9.2 */\n};",
      "static virConnectDriver interfaceConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"interface\", NULL },\n    .hypervisorDriver = &interfaceHypervisorDriver,\n    .interfaceDriver = &interfaceDriver,\n};",
      "static virStateDriver interfaceStateDriver = {\n    .name = INTERFACE_DRIVER_NAME,\n    .stateInitialize = netcfStateInitialize,\n    .stateCleanup = netcfStateCleanup,\n    .stateReload = netcfStateReload,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterStateDriver",
          "args": [
            "&interfaceStateDriver"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterStateDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "588-602",
          "snippet": "int\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetSharedInterfaceDriver",
          "args": [
            "&interfaceDriver"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSharedInterfaceDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "383-398",
          "snippet": "int\nvirSetSharedInterfaceDriver(virInterfaceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedInterfaceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A interface driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as interface driver\", driver->name);\n\n    virSharedInterfaceDriver = driver;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virInterfaceDriverPtr virSharedInterfaceDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\n\nint\nvirSetSharedInterfaceDriver(virInterfaceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedInterfaceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A interface driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as interface driver\", driver->name);\n\n    virSharedInterfaceDriver = driver;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&interfaceConnectDriver",
            "false"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virInterfaceDriver interfaceDriver = {\n    .name = INTERFACE_DRIVER_NAME,\n    .connectNumOfInterfaces = netcfConnectNumOfInterfaces, /* 0.7.0 */\n    .connectListInterfaces = netcfConnectListInterfaces, /* 0.7.0 */\n    .connectNumOfDefinedInterfaces = netcfConnectNumOfDefinedInterfaces, /* 0.7.0 */\n    .connectListDefinedInterfaces = netcfConnectListDefinedInterfaces, /* 0.7.0 */\n    .connectListAllInterfaces = netcfConnectListAllInterfaces, /* 0.10.2 */\n    .interfaceLookupByName = netcfInterfaceLookupByName, /* 0.7.0 */\n    .interfaceLookupByMACString = netcfInterfaceLookupByMACString, /* 0.7.0 */\n    .interfaceGetXMLDesc = netcfInterfaceGetXMLDesc, /* 0.7.0 */\n    .interfaceDefineXML = netcfInterfaceDefineXML, /* 0.7.0 */\n    .interfaceUndefine = netcfInterfaceUndefine, /* 0.7.0 */\n    .interfaceCreate = netcfInterfaceCreate, /* 0.7.0 */\n    .interfaceDestroy = netcfInterfaceDestroy, /* 0.7.0 */\n    .interfaceIsActive = netcfInterfaceIsActive, /* 0.7.3 */\n    .interfaceChangeBegin = netcfInterfaceChangeBegin, /* 0.9.2 */\n    .interfaceChangeCommit = netcfInterfaceChangeCommit, /* 0.9.2 */\n    .interfaceChangeRollback = netcfInterfaceChangeRollback, /* 0.9.2 */\n};\nstatic virConnectDriver interfaceConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"interface\", NULL },\n    .hypervisorDriver = &interfaceHypervisorDriver,\n    .interfaceDriver = &interfaceDriver,\n};\nstatic virStateDriver interfaceStateDriver = {\n    .name = INTERFACE_DRIVER_NAME,\n    .stateInitialize = netcfStateInitialize,\n    .stateCleanup = netcfStateCleanup,\n    .stateReload = netcfStateReload,\n};\n\nint netcfIfaceRegister(void)\n{\n    if (virRegisterConnectDriver(&interfaceConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedInterfaceDriver(&interfaceDriver) < 0)\n        return -1;\n    if (virRegisterStateDriver(&interfaceStateDriver) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "netcfInterfaceChangeRollback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "1174-1197",
    "snippet": "static int netcfInterfaceChangeRollback(virConnectPtr conn, unsigned int flags)\n{\n    int ret;\n\n    virCheckFlags(0, -1); /* currently flags must be 0 */\n\n    if (virInterfaceChangeRollbackEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    ret = ncf_change_rollback(driver->netcf, 0);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to rollback transaction: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to rollback transaction: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to rollback transaction: %s%s%s\""
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_change_rollback",
          "args": [
            "driver->netcf",
            "0"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceChangeRollbackEnsureACL",
          "args": [
            "conn"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceChangeRollback(virConnectPtr conn, unsigned int flags)\n{\n    int ret;\n\n    virCheckFlags(0, -1); /* currently flags must be 0 */\n\n    if (virInterfaceChangeRollbackEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    ret = ncf_change_rollback(driver->netcf, 0);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to rollback transaction: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceChangeCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "1149-1172",
    "snippet": "static int netcfInterfaceChangeCommit(virConnectPtr conn, unsigned int flags)\n{\n    int ret;\n\n    virCheckFlags(0, -1); /* currently flags must be 0 */\n\n    if (virInterfaceChangeCommitEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    ret = ncf_change_commit(driver->netcf, 0);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to commit transaction: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to commit transaction: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to commit transaction: %s%s%s\""
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_change_commit",
          "args": [
            "driver->netcf",
            "0"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceChangeCommitEnsureACL",
          "args": [
            "conn"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceChangeCommit(virConnectPtr conn, unsigned int flags)\n{\n    int ret;\n\n    virCheckFlags(0, -1); /* currently flags must be 0 */\n\n    if (virInterfaceChangeCommitEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    ret = ncf_change_commit(driver->netcf, 0);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to commit transaction: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceChangeBegin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "1124-1147",
    "snippet": "static int netcfInterfaceChangeBegin(virConnectPtr conn, unsigned int flags)\n{\n    int ret;\n\n    virCheckFlags(0, -1); /* currently flags must be 0 */\n\n    if (virInterfaceChangeBeginEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    ret = ncf_change_begin(driver->netcf, 0);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to begin transaction: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to begin transaction: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to begin transaction: %s%s%s\""
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_change_begin",
          "args": [
            "driver->netcf",
            "0"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceChangeBeginEnsureACL",
          "args": [
            "conn"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceChangeBegin(virConnectPtr conn, unsigned int flags)\n{\n    int ret;\n\n    virCheckFlags(0, -1); /* currently flags must be 0 */\n\n    if (virInterfaceChangeBeginEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    ret = ncf_change_begin(driver->netcf, 0);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to begin transaction: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "1091-1122",
    "snippet": "static int netcfInterfaceIsActive(virInterfacePtr ifinfo)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n    bool active;\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceIsActiveEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n        goto cleanup;\n\n    ret = active ? 1 : 0;\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfInterfaceObjIsActive",
          "args": [
            "iface",
            "&active"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "netcfInterfaceObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "328-352",
          "snippet": "static int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceIsActiveEnsureACL",
          "args": [
            "ifinfo->conn",
            "def"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceDriverGetNetcfIF",
          "args": [
            "driver->netcf",
            "ifinfo"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "interfaceDriverGetNetcfIF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "305-326",
          "snippet": "static struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceIsActive(virInterfacePtr ifinfo)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n    bool active;\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceIsActiveEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n        goto cleanup;\n\n    ret = active ? 1 : 0;\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "1039-1089",
    "snippet": "static int netcfInterfaceDestroy(virInterfacePtr ifinfo,\n                                 unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n    bool active;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceDestroyEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n        goto cleanup;\n\n    if (!active) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"interface is not running\"));\n        goto cleanup;\n    }\n\n    ret = ncf_if_down(iface);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to destroy (stop) interface %s: %s%s%s\"),\n                       ifinfo->name, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to destroy (stop) interface %s: %s%s%s\")",
            "ifinfo->name",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to destroy (stop) interface %s: %s%s%s\""
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_down",
          "args": [
            "iface"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"interface is not running\")"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfInterfaceObjIsActive",
          "args": [
            "iface",
            "&active"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "netcfInterfaceObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "328-352",
          "snippet": "static int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDestroyEnsureACL",
          "args": [
            "ifinfo->conn",
            "def"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceDriverGetNetcfIF",
          "args": [
            "driver->netcf",
            "ifinfo"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "interfaceDriverGetNetcfIF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "305-326",
          "snippet": "static struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceDestroy(virInterfacePtr ifinfo,\n                                 unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n    bool active;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceDestroyEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n        goto cleanup;\n\n    if (!active) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"interface is not running\"));\n        goto cleanup;\n    }\n\n    ret = ncf_if_down(iface);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to destroy (stop) interface %s: %s%s%s\"),\n                       ifinfo->name, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "987-1037",
    "snippet": "static int netcfInterfaceCreate(virInterfacePtr ifinfo,\n                                unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n    bool active;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceCreateEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n        goto cleanup;\n\n    if (active) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"interface is already running\"));\n        goto cleanup;\n    }\n\n    ret = ncf_if_up(iface);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to create (start) interface %s: %s%s%s\"),\n                       ifinfo->name, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to create (start) interface %s: %s%s%s\")",
            "ifinfo->name",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to create (start) interface %s: %s%s%s\""
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_up",
          "args": [
            "iface"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"interface is already running\")"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfInterfaceObjIsActive",
          "args": [
            "iface",
            "&active"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "netcfInterfaceObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "328-352",
          "snippet": "static int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceCreateEnsureACL",
          "args": [
            "ifinfo->conn",
            "def"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceDriverGetNetcfIF",
          "args": [
            "driver->netcf",
            "ifinfo"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "interfaceDriverGetNetcfIF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "305-326",
          "snippet": "static struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceCreate(virInterfacePtr ifinfo,\n                                unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n    bool active;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceCreateEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n        goto cleanup;\n\n    if (active) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"interface is already running\"));\n        goto cleanup;\n    }\n\n    ret = ncf_if_up(iface);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to create (start) interface %s: %s%s%s\"),\n                       ifinfo->name, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "948-985",
    "snippet": "static int netcfInterfaceUndefine(virInterfacePtr ifinfo)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceUndefineEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    ret = ncf_if_undefine(iface);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to undefine interface %s: %s%s%s\"),\n                       ifinfo->name, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to undefine interface %s: %s%s%s\")",
            "ifinfo->name",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to undefine interface %s: %s%s%s\""
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_undefine",
          "args": [
            "iface"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceUndefineEnsureACL",
          "args": [
            "ifinfo->conn",
            "def"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceDriverGetNetcfIF",
          "args": [
            "driver->netcf",
            "ifinfo"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "interfaceDriverGetNetcfIF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "305-326",
          "snippet": "static struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfInterfaceUndefine(virInterfacePtr ifinfo)\n{\n    struct netcf_if *iface = NULL;\n    virInterfaceDefPtr def = NULL;\n    int ret = -1;\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceUndefineEnsureACL(ifinfo->conn, def) < 0)\n       goto cleanup;\n\n    ret = ncf_if_undefine(iface);\n    if (ret < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to undefine interface %s: %s%s%s\"),\n                       ifinfo->name, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "899-946",
    "snippet": "static virInterfacePtr netcfInterfaceDefineXML(virConnectPtr conn,\n                                               const char *xml,\n                                               unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    char *xmlstr = NULL;\n    virInterfaceDefPtr ifacedef = NULL;\n    virInterfacePtr ret = NULL;\n\n    virCheckFlags(0, NULL);\n\n    virObjectLock(driver);\n\n    ifacedef = virInterfaceDefParseString(xml);\n    if (!ifacedef) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n    if (virInterfaceDefineXMLEnsureACL(conn, ifacedef) < 0)\n        goto cleanup;\n\n    xmlstr = virInterfaceDefFormat(ifacedef);\n    if (!xmlstr) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n    iface = ncf_define(driver->netcf, xmlstr);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"could not get interface XML description: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    ret = virGetInterface(conn, ncf_if_name(iface), ncf_if_mac_string(iface));\n\n cleanup:\n    ncf_if_free(iface);\n    VIR_FREE(xmlstr);\n    virInterfaceDefFree(ifacedef);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "ifacedef"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "ncf_if_name(iface)",
            "ncf_if_mac_string(iface)"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_mac_string",
          "args": [
            "iface"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_name",
          "args": [
            "iface"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"could not get interface XML description: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get interface XML description: %s%s%s\""
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_define",
          "args": [
            "driver->netcf",
            "xmlstr"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFormat",
          "args": [
            "ifacedef"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1130-1140",
          "snippet": "char *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nchar *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefineXMLEnsureACL",
          "args": [
            "conn",
            "ifacedef"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseString",
          "args": [
            "xml"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "855-859",
          "snippet": "virInterfaceDefPtr\nvirInterfaceDefParseString(const char *xmlStr)\n{\n    return virInterfaceDefParse(xmlStr, NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirInterfaceDefPtr\nvirInterfaceDefParseString(const char *xmlStr)\n{\n    return virInterfaceDefParse(xmlStr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic virInterfacePtr netcfInterfaceDefineXML(virConnectPtr conn,\n                                               const char *xml,\n                                               unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    char *xmlstr = NULL;\n    virInterfaceDefPtr ifacedef = NULL;\n    virInterfacePtr ret = NULL;\n\n    virCheckFlags(0, NULL);\n\n    virObjectLock(driver);\n\n    ifacedef = virInterfaceDefParseString(xml);\n    if (!ifacedef) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n    if (virInterfaceDefineXMLEnsureACL(conn, ifacedef) < 0)\n        goto cleanup;\n\n    xmlstr = virInterfaceDefFormat(ifacedef);\n    if (!xmlstr) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n    iface = ncf_define(driver->netcf, xmlstr);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"could not get interface XML description: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    ret = virGetInterface(conn, ncf_if_name(iface), ncf_if_mac_string(iface));\n\n cleanup:\n    ncf_if_free(iface);\n    VIR_FREE(xmlstr);\n    virInterfaceDefFree(ifacedef);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "839-897",
    "snippet": "static char *netcfInterfaceGetXMLDesc(virInterfacePtr ifinfo,\n                                      unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    char *xmlstr = NULL;\n    virInterfaceDefPtr ifacedef = NULL;\n    char *ret = NULL;\n    bool active;\n\n    virCheckFlags(VIR_INTERFACE_XML_INACTIVE, NULL);\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n       goto cleanup;\n\n    if ((flags & VIR_INTERFACE_XML_INACTIVE) || !active) {\n        xmlstr = ncf_if_xml_desc(iface);\n    } else {\n        xmlstr = ncf_if_xml_state(iface);\n    }\n    if (!xmlstr) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"could not get interface XML description: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    ifacedef = virInterfaceDefParseString(xmlstr);\n    if (!ifacedef) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n    if (virInterfaceGetXMLDescEnsureACL(ifinfo->conn, ifacedef) < 0)\n        goto cleanup;\n\n    ret = virInterfaceDefFormat(ifacedef);\n    if (!ret) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    VIR_FREE(xmlstr);\n    virInterfaceDefFree(ifacedef);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "ifacedef"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlstr"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFormat",
          "args": [
            "ifacedef"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1130-1140",
          "snippet": "char *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nchar *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceGetXMLDescEnsureACL",
          "args": [
            "ifinfo->conn",
            "ifacedef"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefParseString",
          "args": [
            "xmlstr"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "855-859",
          "snippet": "virInterfaceDefPtr\nvirInterfaceDefParseString(const char *xmlStr)\n{\n    return virInterfaceDefParse(xmlStr, NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirInterfaceDefPtr\nvirInterfaceDefParseString(const char *xmlStr)\n{\n    return virInterfaceDefParse(xmlStr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"could not get interface XML description: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get interface XML description: %s%s%s\""
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_xml_state",
          "args": [
            "iface"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_xml_desc",
          "args": [
            "iface"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfInterfaceObjIsActive",
          "args": [
            "iface",
            "&active"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "netcfInterfaceObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "328-352",
          "snippet": "static int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interfaceDriverGetNetcfIF",
          "args": [
            "driver->netcf",
            "ifinfo"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "interfaceDriverGetNetcfIF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "305-326",
          "snippet": "static struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_INTERFACE_XML_INACTIVE",
            "NULL"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic char *netcfInterfaceGetXMLDesc(virInterfacePtr ifinfo,\n                                      unsigned int flags)\n{\n    struct netcf_if *iface = NULL;\n    char *xmlstr = NULL;\n    virInterfaceDefPtr ifacedef = NULL;\n    char *ret = NULL;\n    bool active;\n\n    virCheckFlags(VIR_INTERFACE_XML_INACTIVE, NULL);\n\n    virObjectLock(driver);\n\n    iface = interfaceDriverGetNetcfIF(driver->netcf, ifinfo);\n    if (!iface) {\n        /* helper already reported error */\n        goto cleanup;\n    }\n\n    if (netcfInterfaceObjIsActive(iface, &active) < 0)\n       goto cleanup;\n\n    if ((flags & VIR_INTERFACE_XML_INACTIVE) || !active) {\n        xmlstr = ncf_if_xml_desc(iface);\n    } else {\n        xmlstr = ncf_if_xml_state(iface);\n    }\n    if (!xmlstr) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"could not get interface XML description: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    ifacedef = virInterfaceDefParseString(xmlstr);\n    if (!ifacedef) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n    if (virInterfaceGetXMLDescEnsureACL(ifinfo->conn, ifacedef) < 0)\n        goto cleanup;\n\n    ret = virInterfaceDefFormat(ifacedef);\n    if (!ret) {\n        /* error was already reported */\n        goto cleanup;\n    }\n\n cleanup:\n    ncf_if_free(iface);\n    VIR_FREE(xmlstr);\n    virInterfaceDefFree(ifacedef);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceLookupByMACString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "791-837",
    "snippet": "static virInterfacePtr netcfInterfaceLookupByMACString(virConnectPtr conn,\n                                                       const char *macstr)\n{\n    struct netcf_if *iface;\n    int niface;\n    virInterfacePtr ret = NULL;\n    virInterfaceDefPtr def = NULL;\n\n    virObjectLock(driver);\n    niface = ncf_lookup_by_mac_string(driver->netcf, macstr, 1, &iface);\n\n    if (niface < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"couldn't find interface with MAC address '%s': %s%s%s\"),\n                       macstr, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n    if (niface == 0) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface with MAC address '%s'\"),\n                       macstr);\n        goto cleanup;\n    }\n    if (niface > 1) {\n        virReportError(VIR_ERR_MULTIPLE_INTERFACES,\n                       \"%s\", _(\"multiple interfaces with matching MAC address\"));\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceLookupByMACStringEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "def->name",
            "def->mac"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLookupByMACStringEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_MULTIPLE_INTERFACES",
            "\"%s\"",
            "_(\"multiple interfaces with matching MAC address\")"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"multiple interfaces with matching MAC address\""
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface with MAC address '%s'\")",
            "macstr"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"couldn't find interface with MAC address '%s': %s%s%s\")",
            "macstr",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_lookup_by_mac_string",
          "args": [
            "driver->netcf",
            "macstr",
            "1",
            "&iface"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic virInterfacePtr netcfInterfaceLookupByMACString(virConnectPtr conn,\n                                                       const char *macstr)\n{\n    struct netcf_if *iface;\n    int niface;\n    virInterfacePtr ret = NULL;\n    virInterfaceDefPtr def = NULL;\n\n    virObjectLock(driver);\n    niface = ncf_lookup_by_mac_string(driver->netcf, macstr, 1, &iface);\n\n    if (niface < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"couldn't find interface with MAC address '%s': %s%s%s\"),\n                       macstr, errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n    if (niface == 0) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"couldn't find interface with MAC address '%s'\"),\n                       macstr);\n        goto cleanup;\n    }\n    if (niface > 1) {\n        virReportError(VIR_ERR_MULTIPLE_INTERFACES,\n                       \"%s\", _(\"multiple interfaces with matching MAC address\"));\n        goto cleanup;\n    }\n\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceLookupByMACStringEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "752-789",
    "snippet": "static virInterfacePtr netcfInterfaceLookupByName(virConnectPtr conn,\n                                                  const char *name)\n{\n    struct netcf_if *iface;\n    virInterfacePtr ret = NULL;\n    virInterfaceDefPtr def = NULL;\n\n    virObjectLock(driver);\n    iface = ncf_lookup_by_name(driver->netcf, name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           name, errmsg,\n                           details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"), name);\n        }\n        goto cleanup;\n    }\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceLookupByNameEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "def->name",
            "def->mac"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLookupByNameEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface named '%s'\")",
            "name"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s'\""
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"couldn't find interface named '%s': %s%s%s\")",
            "name",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_lookup_by_name",
          "args": [
            "driver->netcf",
            "name"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic virInterfacePtr netcfInterfaceLookupByName(virConnectPtr conn,\n                                                  const char *name)\n{\n    struct netcf_if *iface;\n    virInterfacePtr ret = NULL;\n    virInterfaceDefPtr def = NULL;\n\n    virObjectLock(driver);\n    iface = ncf_lookup_by_name(driver->netcf, name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           name, errmsg,\n                           details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"), name);\n        }\n        goto cleanup;\n    }\n\n    if (!(def = netcfGetMinimalDefForDevice(iface)))\n        goto cleanup;\n\n    if (virInterfaceLookupByNameEnsureACL(conn, def) < 0)\n       goto cleanup;\n\n    ret = virGetInterface(conn, def->name, def->mac);\n\n cleanup:\n    ncf_if_free(iface);\n    virInterfaceDefFree(def);\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfConnectListAllInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "611-749",
    "snippet": "static int\nnetcfConnectListAllInterfaces(virConnectPtr conn,\n                              virInterfacePtr **ifaces,\n                              unsigned int flags)\n{\n    int count;\n    size_t i;\n    unsigned int ncf_flags = 0;\n    struct netcf_if *iface = NULL;\n    virInterfacePtr *tmp_iface_objs = NULL;\n    virInterfacePtr iface_obj = NULL;\n    int niface_objs = 0;\n    int ret = -1;\n    char **names = NULL;\n\n    virCheckFlags(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE, -1);\n\n    if (virConnectListAllInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    /* let netcf pre-filter for this flag to save time */\n    if (MATCH(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE)) {\n        if (MATCH(VIR_CONNECT_LIST_INTERFACES_ACTIVE))\n            ncf_flags |= NETCF_IFACE_ACTIVE;\n        if (MATCH(VIR_CONNECT_LIST_INTERFACES_INACTIVE))\n            ncf_flags |= NETCF_IFACE_INACTIVE;\n    } else {\n        ncf_flags = NETCF_IFACE_ACTIVE | NETCF_IFACE_INACTIVE;\n    }\n\n    if ((count = ncf_num_of_interfaces(driver->netcf, ncf_flags)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count,\n                                     names, ncf_flags)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (ifaces && VIR_ALLOC_N(tmp_iface_objs, count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface)))\n            goto cleanup;\n\n        if (!virConnectListAllInterfacesCheckACL(conn, def)) {\n            ncf_if_free(iface);\n            iface = NULL;\n            virInterfaceDefFree(def);\n            continue;\n        }\n\n        if (ifaces) {\n            if (!(iface_obj = virGetInterface(conn, def->name, def->mac))) {\n                virInterfaceDefFree(def);\n                goto cleanup;\n            }\n            tmp_iface_objs[niface_objs] = iface_obj;\n        }\n        niface_objs++;\n\n        virInterfaceDefFree(def);\n        ncf_if_free(iface);\n        iface = NULL;\n    }\n\n    if (tmp_iface_objs) {\n        /* trim the array to the final size */\n        ignore_value(VIR_REALLOC_N(tmp_iface_objs, niface_objs + 1));\n        *ifaces = tmp_iface_objs;\n        tmp_iface_objs = NULL;\n    }\n\n    ret = niface_objs;\n\n cleanup:\n    ncf_if_free(iface);\n\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n\n    if (tmp_iface_objs) {\n        for (i = 0; i < niface_objs; i++)\n            virObjectUnref(tmp_iface_objs[i]);\n        VIR_FREE(tmp_iface_objs);\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp_iface_objs"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "tmp_iface_objs[i]"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "VIR_REALLOC_N(tmp_iface_objs, niface_objs + 1)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp_iface_objs",
            "niface_objs + 1"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "def->name",
            "def->mac"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectListAllInterfacesCheckACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\"",
            "names[i]"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"couldn't find interface named '%s': %s%s%s\")",
            "names[i]",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s': %s%s%s\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_lookup_by_name",
          "args": [
            "driver->netcf",
            "names[i]"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "tmp_iface_objs",
            "count + 1"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to list host interfaces: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_list_interfaces",
          "args": [
            "driver->netcf",
            "count",
            "names",
            "ncf_flags"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "names",
            "count"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to get number of host interfaces: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_num_of_interfaces",
          "args": [
            "driver->netcf",
            "ncf_flags"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_INACTIVE"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_ACTIVE"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListAllInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE",
            "-1"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfConnectListAllInterfaces(virConnectPtr conn,\n                              virInterfacePtr **ifaces,\n                              unsigned int flags)\n{\n    int count;\n    size_t i;\n    unsigned int ncf_flags = 0;\n    struct netcf_if *iface = NULL;\n    virInterfacePtr *tmp_iface_objs = NULL;\n    virInterfacePtr iface_obj = NULL;\n    int niface_objs = 0;\n    int ret = -1;\n    char **names = NULL;\n\n    virCheckFlags(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE, -1);\n\n    if (virConnectListAllInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n\n    /* let netcf pre-filter for this flag to save time */\n    if (MATCH(VIR_CONNECT_LIST_INTERFACES_FILTERS_ACTIVE)) {\n        if (MATCH(VIR_CONNECT_LIST_INTERFACES_ACTIVE))\n            ncf_flags |= NETCF_IFACE_ACTIVE;\n        if (MATCH(VIR_CONNECT_LIST_INTERFACES_INACTIVE))\n            ncf_flags |= NETCF_IFACE_INACTIVE;\n    } else {\n        ncf_flags = NETCF_IFACE_ACTIVE | NETCF_IFACE_INACTIVE;\n    }\n\n    if ((count = ncf_num_of_interfaces(driver->netcf, ncf_flags)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count,\n                                     names, ncf_flags)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (ifaces && VIR_ALLOC_N(tmp_iface_objs, count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface)))\n            goto cleanup;\n\n        if (!virConnectListAllInterfacesCheckACL(conn, def)) {\n            ncf_if_free(iface);\n            iface = NULL;\n            virInterfaceDefFree(def);\n            continue;\n        }\n\n        if (ifaces) {\n            if (!(iface_obj = virGetInterface(conn, def->name, def->mac))) {\n                virInterfaceDefFree(def);\n                goto cleanup;\n            }\n            tmp_iface_objs[niface_objs] = iface_obj;\n        }\n        niface_objs++;\n\n        virInterfaceDefFree(def);\n        ncf_if_free(iface);\n        iface = NULL;\n    }\n\n    if (tmp_iface_objs) {\n        /* trim the array to the final size */\n        ignore_value(VIR_REALLOC_N(tmp_iface_objs, niface_objs + 1));\n        *ifaces = tmp_iface_objs;\n        tmp_iface_objs = NULL;\n    }\n\n    ret = niface_objs;\n\n cleanup:\n    ncf_if_free(iface);\n\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n\n    if (tmp_iface_objs) {\n        for (i = 0; i < niface_objs; i++)\n            virObjectUnref(tmp_iface_objs[i]);\n        VIR_FREE(tmp_iface_objs);\n    }\n\n    virObjectUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "netcfConnectListDefinedInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "593-608",
    "snippet": "static int netcfConnectListDefinedInterfaces(virConnectPtr conn, char **const names, int nnames)\n{\n    int count;\n\n    if (virConnectListDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectListInterfacesImpl(conn,\n                                           NETCF_IFACE_INACTIVE,\n                                           names, nnames,\n                                           virConnectListDefinedInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netcfConnectListInterfacesImpl",
          "args": [
            "conn",
            "NETCF_IFACE_INACTIVE",
            "names",
            "nnames",
            "virConnectListDefinedInterfacesCheckACL"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "netcfConnectListInterfacesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "446-543",
          "snippet": "static int netcfConnectListInterfacesImpl(virConnectPtr conn,\n                                          int status,\n                                          char **const names, int nnames,\n                                          virInterfaceObjListFilter filter)\n{\n    int count = 0;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **allnames = NULL;\n\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(allnames, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, allnames, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count && want < nnames; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, allnames[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               allnames[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", allnames[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        names[want++] = allnames[i];\n        allnames[i] = NULL;\n    }\n\n    ret = want;\n\n cleanup:\n    if (allnames && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(allnames[i]);\n    VIR_FREE(allnames);\n    if (ret < 0) {\n        for (i = 0; i < nnames; i++)\n            VIR_FREE(names[i]);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectListInterfacesImpl(virConnectPtr conn,\n                                          int status,\n                                          char **const names, int nnames,\n                                          virInterfaceObjListFilter filter)\n{\n    int count = 0;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **allnames = NULL;\n\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(allnames, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, allnames, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count && want < nnames; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, allnames[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               allnames[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", allnames[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        names[want++] = allnames[i];\n        allnames[i] = NULL;\n    }\n\n    ret = want;\n\n cleanup:\n    if (allnames && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(allnames[i]);\n    VIR_FREE(allnames);\n    if (ret < 0) {\n        for (i = 0; i < nnames; i++)\n            VIR_FREE(names[i]);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListDefinedInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectListDefinedInterfaces(virConnectPtr conn, char **const names, int nnames)\n{\n    int count;\n\n    if (virConnectListDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectListInterfacesImpl(conn,\n                                           NETCF_IFACE_INACTIVE,\n                                           names, nnames,\n                                           virConnectListDefinedInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n\n}"
  },
  {
    "function_name": "netcfConnectNumOfDefinedInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "578-591",
    "snippet": "static int netcfConnectNumOfDefinedInterfaces(virConnectPtr conn)\n{\n    int count;\n\n    if (virConnectNumOfDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectNumOfInterfacesImpl(conn,\n                                            NETCF_IFACE_INACTIVE,\n                                            virConnectNumOfDefinedInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netcfConnectNumOfInterfacesImpl",
          "args": [
            "conn",
            "NETCF_IFACE_INACTIVE",
            "virConnectNumOfDefinedInterfacesCheckACL"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "netcfConnectNumOfInterfacesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "354-443",
          "snippet": "static int netcfConnectNumOfInterfacesImpl(virConnectPtr conn,\n                                           int status,\n                                           virInterfaceObjListFilter filter)\n{\n    int count;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **names = NULL;\n\n    /* List all interfaces, in case we might support new filter flags\n     * beyond active|inactive in future.\n     */\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, names, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        want++;\n    }\n\n    ret = want;\n\n cleanup:\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectNumOfInterfacesImpl(virConnectPtr conn,\n                                           int status,\n                                           virInterfaceObjListFilter filter)\n{\n    int count;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **names = NULL;\n\n    /* List all interfaces, in case we might support new filter flags\n     * beyond active|inactive in future.\n     */\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, names, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        want++;\n    }\n\n    ret = want;\n\n cleanup:\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNumOfDefinedInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectNumOfDefinedInterfaces(virConnectPtr conn)\n{\n    int count;\n\n    if (virConnectNumOfDefinedInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectNumOfInterfacesImpl(conn,\n                                            NETCF_IFACE_INACTIVE,\n                                            virConnectNumOfDefinedInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n}"
  },
  {
    "function_name": "netcfConnectListInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "561-576",
    "snippet": "static int netcfConnectListInterfaces(virConnectPtr conn, char **const names, int nnames)\n{\n    int count;\n\n    if (virConnectListInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectListInterfacesImpl(conn,\n                                           NETCF_IFACE_ACTIVE,\n                                           names, nnames,\n                                           virConnectListInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netcfConnectListInterfacesImpl",
          "args": [
            "conn",
            "NETCF_IFACE_ACTIVE",
            "names",
            "nnames",
            "virConnectListInterfacesCheckACL"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "netcfConnectListInterfacesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "446-543",
          "snippet": "static int netcfConnectListInterfacesImpl(virConnectPtr conn,\n                                          int status,\n                                          char **const names, int nnames,\n                                          virInterfaceObjListFilter filter)\n{\n    int count = 0;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **allnames = NULL;\n\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(allnames, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, allnames, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count && want < nnames; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, allnames[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               allnames[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", allnames[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        names[want++] = allnames[i];\n        allnames[i] = NULL;\n    }\n\n    ret = want;\n\n cleanup:\n    if (allnames && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(allnames[i]);\n    VIR_FREE(allnames);\n    if (ret < 0) {\n        for (i = 0; i < nnames; i++)\n            VIR_FREE(names[i]);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectListInterfacesImpl(virConnectPtr conn,\n                                          int status,\n                                          char **const names, int nnames,\n                                          virInterfaceObjListFilter filter)\n{\n    int count = 0;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **allnames = NULL;\n\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(allnames, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, allnames, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count && want < nnames; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, allnames[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               allnames[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", allnames[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        names[want++] = allnames[i];\n        allnames[i] = NULL;\n    }\n\n    ret = want;\n\n cleanup:\n    if (allnames && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(allnames[i]);\n    VIR_FREE(allnames);\n    if (ret < 0) {\n        for (i = 0; i < nnames; i++)\n            VIR_FREE(names[i]);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectListInterfaces(virConnectPtr conn, char **const names, int nnames)\n{\n    int count;\n\n    if (virConnectListInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectListInterfacesImpl(conn,\n                                           NETCF_IFACE_ACTIVE,\n                                           names, nnames,\n                                           virConnectListInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n\n}"
  },
  {
    "function_name": "netcfConnectNumOfInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "546-559",
    "snippet": "static int netcfConnectNumOfInterfaces(virConnectPtr conn)\n{\n    int count;\n\n    if (virConnectNumOfInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectNumOfInterfacesImpl(conn,\n                                            NETCF_IFACE_ACTIVE,\n                                            virConnectNumOfInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netcfConnectNumOfInterfacesImpl",
          "args": [
            "conn",
            "NETCF_IFACE_ACTIVE",
            "virConnectNumOfInterfacesCheckACL"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "netcfConnectNumOfInterfacesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "354-443",
          "snippet": "static int netcfConnectNumOfInterfacesImpl(virConnectPtr conn,\n                                           int status,\n                                           virInterfaceObjListFilter filter)\n{\n    int count;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **names = NULL;\n\n    /* List all interfaces, in case we might support new filter flags\n     * beyond active|inactive in future.\n     */\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, names, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        want++;\n    }\n\n    ret = want;\n\n cleanup:\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetcfDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectNumOfInterfacesImpl(virConnectPtr conn,\n                                           int status,\n                                           virInterfaceObjListFilter filter)\n{\n    int count;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **names = NULL;\n\n    /* List all interfaces, in case we might support new filter flags\n     * beyond active|inactive in future.\n     */\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, names, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        want++;\n    }\n\n    ret = want;\n\n cleanup:\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNumOfInterfacesEnsureACL",
          "args": [
            "conn"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectNumOfInterfaces(virConnectPtr conn)\n{\n    int count;\n\n    if (virConnectNumOfInterfacesEnsureACL(conn) < 0)\n        return -1;\n\n    virObjectLock(driver);\n    count = netcfConnectNumOfInterfacesImpl(conn,\n                                            NETCF_IFACE_ACTIVE,\n                                            virConnectNumOfInterfacesCheckACL);\n    virObjectUnlock(driver);\n    return count;\n}"
  },
  {
    "function_name": "netcfConnectListInterfacesImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "446-543",
    "snippet": "static int netcfConnectListInterfacesImpl(virConnectPtr conn,\n                                          int status,\n                                          char **const names, int nnames,\n                                          virInterfaceObjListFilter filter)\n{\n    int count = 0;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **allnames = NULL;\n\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(allnames, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, allnames, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count && want < nnames; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, allnames[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               allnames[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", allnames[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        names[want++] = allnames[i];\n        allnames[i] = NULL;\n    }\n\n    ret = want;\n\n cleanup:\n    if (allnames && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(allnames[i]);\n    VIR_FREE(allnames);\n    if (ret < 0) {\n        for (i = 0; i < nnames; i++)\n            VIR_FREE(names[i]);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "allnames"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "allnames[i]"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "conn",
            "def"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_nwfilter_binding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_dispatch.c",
          "lines": "7368-7373",
          "snippet": "static void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}",
          "includes": [
            "#include \"lxc_daemon_dispatch_stubs.h\"",
            "#include \"qemu_daemon_dispatch_stubs.h\"",
            "#include \"remote_daemon_dispatch_stubs.h\"",
            "#include \"access/viraccessapicheck.h\"",
            "#include \"configmake.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virpolkit.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virprobe.h\"",
            "#include \"network_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"object_event.h\"",
            "#include \"virstring.h\"",
            "#include \"lxc_protocol.h\"",
            "#include \"qemu_protocol.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"virprocess.h\"",
            "#include \"virdbus.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virnetserverservice.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc_daemon_dispatch_stubs.h\"\n#include \"qemu_daemon_dispatch_stubs.h\"\n#include \"remote_daemon_dispatch_stubs.h\"\n#include \"access/viraccessapicheck.h\"\n#include \"configmake.h\"\n#include \"virthreadjob.h\"\n#include \"virpolkit.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virprobe.h\"\n#include \"network_conf.h\"\n#include \"domain_conf.h\"\n#include \"object_event.h\"\n#include \"virstring.h\"\n#include \"lxc_protocol.h\"\n#include \"qemu_protocol.h\"\n#include \"remote_protocol.h\"\n#include \"virprocess.h\"\n#include \"virdbus.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virnetserver.h\"\n#include \"virnetserverservice.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"remote_daemon_stream.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"libvirt_internal.h\"\n#include \"remote_daemon.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);\n\nstatic void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\"",
            "allnames[i]"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"couldn't find interface named '%s': %s%s%s\")",
            "allnames[i]",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s': %s%s%s\""
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_lookup_by_name",
          "args": [
            "driver->netcf",
            "allnames[i]"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to list host interfaces: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_list_interfaces",
          "args": [
            "driver->netcf",
            "count",
            "allnames",
            "status"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "allnames",
            "count"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to get number of host interfaces: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_num_of_interfaces",
          "args": [
            "driver->netcf",
            "status"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectListInterfacesImpl(virConnectPtr conn,\n                                          int status,\n                                          char **const names, int nnames,\n                                          virInterfaceObjListFilter filter)\n{\n    int count = 0;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **allnames = NULL;\n\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(allnames, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, allnames, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count && want < nnames; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, allnames[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               allnames[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", allnames[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        names[want++] = allnames[i];\n        allnames[i] = NULL;\n    }\n\n    ret = want;\n\n cleanup:\n    if (allnames && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(allnames[i]);\n    VIR_FREE(allnames);\n    if (ret < 0) {\n        for (i = 0; i < nnames; i++)\n            VIR_FREE(names[i]);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "netcfConnectNumOfInterfacesImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "354-443",
    "snippet": "static int netcfConnectNumOfInterfacesImpl(virConnectPtr conn,\n                                           int status,\n                                           virInterfaceObjListFilter filter)\n{\n    int count;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **names = NULL;\n\n    /* List all interfaces, in case we might support new filter flags\n     * beyond active|inactive in future.\n     */\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, names, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        want++;\n    }\n\n    ret = want;\n\n cleanup:\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFree",
          "args": [
            "def"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "73-115",
          "snippet": "void\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirInterfaceDefFree(virInterfaceDefPtr def)\n{\n    size_t i;\n    int pp;\n\n    if (def == NULL)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->mac);\n\n    switch (def->type) {\n        case VIR_INTERFACE_TYPE_BRIDGE:\n            VIR_FREE(def->data.bridge.delay);\n            for (i = 0; i < def->data.bridge.nbItf; i++) {\n                if (def->data.bridge.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bridge.itf[i]);\n            }\n            VIR_FREE(def->data.bridge.itf);\n            break;\n        case VIR_INTERFACE_TYPE_BOND:\n            VIR_FREE(def->data.bond.target);\n            for (i = 0; i < def->data.bond.nbItf; i++) {\n                if (def->data.bond.itf[i] == NULL)\n                    break; /* to cope with half parsed data on errors */\n                virInterfaceDefFree(def->data.bond.itf[i]);\n            }\n            VIR_FREE(def->data.bond.itf);\n            break;\n        case VIR_INTERFACE_TYPE_VLAN:\n            VIR_FREE(def->data.vlan.tag);\n            VIR_FREE(def->data.vlan.dev_name);\n            break;\n    }\n\n    /* free all protos */\n    for (pp = 0; pp < def->nprotos; pp++)\n        virInterfaceProtocolDefFree(def->protos[pp]);\n    VIR_FREE(def->protos);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter",
          "args": [
            "conn",
            "def"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_nwfilter_binding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_dispatch.c",
          "lines": "7368-7373",
          "snippet": "static void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}",
          "includes": [
            "#include \"lxc_daemon_dispatch_stubs.h\"",
            "#include \"qemu_daemon_dispatch_stubs.h\"",
            "#include \"remote_daemon_dispatch_stubs.h\"",
            "#include \"access/viraccessapicheck.h\"",
            "#include \"configmake.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virpolkit.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virprobe.h\"",
            "#include \"network_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"object_event.h\"",
            "#include \"virstring.h\"",
            "#include \"lxc_protocol.h\"",
            "#include \"qemu_protocol.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"virprocess.h\"",
            "#include \"virdbus.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virnetserverservice.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc_daemon_dispatch_stubs.h\"\n#include \"qemu_daemon_dispatch_stubs.h\"\n#include \"remote_daemon_dispatch_stubs.h\"\n#include \"access/viraccessapicheck.h\"\n#include \"configmake.h\"\n#include \"virthreadjob.h\"\n#include \"virpolkit.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virprobe.h\"\n#include \"network_conf.h\"\n#include \"domain_conf.h\"\n#include \"object_event.h\"\n#include \"virstring.h\"\n#include \"lxc_protocol.h\"\n#include \"qemu_protocol.h\"\n#include \"remote_protocol.h\"\n#include \"virprocess.h\"\n#include \"virdbus.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virnetserver.h\"\n#include \"virnetserverservice.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"remote_daemon_stream.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"libvirt_internal.h\"\n#include \"remote_daemon.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic void make_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src);\n\nstatic void\nmake_nonnull_nwfilter_binding(remote_nonnull_nwfilter_binding *binding_dst, virNWFilterBindingPtr binding_src)\n{\n    binding_dst->portdev = g_strdup(binding_src->portdev);\n    binding_dst->filtername = g_strdup(binding_src->filtername);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_free",
          "args": [
            "iface"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "iface"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\"",
            "names[i]"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"couldn't find interface named '%s': %s%s%s\")",
            "names[i]",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s': %s%s%s\""
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_lookup_by_name",
          "args": [
            "driver->netcf",
            "names[i]"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to list host interfaces: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_list_interfaces",
          "args": [
            "driver->netcf",
            "count",
            "names",
            "status"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "names",
            "count"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to get number of host interfaces: %s%s%s\")",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_num_of_interfaces",
          "args": [
            "driver->netcf",
            "status"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectNumOfInterfacesImpl(virConnectPtr conn,\n                                           int status,\n                                           virInterfaceObjListFilter filter)\n{\n    int count;\n    int want = 0;\n    int ret = -1;\n    size_t i;\n    char **names = NULL;\n\n    /* List all interfaces, in case we might support new filter flags\n     * beyond active|inactive in future.\n     */\n    count = ncf_num_of_interfaces(driver->netcf, status);\n    if (count < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get number of host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    if (count == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(names, count) < 0)\n        goto cleanup;\n\n    if ((count = ncf_list_interfaces(driver->netcf, count, names, status)) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to list host interfaces: %s%s%s\"),\n                       errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        virInterfaceDefPtr def;\n        struct netcf_if *iface;\n\n        iface = ncf_lookup_by_name(driver->netcf, names[i]);\n        if (!iface) {\n            const char *errmsg, *details;\n            int errcode = ncf_error(driver->netcf, &errmsg, &details);\n            if (errcode != NETCF_NOERROR) {\n                virReportError(netcf_to_vir_err(errcode),\n                               _(\"couldn't find interface named '%s': %s%s%s\"),\n                               names[i], errmsg,\n                               details ? \" - \" : \"\", NULLSTR_EMPTY(details));\n                goto cleanup;\n            } else {\n                /* Ignore the NETCF_NOERROR, as the interface is very likely\n                 * deleted by other management apps (e.g. virt-manager).\n                 */\n                VIR_WARN(\"couldn't find interface named '%s', might be \"\n                         \"deleted by other process\", names[i]);\n                continue;\n            }\n        }\n\n        if (!(def = netcfGetMinimalDefForDevice(iface))) {\n            ncf_if_free(iface);\n            goto cleanup;\n        }\n        ncf_if_free(iface);\n\n        if (!filter(conn, def)) {\n            virInterfaceDefFree(def);\n            continue;\n        }\n        virInterfaceDefFree(def);\n\n        want++;\n    }\n\n    ret = want;\n\n cleanup:\n    if (names && count > 0)\n        for (i = 0; i < count; i++)\n            VIR_FREE(names[i]);\n    VIR_FREE(names);\n    return ret;\n}"
  },
  {
    "function_name": "netcfInterfaceObjIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "328-352",
    "snippet": "static int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"failed to get status of interface %s: %s%s%s\")",
            "ncf_if_name(iface)",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_name",
          "args": [
            "iface"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to get status of interface %s: %s%s%s\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "driver->netcf",
            "&errmsg",
            "&details"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_status",
          "args": [
            "iface",
            "&flags"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "driver"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfInterfaceObjIsActive(struct netcf_if *iface,\n                          bool *active)\n{\n    int ret = -1;\n    unsigned int flags = 0;\n\n    virObjectRef(driver);\n    if (ncf_if_status(iface, &flags) < 0) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(driver->netcf, &errmsg, &details);\n        virReportError(netcf_to_vir_err(errcode),\n                       _(\"failed to get status of interface %s: %s%s%s\"),\n                       ncf_if_name(iface), errmsg, details ? \" - \" : \"\",\n                       NULLSTR_EMPTY(details));\n        goto cleanup;\n    }\n\n    *active = flags & NETCF_IFACE_ACTIVE;\n    ret = 0;\n\n cleanup:\n    virObjectUnref(driver);\n    return ret;\n}"
  },
  {
    "function_name": "interfaceDriverGetNetcfIF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "305-326",
    "snippet": "static struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"couldn't find interface named '%s'\")",
            "ifinfo->name"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't find interface named '%s'\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "netcf_to_vir_err(errcode)",
            "_(\"couldn't find interface named '%s': %s%s%s\")",
            "ifinfo->name",
            "errmsg",
            "details ? \" - \" : \"\"",
            "NULLSTR_EMPTY(details)"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "details"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_error",
          "args": [
            "ncf",
            "&errmsg",
            "&details"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_lookup_by_name",
          "args": [
            "ncf",
            "ifinfo->name"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic struct netcf_if *interfaceDriverGetNetcfIF(struct netcf *ncf, virInterfacePtr ifinfo)\n{\n    /* 1) caller already has lock,\n     * 2) caller cleans up iface on return\n     */\n    struct netcf_if *iface = ncf_lookup_by_name(ncf, ifinfo->name);\n    if (!iface) {\n        const char *errmsg, *details;\n        int errcode = ncf_error(ncf, &errmsg, &details);\n        if (errcode != NETCF_NOERROR) {\n            virReportError(netcf_to_vir_err(errcode),\n                           _(\"couldn't find interface named '%s': %s%s%s\"),\n                           ifinfo->name, errmsg, details ? \" - \" : \"\",\n                           NULLSTR_EMPTY(details));\n        } else {\n            virReportError(VIR_ERR_NO_INTERFACE,\n                           _(\"couldn't find interface named '%s'\"),\n                           ifinfo->name);\n        }\n    }\n    return iface;\n}"
  },
  {
    "function_name": "netcf_to_vir_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "265-303",
    "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "249-262",
    "snippet": "static virInterfaceDef * ATTRIBUTE_NONNULL(1)\nnetcfGetMinimalDefForDevice(struct netcf_if *iface)\n{\n    virInterfaceDef *def;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->name = g_strdup(ncf_if_name(iface));\n    def->mac = g_strdup(ncf_if_mac_string(iface));\n\n    return def;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "ncf_if_mac_string(iface)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_if_mac_string",
          "args": [
            "iface"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_if_name",
          "args": [
            "iface"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netcfGetMinimalDefForDevice",
          "args": [
            "structnetcf_if *iface"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virInterfaceDef * ATTRIBUTE_NONNULL(1)\nnetcfGetMinimalDefForDevice(struct netcf_if *iface)\n{\n    virInterfaceDef *def;\n\n    /* Allocate our interface definition structure */\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->name = g_strdup(ncf_if_name(iface));\n    def->mac = g_strdup(ncf_if_mac_string(iface));\n\n    return def;\n}"
  },
  {
    "function_name": "netcfConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "238-241",
    "snippet": "static int netcfConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcfConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}"
  },
  {
    "function_name": "netcfConnectIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "231-235",
    "snippet": "static int netcfConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Not encrypted, but remote driver takes care of that */\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int netcfConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Not encrypted, but remote driver takes care of that */\n    return 0;\n}"
  },
  {
    "function_name": "netcfConnectIsSecure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "224-228",
    "snippet": "static int netcfConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Trivially secure, since always inside the daemon */\n    return 1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcfConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Trivially secure, since always inside the daemon */\n    return 1;\n}"
  },
  {
    "function_name": "netcfConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "218-221",
    "snippet": "static int netcfConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcfConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "netcfConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "193-216",
    "snippet": "static virDrvOpenStatus\nnetcfConnectOpen(virConnectPtr conn,\n                 virConnectAuthPtr auth G_GNUC_UNUSED,\n                 virConfPtr conf G_GNUC_UNUSED,\n                 unsigned int flags)\n{\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (driver == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"interface state driver is not active\"));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    if (!virConnectValidateURIPath(conn->uri->path,\n                                   \"interface\",\n                                   driver->privileged))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (virConnectOpenEnsureACL(conn) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    return VIR_DRV_OPEN_SUCCESS;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConnectOpenEnsureACL",
          "args": [
            "conn"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectValidateURIPath",
          "args": [
            "conn->uri->path",
            "\"interface\"",
            "driver->privileged"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectValidateURIPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "260-296",
          "snippet": "bool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"interface state driver is not active\")"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"interface state driver is not active\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic virDrvOpenStatus\nnetcfConnectOpen(virConnectPtr conn,\n                 virConnectAuthPtr auth G_GNUC_UNUSED,\n                 virConfPtr conf G_GNUC_UNUSED,\n                 unsigned int flags)\n{\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (driver == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"interface state driver is not active\"));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    if (!virConnectValidateURIPath(conn->uri->path,\n                                   \"interface\",\n                                   driver->privileged))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (virConnectOpenEnsureACL(conn) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    return VIR_DRV_OPEN_SUCCESS;\n}"
  },
  {
    "function_name": "netcfStateReload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "162-190",
    "snippet": "static int\nnetcfStateReload(void)\n{\n    int ret = -1;\n\n    if (!driver)\n        return 0;\n\n    virObjectLock(driver);\n    ncf_close(driver->netcf);\n    if (ncf_init(&driver->netcf, NULL) != 0) {\n        /* this isn't a good situation, because we can't shut down the\n         * driver as there may still be connections to it. If we set\n         * the netcf handle to NULL, any subsequent calls to netcf\n         * will just fail rather than causing a crash. Not ideal, but\n         * livable (since this should never happen).\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to re-init netcf\"));\n        driver->netcf = NULL;\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(driver);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "driver"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to re-init netcf\")"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to re-init netcf\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_init",
          "args": [
            "&driver->netcf",
            "NULL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncf_close",
          "args": [
            "driver->netcf"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "driver"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfStateReload(void)\n{\n    int ret = -1;\n\n    if (!driver)\n        return 0;\n\n    virObjectLock(driver);\n    ncf_close(driver->netcf);\n    if (ncf_init(&driver->netcf, NULL) != 0) {\n        /* this isn't a good situation, because we can't shut down the\n         * driver as there may still be connections to it. If we set\n         * the netcf handle to NULL, any subsequent calls to netcf\n         * will just fail rather than causing a crash. Not ideal, but\n         * livable (since this should never happen).\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to re-init netcf\"));\n        driver->netcf = NULL;\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(driver);\n\n    return ret;\n}"
  },
  {
    "function_name": "netcfStateCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "145-159",
    "snippet": "static int\nnetcfStateCleanup(void)\n{\n    if (!driver)\n        return -1;\n\n    if (virObjectUnref(driver)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to close netcf state driver \"\n                         \"with open connections\"));\n        return -1;\n    }\n    driver = NULL;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Attempt to close netcf state driver \"\n                         \"with open connections\")"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Attempt to close netcf state driver \"\n                         \"with open connections\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfStateCleanup(void)\n{\n    if (!driver)\n        return -1;\n\n    if (virObjectUnref(driver)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Attempt to close netcf state driver \"\n                         \"with open connections\"));\n        return -1;\n    }\n    driver = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "netcfStateInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "91-142",
    "snippet": "static int\nnetcfStateInitialize(bool privileged,\n                     const char *root,\n                     virStateInhibitCallback callback G_GNUC_UNUSED,\n                     void *opaque G_GNUC_UNUSED)\n{\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (virNetcfDriverStateInitialize() < 0)\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    if (!(driver = virObjectLockableNew(virNetcfDriverStateClass)))\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    driver->privileged = privileged;\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/interface\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/interface/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto error;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto error;\n\n    /* open netcf */\n    if (ncf_init(&driver->netcf, NULL) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to initialize netcf\"));\n        goto error;\n    }\n    return VIR_DRV_STATE_INIT_COMPLETE;\n\n error:\n    virObjectUnref(driver);\n    driver = NULL;\n    return VIR_DRV_STATE_INIT_ERROR;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetcfDriverStateClass;",
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to initialize netcf\")"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to initialize netcf\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "netcf_to_vir_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
          "lines": "265-303",
          "snippet": "static int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virinterfaceobj.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"interface_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <netcf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int netcf_to_vir_err(int netcf_errcode)\n{\n    switch (netcf_errcode) {\n        case NETCF_NOERROR:\n            /* no error, everything ok */\n            return VIR_ERR_OK;\n        case NETCF_EINTERNAL:\n            /* internal error, aka bug */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EOTHER:\n            /* other error, copout for being more specific */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_ENOMEM:\n            /*\n             * allocation failed return VIR ERR NO MEMORY\n             * though it should not be used now.\n             */\n            return 2;\n        case NETCF_EXMLPARSER:\n            /* XML parser choked */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_EXMLINVALID:\n            /* XML invalid in some form */\n            return VIR_ERR_XML_ERROR;\n        case NETCF_ENOENT:\n            /* Required entry in a tree is missing */\n            return VIR_ERR_INTERNAL_ERROR;\n        case NETCF_EEXEC:\n            /* external program execution failed or returned non-0 */\n            return VIR_ERR_INTERNAL_ERROR;\n#ifdef NETCF_EINVALIDOP\n        case NETCF_EINVALIDOP:\n            /* attempted operation is invalid while the system is in the current state. */\n            return VIR_ERR_OPERATION_INVALID;\n#endif\n        default:\n            return VIR_ERR_INTERNAL_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_init",
          "args": [
            "&driver->netcf",
            "NULL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileAcquire",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "false",
            "getpid()"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "413-427",
          "snippet": "int virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create state directory '%s'\")",
            "driver->stateDir"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePathWithMode",
          "args": [
            "driver->stateDir",
            "S_IRWXU"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePathWithMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3082-3091",
          "snippet": "int\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/interface/run\"",
            "rundir"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetcfDriverStateClass"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetcfDriverStateInitialize",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Driver does not support embedded mode\")"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic virClassPtr virNetcfDriverStateClass;\nstatic virNetcfDriverStatePtr driver;\n\nstatic int\nnetcfStateInitialize(bool privileged,\n                     const char *root,\n                     virStateInhibitCallback callback G_GNUC_UNUSED,\n                     void *opaque G_GNUC_UNUSED)\n{\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (virNetcfDriverStateInitialize() < 0)\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    if (!(driver = virObjectLockableNew(virNetcfDriverStateClass)))\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    driver->privileged = privileged;\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/interface\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/interface/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto error;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto error;\n\n    /* open netcf */\n    if (ncf_init(&driver->netcf, NULL) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to initialize netcf\"));\n        goto error;\n    }\n    return VIR_DRV_STATE_INIT_COMPLETE;\n\n error:\n    virObjectUnref(driver);\n    driver = NULL;\n    return VIR_DRV_STATE_INIT_ERROR;\n}"
  },
  {
    "function_name": "virNetcfDriverStateDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "76-88",
    "snippet": "static void\nvirNetcfDriverStateDispose(void *obj)\n{\n    virNetcfDriverStatePtr _driver = obj;\n\n    if (_driver->netcf)\n        ncf_close(_driver->netcf);\n\n    if (_driver->lockFD != -1)\n        virPidFileRelease(_driver->stateDir, \"driver\", _driver->lockFD);\n\n    VIR_FREE(_driver->stateDir);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetcfDriverStateDispose(void *obj);",
      "static virNetcfDriverStatePtr driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "_driver->stateDir"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileRelease",
          "args": [
            "_driver->stateDir",
            "\"driver\"",
            "_driver->lockFD"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "453-466",
          "snippet": "int virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncf_close",
          "args": [
            "_driver->netcf"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic void virNetcfDriverStateDispose(void *obj);\nstatic virNetcfDriverStatePtr driver;\n\nstatic void\nvirNetcfDriverStateDispose(void *obj)\n{\n    virNetcfDriverStatePtr _driver = obj;\n\n    if (_driver->netcf)\n        ncf_close(_driver->netcf);\n\n    if (_driver->lockFD != -1)\n        virPidFileRelease(_driver->stateDir, \"driver\", _driver->lockFD);\n\n    VIR_FREE(_driver->stateDir);\n}"
  },
  {
    "function_name": "virNetcfDriverStateOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/interface/interface_backend_netcf.c",
    "lines": "62-69",
    "snippet": "static int\nvirNetcfDriverStateOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetcfDriverState, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virinterfaceobj.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"interface_conf.h\"",
      "#include \"interface_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <netcf.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetcfDriverState",
            "virClassForObjectLockable()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virinterfaceobj.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"interface_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <netcf.h>\n#include <config.h>\n\nstatic int\nvirNetcfDriverStateOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetcfDriverState, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]