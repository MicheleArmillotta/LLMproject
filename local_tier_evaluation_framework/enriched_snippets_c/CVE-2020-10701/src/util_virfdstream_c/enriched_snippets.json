[
  {
    "function_name": "virFDStreamSetInternalCloseCb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1500-1509",
    "snippet": "int\nvirFDStreamSetInternalCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCb cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCbFreeOpaque fcb G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamSetInternalCloseCb(virStreamPtr st G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCb cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              virFDStreamInternalCloseCbFreeOpaque fcb G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamOpenBlockDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1486-1497",
    "snippet": "int\nvirFDStreamOpenBlockDevice(virStreamPtr st G_GNUC_UNUSED,\n                           const char *path G_GNUC_UNUSED,\n                           unsigned long long offset G_GNUC_UNUSED,\n                           unsigned long long length G_GNUC_UNUSED,\n                           bool sparse G_GNUC_UNUSED,\n                           int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenBlockDevice(virStreamPtr st G_GNUC_UNUSED,\n                           const char *path G_GNUC_UNUSED,\n                           unsigned long long offset G_GNUC_UNUSED,\n                           unsigned long long length G_GNUC_UNUSED,\n                           bool sparse G_GNUC_UNUSED,\n                           int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamOpenPTY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1473-1483",
    "snippet": "int\nvirFDStreamOpenPTY(virStreamPtr st G_GNUC_UNUSED,\n                   const char *path G_GNUC_UNUSED,\n                   unsigned long long offset G_GNUC_UNUSED,\n                   unsigned long long length G_GNUC_UNUSED,\n                   int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenPTY(virStreamPtr st G_GNUC_UNUSED,\n                   const char *path G_GNUC_UNUSED,\n                   unsigned long long offset G_GNUC_UNUSED,\n                   unsigned long long length G_GNUC_UNUSED,\n                   int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamCreateFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1459-1470",
    "snippet": "int\nvirFDStreamCreateFile(virStreamPtr st G_GNUC_UNUSED,\n                      const char *path G_GNUC_UNUSED,\n                      unsigned long long offset G_GNUC_UNUSED,\n                      unsigned long long length G_GNUC_UNUSED,\n                      int oflags G_GNUC_UNUSED,\n                      mode_t mode G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamCreateFile(virStreamPtr st G_GNUC_UNUSED,\n                      const char *path G_GNUC_UNUSED,\n                      unsigned long long offset G_GNUC_UNUSED,\n                      unsigned long long length G_GNUC_UNUSED,\n                      int oflags G_GNUC_UNUSED,\n                      mode_t mode G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamOpenFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1446-1456",
    "snippet": "int\nvirFDStreamOpenFile(virStreamPtr st G_GNUC_UNUSED,\n                    const char *path G_GNUC_UNUSED,\n                    unsigned long long offset G_GNUC_UNUSED,\n                    unsigned long long length G_GNUC_UNUSED,\n                    int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenFile(virStreamPtr st G_GNUC_UNUSED,\n                    const char *path G_GNUC_UNUSED,\n                    unsigned long long offset G_GNUC_UNUSED,\n                    unsigned long long length G_GNUC_UNUSED,\n                    int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamConnectUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1435-1443",
    "snippet": "int\nvirFDStreamConnectUNIX(virStreamPtr st G_GNUC_UNUSED,\n                       const char *path G_GNUC_UNUSED,\n                       bool abstract G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamConnectUNIX(virStreamPtr st G_GNUC_UNUSED,\n                       const char *path G_GNUC_UNUSED,\n                       bool abstract G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1425-1432",
    "snippet": "int\nvirFDStreamOpen(virStreamPtr st G_GNUC_UNUSED,\n                int fd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"File streams are not supported on this platform\")"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"File streams are not supported on this platform\""
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpen(virStreamPtr st G_GNUC_UNUSED,\n                int fd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamSetInternalCloseCb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1403-1421",
    "snippet": "int virFDStreamSetInternalCloseCb(virStreamPtr st,\n                                  virFDStreamInternalCloseCb cb,\n                                  void *opaque,\n                                  virFDStreamInternalCloseCbFreeOpaque fcb)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n\n    virObjectLock(fdst);\n\n    if (fdst->icbFreeOpaque)\n        (fdst->icbFreeOpaque)(fdst->icbOpaque);\n\n    fdst->icbCb = cb;\n    fdst->icbOpaque = opaque;\n    fdst->icbFreeOpaque = fcb;\n\n    virObjectUnlock(fdst);\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fdst->icbOpaque"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamSetInternalCloseCb(virStreamPtr st,\n                                  virFDStreamInternalCloseCb cb,\n                                  void *opaque,\n                                  virFDStreamInternalCloseCbFreeOpaque fcb)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n\n    virObjectLock(fdst);\n\n    if (fdst->icbFreeOpaque)\n        (fdst->icbFreeOpaque)(fdst->icbOpaque);\n\n    fdst->icbCb = cb;\n    fdst->icbOpaque = opaque;\n    fdst->icbFreeOpaque = fcb;\n\n    virObjectUnlock(fdst);\n    return 0;\n}"
  },
  {
    "function_name": "virFDStreamOpenBlockDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1391-1401",
    "snippet": "int virFDStreamOpenBlockDevice(virStreamPtr st,\n                               const char *path,\n                               unsigned long long offset,\n                               unsigned long long length,\n                               bool sparse,\n                               int oflags)\n{\n    return virFDStreamOpenFileInternal(st, path,\n                                       offset, length,\n                                       oflags, 0, true, sparse);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamOpenFileInternal",
          "args": [
            "st",
            "path",
            "offset",
            "length",
            "oflags",
            "0",
            "true",
            "sparse"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenFileInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1215-1319",
          "snippet": "static int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamOpenBlockDevice(virStreamPtr st,\n                               const char *path,\n                               unsigned long long offset,\n                               unsigned long long length,\n                               bool sparse,\n                               int oflags)\n{\n    return virFDStreamOpenFileInternal(st, path,\n                                       offset, length,\n                                       oflags, 0, true, sparse);\n}"
  },
  {
    "function_name": "virFDStreamOpenPTY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1351-1389",
    "snippet": "int virFDStreamOpenPTY(virStreamPtr st,\n                       const char *path,\n                       unsigned long long offset,\n                       unsigned long long length,\n                       int oflags)\n{\n    virFDStreamDataPtr fdst = NULL;\n    struct termios rawattr;\n\n    if (virFDStreamOpenFileInternal(st, path,\n                                    offset, length,\n                                    oflags | O_CREAT, 0,\n                                    false, false) < 0)\n        return -1;\n\n    fdst = st->privateData;\n\n    if (tcgetattr(fdst->fd, &rawattr) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to get tty attributes: %s\"),\n                             path);\n        goto cleanup;\n    }\n\n    cfmakeraw(&rawattr);\n\n    if (tcsetattr(fdst->fd, TCSANOW, &rawattr) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to set tty attributes: %s\"),\n                             path);\n        goto cleanup;\n    }\n\n    return 0;\n\n cleanup:\n    virFDStreamClose(st);\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamClose",
          "args": [
            "st"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "748-752",
          "snippet": "static int\nvirFDStreamClose(virStreamPtr st)\n{\n    return virFDStreamCloseInt(st, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamClose(virStreamPtr st)\n{\n    return virFDStreamCloseInt(st, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set tty attributes: %s\")",
            "path"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to set tty attributes: %s\""
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "fdst->fd",
            "TCSANOW",
            "&rawattr"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfmakeraw",
          "args": [
            "&rawattr"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get tty attributes: %s\")",
            "path"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "fdst->fd",
            "&rawattr"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamOpenFileInternal",
          "args": [
            "st",
            "path",
            "offset",
            "length",
            "oflags | O_CREAT",
            "0",
            "false",
            "false"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenFileInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1215-1319",
          "snippet": "static int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamOpenPTY(virStreamPtr st,\n                       const char *path,\n                       unsigned long long offset,\n                       unsigned long long length,\n                       int oflags)\n{\n    virFDStreamDataPtr fdst = NULL;\n    struct termios rawattr;\n\n    if (virFDStreamOpenFileInternal(st, path,\n                                    offset, length,\n                                    oflags | O_CREAT, 0,\n                                    false, false) < 0)\n        return -1;\n\n    fdst = st->privateData;\n\n    if (tcgetattr(fdst->fd, &rawattr) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to get tty attributes: %s\"),\n                             path);\n        goto cleanup;\n    }\n\n    cfmakeraw(&rawattr);\n\n    if (tcsetattr(fdst->fd, TCSANOW, &rawattr) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to set tty attributes: %s\"),\n                             path);\n        goto cleanup;\n    }\n\n    return 0;\n\n cleanup:\n    virFDStreamClose(st);\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamCreateFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1338-1349",
    "snippet": "int virFDStreamCreateFile(virStreamPtr st,\n                          const char *path,\n                          unsigned long long offset,\n                          unsigned long long length,\n                          int oflags,\n                          mode_t mode)\n{\n    return virFDStreamOpenFileInternal(st, path,\n                                       offset, length,\n                                       oflags | O_CREAT, mode,\n                                       false, false);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamOpenFileInternal",
          "args": [
            "st",
            "path",
            "offset",
            "length",
            "oflags | O_CREAT",
            "mode",
            "false",
            "false"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenFileInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1215-1319",
          "snippet": "static int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamCreateFile(virStreamPtr st,\n                          const char *path,\n                          unsigned long long offset,\n                          unsigned long long length,\n                          int oflags,\n                          mode_t mode)\n{\n    return virFDStreamOpenFileInternal(st, path,\n                                       offset, length,\n                                       oflags | O_CREAT, mode,\n                                       false, false);\n}"
  },
  {
    "function_name": "virFDStreamOpenFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1321-1336",
    "snippet": "int virFDStreamOpenFile(virStreamPtr st,\n                        const char *path,\n                        unsigned long long offset,\n                        unsigned long long length,\n                        int oflags)\n{\n    if (oflags & O_CREAT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to create %s without specifying mode\"),\n                       path);\n        return -1;\n    }\n    return virFDStreamOpenFileInternal(st, path,\n                                       offset, length,\n                                       oflags, 0, false, false);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamOpenFileInternal",
          "args": [
            "st",
            "path",
            "offset",
            "length",
            "oflags",
            "0",
            "false",
            "false"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenFileInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1215-1319",
          "snippet": "static int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Attempt to create %s without specifying mode\")",
            "path"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Attempt to create %s without specifying mode\""
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamOpenFile(virStreamPtr st,\n                        const char *path,\n                        unsigned long long offset,\n                        unsigned long long length,\n                        int oflags)\n{\n    if (oflags & O_CREAT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Attempt to create %s without specifying mode\"),\n                       path);\n        return -1;\n    }\n    return virFDStreamOpenFileInternal(st, path,\n                                       offset, length,\n                                       oflags, 0, false, false);\n}"
  },
  {
    "function_name": "virFDStreamOpenFileInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1215-1319",
    "snippet": "static int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamThreadDataFree",
          "args": [
            "threadData"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamThreadDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "404-414",
          "snippet": "static void\nvirFDStreamThreadDataFree(virFDStreamThreadDataPtr data)\n{\n    if (!data)\n        return;\n\n    virObjectUnref(data->st);\n    VIR_FREE(data->fdinname);\n    VIR_FREE(data->fdoutname);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamThreadDataFree(virFDStreamThreadDataPtr data)\n{\n    if (!data)\n        return;\n\n    virObjectUnref(data->st);\n    VIR_FREE(data->fdinname);\n    VIR_FREE(data->fdoutname);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipefds[1]"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipefds[0]"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamOpenInternal",
          "args": [
            "st",
            "tmpfd",
            "threadData",
            "length"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1095-1154",
          "snippet": "static int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "st"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "threadData"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "pipefds"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s: Cannot request read and write flags together\")",
            "path"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "sb.st_mode"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to seek %s to %llu\")",
            "path",
            "offset"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "offset",
            "SEEK_SET"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to access stream for '%s'\")",
            "path"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to open stream for '%s'\")",
            "path"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "oflags"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "oflags",
            "mode"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\"",
            "st",
            "path",
            "oflags",
            "offset",
            "length",
            "mode"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamOpenFileInternal(virStreamPtr st,\n                            const char *path,\n                            unsigned long long offset,\n                            unsigned long long length,\n                            int oflags,\n                            int mode,\n                            bool forceIOHelper,\n                            bool sparse)\n{\n    int fd = -1;\n    int pipefds[2] = { -1, -1 };\n    int tmpfd = -1;\n    struct stat sb;\n    virFDStreamThreadDataPtr threadData = NULL;\n\n    VIR_DEBUG(\"st=%p path=%s oflags=0x%x offset=%llu length=%llu mode=0%o\",\n              st, path, oflags, offset, length, mode);\n\n    oflags |= O_NOCTTY;\n\n    if (oflags & O_CREAT)\n        fd = open(path, oflags, mode);\n    else\n        fd = open(path, oflags);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to open stream for '%s'\"),\n                             path);\n        return -1;\n    }\n    tmpfd = fd;\n\n    if (fstat(fd, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to access stream for '%s'\"),\n                             path);\n        goto error;\n    }\n\n    if (offset &&\n        lseek(fd, offset, SEEK_SET) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to seek %s to %llu\"),\n                             path, offset);\n        goto error;\n    }\n\n    /* Thanks to the POSIX i/o model, we can't reliably get\n     * non-blocking I/O on block devs/regular files. To\n     * support those we need to create a helper thread to do\n     * the I/O so we just have a fifo. Or use AIO :-(\n     */\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        ((!S_ISCHR(sb.st_mode) &&\n          !S_ISFIFO(sb.st_mode)) || forceIOHelper)) {\n\n        if ((oflags & O_ACCMODE) == O_RDWR) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"%s: Cannot request read and write flags together\"),\n                           path);\n            goto error;\n        }\n\n        if (virPipe(pipefds) < 0)\n            goto error;\n\n        if (VIR_ALLOC(threadData) < 0)\n            goto error;\n\n        threadData->st = virObjectRef(st);\n        threadData->length = length;\n        threadData->sparse = sparse;\n\n        if ((oflags & O_ACCMODE) == O_RDONLY) {\n            threadData->fdin = fd;\n            threadData->fdout = pipefds[1];\n            threadData->fdinname = g_strdup(path);\n            threadData->fdoutname = g_strdup(\"pipe\");\n            tmpfd = pipefds[0];\n            threadData->doRead = true;\n        } else {\n            threadData->fdin = pipefds[0];\n            threadData->fdout = fd;\n            threadData->fdinname = g_strdup(\"pipe\");\n            threadData->fdoutname = g_strdup(path);\n            tmpfd = pipefds[1];\n            threadData->doRead = false;\n        }\n    }\n\n    if (virFDStreamOpenInternal(st, tmpfd, threadData, length) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    VIR_FORCE_CLOSE(pipefds[0]);\n    VIR_FORCE_CLOSE(pipefds[1]);\n    if (oflags & O_CREAT)\n        unlink(path);\n    virFDStreamThreadDataFree(threadData);\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamConnectUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1164-1212",
    "snippet": "int virFDStreamConnectUNIX(virStreamPtr st,\n                           const char *path,\n                           bool abstract)\n{\n    struct sockaddr_un sa;\n    virTimeBackOffVar timeout;\n    int ret;\n\n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to open UNIX socket\"));\n        goto error;\n    }\n\n    memset(&sa, 0, sizeof(sa));\n    sa.sun_family = AF_UNIX;\n    if (abstract) {\n        if (virStrcpy(sa.sun_path+1, path, sizeof(sa.sun_path)-1) < 0)\n            goto error;\n        sa.sun_path[0] = '\\0';\n    } else {\n        if (virStrcpyStatic(sa.sun_path, path) < 0)\n            goto error;\n    }\n\n    if (virTimeBackOffStart(&timeout, 1, 3*1000 /* ms */) < 0)\n        goto error;\n    while (virTimeBackOffWait(&timeout)) {\n        ret = connect(fd, (struct sockaddr *)&sa, sizeof(sa));\n        if (ret == 0)\n            break;\n\n        if (errno == ENOENT || errno == ECONNREFUSED) {\n            /* ENOENT       : Socket may not have shown up yet\n             * ECONNREFUSED : Leftover socket hasn't been removed yet */\n            continue;\n        }\n\n        goto error;\n    }\n\n    if (virFDStreamOpenInternal(st, fd, NULL, 0) < 0)\n        goto error;\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamOpenInternal",
          "args": [
            "st",
            "fd",
            "NULL",
            "0"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1095-1154",
          "snippet": "static int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "fd",
            "(struct sockaddr *)&sa",
            "sizeof(sa)"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "vir_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "216-232",
          "snippet": "int\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffWait",
          "args": [
            "&timeout"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "379-410",
          "snippet": "bool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_TIME_BACKOFF_CAP 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_TIME_BACKOFF_CAP 1000\n\nbool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffStart",
          "args": [
            "&timeout",
            "1",
            "3*1000/* ms */"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "335-345",
          "snippet": "int\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "sa.sun_path",
            "path"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "sa.sun_path+1",
            "path",
            "sizeof(sa.sun_path)-1"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "0",
            "sizeof(sa)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to open UNIX socket\")"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to open UNIX socket\""
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "vir_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "351-367",
          "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamConnectUNIX(virStreamPtr st,\n                           const char *path,\n                           bool abstract)\n{\n    struct sockaddr_un sa;\n    virTimeBackOffVar timeout;\n    int ret;\n\n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to open UNIX socket\"));\n        goto error;\n    }\n\n    memset(&sa, 0, sizeof(sa));\n    sa.sun_family = AF_UNIX;\n    if (abstract) {\n        if (virStrcpy(sa.sun_path+1, path, sizeof(sa.sun_path)-1) < 0)\n            goto error;\n        sa.sun_path[0] = '\\0';\n    } else {\n        if (virStrcpyStatic(sa.sun_path, path) < 0)\n            goto error;\n    }\n\n    if (virTimeBackOffStart(&timeout, 1, 3*1000 /* ms */) < 0)\n        goto error;\n    while (virTimeBackOffWait(&timeout)) {\n        ret = connect(fd, (struct sockaddr *)&sa, sizeof(sa));\n        if (ret == 0)\n            break;\n\n        if (errno == ENOENT || errno == ECONNREFUSED) {\n            /* ENOENT       : Socket may not have shown up yet\n             * ECONNREFUSED : Leftover socket hasn't been removed yet */\n            continue;\n        }\n\n        goto error;\n    }\n\n    if (virFDStreamOpenInternal(st, fd, NULL, 0) < 0)\n        goto error;\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1157-1161",
    "snippet": "int virFDStreamOpen(virStreamPtr st,\n                    int fd)\n{\n    return virFDStreamOpenInternal(st, fd, NULL, 0);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamOpenInternal",
          "args": [
            "st",
            "fd",
            "NULL",
            "0"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1095-1154",
          "snippet": "static int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virFDStreamOpen(virStreamPtr st,\n                    int fd)\n{\n    return virFDStreamOpenInternal(st, fd, NULL, 0);\n}"
  },
  {
    "function_name": "virFDStreamOpenInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1095-1154",
    "snippet": "static int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "fdst"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fdst->thread"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "fdst->thread",
            "true",
            "virFDStreamThread",
            "\"fd-stream\"",
            "false",
            "threadData"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot initialize condition variable\")"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot initialize condition variable\""
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "fdst->thread"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virFDStreamDataClass"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to set non-blocking mode\")"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetNonBlock",
          "args": [
            "fd"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "virSetNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "126-129",
          "snippet": "int virSetNonBlock(int fd)\n{\n    return virSetBlocking(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetNonBlock(int fd)\n{\n    return virSetBlocking(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamDataInitialize",
          "args": [],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p fd=%d threadData=%p length=%llu\"",
            "st",
            "fd",
            "threadData",
            "length"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamOpenInternal(virStreamPtr st,\n                                   int fd,\n                                   virFDStreamThreadDataPtr threadData,\n                                   unsigned long long length)\n{\n    virFDStreamDataPtr fdst;\n\n    VIR_DEBUG(\"st=%p fd=%d threadData=%p length=%llu\",\n              st, fd, threadData, length);\n\n    if (virFDStreamDataInitialize() < 0)\n        return -1;\n\n    if ((st->flags & VIR_STREAM_NONBLOCK) &&\n        virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to set non-blocking mode\"));\n        return -1;\n    }\n\n    if (!(fdst = virObjectLockableNew(virFDStreamDataClass)))\n        return -1;\n\n    fdst->fd = fd;\n    fdst->length = length;\n\n    st->driver = &virFDStreamDrv;\n    st->privateData = fdst;\n\n    if (threadData) {\n        fdst->threadDoRead = threadData->doRead;\n\n        /* Create the thread after fdst and st were initialized.\n         * The thread worker expects them to be that way. */\n        if (VIR_ALLOC(fdst->thread) < 0)\n            goto error;\n\n        if (virCondInit(&fdst->threadCond) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot initialize condition variable\"));\n            goto error;\n        }\n\n        if (virThreadCreateFull(fdst->thread,\n                                true,\n                                virFDStreamThread,\n                                \"fd-stream\",\n                                false,\n                                threadData) < 0)\n            goto error;\n    }\n\n    return 0;\n\n error:\n    VIR_FREE(fdst->thread);\n    st->driver = NULL;\n    st->privateData = NULL;\n    virObjectUnref(fdst);\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamInData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "1037-1080",
    "snippet": "static int\nvirFDStreamInData(virStreamPtr st,\n                  int *inData,\n                  long long *length)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    int ret = -1;\n\n    virObjectLock(fdst);\n\n    if (fdst->thread) {\n        virFDStreamMsgPtr msg;\n\n        if (fdst->threadErr)\n            goto cleanup;\n\n        while (!(msg = fdst->msg)) {\n            if (fdst->threadQuit) {\n                *inData = *length = 0;\n                ret = 0;\n                goto cleanup;\n            } else {\n                virObjectUnlock(fdst);\n                virCondSignal(&fdst->threadCond);\n                virObjectLock(fdst);\n            }\n        }\n\n        if (msg->type == VIR_FDSTREAM_MSG_TYPE_DATA) {\n            *inData = 1;\n            *length = msg->stream.data.len - msg->stream.data.offset;\n        } else {\n            *inData = 0;\n            *length = msg->stream.hole.len;\n        }\n        ret = 0;\n    } else {\n        ret = virFileInData(fdst->fd, inData, length);\n    }\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileInData",
          "args": [
            "fdst->fd",
            "inData",
            "length"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "virFileInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4053-4062",
          "snippet": "int\nvirFileInData(int fd G_GNUC_UNUSED,\n              int *inData G_GNUC_UNUSED,\n              long long *length G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"sparse files not supported\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileInData(int fd G_GNUC_UNUSED,\n              int *inData G_GNUC_UNUSED,\n              long long *length G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"sparse files not supported\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamInData(virStreamPtr st,\n                  int *inData,\n                  long long *length)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    int ret = -1;\n\n    virObjectLock(fdst);\n\n    if (fdst->thread) {\n        virFDStreamMsgPtr msg;\n\n        if (fdst->threadErr)\n            goto cleanup;\n\n        while (!(msg = fdst->msg)) {\n            if (fdst->threadQuit) {\n                *inData = *length = 0;\n                ret = 0;\n                goto cleanup;\n            } else {\n                virObjectUnlock(fdst);\n                virCondSignal(&fdst->threadCond);\n                virObjectLock(fdst);\n            }\n        }\n\n        if (msg->type == VIR_FDSTREAM_MSG_TYPE_DATA) {\n            *inData = 1;\n            *length = msg->stream.data.len - msg->stream.data.offset;\n        } else {\n            *inData = 0;\n            *length = msg->stream.hole.len;\n        }\n        ret = 0;\n    } else {\n        ret = virFileInData(fdst->fd, inData, length);\n    }\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamSendHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "957-1034",
    "snippet": "static int\nvirFDStreamSendHole(virStreamPtr st,\n                    long long length,\n                    unsigned int flags)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    virFDStreamMsgPtr msg = NULL;\n    off_t off;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n    virCheckPositiveArgReturn(length, -1);\n\n    virObjectLock(fdst);\n    if (fdst->length) {\n        if (length > fdst->length - fdst->offset)\n            length = fdst->length - fdst->offset;\n        fdst->offset += length;\n    }\n\n    if (fdst->thread) {\n        /* Things are a bit complicated here. If FDStream is in a\n         * read mode, then if the message at the queue head is\n         * HOLE, just pop it. The thread has lseek()-ed anyway.\n         * However, if the FDStream is in write mode, then tell\n         * the thread to do the lseek() for us. Under no\n         * circumstances we can do the lseek() ourselves here. We\n         * might mess up file position for the thread. */\n\n        if (fdst->threadQuit || fdst->threadErr) {\n            /* virStreamSendHole will virResetLastError possibly set\n             * by virFDStreamEvent */\n            if (fdst->threadErr && !virGetLastError())\n                virSetError(fdst->threadErr);\n            else\n                virReportSystemError(EBADF, \"%s\", _(\"stream is not open\"));\n            goto cleanup;\n        }\n\n        if (fdst->threadDoRead) {\n            msg = fdst->msg;\n            if (msg->type != VIR_FDSTREAM_MSG_TYPE_HOLE) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Invalid stream hole\"));\n                goto cleanup;\n            }\n\n            virFDStreamMsgQueuePop(fdst, fdst->fd, \"pipe\");\n        } else {\n            if (VIR_ALLOC(msg) < 0)\n                goto cleanup;\n\n            msg->type = VIR_FDSTREAM_MSG_TYPE_HOLE;\n            msg->stream.hole.len = length;\n            virFDStreamMsgQueuePush(fdst, msg, fdst->fd, \"pipe\");\n            msg = NULL;\n        }\n    } else {\n        off = lseek(fdst->fd, length, SEEK_CUR);\n        if (off == (off_t) -1) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to seek\"));\n            goto cleanup;\n        }\n\n        if (ftruncate(fdst->fd, off) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to truncate\"));\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(fdst);\n    virFDStreamMsgFree(msg);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamMsgFree",
          "args": [
            "msg"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "191-207",
          "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to truncate\")"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to truncate\""
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fdst->fd",
            "off"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to seek\")"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fdst->fd",
            "length",
            "SEEK_CUR"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgQueuePush",
          "args": [
            "fdst",
            "msg",
            "fdst->fd",
            "\"pipe\""
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueuePush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "139-162",
          "snippet": "static int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "msg"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgQueuePop",
          "args": [
            "fdst",
            "fdst->fd",
            "\"pipe\""
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueuePop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "165-188",
          "snippet": "static virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid stream hole\")"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EBADF",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "fdst->threadErr"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastError",
          "args": [],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckPositiveArgReturn",
          "args": [
            "length",
            "-1"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamSendHole(virStreamPtr st,\n                    long long length,\n                    unsigned int flags)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    virFDStreamMsgPtr msg = NULL;\n    off_t off;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n    virCheckPositiveArgReturn(length, -1);\n\n    virObjectLock(fdst);\n    if (fdst->length) {\n        if (length > fdst->length - fdst->offset)\n            length = fdst->length - fdst->offset;\n        fdst->offset += length;\n    }\n\n    if (fdst->thread) {\n        /* Things are a bit complicated here. If FDStream is in a\n         * read mode, then if the message at the queue head is\n         * HOLE, just pop it. The thread has lseek()-ed anyway.\n         * However, if the FDStream is in write mode, then tell\n         * the thread to do the lseek() for us. Under no\n         * circumstances we can do the lseek() ourselves here. We\n         * might mess up file position for the thread. */\n\n        if (fdst->threadQuit || fdst->threadErr) {\n            /* virStreamSendHole will virResetLastError possibly set\n             * by virFDStreamEvent */\n            if (fdst->threadErr && !virGetLastError())\n                virSetError(fdst->threadErr);\n            else\n                virReportSystemError(EBADF, \"%s\", _(\"stream is not open\"));\n            goto cleanup;\n        }\n\n        if (fdst->threadDoRead) {\n            msg = fdst->msg;\n            if (msg->type != VIR_FDSTREAM_MSG_TYPE_HOLE) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Invalid stream hole\"));\n                goto cleanup;\n            }\n\n            virFDStreamMsgQueuePop(fdst, fdst->fd, \"pipe\");\n        } else {\n            if (VIR_ALLOC(msg) < 0)\n                goto cleanup;\n\n            msg->type = VIR_FDSTREAM_MSG_TYPE_HOLE;\n            msg->stream.hole.len = length;\n            virFDStreamMsgQueuePush(fdst, msg, fdst->fd, \"pipe\");\n            msg = NULL;\n        }\n    } else {\n        off = lseek(fdst->fd, length, SEEK_CUR);\n        if (off == (off_t) -1) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to seek\"));\n            goto cleanup;\n        }\n\n        if (ftruncate(fdst->fd, off) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to truncate\"));\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(fdst);\n    virFDStreamMsgFree(msg);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "846-954",
    "snippet": "static int virFDStreamRead(virStreamPtr st, char *bytes, size_t nbytes)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    int ret = -1;\n\n    if (nbytes > INT_MAX) {\n        virReportSystemError(ERANGE, \"%s\",\n                             _(\"Too many bytes to read from stream\"));\n        return -1;\n    }\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n\n    if (fdst->length) {\n        if (fdst->length == fdst->offset) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        if ((fdst->length - fdst->offset) < nbytes)\n            nbytes = fdst->length - fdst->offset;\n    }\n\n    if (fdst->thread) {\n        virFDStreamMsgPtr msg = NULL;\n\n        while (!(msg = fdst->msg)) {\n            if (fdst->threadQuit || fdst->threadErr) {\n                if (nbytes) {\n                    /* virStreamRecv will virResetLastError possibly set\n                     * by virFDStreamEvent */\n                    if (fdst->threadErr && !virGetLastError())\n                        virSetError(fdst->threadErr);\n                    else\n                        virReportSystemError(EBADF, \"%s\",\n                                             _(\"stream is not open\"));\n                } else {\n                    ret = 0;\n                }\n                goto cleanup;\n            } else {\n                virObjectUnlock(fdst);\n                virCondSignal(&fdst->threadCond);\n                virObjectLock(fdst);\n            }\n        }\n\n        /* Shortcut, if the stream is in the trailing hole,\n         * return 0 immediately. */\n        if (msg->type == VIR_FDSTREAM_MSG_TYPE_HOLE &&\n            msg->stream.hole.len == 0) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        if (msg->type != VIR_FDSTREAM_MSG_TYPE_DATA) {\n            /* Nope, nope, I'm outta here */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected message type\"));\n            goto cleanup;\n        }\n\n        if (nbytes > msg->stream.data.len - msg->stream.data.offset)\n            nbytes = msg->stream.data.len - msg->stream.data.offset;\n\n        memcpy(bytes,\n               msg->stream.data.buf + msg->stream.data.offset,\n               nbytes);\n\n        msg->stream.data.offset += nbytes;\n        if (msg->stream.data.offset == msg->stream.data.len) {\n            virFDStreamMsgQueuePop(fdst, fdst->fd, \"pipe\");\n            virFDStreamMsgFree(msg);\n        }\n\n        ret = nbytes;\n\n    } else {\n     retry:\n        ret = read(fdst->fd, bytes, nbytes);\n        if (ret < 0) {\n            VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            VIR_WARNINGS_RESET\n                ret = -2;\n            } else if (errno == EINTR) {\n                goto retry;\n            } else {\n                ret = -1;\n                virReportSystemError(errno, \"%s\",\n                                     _(\"cannot read from stream\"));\n            }\n            goto cleanup;\n        }\n    }\n\n    if (fdst->length)\n        fdst->offset += ret;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot read from stream\")"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot read from stream\""
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fdst->fd",
            "bytes",
            "nbytes"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "pthread_sigmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "84-92",
          "snippet": "static inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgFree",
          "args": [
            "msg"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "191-207",
          "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgQueuePop",
          "args": [
            "fdst",
            "fdst->fd",
            "\"pipe\""
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueuePop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "165-188",
          "snippet": "static virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bytes",
            "msg->stream.data.buf + msg->stream.data.offset",
            "nbytes"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unexpected message type\")"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EBADF",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "fdst->threadErr"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastError",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ERANGE",
            "\"%s\"",
            "_(\"Too many bytes to read from stream\")"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamRead(virStreamPtr st, char *bytes, size_t nbytes)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    int ret = -1;\n\n    if (nbytes > INT_MAX) {\n        virReportSystemError(ERANGE, \"%s\",\n                             _(\"Too many bytes to read from stream\"));\n        return -1;\n    }\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n\n    if (fdst->length) {\n        if (fdst->length == fdst->offset) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        if ((fdst->length - fdst->offset) < nbytes)\n            nbytes = fdst->length - fdst->offset;\n    }\n\n    if (fdst->thread) {\n        virFDStreamMsgPtr msg = NULL;\n\n        while (!(msg = fdst->msg)) {\n            if (fdst->threadQuit || fdst->threadErr) {\n                if (nbytes) {\n                    /* virStreamRecv will virResetLastError possibly set\n                     * by virFDStreamEvent */\n                    if (fdst->threadErr && !virGetLastError())\n                        virSetError(fdst->threadErr);\n                    else\n                        virReportSystemError(EBADF, \"%s\",\n                                             _(\"stream is not open\"));\n                } else {\n                    ret = 0;\n                }\n                goto cleanup;\n            } else {\n                virObjectUnlock(fdst);\n                virCondSignal(&fdst->threadCond);\n                virObjectLock(fdst);\n            }\n        }\n\n        /* Shortcut, if the stream is in the trailing hole,\n         * return 0 immediately. */\n        if (msg->type == VIR_FDSTREAM_MSG_TYPE_HOLE &&\n            msg->stream.hole.len == 0) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        if (msg->type != VIR_FDSTREAM_MSG_TYPE_DATA) {\n            /* Nope, nope, I'm outta here */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected message type\"));\n            goto cleanup;\n        }\n\n        if (nbytes > msg->stream.data.len - msg->stream.data.offset)\n            nbytes = msg->stream.data.len - msg->stream.data.offset;\n\n        memcpy(bytes,\n               msg->stream.data.buf + msg->stream.data.offset,\n               nbytes);\n\n        msg->stream.data.offset += nbytes;\n        if (msg->stream.data.offset == msg->stream.data.len) {\n            virFDStreamMsgQueuePop(fdst, fdst->fd, \"pipe\");\n            virFDStreamMsgFree(msg);\n        }\n\n        ret = nbytes;\n\n    } else {\n     retry:\n        ret = read(fdst->fd, bytes, nbytes);\n        if (ret < 0) {\n            VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            VIR_WARNINGS_RESET\n                ret = -2;\n            } else if (errno == EINTR) {\n                goto retry;\n            } else {\n                ret = -1;\n                virReportSystemError(errno, \"%s\",\n                                     _(\"cannot read from stream\"));\n            }\n            goto cleanup;\n        }\n    }\n\n    if (fdst->length)\n        fdst->offset += ret;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "760-843",
    "snippet": "static int virFDStreamWrite(virStreamPtr st, const char *bytes, size_t nbytes)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    virFDStreamMsgPtr msg = NULL;\n    int ret = -1;\n\n    if (nbytes > INT_MAX) {\n        virReportSystemError(ERANGE, \"%s\",\n                             _(\"Too many bytes to write to stream\"));\n        return -1;\n    }\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n\n    if (fdst->length) {\n        if (fdst->length == fdst->offset) {\n            virReportSystemError(ENOSPC, \"%s\",\n                                 _(\"cannot write to stream\"));\n            virObjectUnlock(fdst);\n            return -1;\n        }\n\n        if ((fdst->length - fdst->offset) < nbytes)\n            nbytes = fdst->length - fdst->offset;\n    }\n\n    if (fdst->thread) {\n        char *buf;\n\n        if (fdst->threadQuit || fdst->threadErr) {\n\n            /* virStreamSend will virResetLastError possibly set\n             * by virFDStreamEvent */\n            if (fdst->threadErr && !virGetLastError())\n                virSetError(fdst->threadErr);\n            else\n                virReportSystemError(EBADF, \"%s\", _(\"cannot write to stream\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(msg) < 0 ||\n            VIR_ALLOC_N(buf, nbytes) < 0)\n            goto cleanup;\n\n        memcpy(buf, bytes, nbytes);\n        msg->type = VIR_FDSTREAM_MSG_TYPE_DATA;\n        msg->stream.data.buf = buf;\n        msg->stream.data.len = nbytes;\n\n        virFDStreamMsgQueuePush(fdst, msg, fdst->fd, \"pipe\");\n        msg = NULL;\n        ret = nbytes;\n    } else {\n     retry:\n        ret = write(fdst->fd, bytes, nbytes);\n        if (ret < 0) {\n            VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            VIR_WARNINGS_RESET\n                ret = -2;\n            } else if (errno == EINTR) {\n                goto retry;\n            } else {\n                ret = -1;\n                virReportSystemError(errno, \"%s\",\n                                     _(\"cannot write to stream\"));\n            }\n        }\n    }\n\n    if (fdst->length)\n        fdst->offset += ret;\n\n cleanup:\n    virObjectUnlock(fdst);\n    virFDStreamMsgFree(msg);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamMsgFree",
          "args": [
            "msg"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "191-207",
          "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot write to stream\")"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot write to stream\""
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fdst->fd",
            "bytes",
            "nbytes"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgQueuePush",
          "args": [
            "fdst",
            "msg",
            "fdst->fd",
            "\"pipe\""
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueuePush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "139-162",
          "snippet": "static int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "bytes",
            "nbytes"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buf",
            "nbytes"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "msg"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EBADF",
            "\"%s\"",
            "_(\"cannot write to stream\")"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "fdst->threadErr"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastError",
          "args": [],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSPC",
            "\"%s\"",
            "_(\"cannot write to stream\")"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ERANGE",
            "\"%s\"",
            "_(\"Too many bytes to write to stream\")"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamWrite(virStreamPtr st, const char *bytes, size_t nbytes)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    virFDStreamMsgPtr msg = NULL;\n    int ret = -1;\n\n    if (nbytes > INT_MAX) {\n        virReportSystemError(ERANGE, \"%s\",\n                             _(\"Too many bytes to write to stream\"));\n        return -1;\n    }\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n\n    if (fdst->length) {\n        if (fdst->length == fdst->offset) {\n            virReportSystemError(ENOSPC, \"%s\",\n                                 _(\"cannot write to stream\"));\n            virObjectUnlock(fdst);\n            return -1;\n        }\n\n        if ((fdst->length - fdst->offset) < nbytes)\n            nbytes = fdst->length - fdst->offset;\n    }\n\n    if (fdst->thread) {\n        char *buf;\n\n        if (fdst->threadQuit || fdst->threadErr) {\n\n            /* virStreamSend will virResetLastError possibly set\n             * by virFDStreamEvent */\n            if (fdst->threadErr && !virGetLastError())\n                virSetError(fdst->threadErr);\n            else\n                virReportSystemError(EBADF, \"%s\", _(\"cannot write to stream\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(msg) < 0 ||\n            VIR_ALLOC_N(buf, nbytes) < 0)\n            goto cleanup;\n\n        memcpy(buf, bytes, nbytes);\n        msg->type = VIR_FDSTREAM_MSG_TYPE_DATA;\n        msg->stream.data.buf = buf;\n        msg->stream.data.len = nbytes;\n\n        virFDStreamMsgQueuePush(fdst, msg, fdst->fd, \"pipe\");\n        msg = NULL;\n        ret = nbytes;\n    } else {\n     retry:\n        ret = write(fdst->fd, bytes, nbytes);\n        if (ret < 0) {\n            VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            VIR_WARNINGS_RESET\n                ret = -2;\n            } else if (errno == EINTR) {\n                goto retry;\n            } else {\n                ret = -1;\n                virReportSystemError(errno, \"%s\",\n                                     _(\"cannot write to stream\"));\n            }\n        }\n    }\n\n    if (fdst->length)\n        fdst->offset += ret;\n\n cleanup:\n    virObjectUnlock(fdst);\n    virFDStreamMsgFree(msg);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "754-758",
    "snippet": "static int\nvirFDStreamAbort(virStreamPtr st)\n{\n    return virFDStreamCloseInt(st, true);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamCloseInt",
          "args": [
            "st",
            "true"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamCloseInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "677-746",
          "snippet": "static int\nvirFDStreamCloseInt(virStreamPtr st, bool streamAbort)\n{\n    virFDStreamDataPtr fdst;\n    virStreamEventCallback cb;\n    void *opaque;\n    int ret;\n\n    VIR_DEBUG(\"st=%p\", st);\n\n    if (!st || !(fdst = st->privateData) || fdst->abortCallbackDispatching)\n        return 0;\n\n    virObjectLock(fdst);\n\n    /* aborting the stream, ensure the callback is called if it's\n     * registered for stream error event */\n    if (streamAbort &&\n        fdst->cb &&\n        (fdst->events & (VIR_STREAM_EVENT_READABLE |\n                         VIR_STREAM_EVENT_WRITABLE))) {\n        /* don't enter this function accidentally from the callback again */\n        if (fdst->abortCallbackCalled) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        fdst->abortCallbackCalled = true;\n        fdst->abortCallbackDispatching = true;\n\n        /* cache the pointers */\n        cb = fdst->cb;\n        opaque = fdst->opaque;\n        virObjectUnlock(fdst);\n\n        /* call failure callback, poll reports nothing on closed fd */\n        (cb)(st, VIR_STREAM_EVENT_ERROR, opaque);\n\n        virObjectLock(fdst);\n        fdst->abortCallbackDispatching = false;\n    }\n\n    if (virFDStreamJoinWorker(fdst, streamAbort) < 0)\n        ret = -1;\n\n    /* mutex locked */\n    if ((ret = VIR_CLOSE(fdst->fd)) < 0)\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to close\"));\n\n    st->privateData = NULL;\n\n    /* call the internal stream closing callback */\n    if (fdst->icbCb) {\n        /* the mutex is not accessible anymore, as private data is null */\n        (fdst->icbCb)(st, fdst->icbOpaque);\n        if (fdst->icbFreeOpaque)\n            (fdst->icbFreeOpaque)(fdst->icbOpaque);\n    }\n\n    if (fdst->dispatching) {\n        fdst->closed = true;\n        virObjectUnlock(fdst);\n    } else {\n        virObjectUnlock(fdst);\n        virObjectUnref(fdst);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamCloseInt(virStreamPtr st, bool streamAbort)\n{\n    virFDStreamDataPtr fdst;\n    virStreamEventCallback cb;\n    void *opaque;\n    int ret;\n\n    VIR_DEBUG(\"st=%p\", st);\n\n    if (!st || !(fdst = st->privateData) || fdst->abortCallbackDispatching)\n        return 0;\n\n    virObjectLock(fdst);\n\n    /* aborting the stream, ensure the callback is called if it's\n     * registered for stream error event */\n    if (streamAbort &&\n        fdst->cb &&\n        (fdst->events & (VIR_STREAM_EVENT_READABLE |\n                         VIR_STREAM_EVENT_WRITABLE))) {\n        /* don't enter this function accidentally from the callback again */\n        if (fdst->abortCallbackCalled) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        fdst->abortCallbackCalled = true;\n        fdst->abortCallbackDispatching = true;\n\n        /* cache the pointers */\n        cb = fdst->cb;\n        opaque = fdst->opaque;\n        virObjectUnlock(fdst);\n\n        /* call failure callback, poll reports nothing on closed fd */\n        (cb)(st, VIR_STREAM_EVENT_ERROR, opaque);\n\n        virObjectLock(fdst);\n        fdst->abortCallbackDispatching = false;\n    }\n\n    if (virFDStreamJoinWorker(fdst, streamAbort) < 0)\n        ret = -1;\n\n    /* mutex locked */\n    if ((ret = VIR_CLOSE(fdst->fd)) < 0)\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to close\"));\n\n    st->privateData = NULL;\n\n    /* call the internal stream closing callback */\n    if (fdst->icbCb) {\n        /* the mutex is not accessible anymore, as private data is null */\n        (fdst->icbCb)(st, fdst->icbOpaque);\n        if (fdst->icbFreeOpaque)\n            (fdst->icbFreeOpaque)(fdst->icbOpaque);\n    }\n\n    if (fdst->dispatching) {\n        fdst->closed = true;\n        virObjectUnlock(fdst);\n    } else {\n        virObjectUnlock(fdst);\n        virObjectUnref(fdst);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamAbort(virStreamPtr st)\n{\n    return virFDStreamCloseInt(st, true);\n}"
  },
  {
    "function_name": "virFDStreamClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "748-752",
    "snippet": "static int\nvirFDStreamClose(virStreamPtr st)\n{\n    return virFDStreamCloseInt(st, false);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamCloseInt",
          "args": [
            "st",
            "false"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamCloseInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "677-746",
          "snippet": "static int\nvirFDStreamCloseInt(virStreamPtr st, bool streamAbort)\n{\n    virFDStreamDataPtr fdst;\n    virStreamEventCallback cb;\n    void *opaque;\n    int ret;\n\n    VIR_DEBUG(\"st=%p\", st);\n\n    if (!st || !(fdst = st->privateData) || fdst->abortCallbackDispatching)\n        return 0;\n\n    virObjectLock(fdst);\n\n    /* aborting the stream, ensure the callback is called if it's\n     * registered for stream error event */\n    if (streamAbort &&\n        fdst->cb &&\n        (fdst->events & (VIR_STREAM_EVENT_READABLE |\n                         VIR_STREAM_EVENT_WRITABLE))) {\n        /* don't enter this function accidentally from the callback again */\n        if (fdst->abortCallbackCalled) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        fdst->abortCallbackCalled = true;\n        fdst->abortCallbackDispatching = true;\n\n        /* cache the pointers */\n        cb = fdst->cb;\n        opaque = fdst->opaque;\n        virObjectUnlock(fdst);\n\n        /* call failure callback, poll reports nothing on closed fd */\n        (cb)(st, VIR_STREAM_EVENT_ERROR, opaque);\n\n        virObjectLock(fdst);\n        fdst->abortCallbackDispatching = false;\n    }\n\n    if (virFDStreamJoinWorker(fdst, streamAbort) < 0)\n        ret = -1;\n\n    /* mutex locked */\n    if ((ret = VIR_CLOSE(fdst->fd)) < 0)\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to close\"));\n\n    st->privateData = NULL;\n\n    /* call the internal stream closing callback */\n    if (fdst->icbCb) {\n        /* the mutex is not accessible anymore, as private data is null */\n        (fdst->icbCb)(st, fdst->icbOpaque);\n        if (fdst->icbFreeOpaque)\n            (fdst->icbFreeOpaque)(fdst->icbOpaque);\n    }\n\n    if (fdst->dispatching) {\n        fdst->closed = true;\n        virObjectUnlock(fdst);\n    } else {\n        virObjectUnlock(fdst);\n        virObjectUnref(fdst);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamCloseInt(virStreamPtr st, bool streamAbort)\n{\n    virFDStreamDataPtr fdst;\n    virStreamEventCallback cb;\n    void *opaque;\n    int ret;\n\n    VIR_DEBUG(\"st=%p\", st);\n\n    if (!st || !(fdst = st->privateData) || fdst->abortCallbackDispatching)\n        return 0;\n\n    virObjectLock(fdst);\n\n    /* aborting the stream, ensure the callback is called if it's\n     * registered for stream error event */\n    if (streamAbort &&\n        fdst->cb &&\n        (fdst->events & (VIR_STREAM_EVENT_READABLE |\n                         VIR_STREAM_EVENT_WRITABLE))) {\n        /* don't enter this function accidentally from the callback again */\n        if (fdst->abortCallbackCalled) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        fdst->abortCallbackCalled = true;\n        fdst->abortCallbackDispatching = true;\n\n        /* cache the pointers */\n        cb = fdst->cb;\n        opaque = fdst->opaque;\n        virObjectUnlock(fdst);\n\n        /* call failure callback, poll reports nothing on closed fd */\n        (cb)(st, VIR_STREAM_EVENT_ERROR, opaque);\n\n        virObjectLock(fdst);\n        fdst->abortCallbackDispatching = false;\n    }\n\n    if (virFDStreamJoinWorker(fdst, streamAbort) < 0)\n        ret = -1;\n\n    /* mutex locked */\n    if ((ret = VIR_CLOSE(fdst->fd)) < 0)\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to close\"));\n\n    st->privateData = NULL;\n\n    /* call the internal stream closing callback */\n    if (fdst->icbCb) {\n        /* the mutex is not accessible anymore, as private data is null */\n        (fdst->icbCb)(st, fdst->icbOpaque);\n        if (fdst->icbFreeOpaque)\n            (fdst->icbFreeOpaque)(fdst->icbOpaque);\n    }\n\n    if (fdst->dispatching) {\n        fdst->closed = true;\n        virObjectUnlock(fdst);\n    } else {\n        virObjectUnlock(fdst);\n        virObjectUnref(fdst);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamClose(virStreamPtr st)\n{\n    return virFDStreamCloseInt(st, false);\n}"
  },
  {
    "function_name": "virFDStreamCloseInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "677-746",
    "snippet": "static int\nvirFDStreamCloseInt(virStreamPtr st, bool streamAbort)\n{\n    virFDStreamDataPtr fdst;\n    virStreamEventCallback cb;\n    void *opaque;\n    int ret;\n\n    VIR_DEBUG(\"st=%p\", st);\n\n    if (!st || !(fdst = st->privateData) || fdst->abortCallbackDispatching)\n        return 0;\n\n    virObjectLock(fdst);\n\n    /* aborting the stream, ensure the callback is called if it's\n     * registered for stream error event */\n    if (streamAbort &&\n        fdst->cb &&\n        (fdst->events & (VIR_STREAM_EVENT_READABLE |\n                         VIR_STREAM_EVENT_WRITABLE))) {\n        /* don't enter this function accidentally from the callback again */\n        if (fdst->abortCallbackCalled) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        fdst->abortCallbackCalled = true;\n        fdst->abortCallbackDispatching = true;\n\n        /* cache the pointers */\n        cb = fdst->cb;\n        opaque = fdst->opaque;\n        virObjectUnlock(fdst);\n\n        /* call failure callback, poll reports nothing on closed fd */\n        (cb)(st, VIR_STREAM_EVENT_ERROR, opaque);\n\n        virObjectLock(fdst);\n        fdst->abortCallbackDispatching = false;\n    }\n\n    if (virFDStreamJoinWorker(fdst, streamAbort) < 0)\n        ret = -1;\n\n    /* mutex locked */\n    if ((ret = VIR_CLOSE(fdst->fd)) < 0)\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to close\"));\n\n    st->privateData = NULL;\n\n    /* call the internal stream closing callback */\n    if (fdst->icbCb) {\n        /* the mutex is not accessible anymore, as private data is null */\n        (fdst->icbCb)(st, fdst->icbOpaque);\n        if (fdst->icbFreeOpaque)\n            (fdst->icbFreeOpaque)(fdst->icbOpaque);\n    }\n\n    if (fdst->dispatching) {\n        fdst->closed = true;\n        virObjectUnlock(fdst);\n    } else {\n        virObjectUnlock(fdst);\n        virObjectUnref(fdst);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "fdst"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fdst->icbOpaque"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "st",
            "fdst->icbOpaque"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to close\")"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to close\""
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fdst->fd"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamJoinWorker",
          "args": [
            "fdst",
            "streamAbort"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamJoinWorker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "647-674",
          "snippet": "static int\nvirFDStreamJoinWorker(virFDStreamDataPtr fdst,\n                      bool streamAbort)\n{\n    int ret = -1;\n    if (!fdst->thread)\n        return 0;\n\n    fdst->threadAbort = streamAbort;\n    fdst->threadQuit = true;\n    virCondSignal(&fdst->threadCond);\n\n    /* Give the thread a chance to lock the FD stream object. */\n    virObjectUnlock(fdst);\n    virThreadJoin(fdst->thread);\n    virObjectLock(fdst);\n\n    if (fdst->threadErr && !streamAbort) {\n        /* errors are expected on streamAbort */\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(fdst->thread);\n    virCondDestroy(&fdst->threadCond);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamJoinWorker(virFDStreamDataPtr fdst,\n                      bool streamAbort)\n{\n    int ret = -1;\n    if (!fdst->thread)\n        return 0;\n\n    fdst->threadAbort = streamAbort;\n    fdst->threadQuit = true;\n    virCondSignal(&fdst->threadCond);\n\n    /* Give the thread a chance to lock the FD stream object. */\n    virObjectUnlock(fdst);\n    virThreadJoin(fdst->thread);\n    virObjectLock(fdst);\n\n    if (fdst->threadErr && !streamAbort) {\n        /* errors are expected on streamAbort */\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(fdst->thread);\n    virCondDestroy(&fdst->threadCond);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "st",
            "VIR_STREAM_EVENT_ERROR",
            "opaque"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p\"",
            "st"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamCloseInt(virStreamPtr st, bool streamAbort)\n{\n    virFDStreamDataPtr fdst;\n    virStreamEventCallback cb;\n    void *opaque;\n    int ret;\n\n    VIR_DEBUG(\"st=%p\", st);\n\n    if (!st || !(fdst = st->privateData) || fdst->abortCallbackDispatching)\n        return 0;\n\n    virObjectLock(fdst);\n\n    /* aborting the stream, ensure the callback is called if it's\n     * registered for stream error event */\n    if (streamAbort &&\n        fdst->cb &&\n        (fdst->events & (VIR_STREAM_EVENT_READABLE |\n                         VIR_STREAM_EVENT_WRITABLE))) {\n        /* don't enter this function accidentally from the callback again */\n        if (fdst->abortCallbackCalled) {\n            virObjectUnlock(fdst);\n            return 0;\n        }\n\n        fdst->abortCallbackCalled = true;\n        fdst->abortCallbackDispatching = true;\n\n        /* cache the pointers */\n        cb = fdst->cb;\n        opaque = fdst->opaque;\n        virObjectUnlock(fdst);\n\n        /* call failure callback, poll reports nothing on closed fd */\n        (cb)(st, VIR_STREAM_EVENT_ERROR, opaque);\n\n        virObjectLock(fdst);\n        fdst->abortCallbackDispatching = false;\n    }\n\n    if (virFDStreamJoinWorker(fdst, streamAbort) < 0)\n        ret = -1;\n\n    /* mutex locked */\n    if ((ret = VIR_CLOSE(fdst->fd)) < 0)\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to close\"));\n\n    st->privateData = NULL;\n\n    /* call the internal stream closing callback */\n    if (fdst->icbCb) {\n        /* the mutex is not accessible anymore, as private data is null */\n        (fdst->icbCb)(st, fdst->icbOpaque);\n        if (fdst->icbFreeOpaque)\n            (fdst->icbFreeOpaque)(fdst->icbOpaque);\n    }\n\n    if (fdst->dispatching) {\n        fdst->closed = true;\n        virObjectUnlock(fdst);\n    } else {\n        virObjectUnlock(fdst);\n        virObjectUnref(fdst);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamJoinWorker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "647-674",
    "snippet": "static int\nvirFDStreamJoinWorker(virFDStreamDataPtr fdst,\n                      bool streamAbort)\n{\n    int ret = -1;\n    if (!fdst->thread)\n        return 0;\n\n    fdst->threadAbort = streamAbort;\n    fdst->threadQuit = true;\n    virCondSignal(&fdst->threadCond);\n\n    /* Give the thread a chance to lock the FD stream object. */\n    virObjectUnlock(fdst);\n    virThreadJoin(fdst->thread);\n    virObjectLock(fdst);\n\n    if (fdst->threadErr && !streamAbort) {\n        /* errors are expected on streamAbort */\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(fdst->thread);\n    virCondDestroy(&fdst->threadCond);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fdst->thread"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "fdst->thread"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamJoinWorker(virFDStreamDataPtr fdst,\n                      bool streamAbort)\n{\n    int ret = -1;\n    if (!fdst->thread)\n        return 0;\n\n    fdst->threadAbort = streamAbort;\n    fdst->threadQuit = true;\n    virCondSignal(&fdst->threadCond);\n\n    /* Give the thread a chance to lock the FD stream object. */\n    virObjectUnlock(fdst);\n    virThreadJoin(fdst->thread);\n    virObjectLock(fdst);\n\n    if (fdst->threadErr && !streamAbort) {\n        /* errors are expected on streamAbort */\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(fdst->thread);\n    virCondDestroy(&fdst->threadCond);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "569-644",
    "snippet": "static void\nvirFDStreamThread(void *opaque)\n{\n    virFDStreamThreadDataPtr data = opaque;\n    virStreamPtr st = data->st;\n    size_t length = data->length;\n    bool sparse = data->sparse;\n    int fdin = data->fdin;\n    char *fdinname = data->fdinname;\n    int fdout = data->fdout;\n    char *fdoutname = data->fdoutname;\n    virFDStreamDataPtr fdst = st->privateData;\n    bool doRead = fdst->threadDoRead;\n    size_t buflen = 256 * 1024;\n    size_t total = 0;\n    size_t dataLen = 0;\n\n    virObjectRef(fdst);\n    virObjectLock(fdst);\n\n    while (1) {\n        ssize_t got;\n\n        while (doRead == (fdst->msg != NULL) &&\n               !fdst->threadQuit) {\n            if (virCondWait(&fdst->threadCond, &fdst->parent.lock)) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"failed to wait on condition\"));\n                goto error;\n            }\n        }\n\n        if (fdst->threadQuit) {\n            /* If stream abort was requested, quit early. */\n            if (fdst->threadAbort)\n                goto cleanup;\n\n            /* Otherwise flush buffers and quit gracefully. */\n            if (doRead == (fdst->msg != NULL))\n                break;\n        }\n\n        if (doRead)\n            got = virFDStreamThreadDoRead(fdst, sparse,\n                                          fdin, fdout,\n                                          fdinname, fdoutname,\n                                          length, total,\n                                          &dataLen, buflen);\n        else\n            got = virFDStreamThreadDoWrite(fdst, sparse,\n                                           fdin, fdout,\n                                           fdinname, fdoutname);\n\n        if (got < 0)\n            goto error;\n\n        if (got == 0)\n            break;\n\n        total += got;\n    }\n\n cleanup:\n    fdst->threadQuit = true;\n    virObjectUnlock(fdst);\n    if (!virObjectUnref(fdst))\n        st->privateData = NULL;\n    VIR_FORCE_CLOSE(fdin);\n    VIR_FORCE_CLOSE(fdout);\n    virFDStreamThreadDataFree(data);\n    return;\n\n error:\n    fdst->threadErr = virSaveLastError();\n    goto cleanup;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSaveLastError",
          "args": [],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "virSaveLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "401-413",
          "snippet": "virErrorPtr\nvirSaveLastError(void)\n{\n    virErrorPtr to;\n    int saved_errno = errno;\n\n    if (VIR_ALLOC_QUIET(to) < 0)\n        return NULL;\n\n    virCopyLastError(to);\n    errno = saved_errno;\n    return to;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorPtr\nvirSaveLastError(void)\n{\n    virErrorPtr to;\n    int saved_errno = errno;\n\n    if (VIR_ALLOC_QUIET(to) < 0)\n        return NULL;\n\n    virCopyLastError(to);\n    errno = saved_errno;\n    return to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamThreadDataFree",
          "args": [
            "data"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamThreadDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "404-414",
          "snippet": "static void\nvirFDStreamThreadDataFree(virFDStreamThreadDataPtr data)\n{\n    if (!data)\n        return;\n\n    virObjectUnref(data->st);\n    VIR_FREE(data->fdinname);\n    VIR_FREE(data->fdoutname);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamThreadDataFree(virFDStreamThreadDataPtr data)\n{\n    if (!data)\n        return;\n\n    virObjectUnref(data->st);\n    VIR_FREE(data->fdinname);\n    VIR_FREE(data->fdoutname);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fdout"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fdin"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "fdst"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamThreadDoWrite",
          "args": [
            "fdst",
            "sparse",
            "fdin",
            "fdout",
            "fdinname",
            "fdoutname"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamThreadDoWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "503-566",
          "snippet": "static ssize_t\nvirFDStreamThreadDoWrite(virFDStreamDataPtr fdst,\n                         bool sparse,\n                         const int fdin,\n                         const int fdout,\n                         const char *fdinname,\n                         const char *fdoutname)\n{\n    ssize_t got = 0;\n    virFDStreamMsgPtr msg = fdst->msg;\n    off_t off;\n    bool pop = false;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        got = safewrite(fdout,\n                        msg->stream.data.buf + msg->stream.data.offset,\n                        msg->stream.data.len - msg->stream.data.offset);\n        if (got < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to write %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        msg->stream.data.offset += got;\n\n        pop = msg->stream.data.offset == msg->stream.data.len;\n        break;\n\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        if (!sparse) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected stream hole\"));\n            return -1;\n        }\n\n        got = msg->stream.hole.len;\n        off = lseek(fdout, got, SEEK_CUR);\n        if (off == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        if (ftruncate(fdout, off) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to truncate %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        pop = true;\n        break;\n    }\n\n    if (pop) {\n        virFDStreamMsgQueuePop(fdst, fdin, fdinname);\n        virFDStreamMsgFree(msg);\n    }\n\n    return got;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic ssize_t\nvirFDStreamThreadDoWrite(virFDStreamDataPtr fdst,\n                         bool sparse,\n                         const int fdin,\n                         const int fdout,\n                         const char *fdinname,\n                         const char *fdoutname)\n{\n    ssize_t got = 0;\n    virFDStreamMsgPtr msg = fdst->msg;\n    off_t off;\n    bool pop = false;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        got = safewrite(fdout,\n                        msg->stream.data.buf + msg->stream.data.offset,\n                        msg->stream.data.len - msg->stream.data.offset);\n        if (got < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to write %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        msg->stream.data.offset += got;\n\n        pop = msg->stream.data.offset == msg->stream.data.len;\n        break;\n\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        if (!sparse) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected stream hole\"));\n            return -1;\n        }\n\n        got = msg->stream.hole.len;\n        off = lseek(fdout, got, SEEK_CUR);\n        if (off == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        if (ftruncate(fdout, off) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to truncate %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        pop = true;\n        break;\n    }\n\n    if (pop) {\n        virFDStreamMsgQueuePop(fdst, fdin, fdinname);\n        virFDStreamMsgFree(msg);\n    }\n\n    return got;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamThreadDoRead",
          "args": [
            "fdst",
            "sparse",
            "fdin",
            "fdout",
            "fdinname",
            "fdoutname",
            "length",
            "total",
            "&dataLen",
            "buflen"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamThreadDoRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "417-500",
          "snippet": "static ssize_t\nvirFDStreamThreadDoRead(virFDStreamDataPtr fdst,\n                        bool sparse,\n                        const int fdin,\n                        const int fdout,\n                        const char *fdinname,\n                        const char *fdoutname,\n                        size_t length,\n                        size_t total,\n                        size_t *dataLen,\n                        size_t buflen)\n{\n    virFDStreamMsgPtr msg = NULL;\n    int inData = 0;\n    long long sectionLen = 0;\n    char *buf = NULL;\n    ssize_t got;\n\n    if (sparse && *dataLen == 0) {\n        if (virFileInData(fdin, &inData, &sectionLen) < 0)\n            goto error;\n\n        if (length &&\n            sectionLen > length - total)\n            sectionLen = length - total;\n\n        if (inData)\n            *dataLen = sectionLen;\n    }\n\n    if (length &&\n        buflen > length - total)\n        buflen = length - total;\n\n    if (VIR_ALLOC(msg) < 0)\n        goto error;\n\n    if (sparse && *dataLen == 0) {\n        msg->type = VIR_FDSTREAM_MSG_TYPE_HOLE;\n        msg->stream.hole.len = sectionLen;\n        got = sectionLen;\n\n        /* HACK: The message queue is one directional. So caller\n         * cannot make us skip the hole. Do that for them instead. */\n        if (sectionLen &&\n            lseek(fdin, sectionLen, SEEK_CUR) == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdinname);\n            goto error;\n        }\n    } else {\n        if (sparse &&\n            buflen > *dataLen)\n            buflen = *dataLen;\n\n        if (VIR_ALLOC_N(buf, buflen) < 0)\n            goto error;\n\n        if ((got = saferead(fdin, buf, buflen)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to read %s\"),\n                                 fdinname);\n            goto error;\n        }\n\n        msg->type = VIR_FDSTREAM_MSG_TYPE_DATA;\n        msg->stream.data.buf = buf;\n        msg->stream.data.len = got;\n        buf = NULL;\n        if (sparse)\n            *dataLen -= got;\n    }\n\n    virFDStreamMsgQueuePush(fdst, msg, fdout, fdoutname);\n    msg = NULL;\n\n    return got;\n\n error:\n    VIR_FREE(buf);\n    virFDStreamMsgFree(msg);\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic ssize_t\nvirFDStreamThreadDoRead(virFDStreamDataPtr fdst,\n                        bool sparse,\n                        const int fdin,\n                        const int fdout,\n                        const char *fdinname,\n                        const char *fdoutname,\n                        size_t length,\n                        size_t total,\n                        size_t *dataLen,\n                        size_t buflen)\n{\n    virFDStreamMsgPtr msg = NULL;\n    int inData = 0;\n    long long sectionLen = 0;\n    char *buf = NULL;\n    ssize_t got;\n\n    if (sparse && *dataLen == 0) {\n        if (virFileInData(fdin, &inData, &sectionLen) < 0)\n            goto error;\n\n        if (length &&\n            sectionLen > length - total)\n            sectionLen = length - total;\n\n        if (inData)\n            *dataLen = sectionLen;\n    }\n\n    if (length &&\n        buflen > length - total)\n        buflen = length - total;\n\n    if (VIR_ALLOC(msg) < 0)\n        goto error;\n\n    if (sparse && *dataLen == 0) {\n        msg->type = VIR_FDSTREAM_MSG_TYPE_HOLE;\n        msg->stream.hole.len = sectionLen;\n        got = sectionLen;\n\n        /* HACK: The message queue is one directional. So caller\n         * cannot make us skip the hole. Do that for them instead. */\n        if (sectionLen &&\n            lseek(fdin, sectionLen, SEEK_CUR) == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdinname);\n            goto error;\n        }\n    } else {\n        if (sparse &&\n            buflen > *dataLen)\n            buflen = *dataLen;\n\n        if (VIR_ALLOC_N(buf, buflen) < 0)\n            goto error;\n\n        if ((got = saferead(fdin, buf, buflen)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to read %s\"),\n                                 fdinname);\n            goto error;\n        }\n\n        msg->type = VIR_FDSTREAM_MSG_TYPE_DATA;\n        msg->stream.data.buf = buf;\n        msg->stream.data.len = got;\n        buf = NULL;\n        if (sparse)\n            *dataLen -= got;\n    }\n\n    virFDStreamMsgQueuePush(fdst, msg, fdout, fdoutname);\n    msg = NULL;\n\n    return got;\n\n error:\n    VIR_FREE(buf);\n    virFDStreamMsgFree(msg);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to wait on condition\")"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to wait on condition\""
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondWait",
          "args": [
            "&fdst->threadCond",
            "&fdst->parent.lock"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "145-153",
          "snippet": "int virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "fdst"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamThread(void *opaque)\n{\n    virFDStreamThreadDataPtr data = opaque;\n    virStreamPtr st = data->st;\n    size_t length = data->length;\n    bool sparse = data->sparse;\n    int fdin = data->fdin;\n    char *fdinname = data->fdinname;\n    int fdout = data->fdout;\n    char *fdoutname = data->fdoutname;\n    virFDStreamDataPtr fdst = st->privateData;\n    bool doRead = fdst->threadDoRead;\n    size_t buflen = 256 * 1024;\n    size_t total = 0;\n    size_t dataLen = 0;\n\n    virObjectRef(fdst);\n    virObjectLock(fdst);\n\n    while (1) {\n        ssize_t got;\n\n        while (doRead == (fdst->msg != NULL) &&\n               !fdst->threadQuit) {\n            if (virCondWait(&fdst->threadCond, &fdst->parent.lock)) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"failed to wait on condition\"));\n                goto error;\n            }\n        }\n\n        if (fdst->threadQuit) {\n            /* If stream abort was requested, quit early. */\n            if (fdst->threadAbort)\n                goto cleanup;\n\n            /* Otherwise flush buffers and quit gracefully. */\n            if (doRead == (fdst->msg != NULL))\n                break;\n        }\n\n        if (doRead)\n            got = virFDStreamThreadDoRead(fdst, sparse,\n                                          fdin, fdout,\n                                          fdinname, fdoutname,\n                                          length, total,\n                                          &dataLen, buflen);\n        else\n            got = virFDStreamThreadDoWrite(fdst, sparse,\n                                           fdin, fdout,\n                                           fdinname, fdoutname);\n\n        if (got < 0)\n            goto error;\n\n        if (got == 0)\n            break;\n\n        total += got;\n    }\n\n cleanup:\n    fdst->threadQuit = true;\n    virObjectUnlock(fdst);\n    if (!virObjectUnref(fdst))\n        st->privateData = NULL;\n    VIR_FORCE_CLOSE(fdin);\n    VIR_FORCE_CLOSE(fdout);\n    virFDStreamThreadDataFree(data);\n    return;\n\n error:\n    fdst->threadErr = virSaveLastError();\n    goto cleanup;\n}"
  },
  {
    "function_name": "virFDStreamThreadDoWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "503-566",
    "snippet": "static ssize_t\nvirFDStreamThreadDoWrite(virFDStreamDataPtr fdst,\n                         bool sparse,\n                         const int fdin,\n                         const int fdout,\n                         const char *fdinname,\n                         const char *fdoutname)\n{\n    ssize_t got = 0;\n    virFDStreamMsgPtr msg = fdst->msg;\n    off_t off;\n    bool pop = false;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        got = safewrite(fdout,\n                        msg->stream.data.buf + msg->stream.data.offset,\n                        msg->stream.data.len - msg->stream.data.offset);\n        if (got < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to write %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        msg->stream.data.offset += got;\n\n        pop = msg->stream.data.offset == msg->stream.data.len;\n        break;\n\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        if (!sparse) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected stream hole\"));\n            return -1;\n        }\n\n        got = msg->stream.hole.len;\n        off = lseek(fdout, got, SEEK_CUR);\n        if (off == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        if (ftruncate(fdout, off) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to truncate %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        pop = true;\n        break;\n    }\n\n    if (pop) {\n        virFDStreamMsgQueuePop(fdst, fdin, fdinname);\n        virFDStreamMsgFree(msg);\n    }\n\n    return got;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamMsgFree",
          "args": [
            "msg"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "191-207",
          "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgQueuePop",
          "args": [
            "fdst",
            "fdin",
            "fdinname"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueuePop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "165-188",
          "snippet": "static virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to truncate %s\")",
            "fdoutname"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to truncate %s\""
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fdout",
            "off"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to seek in %s\")",
            "fdoutname"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fdout",
            "got",
            "SEEK_CUR"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unexpected stream hole\")"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to write %s\")",
            "fdoutname"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fdout",
            "msg->stream.data.buf + msg->stream.data.offset",
            "msg->stream.data.len - msg->stream.data.offset"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic ssize_t\nvirFDStreamThreadDoWrite(virFDStreamDataPtr fdst,\n                         bool sparse,\n                         const int fdin,\n                         const int fdout,\n                         const char *fdinname,\n                         const char *fdoutname)\n{\n    ssize_t got = 0;\n    virFDStreamMsgPtr msg = fdst->msg;\n    off_t off;\n    bool pop = false;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        got = safewrite(fdout,\n                        msg->stream.data.buf + msg->stream.data.offset,\n                        msg->stream.data.len - msg->stream.data.offset);\n        if (got < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to write %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        msg->stream.data.offset += got;\n\n        pop = msg->stream.data.offset == msg->stream.data.len;\n        break;\n\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        if (!sparse) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"unexpected stream hole\"));\n            return -1;\n        }\n\n        got = msg->stream.hole.len;\n        off = lseek(fdout, got, SEEK_CUR);\n        if (off == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        if (ftruncate(fdout, off) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to truncate %s\"),\n                                 fdoutname);\n            return -1;\n        }\n\n        pop = true;\n        break;\n    }\n\n    if (pop) {\n        virFDStreamMsgQueuePop(fdst, fdin, fdinname);\n        virFDStreamMsgFree(msg);\n    }\n\n    return got;\n}"
  },
  {
    "function_name": "virFDStreamThreadDoRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "417-500",
    "snippet": "static ssize_t\nvirFDStreamThreadDoRead(virFDStreamDataPtr fdst,\n                        bool sparse,\n                        const int fdin,\n                        const int fdout,\n                        const char *fdinname,\n                        const char *fdoutname,\n                        size_t length,\n                        size_t total,\n                        size_t *dataLen,\n                        size_t buflen)\n{\n    virFDStreamMsgPtr msg = NULL;\n    int inData = 0;\n    long long sectionLen = 0;\n    char *buf = NULL;\n    ssize_t got;\n\n    if (sparse && *dataLen == 0) {\n        if (virFileInData(fdin, &inData, &sectionLen) < 0)\n            goto error;\n\n        if (length &&\n            sectionLen > length - total)\n            sectionLen = length - total;\n\n        if (inData)\n            *dataLen = sectionLen;\n    }\n\n    if (length &&\n        buflen > length - total)\n        buflen = length - total;\n\n    if (VIR_ALLOC(msg) < 0)\n        goto error;\n\n    if (sparse && *dataLen == 0) {\n        msg->type = VIR_FDSTREAM_MSG_TYPE_HOLE;\n        msg->stream.hole.len = sectionLen;\n        got = sectionLen;\n\n        /* HACK: The message queue is one directional. So caller\n         * cannot make us skip the hole. Do that for them instead. */\n        if (sectionLen &&\n            lseek(fdin, sectionLen, SEEK_CUR) == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdinname);\n            goto error;\n        }\n    } else {\n        if (sparse &&\n            buflen > *dataLen)\n            buflen = *dataLen;\n\n        if (VIR_ALLOC_N(buf, buflen) < 0)\n            goto error;\n\n        if ((got = saferead(fdin, buf, buflen)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to read %s\"),\n                                 fdinname);\n            goto error;\n        }\n\n        msg->type = VIR_FDSTREAM_MSG_TYPE_DATA;\n        msg->stream.data.buf = buf;\n        msg->stream.data.len = got;\n        buf = NULL;\n        if (sparse)\n            *dataLen -= got;\n    }\n\n    virFDStreamMsgQueuePush(fdst, msg, fdout, fdoutname);\n    msg = NULL;\n\n    return got;\n\n error:\n    VIR_FREE(buf);\n    virFDStreamMsgFree(msg);\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamMsgFree",
          "args": [
            "msg"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "191-207",
          "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamMsgQueuePush",
          "args": [
            "fdst",
            "msg",
            "fdout",
            "fdoutname"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueuePush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "139-162",
          "snippet": "static int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to read %s\")",
            "fdinname"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to read %s\""
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fdin",
            "buf",
            "buflen"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buf",
            "buflen"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to seek in %s\")",
            "fdinname"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fdin",
            "sectionLen",
            "SEEK_CUR"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "msg"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileInData",
          "args": [
            "fdin",
            "&inData",
            "&sectionLen"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virFileInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4053-4062",
          "snippet": "int\nvirFileInData(int fd G_GNUC_UNUSED,\n              int *inData G_GNUC_UNUSED,\n              long long *length G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"sparse files not supported\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileInData(int fd G_GNUC_UNUSED,\n              int *inData G_GNUC_UNUSED,\n              long long *length G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    virReportSystemError(errno, \"%s\",\n                         _(\"sparse files not supported\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic ssize_t\nvirFDStreamThreadDoRead(virFDStreamDataPtr fdst,\n                        bool sparse,\n                        const int fdin,\n                        const int fdout,\n                        const char *fdinname,\n                        const char *fdoutname,\n                        size_t length,\n                        size_t total,\n                        size_t *dataLen,\n                        size_t buflen)\n{\n    virFDStreamMsgPtr msg = NULL;\n    int inData = 0;\n    long long sectionLen = 0;\n    char *buf = NULL;\n    ssize_t got;\n\n    if (sparse && *dataLen == 0) {\n        if (virFileInData(fdin, &inData, &sectionLen) < 0)\n            goto error;\n\n        if (length &&\n            sectionLen > length - total)\n            sectionLen = length - total;\n\n        if (inData)\n            *dataLen = sectionLen;\n    }\n\n    if (length &&\n        buflen > length - total)\n        buflen = length - total;\n\n    if (VIR_ALLOC(msg) < 0)\n        goto error;\n\n    if (sparse && *dataLen == 0) {\n        msg->type = VIR_FDSTREAM_MSG_TYPE_HOLE;\n        msg->stream.hole.len = sectionLen;\n        got = sectionLen;\n\n        /* HACK: The message queue is one directional. So caller\n         * cannot make us skip the hole. Do that for them instead. */\n        if (sectionLen &&\n            lseek(fdin, sectionLen, SEEK_CUR) == (off_t) -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to seek in %s\"),\n                                 fdinname);\n            goto error;\n        }\n    } else {\n        if (sparse &&\n            buflen > *dataLen)\n            buflen = *dataLen;\n\n        if (VIR_ALLOC_N(buf, buflen) < 0)\n            goto error;\n\n        if ((got = saferead(fdin, buf, buflen)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to read %s\"),\n                                 fdinname);\n            goto error;\n        }\n\n        msg->type = VIR_FDSTREAM_MSG_TYPE_DATA;\n        msg->stream.data.buf = buf;\n        msg->stream.data.len = got;\n        buf = NULL;\n        if (sparse)\n            *dataLen -= got;\n    }\n\n    virFDStreamMsgQueuePush(fdst, msg, fdout, fdoutname);\n    msg = NULL;\n\n    return got;\n\n error:\n    VIR_FREE(buf);\n    virFDStreamMsgFree(msg);\n    return -1;\n}"
  },
  {
    "function_name": "virFDStreamThreadDataFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "404-414",
    "snippet": "static void\nvirFDStreamThreadDataFree(virFDStreamThreadDataPtr data)\n{\n    if (!data)\n        return;\n\n    virObjectUnref(data->st);\n    VIR_FREE(data->fdinname);\n    VIR_FREE(data->fdoutname);\n    VIR_FREE(data);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->fdoutname"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->fdinname"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "data->st"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamThreadDataFree(virFDStreamThreadDataPtr data)\n{\n    if (!data)\n        return;\n\n    virObjectUnref(data->st);\n    VIR_FREE(data->fdinname);\n    VIR_FREE(data->fdoutname);\n    VIR_FREE(data);\n}"
  },
  {
    "function_name": "virFDStreamAddCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "341-387",
    "snippet": "static int\nvirFDStreamAddCallback(virStreamPtr st,\n                       int events,\n                       virStreamEventCallback cb,\n                       void *opaque,\n                       virFreeCallback ff)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    int ret = -1;\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n    if (fdst->watch != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream already has a callback registered\"));\n        goto cleanup;\n    }\n\n    if ((fdst->watch = virEventAddHandle(fdst->fd,\n                                         events,\n                                         virFDStreamEvent,\n                                         st,\n                                         virFDStreamCallbackFree)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot register file watch on stream\"));\n        goto cleanup;\n    }\n\n    fdst->cbRemoved = false;\n    fdst->cb = cb;\n    fdst->opaque = opaque;\n    fdst->ff = ff;\n    fdst->events = events;\n    fdst->abortCallbackCalled = false;\n    virStreamRef(st);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamRef",
          "args": [
            "st"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "85-97",
          "snippet": "int\nvirStreamRef(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p refs=%d\", stream,\n              stream ? stream->parent.u.s.refs : 0);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    virObjectRef(stream);\n    return 0;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamRef(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p refs=%d\", stream,\n              stream ? stream->parent.u.s.refs : 0);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    virObjectRef(stream);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot register file watch on stream\")"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot register file watch on stream\""
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "fdst->fd",
            "events",
            "virFDStreamEvent",
            "st",
            "virFDStreamCallbackFree"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream already has a callback registered\")"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamAddCallback(virStreamPtr st,\n                       int events,\n                       virStreamEventCallback cb,\n                       void *opaque,\n                       virFreeCallback ff)\n{\n    virFDStreamDataPtr fdst = st->privateData;\n    int ret = -1;\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n    if (fdst->watch != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream already has a callback registered\"));\n        goto cleanup;\n    }\n\n    if ((fdst->watch = virEventAddHandle(fdst->fd,\n                                         events,\n                                         virFDStreamEvent,\n                                         st,\n                                         virFDStreamCallbackFree)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot register file watch on stream\"));\n        goto cleanup;\n    }\n\n    fdst->cbRemoved = false;\n    fdst->cb = cb;\n    fdst->opaque = opaque;\n    fdst->ff = ff;\n    fdst->events = events;\n    fdst->abortCallbackCalled = false;\n    virStreamRef(st);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamCallbackFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "335-338",
    "snippet": "static void virFDStreamCallbackFree(void *opaque)\n{\n    virObjectUnref(opaque);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "opaque"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void virFDStreamCallbackFree(void *opaque)\n{\n    virObjectUnref(opaque);\n}"
  },
  {
    "function_name": "virFDStreamEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "290-333",
    "snippet": "static void virFDStreamEvent(int watch G_GNUC_UNUSED,\n                             int fd G_GNUC_UNUSED,\n                             int events,\n                             void *opaque)\n{\n    virStreamPtr stream = opaque;\n    virFDStreamDataPtr fdst = stream->privateData;\n    virStreamEventCallback cb;\n    void *cbopaque;\n    virFreeCallback ff;\n    bool closed;\n\n    if (!fdst)\n        return;\n\n    virObjectLock(fdst);\n    if (!fdst->cb) {\n        virObjectUnlock(fdst);\n        return;\n    }\n\n    if (fdst->threadErr) {\n        events |= VIR_STREAM_EVENT_ERROR;\n        virSetError(fdst->threadErr);\n    }\n\n    cb = fdst->cb;\n    cbopaque = fdst->opaque;\n    ff = fdst->ff;\n    fdst->dispatching = true;\n    virObjectUnlock(fdst);\n\n    cb(stream, events, cbopaque);\n\n    virObjectLock(fdst);\n    fdst->dispatching = false;\n    if (fdst->cbRemoved && ff)\n        (ff)(cbopaque);\n    closed = fdst->closed;\n    virObjectUnlock(fdst);\n\n    if (closed)\n        virObjectUnref(fdst);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "fdst"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cbopaque"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "stream",
            "events",
            "cbopaque"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "file_iterate_pci_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "855-861",
          "snippet": "static int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "fdst->threadErr"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void virFDStreamEvent(int watch G_GNUC_UNUSED,\n                             int fd G_GNUC_UNUSED,\n                             int events,\n                             void *opaque)\n{\n    virStreamPtr stream = opaque;\n    virFDStreamDataPtr fdst = stream->privateData;\n    virStreamEventCallback cb;\n    void *cbopaque;\n    virFreeCallback ff;\n    bool closed;\n\n    if (!fdst)\n        return;\n\n    virObjectLock(fdst);\n    if (!fdst->cb) {\n        virObjectUnlock(fdst);\n        return;\n    }\n\n    if (fdst->threadErr) {\n        events |= VIR_STREAM_EVENT_ERROR;\n        virSetError(fdst->threadErr);\n    }\n\n    cb = fdst->cb;\n    cbopaque = fdst->opaque;\n    ff = fdst->ff;\n    fdst->dispatching = true;\n    virObjectUnlock(fdst);\n\n    cb(stream, events, cbopaque);\n\n    virObjectLock(fdst);\n    fdst->dispatching = false;\n    if (fdst->cbRemoved && ff)\n        (ff)(cbopaque);\n    closed = fdst->closed;\n    virObjectUnlock(fdst);\n\n    if (closed)\n        virObjectUnref(fdst);\n}"
  },
  {
    "function_name": "virFDStreamUpdateCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "262-288",
    "snippet": "static int virFDStreamUpdateCallback(virStreamPtr stream, int events)\n{\n    virFDStreamDataPtr fdst = stream->privateData;\n    int ret = -1;\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n    if (fdst->watch == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream does not have a callback registered\"));\n        goto cleanup;\n    }\n\n    virEventUpdateHandle(fdst->watch, events);\n    fdst->events = events;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventUpdateHandle",
          "args": [
            "fdst->watch",
            "events"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virEventUpdateHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "98-103",
          "snippet": "void\nvirEventUpdateHandle(int watch, int events)\n{\n    if (updateHandleImpl)\n        updateHandleImpl(watch, events);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventUpdateHandleFunc updateHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventUpdateHandleFunc updateHandleImpl;\n\nvoid\nvirEventUpdateHandle(int watch, int events)\n{\n    if (updateHandleImpl)\n        updateHandleImpl(watch, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream does not have a callback registered\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"stream does not have a callback registered\""
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamUpdateCallback(virStreamPtr stream, int events)\n{\n    virFDStreamDataPtr fdst = stream->privateData;\n    int ret = -1;\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n    if (fdst->watch == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream does not have a callback registered\"));\n        goto cleanup;\n    }\n\n    virEventUpdateHandle(fdst->watch, events);\n    fdst->events = events;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamRemoveCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "225-260",
    "snippet": "static int virFDStreamRemoveCallback(virStreamPtr stream)\n{\n    virFDStreamDataPtr fdst = stream->privateData;\n    int ret = -1;\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n    if (fdst->watch == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream does not have a callback registered\"));\n        goto cleanup;\n    }\n\n    virEventRemoveHandle(fdst->watch);\n    if (fdst->dispatching)\n        fdst->cbRemoved = true;\n    else if (fdst->ff)\n        (fdst->ff)(fdst->opaque);\n\n    fdst->watch = 0;\n    fdst->ff = NULL;\n    fdst->cb = NULL;\n    fdst->events = 0;\n    fdst->opaque = NULL;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "fdst"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fdst->opaque"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "fdst->watch"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream does not have a callback registered\")"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"stream does not have a callback registered\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "fdst"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"stream is not open\")"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamRemoveCallback(virStreamPtr stream)\n{\n    virFDStreamDataPtr fdst = stream->privateData;\n    int ret = -1;\n\n    if (!fdst) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream is not open\"));\n        return -1;\n    }\n\n    virObjectLock(fdst);\n    if (fdst->watch == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"stream does not have a callback registered\"));\n        goto cleanup;\n    }\n\n    virEventRemoveHandle(fdst->watch);\n    if (fdst->dispatching)\n        fdst->cbRemoved = true;\n    else if (fdst->ff)\n        (fdst->ff)(fdst->opaque);\n\n    fdst->watch = 0;\n    fdst->ff = NULL;\n    fdst->cb = NULL;\n    fdst->events = 0;\n    fdst->opaque = NULL;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(fdst);\n    return ret;\n}"
  },
  {
    "function_name": "virFDStreamMsgQueueFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "210-222",
    "snippet": "static void\nvirFDStreamMsgQueueFree(virFDStreamMsgPtr *queue)\n{\n    virFDStreamMsgPtr tmp = *queue;\n\n    while (tmp) {\n        virFDStreamMsgPtr next = tmp->next;\n        virFDStreamMsgFree(tmp);\n        tmp = next;\n    }\n\n    *queue = NULL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamMsgFree",
          "args": [
            "tmp"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "191-207",
          "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgQueueFree(virFDStreamMsgPtr *queue)\n{\n    virFDStreamMsgPtr tmp = *queue;\n\n    while (tmp) {\n        virFDStreamMsgPtr next = tmp->next;\n        virFDStreamMsgFree(tmp);\n        tmp = next;\n    }\n\n    *queue = NULL;\n}"
  },
  {
    "function_name": "virFDStreamMsgFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "191-207",
    "snippet": "static void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg->stream.data.buf"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgFree(virFDStreamMsgPtr msg)\n{\n    if (!msg)\n        return;\n\n    switch (msg->type) {\n    case VIR_FDSTREAM_MSG_TYPE_DATA:\n        VIR_FREE(msg->stream.data.buf);\n        break;\n    case VIR_FDSTREAM_MSG_TYPE_HOLE:\n        /* nada */\n        break;\n    }\n\n    VIR_FREE(msg);\n}"
  },
  {
    "function_name": "virFDStreamMsgQueuePop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "165-188",
    "snippet": "static virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to read from %s\")",
            "fdname"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to read from %s\""
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fd",
            "&c",
            "sizeof(c)"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virFDStreamMsgPtr\nvirFDStreamMsgQueuePop(virFDStreamDataPtr fdst,\n                       int fd,\n                       const char *fdname)\n{\n    virFDStreamMsgPtr tmp = fdst->msg;\n    char c;\n\n    if (tmp) {\n        fdst->msg = tmp->next;\n        tmp->next = NULL;\n    }\n\n    virCondSignal(&fdst->threadCond);\n\n    if (saferead(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to read from %s\"),\n                             fdname);\n        return NULL;\n    }\n\n    return tmp;\n}"
  },
  {
    "function_name": "virFDStreamMsgQueuePush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "139-162",
    "snippet": "static int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to write to %s\")",
            "fdname"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to write to %s\""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "&c",
            "sizeof(c)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&fdst->threadCond"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirFDStreamMsgQueuePush(virFDStreamDataPtr fdst,\n                        virFDStreamMsgPtr msg,\n                        int fd,\n                        const char *fdname)\n{\n    virFDStreamMsgPtr *tmp = &fdst->msg;\n    char c = '1';\n\n    while (*tmp)\n        tmp = &(*tmp)->next;\n\n    *tmp = msg;\n    virCondSignal(&fdst->threadCond);\n\n    if (safewrite(fd, &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno,\n                             _(\"Unable to write to %s\"),\n                             fdname);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virFDStreamDataOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "128-134",
    "snippet": "static int virFDStreamDataOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virFDStreamData, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virFDStreamData",
            "virClassForObjectLockable()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virFDStreamDataOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virFDStreamData, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virFDStreamDataDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
    "lines": "118-126",
    "snippet": "static void\nvirFDStreamDataDispose(void *obj)\n{\n    virFDStreamDataPtr fdst = obj;\n\n    VIR_DEBUG(\"obj=%p\", fdst);\n    virFreeError(fdst->threadErr);\n    virFDStreamMsgQueueFree(&fdst->msg);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"virfdstream.h\"",
      "# include <termios.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFDStreamMsgQueueFree",
          "args": [
            "&fdst->msg"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamMsgQueueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "210-222",
          "snippet": "static void\nvirFDStreamMsgQueueFree(virFDStreamMsgPtr *queue)\n{\n    virFDStreamMsgPtr tmp = *queue;\n\n    while (tmp) {\n        virFDStreamMsgPtr next = tmp->next;\n        virFDStreamMsgFree(tmp);\n        tmp = next;\n    }\n\n    *queue = NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamMsgQueueFree(virFDStreamMsgPtr *queue)\n{\n    virFDStreamMsgPtr tmp = *queue;\n\n    while (tmp) {\n        virFDStreamMsgPtr next = tmp->next;\n        virFDStreamMsgFree(tmp);\n        tmp = next;\n    }\n\n    *queue = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "fdst->threadErr"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"obj=%p\"",
            "fdst"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirFDStreamDataDispose(void *obj)\n{\n    virFDStreamDataPtr fdst = obj;\n\n    VIR_DEBUG(\"obj=%p\", fdst);\n    virFreeError(fdst->threadErr);\n    virFDStreamMsgQueueFree(&fdst->msg);\n}"
  }
]