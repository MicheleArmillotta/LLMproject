[
  {
    "function_name": "vir_g_strdup_vprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
    "lines": "205-213",
    "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
    "includes": [
      "#include \"glibcompat.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_vprintf",
          "args": [
            "msg",
            "args"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
  },
  {
    "function_name": "vir_g_strdup_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
    "lines": "191-202",
    "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
    "includes": [
      "#include \"glibcompat.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_vprintf",
          "args": [
            "msg",
            "args"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "msg"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
  },
  {
    "function_name": "vir_g_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
    "lines": "177-185",
    "snippet": "gint\nvir_g_fsync(gint fd)\n{\n#ifdef G_OS_WIN32\n    return _commit(fd);\n#else\n    return fsync(fd);\n#endif\n}",
    "includes": [
      "#include \"glibcompat.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "fd"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "177-185",
          "snippet": "gint\nvir_g_fsync(gint fd)\n{\n#ifdef G_OS_WIN32\n    return _commit(fd);\n#else\n    return fsync(fd);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_commit",
          "args": [
            "fd"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\ngint\nvir_g_fsync(gint fd)\n{\n#ifdef G_OS_WIN32\n    return _commit(fd);\n#else\n    return fsync(fd);\n#endif\n}"
  },
  {
    "function_name": "vir_g_canonicalize_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
    "lines": "72-173",
    "snippet": "gchar *\nvir_g_canonicalize_filename(const gchar *filename,\n                            const gchar *relative_to)\n{\n#if GLIB_CHECK_VERSION(2, 58, 0)\n    return g_canonicalize_filename(filename, relative_to);\n#else /* ! GLIB_CHECK_VERSION(2, 58, 0) */\n    gchar *canon, *start, *p, *q;\n    guint i;\n\n    g_return_val_if_fail(relative_to == NULL || g_path_is_absolute(relative_to), NULL);\n\n    if (!g_path_is_absolute(filename)) {\n        gchar *cwd_allocated = NULL;\n        const gchar  *cwd;\n\n        if (relative_to != NULL)\n            cwd = relative_to;\n        else\n            cwd = cwd_allocated = g_get_current_dir();\n\n        canon = g_build_filename(cwd, filename, NULL);\n        g_free(cwd_allocated);\n    } else {\n        canon = g_strdup(filename);\n    }\n\n    start = (char *)g_path_skip_root(canon);\n\n    if (start == NULL) {\n        /* This shouldn't really happen, as g_get_current_dir() should\n           return an absolute pathname, but bug 573843 shows this is\n           not always happening */\n        g_free(canon);\n        return g_build_filename(G_DIR_SEPARATOR_S, filename, NULL);\n    }\n\n    /* POSIX allows double slashes at the start to\n     * mean something special (as does windows too).\n     * So, \"//\" != \"/\", but more than two slashes\n     * is treated as \"/\".\n     */\n    i = 0;\n    for (p = start - 1;\n         (p >= canon) &&\n             G_IS_DIR_SEPARATOR(*p);\n         p--)\n        i++;\n    if (i > 2) {\n        i -= 1;\n        start -= i;\n        memmove(start, start+i, strlen(start+i) + 1);\n    }\n\n    /* Make sure we're using the canonical dir separator */\n    p++;\n    while (p < start && G_IS_DIR_SEPARATOR(*p))\n        *p++ = G_DIR_SEPARATOR;\n\n    p = start;\n    while (*p != 0) {\n        if (p[0] == '.' && (p[1] == 0 || G_IS_DIR_SEPARATOR(p[1]))) {\n            memmove(p, p+1, strlen(p+1)+1);\n        } else if (p[0] == '.' && p[1] == '.' &&\n                   (p[2] == 0 || G_IS_DIR_SEPARATOR(p[2]))) {\n            q = p + 2;\n            /* Skip previous separator */\n            p = p - 2;\n            if (p < start)\n                p = start;\n            while (p > start && !G_IS_DIR_SEPARATOR(*p))\n                p--;\n            if (G_IS_DIR_SEPARATOR(*p))\n                *p++ = G_DIR_SEPARATOR;\n            memmove(p, q, strlen(q)+1);\n        } else {\n            /* Skip until next separator */\n            while (*p != 0 && !G_IS_DIR_SEPARATOR(*p))\n                p++;\n\n            if (*p != 0) {\n                /* Canonicalize one separator */\n                *p++ = G_DIR_SEPARATOR;\n            }\n        }\n\n        /* Remove additional separators */\n        q = p;\n        while (*q && G_IS_DIR_SEPARATOR(*q))\n            q++;\n\n        if (p != q)\n            memmove(p, q, strlen(q) + 1);\n    }\n\n    /* Remove trailing slashes */\n    if (p > start && G_IS_DIR_SEPARATOR(*(p-1)))\n        *(p-1) = 0;\n\n    return canon;\n#endif /* ! GLIB_CHECK_VERSION(2, 58, 0) */\n}",
    "includes": [
      "#include \"glibcompat.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*(p-1)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "q",
            "strlen(q) + 1"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*q"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*p"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "q",
            "strlen(q)+1"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*p"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*p"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "p[2]"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "p+1",
            "strlen(p+1)+1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p+1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "p[1]"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*p"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "start",
            "start+i",
            "strlen(start+i) + 1"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start+i"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_IS_DIR_SEPARATOR",
          "args": [
            "*p"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_build_filename",
          "args": [
            "G_DIR_SEPARATOR_S",
            "filename",
            "NULL"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "canon"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_skip_root",
          "args": [
            "canon"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "filename"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "cwd_allocated"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_build_filename",
          "args": [
            "cwd",
            "filename",
            "NULL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_get_current_dir",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_is_absolute",
          "args": [
            "filename"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_return_val_if_fail",
          "args": [
            "relative_to == NULL || g_path_is_absolute(relative_to)",
            "NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_is_absolute",
          "args": [
            "relative_to"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_canonicalize_filename",
          "args": [
            "filename",
            "relative_to"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_canonicalize_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "72-173",
          "snippet": "gchar *\nvir_g_canonicalize_filename(const gchar *filename,\n                            const gchar *relative_to)\n{\n#if GLIB_CHECK_VERSION(2, 58, 0)\n    return g_canonicalize_filename(filename, relative_to);\n#else /* ! GLIB_CHECK_VERSION(2, 58, 0) */\n    gchar *canon, *start, *p, *q;\n    guint i;\n\n    g_return_val_if_fail(relative_to == NULL || g_path_is_absolute(relative_to), NULL);\n\n    if (!g_path_is_absolute(filename)) {\n        gchar *cwd_allocated = NULL;\n        const gchar  *cwd;\n\n        if (relative_to != NULL)\n            cwd = relative_to;\n        else\n            cwd = cwd_allocated = g_get_current_dir();\n\n        canon = g_build_filename(cwd, filename, NULL);\n        g_free(cwd_allocated);\n    } else {\n        canon = g_strdup(filename);\n    }\n\n    start = (char *)g_path_skip_root(canon);\n\n    if (start == NULL) {\n        /* This shouldn't really happen, as g_get_current_dir() should\n           return an absolute pathname, but bug 573843 shows this is\n           not always happening */\n        g_free(canon);\n        return g_build_filename(G_DIR_SEPARATOR_S, filename, NULL);\n    }\n\n    /* POSIX allows double slashes at the start to\n     * mean something special (as does windows too).\n     * So, \"//\" != \"/\", but more than two slashes\n     * is treated as \"/\".\n     */\n    i = 0;\n    for (p = start - 1;\n         (p >= canon) &&\n             G_IS_DIR_SEPARATOR(*p);\n         p--)\n        i++;\n    if (i > 2) {\n        i -= 1;\n        start -= i;\n        memmove(start, start+i, strlen(start+i) + 1);\n    }\n\n    /* Make sure we're using the canonical dir separator */\n    p++;\n    while (p < start && G_IS_DIR_SEPARATOR(*p))\n        *p++ = G_DIR_SEPARATOR;\n\n    p = start;\n    while (*p != 0) {\n        if (p[0] == '.' && (p[1] == 0 || G_IS_DIR_SEPARATOR(p[1]))) {\n            memmove(p, p+1, strlen(p+1)+1);\n        } else if (p[0] == '.' && p[1] == '.' &&\n                   (p[2] == 0 || G_IS_DIR_SEPARATOR(p[2]))) {\n            q = p + 2;\n            /* Skip previous separator */\n            p = p - 2;\n            if (p < start)\n                p = start;\n            while (p > start && !G_IS_DIR_SEPARATOR(*p))\n                p--;\n            if (G_IS_DIR_SEPARATOR(*p))\n                *p++ = G_DIR_SEPARATOR;\n            memmove(p, q, strlen(q)+1);\n        } else {\n            /* Skip until next separator */\n            while (*p != 0 && !G_IS_DIR_SEPARATOR(*p))\n                p++;\n\n            if (*p != 0) {\n                /* Canonicalize one separator */\n                *p++ = G_DIR_SEPARATOR;\n            }\n        }\n\n        /* Remove additional separators */\n        q = p;\n        while (*q && G_IS_DIR_SEPARATOR(*q))\n            q++;\n\n        if (p != q)\n            memmove(p, q, strlen(q) + 1);\n    }\n\n    /* Remove trailing slashes */\n    if (p > start && G_IS_DIR_SEPARATOR(*(p-1)))\n        *(p-1) = 0;\n\n    return canon;\n#endif /* ! GLIB_CHECK_VERSION(2, 58, 0) */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GLIB_CHECK_VERSION",
          "args": [
            "2",
            "58",
            "0"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\ngchar *\nvir_g_canonicalize_filename(const gchar *filename,\n                            const gchar *relative_to)\n{\n#if GLIB_CHECK_VERSION(2, 58, 0)\n    return g_canonicalize_filename(filename, relative_to);\n#else /* ! GLIB_CHECK_VERSION(2, 58, 0) */\n    gchar *canon, *start, *p, *q;\n    guint i;\n\n    g_return_val_if_fail(relative_to == NULL || g_path_is_absolute(relative_to), NULL);\n\n    if (!g_path_is_absolute(filename)) {\n        gchar *cwd_allocated = NULL;\n        const gchar  *cwd;\n\n        if (relative_to != NULL)\n            cwd = relative_to;\n        else\n            cwd = cwd_allocated = g_get_current_dir();\n\n        canon = g_build_filename(cwd, filename, NULL);\n        g_free(cwd_allocated);\n    } else {\n        canon = g_strdup(filename);\n    }\n\n    start = (char *)g_path_skip_root(canon);\n\n    if (start == NULL) {\n        /* This shouldn't really happen, as g_get_current_dir() should\n           return an absolute pathname, but bug 573843 shows this is\n           not always happening */\n        g_free(canon);\n        return g_build_filename(G_DIR_SEPARATOR_S, filename, NULL);\n    }\n\n    /* POSIX allows double slashes at the start to\n     * mean something special (as does windows too).\n     * So, \"//\" != \"/\", but more than two slashes\n     * is treated as \"/\".\n     */\n    i = 0;\n    for (p = start - 1;\n         (p >= canon) &&\n             G_IS_DIR_SEPARATOR(*p);\n         p--)\n        i++;\n    if (i > 2) {\n        i -= 1;\n        start -= i;\n        memmove(start, start+i, strlen(start+i) + 1);\n    }\n\n    /* Make sure we're using the canonical dir separator */\n    p++;\n    while (p < start && G_IS_DIR_SEPARATOR(*p))\n        *p++ = G_DIR_SEPARATOR;\n\n    p = start;\n    while (*p != 0) {\n        if (p[0] == '.' && (p[1] == 0 || G_IS_DIR_SEPARATOR(p[1]))) {\n            memmove(p, p+1, strlen(p+1)+1);\n        } else if (p[0] == '.' && p[1] == '.' &&\n                   (p[2] == 0 || G_IS_DIR_SEPARATOR(p[2]))) {\n            q = p + 2;\n            /* Skip previous separator */\n            p = p - 2;\n            if (p < start)\n                p = start;\n            while (p > start && !G_IS_DIR_SEPARATOR(*p))\n                p--;\n            if (G_IS_DIR_SEPARATOR(*p))\n                *p++ = G_DIR_SEPARATOR;\n            memmove(p, q, strlen(q)+1);\n        } else {\n            /* Skip until next separator */\n            while (*p != 0 && !G_IS_DIR_SEPARATOR(*p))\n                p++;\n\n            if (*p != 0) {\n                /* Canonicalize one separator */\n                *p++ = G_DIR_SEPARATOR;\n            }\n        }\n\n        /* Remove additional separators */\n        q = p;\n        while (*q && G_IS_DIR_SEPARATOR(*q))\n            q++;\n\n        if (p != q)\n            memmove(p, q, strlen(q) + 1);\n    }\n\n    /* Remove trailing slashes */\n    if (p > start && G_IS_DIR_SEPARATOR(*(p-1)))\n        *(p-1) = 0;\n\n    return canon;\n#endif /* ! GLIB_CHECK_VERSION(2, 58, 0) */\n}"
  }
]