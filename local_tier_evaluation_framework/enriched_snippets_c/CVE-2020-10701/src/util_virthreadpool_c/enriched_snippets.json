[
  {
    "function_name": "virThreadPoolSetParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "428-485",
    "snippet": "int\nvirThreadPoolSetParameters(virThreadPoolPtr pool,\n                           long long int minWorkers,\n                           long long int maxWorkers,\n                           long long int prioWorkers)\n{\n    size_t max;\n    size_t min;\n\n    virMutexLock(&pool->mutex);\n\n    max = maxWorkers >= 0 ? maxWorkers : pool->maxWorkers;\n    min = minWorkers >= 0 ? minWorkers : pool->minWorkers;\n    if (min > max) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"minWorkers cannot be larger than maxWorkers\"));\n        goto error;\n    }\n\n    if ((maxWorkers == 0 && pool->maxWorkers > 0) ||\n        (maxWorkers > 0 && pool->maxWorkers == 0)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"maxWorkers must not be switched from zero to non-zero\"\n                         \" and vice versa\"));\n        goto error;\n    }\n\n    if (minWorkers >= 0) {\n        if ((size_t) minWorkers > pool->nWorkers &&\n            virThreadPoolExpand(pool, minWorkers - pool->nWorkers,\n                                false) < 0)\n            goto error;\n        pool->minWorkers = minWorkers;\n    }\n\n    if (maxWorkers >= 0) {\n        pool->maxWorkers = maxWorkers;\n        virCondBroadcast(&pool->cond);\n    }\n\n    if (prioWorkers >= 0) {\n        if (prioWorkers < pool->nPrioWorkers) {\n            virCondBroadcast(&pool->prioCond);\n        } else if ((size_t) prioWorkers > pool->nPrioWorkers &&\n                   virThreadPoolExpand(pool, prioWorkers - pool->nPrioWorkers,\n                                       true) < 0) {\n            goto error;\n        }\n        pool->maxPrioWorkers = prioWorkers;\n    }\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolExpand",
          "args": [
            "pool",
            "prioWorkers - pool->nPrioWorkers",
            "true"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "178-220",
          "snippet": "static int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondBroadcast",
          "args": [
            "&pool->prioCond"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "virCondBroadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "175-178",
          "snippet": "void virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"maxWorkers must not be switched from zero to non-zero\"\n                         \" and vice versa\")"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"maxWorkers must not be switched from zero to non-zero\"\n                         \" and vice versa\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"minWorkers cannot be larger than maxWorkers\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nint\nvirThreadPoolSetParameters(virThreadPoolPtr pool,\n                           long long int minWorkers,\n                           long long int maxWorkers,\n                           long long int prioWorkers)\n{\n    size_t max;\n    size_t min;\n\n    virMutexLock(&pool->mutex);\n\n    max = maxWorkers >= 0 ? maxWorkers : pool->maxWorkers;\n    min = minWorkers >= 0 ? minWorkers : pool->minWorkers;\n    if (min > max) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"minWorkers cannot be larger than maxWorkers\"));\n        goto error;\n    }\n\n    if ((maxWorkers == 0 && pool->maxWorkers > 0) ||\n        (maxWorkers > 0 && pool->maxWorkers == 0)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"maxWorkers must not be switched from zero to non-zero\"\n                         \" and vice versa\"));\n        goto error;\n    }\n\n    if (minWorkers >= 0) {\n        if ((size_t) minWorkers > pool->nWorkers &&\n            virThreadPoolExpand(pool, minWorkers - pool->nWorkers,\n                                false) < 0)\n            goto error;\n        pool->minWorkers = minWorkers;\n    }\n\n    if (maxWorkers >= 0) {\n        pool->maxWorkers = maxWorkers;\n        virCondBroadcast(&pool->cond);\n    }\n\n    if (prioWorkers >= 0) {\n        if (prioWorkers < pool->nPrioWorkers) {\n            virCondBroadcast(&pool->prioCond);\n        } else if ((size_t) prioWorkers > pool->nPrioWorkers &&\n                   virThreadPoolExpand(pool, prioWorkers - pool->nPrioWorkers,\n                                       true) < 0) {\n            goto error;\n        }\n        pool->maxPrioWorkers = prioWorkers;\n    }\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}"
  },
  {
    "function_name": "virThreadPoolSendJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "382-426",
    "snippet": "int virThreadPoolSendJob(virThreadPoolPtr pool,\n                         unsigned int priority,\n                         void *jobData)\n{\n    virThreadPoolJobPtr job;\n\n    virMutexLock(&pool->mutex);\n    if (pool->quit)\n        goto error;\n\n    if (pool->freeWorkers - pool->jobQueueDepth <= 0 &&\n        pool->nWorkers < pool->maxWorkers &&\n        virThreadPoolExpand(pool, 1, false) < 0)\n        goto error;\n\n    if (VIR_ALLOC(job) < 0)\n        goto error;\n\n    job->data = jobData;\n    job->priority = priority;\n\n    job->prev = pool->jobList.tail;\n    if (pool->jobList.tail)\n        pool->jobList.tail->next = job;\n    pool->jobList.tail = job;\n\n    if (!pool->jobList.head)\n        pool->jobList.head = job;\n\n    if (priority && !pool->jobList.firstPrio)\n        pool->jobList.firstPrio = job;\n\n    pool->jobQueueDepth++;\n\n    virCondSignal(&pool->cond);\n    if (priority)\n        virCondSignal(&pool->prioCond);\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&pool->prioCond"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "job"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolExpand",
          "args": [
            "pool",
            "1",
            "false"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "178-220",
          "snippet": "static int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nint virThreadPoolSendJob(virThreadPoolPtr pool,\n                         unsigned int priority,\n                         void *jobData)\n{\n    virThreadPoolJobPtr job;\n\n    virMutexLock(&pool->mutex);\n    if (pool->quit)\n        goto error;\n\n    if (pool->freeWorkers - pool->jobQueueDepth <= 0 &&\n        pool->nWorkers < pool->maxWorkers &&\n        virThreadPoolExpand(pool, 1, false) < 0)\n        goto error;\n\n    if (VIR_ALLOC(job) < 0)\n        goto error;\n\n    job->data = jobData;\n    job->priority = priority;\n\n    job->prev = pool->jobList.tail;\n    if (pool->jobList.tail)\n        pool->jobList.tail->next = job;\n    pool->jobList.tail = job;\n\n    if (!pool->jobList.head)\n        pool->jobList.head = job;\n\n    if (priority && !pool->jobList.firstPrio)\n        pool->jobList.firstPrio = job;\n\n    pool->jobQueueDepth++;\n\n    virCondSignal(&pool->cond);\n    if (priority)\n        virCondSignal(&pool->prioCond);\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}"
  },
  {
    "function_name": "virThreadPoolGetJobQueueDepth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "367-376",
    "snippet": "size_t virThreadPoolGetJobQueueDepth(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->jobQueueDepth;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetJobQueueDepth(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->jobQueueDepth;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
  },
  {
    "function_name": "virThreadPoolGetFreeWorkers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "356-365",
    "snippet": "size_t virThreadPoolGetFreeWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->freeWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetFreeWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->freeWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
  },
  {
    "function_name": "virThreadPoolGetCurrentWorkers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "345-354",
    "snippet": "size_t virThreadPoolGetCurrentWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetCurrentWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
  },
  {
    "function_name": "virThreadPoolGetPriorityWorkers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "334-343",
    "snippet": "size_t virThreadPoolGetPriorityWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nPrioWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetPriorityWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nPrioWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
  },
  {
    "function_name": "virThreadPoolGetMaxWorkers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "323-332",
    "snippet": "size_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
  },
  {
    "function_name": "virThreadPoolGetMinWorkers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "312-321",
    "snippet": "size_t virThreadPoolGetMinWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->minWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMinWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->minWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
  },
  {
    "function_name": "virThreadPoolFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "274-309",
    "snippet": "void virThreadPoolFree(virThreadPoolPtr pool)\n{\n    virThreadPoolJobPtr job;\n    bool priority = false;\n\n    if (!pool)\n        return;\n\n    virMutexLock(&pool->mutex);\n    pool->quit = true;\n    if (pool->nWorkers > 0)\n        virCondBroadcast(&pool->cond);\n    if (pool->nPrioWorkers > 0) {\n        priority = true;\n        virCondBroadcast(&pool->prioCond);\n    }\n\n    while (pool->nWorkers > 0 || pool->nPrioWorkers > 0)\n        ignore_value(virCondWait(&pool->quit_cond, &pool->mutex));\n\n    while ((job = pool->jobList.head)) {\n        pool->jobList.head = pool->jobList.head->next;\n        VIR_FREE(job);\n    }\n\n    VIR_FREE(pool->workers);\n    virMutexUnlock(&pool->mutex);\n    virMutexDestroy(&pool->mutex);\n    virCondDestroy(&pool->quit_cond);\n    virCondDestroy(&pool->cond);\n    if (priority) {\n        VIR_FREE(pool->prioWorkers);\n        virCondDestroy(&pool->prioCond);\n    }\n    VIR_FREE(pool);\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pool"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&pool->prioCond"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pool->prioWorkers"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&pool->mutex"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pool->workers"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virCondWait(&pool->quit_cond, &pool->mutex)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondWait",
          "args": [
            "&pool->quit_cond",
            "&pool->mutex"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "145-153",
          "snippet": "int virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondBroadcast",
          "args": [
            "&pool->prioCond"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virCondBroadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "175-178",
          "snippet": "void virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nvoid virThreadPoolFree(virThreadPoolPtr pool)\n{\n    virThreadPoolJobPtr job;\n    bool priority = false;\n\n    if (!pool)\n        return;\n\n    virMutexLock(&pool->mutex);\n    pool->quit = true;\n    if (pool->nWorkers > 0)\n        virCondBroadcast(&pool->cond);\n    if (pool->nPrioWorkers > 0) {\n        priority = true;\n        virCondBroadcast(&pool->prioCond);\n    }\n\n    while (pool->nWorkers > 0 || pool->nPrioWorkers > 0)\n        ignore_value(virCondWait(&pool->quit_cond, &pool->mutex));\n\n    while ((job = pool->jobList.head)) {\n        pool->jobList.head = pool->jobList.head->next;\n        VIR_FREE(job);\n    }\n\n    VIR_FREE(pool->workers);\n    virMutexUnlock(&pool->mutex);\n    virMutexDestroy(&pool->mutex);\n    virCondDestroy(&pool->quit_cond);\n    virCondDestroy(&pool->cond);\n    if (priority) {\n        VIR_FREE(pool->prioWorkers);\n        virCondDestroy(&pool->prioCond);\n    }\n    VIR_FREE(pool);\n}"
  },
  {
    "function_name": "virThreadPoolNewFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "222-272",
    "snippet": "virThreadPoolPtr\nvirThreadPoolNewFull(size_t minWorkers,\n                     size_t maxWorkers,\n                     size_t prioWorkers,\n                     virThreadPoolJobFunc func,\n                     const char *name,\n                     void *opaque)\n{\n    virThreadPoolPtr pool;\n\n    if (minWorkers > maxWorkers)\n        minWorkers = maxWorkers;\n\n    if (VIR_ALLOC(pool) < 0)\n        return NULL;\n\n    pool->jobList.tail = pool->jobList.head = NULL;\n\n    pool->jobFunc = func;\n    pool->jobName = name;\n    pool->jobOpaque = opaque;\n\n    if (virMutexInit(&pool->mutex) < 0)\n        goto error;\n    if (virCondInit(&pool->cond) < 0)\n        goto error;\n    if (virCondInit(&pool->quit_cond) < 0)\n        goto error;\n\n    pool->minWorkers = minWorkers;\n    pool->maxWorkers = maxWorkers;\n    pool->maxPrioWorkers = prioWorkers;\n\n    if (virThreadPoolExpand(pool, minWorkers, false) < 0)\n        goto error;\n\n    if (prioWorkers) {\n        if (virCondInit(&pool->prioCond) < 0)\n            goto error;\n\n        if (virThreadPoolExpand(pool, prioWorkers, true) < 0)\n            goto error;\n    }\n\n    return pool;\n\n error:\n    virThreadPoolFree(pool);\n    return NULL;\n\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virThreadPoolFree",
          "args": [
            "pool"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "274-309",
          "snippet": "void virThreadPoolFree(virThreadPoolPtr pool)\n{\n    virThreadPoolJobPtr job;\n    bool priority = false;\n\n    if (!pool)\n        return;\n\n    virMutexLock(&pool->mutex);\n    pool->quit = true;\n    if (pool->nWorkers > 0)\n        virCondBroadcast(&pool->cond);\n    if (pool->nPrioWorkers > 0) {\n        priority = true;\n        virCondBroadcast(&pool->prioCond);\n    }\n\n    while (pool->nWorkers > 0 || pool->nPrioWorkers > 0)\n        ignore_value(virCondWait(&pool->quit_cond, &pool->mutex));\n\n    while ((job = pool->jobList.head)) {\n        pool->jobList.head = pool->jobList.head->next;\n        VIR_FREE(job);\n    }\n\n    VIR_FREE(pool->workers);\n    virMutexUnlock(&pool->mutex);\n    virMutexDestroy(&pool->mutex);\n    virCondDestroy(&pool->quit_cond);\n    virCondDestroy(&pool->cond);\n    if (priority) {\n        VIR_FREE(pool->prioWorkers);\n        virCondDestroy(&pool->prioCond);\n    }\n    VIR_FREE(pool);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nvoid virThreadPoolFree(virThreadPoolPtr pool)\n{\n    virThreadPoolJobPtr job;\n    bool priority = false;\n\n    if (!pool)\n        return;\n\n    virMutexLock(&pool->mutex);\n    pool->quit = true;\n    if (pool->nWorkers > 0)\n        virCondBroadcast(&pool->cond);\n    if (pool->nPrioWorkers > 0) {\n        priority = true;\n        virCondBroadcast(&pool->prioCond);\n    }\n\n    while (pool->nWorkers > 0 || pool->nPrioWorkers > 0)\n        ignore_value(virCondWait(&pool->quit_cond, &pool->mutex));\n\n    while ((job = pool->jobList.head)) {\n        pool->jobList.head = pool->jobList.head->next;\n        VIR_FREE(job);\n    }\n\n    VIR_FREE(pool->workers);\n    virMutexUnlock(&pool->mutex);\n    virMutexDestroy(&pool->mutex);\n    virCondDestroy(&pool->quit_cond);\n    virCondDestroy(&pool->cond);\n    if (priority) {\n        VIR_FREE(pool->prioWorkers);\n        virCondDestroy(&pool->prioCond);\n    }\n    VIR_FREE(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolExpand",
          "args": [
            "pool",
            "prioWorkers",
            "true"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "178-220",
          "snippet": "static int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&pool->prioCond"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&pool->mutex"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pool"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nvirThreadPoolPtr\nvirThreadPoolNewFull(size_t minWorkers,\n                     size_t maxWorkers,\n                     size_t prioWorkers,\n                     virThreadPoolJobFunc func,\n                     const char *name,\n                     void *opaque)\n{\n    virThreadPoolPtr pool;\n\n    if (minWorkers > maxWorkers)\n        minWorkers = maxWorkers;\n\n    if (VIR_ALLOC(pool) < 0)\n        return NULL;\n\n    pool->jobList.tail = pool->jobList.head = NULL;\n\n    pool->jobFunc = func;\n    pool->jobName = name;\n    pool->jobOpaque = opaque;\n\n    if (virMutexInit(&pool->mutex) < 0)\n        goto error;\n    if (virCondInit(&pool->cond) < 0)\n        goto error;\n    if (virCondInit(&pool->quit_cond) < 0)\n        goto error;\n\n    pool->minWorkers = minWorkers;\n    pool->maxWorkers = maxWorkers;\n    pool->maxPrioWorkers = prioWorkers;\n\n    if (virThreadPoolExpand(pool, minWorkers, false) < 0)\n        goto error;\n\n    if (prioWorkers) {\n        if (virCondInit(&pool->prioCond) < 0)\n            goto error;\n\n        if (virThreadPoolExpand(pool, prioWorkers, true) < 0)\n            goto error;\n    }\n\n    return pool;\n\n error:\n    virThreadPoolFree(pool);\n    return NULL;\n\n}"
  },
  {
    "function_name": "virThreadPoolExpand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "178-220",
    "snippet": "static int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to create thread\")"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create thread\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&(*workers)[i]",
            "false",
            "virThreadPoolWorker",
            "name",
            "true",
            "data"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "data"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "*workers",
            "*curWorkers",
            "gain"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic int\nvirThreadPoolExpand(virThreadPoolPtr pool, size_t gain, bool priority)\n{\n    virThreadPtr *workers = priority ? &pool->prioWorkers : &pool->workers;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t i = 0;\n    struct virThreadPoolWorkerData *data = NULL;\n\n    if (VIR_EXPAND_N(*workers, *curWorkers, gain) < 0)\n        return -1;\n\n    for (i = 0; i < gain; i++) {\n        g_autofree char *name = NULL;\n        if (VIR_ALLOC(data) < 0)\n            goto error;\n\n        data->pool = pool;\n        data->cond = priority ? &pool->prioCond : &pool->cond;\n        data->priority = priority;\n\n        if (priority)\n            name = g_strdup_printf(\"prio-%s\", pool->jobName);\n        else\n            name = g_strdup(pool->jobName);\n\n        if (virThreadCreateFull(&(*workers)[i],\n                                false,\n                                virThreadPoolWorker,\n                                name,\n                                true,\n                                data) < 0) {\n            VIR_FREE(data);\n            virReportSystemError(errno, \"%s\", _(\"Failed to create thread\"));\n            goto error;\n        }\n    }\n\n    return 0;\n\n error:\n    *curWorkers -= gain - i;\n    return -1;\n}"
  },
  {
    "function_name": "virThreadPoolWorker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "92-176",
    "snippet": "static void virThreadPoolWorker(void *opaque)\n{\n    struct virThreadPoolWorkerData *data = opaque;\n    virThreadPoolPtr pool = data->pool;\n    virCondPtr cond = data->cond;\n    bool priority = data->priority;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t *maxLimit = priority ? &pool->maxPrioWorkers : &pool->maxWorkers;\n    virThreadPoolJobPtr job = NULL;\n\n    VIR_FREE(data);\n\n    virMutexLock(&pool->mutex);\n\n    while (1) {\n        /* In order to support async worker termination, we need ensure that\n         * both busy and free workers know if they need to terminated. Thus,\n         * busy workers need to check for this fact before they start waiting for\n         * another job (and before taking another one from the queue); and\n         * free workers need to check for this right after waking up.\n         */\n        if (virThreadPoolWorkerQuitHelper(*curWorkers, *maxLimit))\n            goto out;\n        while (!pool->quit &&\n               ((!priority && !pool->jobList.head) ||\n                (priority && !pool->jobList.firstPrio))) {\n            if (!priority)\n                pool->freeWorkers++;\n            if (virCondWait(cond, &pool->mutex) < 0) {\n                if (!priority)\n                    pool->freeWorkers--;\n                goto out;\n            }\n            if (!priority)\n                pool->freeWorkers--;\n\n            if (virThreadPoolWorkerQuitHelper(*curWorkers, *maxLimit))\n                goto out;\n        }\n\n        if (pool->quit)\n            break;\n\n        if (priority) {\n            job = pool->jobList.firstPrio;\n        } else {\n            job = pool->jobList.head;\n        }\n\n        if (job == pool->jobList.firstPrio) {\n            virThreadPoolJobPtr tmp = job->next;\n            while (tmp) {\n                if (tmp->priority)\n                    break;\n                tmp = tmp->next;\n            }\n            pool->jobList.firstPrio = tmp;\n        }\n\n        if (job->prev)\n            job->prev->next = job->next;\n        else\n            pool->jobList.head = job->next;\n        if (job->next)\n            job->next->prev = job->prev;\n        else\n            pool->jobList.tail = job->prev;\n\n        pool->jobQueueDepth--;\n\n        virMutexUnlock(&pool->mutex);\n        (pool->jobFunc)(job->data, pool->jobOpaque);\n        VIR_FREE(job);\n        virMutexLock(&pool->mutex);\n    }\n\n out:\n    if (priority)\n        pool->nPrioWorkers--;\n    else\n        pool->nWorkers--;\n    if (pool->nWorkers == 0 && pool->nPrioWorkers == 0)\n        virCondSignal(&pool->quit_cond);\n    virMutexUnlock(&pool->mutex);\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&pool->mutex"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&pool->quit_cond"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&pool->mutex"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job->data",
            "pool->jobOpaque"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolWorkerQuitHelper",
          "args": [
            "*curWorkers",
            "*maxLimit"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolWorkerQuitHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "87-90",
          "snippet": "static inline bool virThreadPoolWorkerQuitHelper(size_t count, size_t limit)\n{\n    return count > limit;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic inline bool virThreadPoolWorkerQuitHelper(size_t count, size_t limit)\n{\n    return count > limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondWait",
          "args": [
            "cond",
            "&pool->mutex"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "145-153",
          "snippet": "int virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWait(virCondPtr c, virMutexPtr m)\n{\n    int ret;\n    if ((ret = pthread_cond_wait(&c->cond, &m->lock)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic void virThreadPoolWorker(void *opaque)\n{\n    struct virThreadPoolWorkerData *data = opaque;\n    virThreadPoolPtr pool = data->pool;\n    virCondPtr cond = data->cond;\n    bool priority = data->priority;\n    size_t *curWorkers = priority ? &pool->nPrioWorkers : &pool->nWorkers;\n    size_t *maxLimit = priority ? &pool->maxPrioWorkers : &pool->maxWorkers;\n    virThreadPoolJobPtr job = NULL;\n\n    VIR_FREE(data);\n\n    virMutexLock(&pool->mutex);\n\n    while (1) {\n        /* In order to support async worker termination, we need ensure that\n         * both busy and free workers know if they need to terminated. Thus,\n         * busy workers need to check for this fact before they start waiting for\n         * another job (and before taking another one from the queue); and\n         * free workers need to check for this right after waking up.\n         */\n        if (virThreadPoolWorkerQuitHelper(*curWorkers, *maxLimit))\n            goto out;\n        while (!pool->quit &&\n               ((!priority && !pool->jobList.head) ||\n                (priority && !pool->jobList.firstPrio))) {\n            if (!priority)\n                pool->freeWorkers++;\n            if (virCondWait(cond, &pool->mutex) < 0) {\n                if (!priority)\n                    pool->freeWorkers--;\n                goto out;\n            }\n            if (!priority)\n                pool->freeWorkers--;\n\n            if (virThreadPoolWorkerQuitHelper(*curWorkers, *maxLimit))\n                goto out;\n        }\n\n        if (pool->quit)\n            break;\n\n        if (priority) {\n            job = pool->jobList.firstPrio;\n        } else {\n            job = pool->jobList.head;\n        }\n\n        if (job == pool->jobList.firstPrio) {\n            virThreadPoolJobPtr tmp = job->next;\n            while (tmp) {\n                if (tmp->priority)\n                    break;\n                tmp = tmp->next;\n            }\n            pool->jobList.firstPrio = tmp;\n        }\n\n        if (job->prev)\n            job->prev->next = job->next;\n        else\n            pool->jobList.head = job->next;\n        if (job->next)\n            job->next->prev = job->prev;\n        else\n            pool->jobList.tail = job->prev;\n\n        pool->jobQueueDepth--;\n\n        virMutexUnlock(&pool->mutex);\n        (pool->jobFunc)(job->data, pool->jobOpaque);\n        VIR_FREE(job);\n        virMutexLock(&pool->mutex);\n    }\n\n out:\n    if (priority)\n        pool->nPrioWorkers--;\n    else\n        pool->nWorkers--;\n    if (pool->nWorkers == 0 && pool->nPrioWorkers == 0)\n        virCondSignal(&pool->quit_cond);\n    virMutexUnlock(&pool->mutex);\n}"
  },
  {
    "function_name": "virThreadPoolWorkerQuitHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
    "lines": "87-90",
    "snippet": "static inline bool virThreadPoolWorkerQuitHelper(size_t count, size_t limit)\n{\n    return count > limit;\n}",
    "includes": [
      "#include \"virerror.h\"",
      "#include \"virthread.h\"",
      "#include \"viralloc.h\"",
      "#include \"virthreadpool.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nstatic inline bool virThreadPoolWorkerQuitHelper(size_t count, size_t limit)\n{\n    return count > limit;\n}"
  }
]