[
  {
    "function_name": "virHostCPUGetTscInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1408-1414",
    "snippet": "virHostCPUTscInfoPtr\nvirHostCPUGetTscInfo(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Probing TSC is not supported on this platform\"));\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Probing TSC is not supported on this platform\")"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Probing TSC is not supported on this platform\""
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirHostCPUTscInfoPtr\nvirHostCPUGetTscInfo(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Probing TSC is not supported on this platform\"));\n    return NULL;\n}"
  },
  {
    "function_name": "virHostCPUGetMSR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1399-1406",
    "snippet": "int\nvirHostCPUGetMSR(unsigned long index G_GNUC_UNUSED,\n                 uint64_t *msr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Reading MSRs is not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Reading MSRs is not supported on this platform\")"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Reading MSRs is not supported on this platform\""
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetMSR(unsigned long index G_GNUC_UNUSED,\n                 uint64_t *msr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Reading MSRs is not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virHostCPUGetTscInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1345-1395",
    "snippet": "virHostCPUTscInfoPtr\nvirHostCPUGetTscInfo(void)\n{\n    virHostCPUTscInfoPtr info;\n    VIR_AUTOCLOSE kvmFd = -1;\n    VIR_AUTOCLOSE vmFd = -1;\n    VIR_AUTOCLOSE vcpuFd = -1;\n    uint64_t msr = 0;\n    int rc;\n\n    if ((kvmFd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return NULL;\n    }\n\n    if ((vmFd = ioctl(kvmFd, KVM_CREATE_VM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create KVM VM for TSC probing\"));\n        return NULL;\n    }\n\n    if ((vcpuFd = ioctl(vmFd, KVM_CREATE_VCPU, 0)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create KVM vCPU for TSC probing\"));\n        return NULL;\n    }\n\n    if ((rc = ioctl(vcpuFd, KVM_GET_TSC_KHZ)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to probe TSC frequency\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC(info) < 0)\n        return NULL;\n\n    info->frequency = rc * 1000ULL;\n\n    if (virHostCPUGetMSR(VMX_PROCBASED_CTLS2_MSR, &msr) == 0) {\n        /* High 32 bits of the MSR value indicate whether specific control\n         * can be set to 1. */\n        msr >>= 32;\n\n        info->scaling = virTristateBoolFromBool(!!(msr & VMX_USE_TSC_SCALING));\n    }\n\n    VIR_DEBUG(\"Detected TSC frequency %llu Hz, scaling %s\",\n              info->frequency, virTristateBoolTypeToString(info->scaling));\n\n    return info;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define KVM_DEVICE \"/dev/kvm\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Detected TSC frequency %llu Hz, scaling %s\"",
            "info->frequency",
            "virTristateBoolTypeToString(info->scaling)"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "info->scaling"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolFromBool",
          "args": [
            "!!(msr & VMX_USE_TSC_SCALING)"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "virTristateBoolFromBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virenum.c",
          "lines": "40-47",
          "snippet": "virTristateBool\nvirTristateBoolFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_BOOL_YES;\n    else\n        return VIR_TRISTATE_BOOL_NO;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virenum.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virenum.h\"\n#include <config.h>\n\nvirTristateBool\nvirTristateBoolFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_BOOL_YES;\n    else\n        return VIR_TRISTATE_BOOL_NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetMSR",
          "args": [
            "VMX_PROCBASED_CTLS2_MSR",
            "&msr"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMSR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1399-1406",
          "snippet": "int\nvirHostCPUGetMSR(unsigned long index G_GNUC_UNUSED,\n                 uint64_t *msr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Reading MSRs is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetMSR(unsigned long index G_GNUC_UNUSED,\n                 uint64_t *msr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Reading MSRs is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "info"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to probe TSC frequency\")"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to probe TSC frequency\""
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "vcpuFd",
            "KVM_GET_TSC_KHZ"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create KVM vCPU for TSC probing\")"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "vmFd",
            "KVM_CREATE_VCPU",
            "0"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create KVM VM for TSC probing\")"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to open %s\")",
            "KVM_DEVICE"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "KVM_DEVICE",
            "O_RDONLY"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define KVM_DEVICE \"/dev/kvm\"\n\nvirHostCPUTscInfoPtr\nvirHostCPUGetTscInfo(void)\n{\n    virHostCPUTscInfoPtr info;\n    VIR_AUTOCLOSE kvmFd = -1;\n    VIR_AUTOCLOSE vmFd = -1;\n    VIR_AUTOCLOSE vcpuFd = -1;\n    uint64_t msr = 0;\n    int rc;\n\n    if ((kvmFd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return NULL;\n    }\n\n    if ((vmFd = ioctl(kvmFd, KVM_CREATE_VM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create KVM VM for TSC probing\"));\n        return NULL;\n    }\n\n    if ((vcpuFd = ioctl(vmFd, KVM_CREATE_VCPU, 0)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create KVM vCPU for TSC probing\"));\n        return NULL;\n    }\n\n    if ((rc = ioctl(vcpuFd, KVM_GET_TSC_KHZ)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to probe TSC frequency\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC(info) < 0)\n        return NULL;\n\n    info->frequency = rc * 1000ULL;\n\n    if (virHostCPUGetMSR(VMX_PROCBASED_CTLS2_MSR, &msr) == 0) {\n        /* High 32 bits of the MSR value indicate whether specific control\n         * can be set to 1. */\n        msr >>= 32;\n\n        info->scaling = virTristateBoolFromBool(!!(msr & VMX_USE_TSC_SCALING));\n    }\n\n    VIR_DEBUG(\"Detected TSC frequency %llu Hz, scaling %s\",\n              info->frequency, virTristateBoolTypeToString(info->scaling));\n\n    return info;\n}"
  },
  {
    "function_name": "virHostCPUGetMSR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1303-1332",
    "snippet": "int\nvirHostCPUGetMSR(unsigned long index,\n                 uint64_t *msr)\n{\n    VIR_AUTOCLOSE fd = -1;\n\n    *msr = 0;\n\n    if ((fd = open(MSR_DEVICE, O_RDONLY)) < 0) {\n        VIR_DEBUG(\"Unable to open %s: %s\",\n                  MSR_DEVICE, g_strerror(errno));\n    } else {\n        int rc = pread(fd, msr, sizeof(*msr), index);\n\n        if (rc == sizeof(*msr))\n            return 0;\n\n        if (rc < 0 && errno == EIO) {\n            VIR_DEBUG(\"CPU does not support MSR 0x%lx\", index);\n            return 1;\n        }\n\n        VIR_DEBUG(\"Cannot read MSR 0x%lx from %s: %s\",\n                  index, MSR_DEVICE, g_strerror(errno));\n    }\n\n    VIR_DEBUG(\"Falling back to KVM ioctl\");\n\n    return virHostCPUGetMSRFromKVM(index, msr);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MSR_DEVICE \"/dev/cpu/0/msr\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostCPUGetMSRFromKVM",
          "args": [
            "index",
            "msr"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMSRFromKVM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1271-1296",
          "snippet": "static int\nvirHostCPUGetMSRFromKVM(unsigned long index,\n                        uint64_t *result)\n{\n    VIR_AUTOCLOSE fd = -1;\n    struct {\n        struct kvm_msrs header;\n        struct kvm_msr_entry entry;\n    } msr = {\n        .header = { .nmsrs = 1 },\n        .entry = { .index = index },\n    };\n\n    if ((fd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return -1;\n    }\n\n    if (ioctl(fd, KVM_GET_MSRS, &msr) < 0) {\n        VIR_DEBUG(\"Cannot get MSR 0x%lx from KVM\", index);\n        return 1;\n    }\n\n    *result = msr.entry.data;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define KVM_DEVICE \"/dev/kvm\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define KVM_DEVICE \"/dev/kvm\"\n\nstatic int\nvirHostCPUGetMSRFromKVM(unsigned long index,\n                        uint64_t *result)\n{\n    VIR_AUTOCLOSE fd = -1;\n    struct {\n        struct kvm_msrs header;\n        struct kvm_msr_entry entry;\n    } msr = {\n        .header = { .nmsrs = 1 },\n        .entry = { .index = index },\n    };\n\n    if ((fd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return -1;\n    }\n\n    if (ioctl(fd, KVM_GET_MSRS, &msr) < 0) {\n        VIR_DEBUG(\"Cannot get MSR 0x%lx from KVM\", index);\n        return 1;\n    }\n\n    *result = msr.entry.data;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Falling back to KVM ioctl\""
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cannot read MSR 0x%lx from %s: %s\"",
            "index",
            "MSR_DEVICE",
            "g_strerror(errno)"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CPU does not support MSR 0x%lx\"",
            "index"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "msr",
            "sizeof(*msr)",
            "index"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to open %s: %s\"",
            "MSR_DEVICE",
            "g_strerror(errno)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "MSR_DEVICE",
            "O_RDONLY"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define MSR_DEVICE \"/dev/cpu/0/msr\"\n\nint\nvirHostCPUGetMSR(unsigned long index,\n                 uint64_t *msr)\n{\n    VIR_AUTOCLOSE fd = -1;\n\n    *msr = 0;\n\n    if ((fd = open(MSR_DEVICE, O_RDONLY)) < 0) {\n        VIR_DEBUG(\"Unable to open %s: %s\",\n                  MSR_DEVICE, g_strerror(errno));\n    } else {\n        int rc = pread(fd, msr, sizeof(*msr), index);\n\n        if (rc == sizeof(*msr))\n            return 0;\n\n        if (rc < 0 && errno == EIO) {\n            VIR_DEBUG(\"CPU does not support MSR 0x%lx\", index);\n            return 1;\n        }\n\n        VIR_DEBUG(\"Cannot read MSR 0x%lx from %s: %s\",\n                  index, MSR_DEVICE, g_strerror(errno));\n    }\n\n    VIR_DEBUG(\"Falling back to KVM ioctl\");\n\n    return virHostCPUGetMSRFromKVM(index, msr);\n}"
  },
  {
    "function_name": "virHostCPUGetMSRFromKVM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1271-1296",
    "snippet": "static int\nvirHostCPUGetMSRFromKVM(unsigned long index,\n                        uint64_t *result)\n{\n    VIR_AUTOCLOSE fd = -1;\n    struct {\n        struct kvm_msrs header;\n        struct kvm_msr_entry entry;\n    } msr = {\n        .header = { .nmsrs = 1 },\n        .entry = { .index = index },\n    };\n\n    if ((fd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return -1;\n    }\n\n    if (ioctl(fd, KVM_GET_MSRS, &msr) < 0) {\n        VIR_DEBUG(\"Cannot get MSR 0x%lx from KVM\", index);\n        return 1;\n    }\n\n    *result = msr.entry.data;\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define KVM_DEVICE \"/dev/kvm\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cannot get MSR 0x%lx from KVM\"",
            "index"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "KVM_GET_MSRS",
            "&msr"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to open %s\")",
            "KVM_DEVICE"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to open %s\""
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "KVM_DEVICE",
            "O_RDONLY"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define KVM_DEVICE \"/dev/kvm\"\n\nstatic int\nvirHostCPUGetMSRFromKVM(unsigned long index,\n                        uint64_t *result)\n{\n    VIR_AUTOCLOSE fd = -1;\n    struct {\n        struct kvm_msrs header;\n        struct kvm_msr_entry entry;\n    } msr = {\n        .header = { .nmsrs = 1 },\n        .entry = { .index = index },\n    };\n\n    if ((fd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return -1;\n    }\n\n    if (ioctl(fd, KVM_GET_MSRS, &msr) < 0) {\n        VIR_DEBUG(\"Cannot get MSR 0x%lx from KVM\", index);\n        return 1;\n    }\n\n    *result = msr.entry.data;\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetMicrocodeVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1259-1263",
    "snippet": "unsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetMicrocodeVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1228-1255",
    "snippet": "unsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    char *outbuf = NULL;\n    char *cur;\n    unsigned int version = 0;\n\n    if (virFileReadHeaderQuiet(CPUINFO_PATH, 4096, &outbuf) < 0) {\n        VIR_DEBUG(\"Failed to read microcode version from %s: %s\",\n                  CPUINFO_PATH, g_strerror(errno));\n        return 0;\n    }\n\n    /* Account for format 'microcode    : XXXX'*/\n    if (!(cur = strstr(outbuf, \"microcode\")) ||\n        !(cur = strchr(cur, ':')))\n        goto cleanup;\n    cur++;\n\n    /* Linux places the microcode revision in a 32-bit integer, so\n     * ui is fine for us too.  */\n    if (virStrToLong_ui(cur, &cur, 0, &version) < 0)\n        goto cleanup;\n\n cleanup:\n    VIR_FREE(outbuf);\n    return version;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "outbuf"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "cur",
            "&cur",
            "0",
            "&version"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cur",
            "':'"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "outbuf",
            "\"microcode\""
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to read microcode version from %s: %s\"",
            "CPUINFO_PATH",
            "g_strerror(errno)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadHeaderQuiet",
          "args": [
            "CPUINFO_PATH",
            "4096",
            "&outbuf"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadHeaderQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1395-1411",
          "snippet": "int\nvirFileReadHeaderQuiet(const char *path,\n                       int maxlen,\n                       char **buf)\n{\n    int fd;\n    int len;\n\n    fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -1;\n\n    len = virFileReadHeaderFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadHeaderQuiet(const char *path,\n                       int maxlen,\n                       char **buf)\n{\n    int fd;\n    int len;\n\n    fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -1;\n\n    len = virFileReadHeaderFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    char *outbuf = NULL;\n    char *cur;\n    unsigned int version = 0;\n\n    if (virFileReadHeaderQuiet(CPUINFO_PATH, 4096, &outbuf) < 0) {\n        VIR_DEBUG(\"Failed to read microcode version from %s: %s\",\n                  CPUINFO_PATH, g_strerror(errno));\n        return 0;\n    }\n\n    /* Account for format 'microcode    : XXXX'*/\n    if (!(cur = strstr(outbuf, \"microcode\")) ||\n        !(cur = strchr(cur, ':')))\n        goto cleanup;\n    cur++;\n\n    /* Linux places the microcode revision in a 32-bit integer, so\n     * ui is fine for us too.  */\n    if (virStrToLong_ui(cur, &cur, 0, &version) < 0)\n        goto cleanup;\n\n cleanup:\n    VIR_FREE(outbuf);\n    return version;\n}"
  },
  {
    "function_name": "virHostCPUGetKVMMaxVCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1212-1218",
    "snippet": "int\nvirHostCPUGetKVMMaxVCPUs(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"KVM is not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"KVM is not supported on this platform\")"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"KVM is not supported on this platform\""
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetKVMMaxVCPUs(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"KVM is not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virHostCPUGetKVMMaxVCPUs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1181-1210",
    "snippet": "int\nvirHostCPUGetKVMMaxVCPUs(void)\n{\n    int fd;\n    int ret;\n\n    if ((fd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return -1;\n    }\n\n# ifdef KVM_CAP_MAX_VCPUS\n    /* at first try KVM_CAP_MAX_VCPUS to determine the maximum count */\n    if ((ret = ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_MAX_VCPUS)) > 0)\n        goto cleanup;\n# endif /* KVM_CAP_MAX_VCPUS */\n\n    /* as a fallback get KVM_CAP_NR_VCPUS (the recommended maximum number of\n     * vcpus). Note that on most machines this is set to 160. */\n    if ((ret = ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_NR_VCPUS)) > 0)\n        goto cleanup;\n\n    /* if KVM_CAP_NR_VCPUS doesn't exist either, kernel documentation states\n     * that 4 should be used as the maximum number of cpus */\n    ret = 4;\n\n cleanup:\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define KVM_DEVICE \"/dev/kvm\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "KVM_CHECK_EXTENSION",
            "KVM_CAP_NR_VCPUS"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to open %s\")",
            "KVM_DEVICE"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to open %s\""
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "KVM_DEVICE",
            "O_RDONLY"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define KVM_DEVICE \"/dev/kvm\"\n\nint\nvirHostCPUGetKVMMaxVCPUs(void)\n{\n    int fd;\n    int ret;\n\n    if ((fd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n        virReportSystemError(errno, _(\"Unable to open %s\"), KVM_DEVICE);\n        return -1;\n    }\n\n# ifdef KVM_CAP_MAX_VCPUS\n    /* at first try KVM_CAP_MAX_VCPUS to determine the maximum count */\n    if ((ret = ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_MAX_VCPUS)) > 0)\n        goto cleanup;\n# endif /* KVM_CAP_MAX_VCPUS */\n\n    /* as a fallback get KVM_CAP_NR_VCPUS (the recommended maximum number of\n     * vcpus). Note that on most machines this is set to 160. */\n    if ((ret = ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_NR_VCPUS)) > 0)\n        goto cleanup;\n\n    /* if KVM_CAP_NR_VCPUS doesn't exist either, kernel documentation states\n     * that 4 should be used as the maximum number of cpus */\n    ret = 4;\n\n cleanup:\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUGetThreadsPerSubcore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1172-1176",
    "snippet": "int\nvirHostCPUGetThreadsPerSubcore(virArch arch G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetThreadsPerSubcore(virArch arch G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetThreadsPerSubcore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1128-1166",
    "snippet": "int\nvirHostCPUGetThreadsPerSubcore(virArch arch)\n{\n    int threads_per_subcore = 0;\n    int kvmfd;\n\n    if (ARCH_IS_PPC64(arch)) {\n\n        /* It's okay if /dev/kvm doesn't exist, because\n         *   a. we might be running in a guest\n         *   b. the kvm module might not be installed or enabled\n         * In either case, falling back to the subcore-unaware thread\n         * counting logic is the right thing to do */\n        if (!virFileExists(KVM_DEVICE))\n            return 0;\n\n        if ((kvmfd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n            /* This can happen when running as a regular user if\n             * permissions are tight enough, in which case erroring out\n             * is better than silently falling back and reporting\n             * different nodeinfo depending on the user */\n            virReportSystemError(errno,\n                                 _(\"Failed to open '%s'\"),\n                                 KVM_DEVICE);\n            return -1;\n        }\n\n        /* For Phyp and KVM based guests the ioctl for KVM_CAP_PPC_SMT\n         * returns zero and both primary and secondary threads will be\n         * online */\n        threads_per_subcore = ioctl(kvmfd,\n                                    KVM_CHECK_EXTENSION,\n                                    KVM_CAP_PPC_SMT);\n\n        VIR_FORCE_CLOSE(kvmfd);\n    }\n\n    return threads_per_subcore;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define KVM_DEVICE \"/dev/kvm\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "kvmfd"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "kvmfd",
            "KVM_CHECK_EXTENSION",
            "KVM_CAP_PPC_SMT"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to open '%s'\")",
            "KVM_DEVICE"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to open '%s'\""
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "KVM_DEVICE",
            "O_RDONLY"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "KVM_DEVICE"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "arch"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define KVM_DEVICE \"/dev/kvm\"\n\nint\nvirHostCPUGetThreadsPerSubcore(virArch arch)\n{\n    int threads_per_subcore = 0;\n    int kvmfd;\n\n    if (ARCH_IS_PPC64(arch)) {\n\n        /* It's okay if /dev/kvm doesn't exist, because\n         *   a. we might be running in a guest\n         *   b. the kvm module might not be installed or enabled\n         * In either case, falling back to the subcore-unaware thread\n         * counting logic is the right thing to do */\n        if (!virFileExists(KVM_DEVICE))\n            return 0;\n\n        if ((kvmfd = open(KVM_DEVICE, O_RDONLY)) < 0) {\n            /* This can happen when running as a regular user if\n             * permissions are tight enough, in which case erroring out\n             * is better than silently falling back and reporting\n             * different nodeinfo depending on the user */\n            virReportSystemError(errno,\n                                 _(\"Failed to open '%s'\"),\n                                 KVM_DEVICE);\n            return -1;\n        }\n\n        /* For Phyp and KVM based guests the ioctl for KVM_CAP_PPC_SMT\n         * returns zero and both primary and secondary threads will be\n         * online */\n        threads_per_subcore = ioctl(kvmfd,\n                                    KVM_CHECK_EXTENSION,\n                                    KVM_CAP_PPC_SMT);\n\n        VIR_FORCE_CLOSE(kvmfd);\n    }\n\n    return threads_per_subcore;\n}"
  },
  {
    "function_name": "virHostCPUGetMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1087-1116",
    "snippet": "int\nvirHostCPUGetMap(unsigned char **cpumap,\n                 unsigned int *online,\n                 unsigned int flags)\n{\n    virBitmapPtr cpus = NULL;\n    int ret = -1;\n    int dummy;\n\n    virCheckFlags(0, -1);\n\n    if (!cpumap && !online)\n        return virHostCPUGetCount();\n\n    if (!(cpus = virHostCPUGetOnlineBitmap()))\n        goto cleanup;\n\n    if (cpumap && virBitmapToData(cpus, cpumap, &dummy) < 0)\n        goto cleanup;\n    if (online)\n        *online = virBitmapCountBits(cpus);\n\n    ret = virHostCPUGetCount();\n\n cleanup:\n    if (ret < 0 && cpumap)\n        VIR_FREE(*cpumap);\n    virBitmapFree(cpus);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cpus"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*cpumap"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCount",
          "args": [],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1030-1042",
          "snippet": "int\nvirHostCPUGetCount(void)\n{\n#if defined(__linux__)\n    return virHostCPUParseCountLinux();\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    return virHostCPUGetCountAppleFreeBSD();\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"host cpu counting not implemented on this platform\"));\n    return -1;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetCount(void)\n{\n#if defined(__linux__)\n    return virHostCPUParseCountLinux();\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    return virHostCPUGetCountAppleFreeBSD();\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"host cpu counting not implemented on this platform\"));\n    return -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapCountBits",
          "args": [
            "cpus"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCountBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1122-1132",
          "snippet": "size_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapToData",
          "args": [
            "cpus",
            "cpumap",
            "&dummy"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapToDataBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "805-828",
          "snippet": "void\nvirBitmapToDataBuf(virBitmapPtr bitmap,\n                   unsigned char *bytes,\n                   size_t len)\n{\n    size_t nbytes = bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT);\n    unsigned long *l;\n    size_t i, j;\n\n    memset(bytes, 0, len);\n\n    /* If bitmap and buffer differ in size, only fill to the smaller length */\n    len = MIN(len, nbytes);\n\n    /* htole64 is not available, so we do the conversion by hand */\n    l = bitmap->map;\n    for (i = j = 0; i < len; i++, j++) {\n        if (j == sizeof(*l)) {\n            j = 0;\n            l++;\n        }\n        bytes[i] = *l >> (j * CHAR_BIT);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nvoid\nvirBitmapToDataBuf(virBitmapPtr bitmap,\n                   unsigned char *bytes,\n                   size_t len)\n{\n    size_t nbytes = bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT);\n    unsigned long *l;\n    size_t i, j;\n\n    memset(bytes, 0, len);\n\n    /* If bitmap and buffer differ in size, only fill to the smaller length */\n    len = MIN(len, nbytes);\n\n    /* htole64 is not available, so we do the conversion by hand */\n    l = bitmap->map;\n    for (i = j = 0; i < len; i++, j++) {\n        if (j == sizeof(*l)) {\n            j = 0;\n            l++;\n        }\n        bytes[i] = *l >> (j * CHAR_BIT);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetOnlineBitmap",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetOnlineBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1070-1084",
          "snippet": "virBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetMap(unsigned char **cpumap,\n                 unsigned int *online,\n                 unsigned int flags)\n{\n    virBitmapPtr cpus = NULL;\n    int ret = -1;\n    int dummy;\n\n    virCheckFlags(0, -1);\n\n    if (!cpumap && !online)\n        return virHostCPUGetCount();\n\n    if (!(cpus = virHostCPUGetOnlineBitmap()))\n        goto cleanup;\n\n    if (cpumap && virBitmapToData(cpus, cpumap, &dummy) < 0)\n        goto cleanup;\n    if (online)\n        *online = virBitmapCountBits(cpus);\n\n    ret = virHostCPUGetCount();\n\n cleanup:\n    if (ret < 0 && cpumap)\n        VIR_FREE(*cpumap);\n    virBitmapFree(cpus);\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUGetOnlineBitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1070-1084",
    "snippet": "virBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node online CPU map not implemented on this platform\")"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node online CPU map not implemented on this platform\""
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueBitmap",
          "args": [
            "&ret",
            "\"%s/cpu/online\"",
            "SYSFS_SYSTEM_PATH"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4241-4265",
          "snippet": "int\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}"
  },
  {
    "function_name": "virHostCPUGetPresentBitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1054-1068",
    "snippet": "virBitmapPtr\nvirHostCPUGetPresentBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/present\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node present CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node present CPU map not implemented on this platform\")"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node present CPU map not implemented on this platform\""
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueBitmap",
          "args": [
            "&ret",
            "\"%s/cpu/present\"",
            "SYSFS_SYSTEM_PATH"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4241-4265",
          "snippet": "int\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetPresentBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/present\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node present CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}"
  },
  {
    "function_name": "virHostCPUHasBitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1044-1052",
    "snippet": "bool\nvirHostCPUHasBitmap(void)\n{\n#ifdef __linux__\n    return true;\n#else\n    return false;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirHostCPUHasBitmap(void)\n{\n#ifdef __linux__\n    return true;\n#else\n    return false;\n#endif\n}"
  },
  {
    "function_name": "virHostCPUGetCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "1030-1042",
    "snippet": "int\nvirHostCPUGetCount(void)\n{\n#if defined(__linux__)\n    return virHostCPUParseCountLinux();\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    return virHostCPUGetCountAppleFreeBSD();\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"host cpu counting not implemented on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"host cpu counting not implemented on this platform\")"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"host cpu counting not implemented on this platform\""
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCountAppleFreeBSD",
          "args": [],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCountAppleFreeBSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "62-75",
          "snippet": "static int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUParseCountLinux",
          "args": [],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUParseCountLinux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "861-886",
          "snippet": "static int\nvirHostCPUParseCountLinux(void)\n{\n    char *str = NULL;\n    char *tmp;\n    int ret = -1;\n\n    if (virFileReadValueString(&str, \"%s/cpu/present\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    tmp = str;\n    do {\n        if (virStrToLong_i(tmp, &tmp, 10, &ret) < 0 ||\n            !strchr(\",-\", *tmp)) {\n            virReportError(VIR_ERR_NO_SUPPORT,\n                           _(\"failed to parse %s\"), str);\n            ret = -1;\n            goto cleanup;\n        }\n    } while (*tmp++ && *tmp);\n    ret++;\n\n cleanup:\n    VIR_FREE(str);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nstatic int\nvirHostCPUParseCountLinux(void)\n{\n    char *str = NULL;\n    char *tmp;\n    int ret = -1;\n\n    if (virFileReadValueString(&str, \"%s/cpu/present\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    tmp = str;\n    do {\n        if (virStrToLong_i(tmp, &tmp, 10, &ret) < 0 ||\n            !strchr(\",-\", *tmp)) {\n            virReportError(VIR_ERR_NO_SUPPORT,\n                           _(\"failed to parse %s\"), str);\n            ret = -1;\n            goto cleanup;\n        }\n    } while (*tmp++ && *tmp);\n    ret++;\n\n cleanup:\n    VIR_FREE(str);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetCount(void)\n{\n#if defined(__linux__)\n    return virHostCPUParseCountLinux();\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    return virHostCPUGetCountAppleFreeBSD();\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"host cpu counting not implemented on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virHostCPUGetStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "998-1027",
    "snippet": "int\nvirHostCPUGetStats(int cpuNum G_GNUC_UNUSED,\n                   virNodeCPUStatsPtr params G_GNUC_UNUSED,\n                   int *nparams G_GNUC_UNUSED,\n                   unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n#ifdef __linux__\n    {\n        int ret;\n        FILE *procstat = fopen(PROCSTAT_PATH, \"r\");\n        if (!procstat) {\n            virReportSystemError(errno,\n                                 _(\"cannot open %s\"), PROCSTAT_PATH);\n            return -1;\n        }\n        ret = virHostCPUGetStatsLinux(procstat, cpuNum, params, nparams);\n        VIR_FORCE_FCLOSE(procstat);\n\n        return ret;\n    }\n#elif defined(__FreeBSD__)\n    return virHostCPUGetStatsFreeBSD(cpuNum, params, nparams);\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node CPU stats not implemented on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node CPU stats not implemented on this platform\")"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node CPU stats not implemented on this platform\""
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetStatsFreeBSD",
          "args": [
            "cpuNum",
            "params",
            "nparams"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetStatsFreeBSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "84-179",
          "snippet": "static int\nvirHostCPUGetStatsFreeBSD(int cpuNum,\n                          virNodeCPUStatsPtr params,\n                          int *nparams)\n{\n    const char *sysctl_name;\n    long *cpu_times;\n    struct clockinfo clkinfo;\n    size_t i, j, cpu_times_size, clkinfo_size;\n    int cpu_times_num, offset, hz, stathz, ret = -1;\n    struct field_cpu_map {\n        const char *field;\n        int idx[CPUSTATES];\n    } cpu_map[] = {\n        {VIR_NODE_CPU_STATS_KERNEL, {CP_SYS}},\n        {VIR_NODE_CPU_STATS_USER, {CP_USER, CP_NICE}},\n        {VIR_NODE_CPU_STATS_IDLE, {CP_IDLE}},\n        {VIR_NODE_CPU_STATS_INTR, {CP_INTR}},\n        {NULL, {0}}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_CPU_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_CPU_STATS_ALL) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, BSD_CPU_STATS_ALL);\n        return -1;\n    }\n\n    clkinfo_size = sizeof(clkinfo);\n    if (sysctlbyname(\"kern.clockrate\", &clkinfo, &clkinfo_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             \"kern.clockrate\");\n        return -1;\n    }\n\n    stathz = clkinfo.stathz;\n    hz = clkinfo.hz;\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        sysctl_name = \"kern.cp_time\";\n        cpu_times_num = 1;\n        offset = 0;\n    } else {\n        sysctl_name = \"kern.cp_times\";\n        cpu_times_num = virHostCPUGetCountAppleFreeBSD();\n\n        if (cpuNum >= cpu_times_num) {\n            virReportInvalidArg(cpuNum,\n                                _(\"Invalid cpuNum in %s\"),\n                                __FUNCTION__);\n            return -1;\n        }\n\n        offset = cpu_times_num * CPUSTATES;\n    }\n\n    cpu_times_size = sizeof(long) * cpu_times_num * CPUSTATES;\n\n    if (VIR_ALLOC_N(cpu_times, cpu_times_num * CPUSTATES) < 0)\n        goto cleanup;\n\n    if (sysctlbyname(sysctl_name, cpu_times, &cpu_times_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             sysctl_name);\n        goto cleanup;\n    }\n\n    for (i = 0; cpu_map[i].field != NULL; i++) {\n        virNodeCPUStatsPtr param = &params[i];\n\n        if (virStrcpyStatic(param->field, cpu_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           cpu_map[i].field);\n            goto cleanup;\n        }\n\n        param->value = 0;\n        for (j = 0; j < G_N_ELEMENTS(cpu_map[i].idx); j++)\n            param->value += cpu_times[offset + cpu_map[i].idx[j]] * TICK_TO_NSEC;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpu_times);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUGetStatsFreeBSD(int cpuNum,\n                          virNodeCPUStatsPtr params,\n                          int *nparams)\n{\n    const char *sysctl_name;\n    long *cpu_times;\n    struct clockinfo clkinfo;\n    size_t i, j, cpu_times_size, clkinfo_size;\n    int cpu_times_num, offset, hz, stathz, ret = -1;\n    struct field_cpu_map {\n        const char *field;\n        int idx[CPUSTATES];\n    } cpu_map[] = {\n        {VIR_NODE_CPU_STATS_KERNEL, {CP_SYS}},\n        {VIR_NODE_CPU_STATS_USER, {CP_USER, CP_NICE}},\n        {VIR_NODE_CPU_STATS_IDLE, {CP_IDLE}},\n        {VIR_NODE_CPU_STATS_INTR, {CP_INTR}},\n        {NULL, {0}}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_CPU_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_CPU_STATS_ALL) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, BSD_CPU_STATS_ALL);\n        return -1;\n    }\n\n    clkinfo_size = sizeof(clkinfo);\n    if (sysctlbyname(\"kern.clockrate\", &clkinfo, &clkinfo_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             \"kern.clockrate\");\n        return -1;\n    }\n\n    stathz = clkinfo.stathz;\n    hz = clkinfo.hz;\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        sysctl_name = \"kern.cp_time\";\n        cpu_times_num = 1;\n        offset = 0;\n    } else {\n        sysctl_name = \"kern.cp_times\";\n        cpu_times_num = virHostCPUGetCountAppleFreeBSD();\n\n        if (cpuNum >= cpu_times_num) {\n            virReportInvalidArg(cpuNum,\n                                _(\"Invalid cpuNum in %s\"),\n                                __FUNCTION__);\n            return -1;\n        }\n\n        offset = cpu_times_num * CPUSTATES;\n    }\n\n    cpu_times_size = sizeof(long) * cpu_times_num * CPUSTATES;\n\n    if (VIR_ALLOC_N(cpu_times, cpu_times_num * CPUSTATES) < 0)\n        goto cleanup;\n\n    if (sysctlbyname(sysctl_name, cpu_times, &cpu_times_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             sysctl_name);\n        goto cleanup;\n    }\n\n    for (i = 0; cpu_map[i].field != NULL; i++) {\n        virNodeCPUStatsPtr param = &params[i];\n\n        if (virStrcpyStatic(param->field, cpu_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           cpu_map[i].field);\n            goto cleanup;\n        }\n\n        param->value = 0;\n        for (j = 0; j < G_N_ELEMENTS(cpu_map[i].idx); j++)\n            param->value += cpu_times[offset + cpu_map[i].idx[j]] * TICK_TO_NSEC;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpu_times);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "procstat"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetStatsLinux",
          "args": [
            "procstat",
            "cpuNum",
            "params",
            "nparams"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetStatsLinux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "789-856",
          "snippet": "int\nvirHostCPUGetStatsLinux(FILE *procstat,\n                        int cpuNum,\n                        virNodeCPUStatsPtr params,\n                        int *nparams)\n{\n    char line[1024];\n    unsigned long long usr, ni, sys, idle, iowait;\n    unsigned long long irq, softirq, steal, guest, guest_nice;\n    char cpu_header[4 + VIR_INT64_STR_BUFLEN];\n\n    if ((*nparams) == 0) {\n        /* Current number of cpu stats supported by linux */\n        *nparams = LINUX_NB_CPU_STATS;\n        return 0;\n    }\n\n    if ((*nparams) != LINUX_NB_CPU_STATS) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, LINUX_NB_CPU_STATS);\n        return -1;\n    }\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        strcpy(cpu_header, \"cpu \");\n    } else {\n        g_snprintf(cpu_header, sizeof(cpu_header), \"cpu%d \", cpuNum);\n    }\n\n    while (fgets(line, sizeof(line), procstat) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, cpu_header)) { /* aka logical CPU time */\n            if (sscanf(buf,\n                       \"%*s %llu %llu %llu %llu %llu\" /* user ~ iowait */\n                       \"%llu %llu %llu %llu %llu\",    /* irq  ~ guest_nice */\n                       &usr, &ni, &sys, &idle, &iowait,\n                       &irq, &softirq, &steal, &guest, &guest_nice) < 4) {\n                continue;\n            }\n\n            if (virHostCPUStatsAssign(&params[0], VIR_NODE_CPU_STATS_KERNEL,\n                                      (sys + irq + softirq) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[1], VIR_NODE_CPU_STATS_USER,\n                                      (usr + ni) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[2], VIR_NODE_CPU_STATS_IDLE,\n                                      idle * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[3], VIR_NODE_CPU_STATS_IOWAIT,\n                                      iowait * TICK_TO_NSEC) < 0)\n                return -1;\n\n            return 0;\n        }\n    }\n\n    virReportInvalidArg(cpuNum,\n                        _(\"Invalid cpuNum in %s\"),\n                        __FUNCTION__);\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetStatsLinux(FILE *procstat,\n                        int cpuNum,\n                        virNodeCPUStatsPtr params,\n                        int *nparams)\n{\n    char line[1024];\n    unsigned long long usr, ni, sys, idle, iowait;\n    unsigned long long irq, softirq, steal, guest, guest_nice;\n    char cpu_header[4 + VIR_INT64_STR_BUFLEN];\n\n    if ((*nparams) == 0) {\n        /* Current number of cpu stats supported by linux */\n        *nparams = LINUX_NB_CPU_STATS;\n        return 0;\n    }\n\n    if ((*nparams) != LINUX_NB_CPU_STATS) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, LINUX_NB_CPU_STATS);\n        return -1;\n    }\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        strcpy(cpu_header, \"cpu \");\n    } else {\n        g_snprintf(cpu_header, sizeof(cpu_header), \"cpu%d \", cpuNum);\n    }\n\n    while (fgets(line, sizeof(line), procstat) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, cpu_header)) { /* aka logical CPU time */\n            if (sscanf(buf,\n                       \"%*s %llu %llu %llu %llu %llu\" /* user ~ iowait */\n                       \"%llu %llu %llu %llu %llu\",    /* irq  ~ guest_nice */\n                       &usr, &ni, &sys, &idle, &iowait,\n                       &irq, &softirq, &steal, &guest, &guest_nice) < 4) {\n                continue;\n            }\n\n            if (virHostCPUStatsAssign(&params[0], VIR_NODE_CPU_STATS_KERNEL,\n                                      (sys + irq + softirq) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[1], VIR_NODE_CPU_STATS_USER,\n                                      (usr + ni) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[2], VIR_NODE_CPU_STATS_IDLE,\n                                      idle * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[3], VIR_NODE_CPU_STATS_IOWAIT,\n                                      iowait * TICK_TO_NSEC) < 0)\n                return -1;\n\n            return 0;\n        }\n    }\n\n    virReportInvalidArg(cpuNum,\n                        _(\"Invalid cpuNum in %s\"),\n                        __FUNCTION__);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open %s\")",
            "PROCSTAT_PATH"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "PROCSTAT_PATH",
            "\"r\""
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetStats(int cpuNum G_GNUC_UNUSED,\n                   virNodeCPUStatsPtr params G_GNUC_UNUSED,\n                   int *nparams G_GNUC_UNUSED,\n                   unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n#ifdef __linux__\n    {\n        int ret;\n        FILE *procstat = fopen(PROCSTAT_PATH, \"r\");\n        if (!procstat) {\n            virReportSystemError(errno,\n                                 _(\"cannot open %s\"), PROCSTAT_PATH);\n            return -1;\n        }\n        ret = virHostCPUGetStatsLinux(procstat, cpuNum, params, nparams);\n        VIR_FORCE_FCLOSE(procstat);\n\n        return ret;\n    }\n#elif defined(__FreeBSD__)\n    return virHostCPUGetStatsFreeBSD(cpuNum, params, nparams);\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node CPU stats not implemented on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virHostCPUGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "924-995",
    "snippet": "int\nvirHostCPUGetInfo(virArch hostarch G_GNUC_UNUSED,\n                  unsigned int *cpus G_GNUC_UNUSED,\n                  unsigned int *mhz G_GNUC_UNUSED,\n                  unsigned int *nodes G_GNUC_UNUSED,\n                  unsigned int *sockets G_GNUC_UNUSED,\n                  unsigned int *cores G_GNUC_UNUSED,\n                  unsigned int *threads G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    int ret = -1;\n    FILE *cpuinfo = fopen(CPUINFO_PATH, \"r\");\n\n    if (!cpuinfo) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"), CPUINFO_PATH);\n        return -1;\n    }\n\n    ret = virHostCPUGetInfoPopulateLinux(cpuinfo, hostarch,\n                                         cpus, mhz, nodes,\n                                         sockets, cores, threads);\n    if (ret < 0)\n        goto cleanup;\n\n cleanup:\n    VIR_FORCE_FCLOSE(cpuinfo);\n    return ret;\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    unsigned long cpu_freq;\n    size_t cpu_freq_len = sizeof(cpu_freq);\n\n    *cpus = virHostCPUGetCountAppleFreeBSD();\n    if (*cpus == -1)\n        return -1;\n\n    *nodes = 1;\n    *sockets = 1;\n    *cores = *cpus;\n    *threads = 1;\n\n# ifdef __FreeBSD__\n    /* dev.cpu.%d.freq reports current active CPU frequency. It is provided by\n     * the cpufreq(4) framework. However, it might be disabled or no driver\n     * available. In this case fallback to \"hw.clockrate\" which reports boot time\n     * CPU frequency. */\n\n    if (sysctlbyname(\"dev.cpu.0.freq\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        if (sysctlbyname(\"hw.clockrate\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n            return -1;\n        }\n    }\n\n    *mhz = cpu_freq;\n# else\n    if (sysctlbyname(\"hw.cpufrequency\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n        return -1;\n    }\n\n    *mhz = cpu_freq / 1000000;\n# endif\n\n    return 0;\n#else\n    /* XXX Solaris will need an impl later if they port QEMU driver */\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node info not implemented on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node info not implemented on this platform\")"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node info not implemented on this platform\""
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot obtain CPU freq\")"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"hw.cpufrequency\"",
            "&cpu_freq",
            "&cpu_freq_len",
            "NULL",
            "0"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot obtain CPU freq\")"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"hw.clockrate\"",
            "&cpu_freq",
            "&cpu_freq_len",
            "NULL",
            "0"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"dev.cpu.0.freq\"",
            "&cpu_freq",
            "&cpu_freq_len",
            "NULL",
            "0"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCountAppleFreeBSD",
          "args": [],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCountAppleFreeBSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "62-75",
          "snippet": "static int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "cpuinfo"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetInfoPopulateLinux",
          "args": [
            "cpuinfo",
            "hostarch",
            "cpus",
            "mhz",
            "nodes",
            "sockets",
            "cores",
            "threads"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetInfoPopulateLinux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "606-785",
          "snippet": "int\nvirHostCPUGetInfoPopulateLinux(FILE *cpuinfo,\n                               virArch arch,\n                               unsigned int *cpus,\n                               unsigned int *mhz,\n                               unsigned int *nodes,\n                               unsigned int *sockets,\n                               unsigned int *cores,\n                               unsigned int *threads)\n{\n    virBitmapPtr present_cpus_map = NULL;\n    virBitmapPtr online_cpus_map = NULL;\n    DIR *nodedir = NULL;\n    struct dirent *nodedirent = NULL;\n    int nodecpus, nodecores, nodesockets, nodethreads, offline = 0;\n    int threads_per_subcore = 0;\n    unsigned int node;\n    int ret = -1;\n    char *sysfs_nodedir = NULL;\n    char *sysfs_cpudir = NULL;\n    int direrr;\n\n    *mhz = 0;\n    *cpus = *nodes = *sockets = *cores = *threads = 0;\n\n    /* Start with parsing CPU clock speed from /proc/cpuinfo */\n    if (virHostCPUParseFrequency(cpuinfo, arch, mhz) < 0) {\n        VIR_WARN(\"Unable to parse CPU frequency information from %s\",\n                 CPUINFO_PATH);\n    }\n\n    /* Get information about what CPUs are present in the host and what\n     * CPUs are online, so that we don't have to so for each node */\n    present_cpus_map = virHostCPUGetPresentBitmap();\n    if (!present_cpus_map)\n        goto cleanup;\n    online_cpus_map = virHostCPUGetOnlineBitmap();\n    if (!online_cpus_map)\n        goto cleanup;\n\n    /* OK, we've parsed clock speed out of /proc/cpuinfo. Get the\n     * core, node, socket, thread and topology information from /sys\n     */\n    sysfs_nodedir = g_strdup_printf(\"%s/node\", SYSFS_SYSTEM_PATH);\n\n    if (virDirOpenQuiet(&nodedir, sysfs_nodedir) < 0) {\n        /* the host isn't probably running a NUMA architecture */\n        goto fallback;\n    }\n\n    /* PPC-KVM needs the secondary threads of a core to be offline on the\n     * host. The kvm scheduler brings the secondary threads online in the\n     * guest context. Moreover, P8 processor has split-core capability\n     * where, there can be 1,2 or 4 subcores per core. The primaries of the\n     * subcores alone will be online on the host for a subcore in the\n     * host. Even though the actual threads per core for P8 processor is 8,\n     * depending on the subcores_per_core = 1, 2 or 4, the threads per\n     * subcore will vary accordingly to 8, 4 and 2 respectively.\n     * So, On host threads_per_core what is arrived at from sysfs in the\n     * current logic is actually the subcores_per_core. Threads per subcore\n     * can only be obtained from the kvm device. For example, on P8 wih 1\n     * core having 8 threads, sub_cores_percore=4, the threads 0,2,4 & 6\n     * will be online. The sysfs reflects this and in the current logic\n     * variable 'threads' will be 4 which is nothing but subcores_per_core.\n     * If the user tampers the cpu online/offline states using chcpu or other\n     * means, then it is an unsupported configuration for kvm.\n     * The code below tries to keep in mind\n     *  - when the libvirtd is run inside a KVM guest or Phyp based guest.\n     *  - Or on the kvm host where user manually tampers the cpu states to\n     *    offline/online randomly.\n     * On hosts other than POWER this will be 0, in which case a simpler\n     * thread-counting logic will be used  */\n    if ((threads_per_subcore = virHostCPUGetThreadsPerSubcore(arch)) < 0)\n        goto cleanup;\n\n    /* If the subcore configuration is not valid, just pretend subcores\n     * are not in use and count threads one by one */\n    if (!virHostCPUHasValidSubcoreConfiguration(threads_per_subcore))\n        threads_per_subcore = 0;\n\n    while ((direrr = virDirRead(nodedir, &nodedirent, sysfs_nodedir)) > 0) {\n        if (sscanf(nodedirent->d_name, \"node%u\", &node) != 1)\n            continue;\n\n        (*nodes)++;\n\n        sysfs_cpudir = g_strdup_printf(\"%s/node/%s\", SYSFS_SYSTEM_PATH,\n                                       nodedirent->d_name);\n\n        if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                            present_cpus_map,\n                                            online_cpus_map,\n                                            threads_per_subcore,\n                                            &nodesockets, &nodecores,\n                                            &nodethreads, &offline)) < 0)\n            goto cleanup;\n\n        VIR_FREE(sysfs_cpudir);\n\n        *cpus += nodecpus;\n\n        if (nodesockets > *sockets)\n            *sockets = nodesockets;\n\n        if (nodecores > *cores)\n            *cores = nodecores;\n\n        if (nodethreads > *threads)\n            *threads = nodethreads;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    if (*cpus && *nodes)\n        goto done;\n\n fallback:\n    VIR_FREE(sysfs_cpudir);\n\n    sysfs_cpudir = g_strdup_printf(\"%s/cpu\", SYSFS_SYSTEM_PATH);\n\n    if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                        present_cpus_map,\n                                        online_cpus_map,\n                                        threads_per_subcore,\n                                        &nodesockets, &nodecores,\n                                        &nodethreads, &offline)) < 0)\n        goto cleanup;\n\n    *nodes = 1;\n    *cpus = nodecpus;\n    *sockets = nodesockets;\n    *cores = nodecores;\n    *threads = nodethreads;\n\n done:\n    /* There should always be at least one cpu, socket, node, and thread. */\n    if (*cpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no CPUs found\"));\n        goto cleanup;\n    }\n\n    if (*sockets == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no sockets found\"));\n        goto cleanup;\n    }\n\n    if (*threads == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no threads found\"));\n        goto cleanup;\n    }\n\n    /* Now check if the topology makes sense. There are machines that don't\n     * expose their real number of nodes or for example the AMD Bulldozer\n     * architecture that exposes their Clustered integer core modules as both\n     * threads and cores. This approach throws off our detection. Unfortunately\n     * the nodeinfo structure isn't designed to carry the full topology so\n     * we're going to lie about the detected topology to notify the user\n     * to check the host capabilities for the actual topology. */\n    if ((*nodes *\n         *sockets *\n         *cores *\n         *threads) != (*cpus + offline)) {\n        *nodes = 1;\n        *sockets = 1;\n        *cores = *cpus + offline;\n        *threads = 1;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(nodedir);\n    virBitmapFree(present_cpus_map);\n    virBitmapFree(online_cpus_map);\n    VIR_FREE(sysfs_nodedir);\n    VIR_FREE(sysfs_cpudir);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetInfoPopulateLinux(FILE *cpuinfo,\n                               virArch arch,\n                               unsigned int *cpus,\n                               unsigned int *mhz,\n                               unsigned int *nodes,\n                               unsigned int *sockets,\n                               unsigned int *cores,\n                               unsigned int *threads)\n{\n    virBitmapPtr present_cpus_map = NULL;\n    virBitmapPtr online_cpus_map = NULL;\n    DIR *nodedir = NULL;\n    struct dirent *nodedirent = NULL;\n    int nodecpus, nodecores, nodesockets, nodethreads, offline = 0;\n    int threads_per_subcore = 0;\n    unsigned int node;\n    int ret = -1;\n    char *sysfs_nodedir = NULL;\n    char *sysfs_cpudir = NULL;\n    int direrr;\n\n    *mhz = 0;\n    *cpus = *nodes = *sockets = *cores = *threads = 0;\n\n    /* Start with parsing CPU clock speed from /proc/cpuinfo */\n    if (virHostCPUParseFrequency(cpuinfo, arch, mhz) < 0) {\n        VIR_WARN(\"Unable to parse CPU frequency information from %s\",\n                 CPUINFO_PATH);\n    }\n\n    /* Get information about what CPUs are present in the host and what\n     * CPUs are online, so that we don't have to so for each node */\n    present_cpus_map = virHostCPUGetPresentBitmap();\n    if (!present_cpus_map)\n        goto cleanup;\n    online_cpus_map = virHostCPUGetOnlineBitmap();\n    if (!online_cpus_map)\n        goto cleanup;\n\n    /* OK, we've parsed clock speed out of /proc/cpuinfo. Get the\n     * core, node, socket, thread and topology information from /sys\n     */\n    sysfs_nodedir = g_strdup_printf(\"%s/node\", SYSFS_SYSTEM_PATH);\n\n    if (virDirOpenQuiet(&nodedir, sysfs_nodedir) < 0) {\n        /* the host isn't probably running a NUMA architecture */\n        goto fallback;\n    }\n\n    /* PPC-KVM needs the secondary threads of a core to be offline on the\n     * host. The kvm scheduler brings the secondary threads online in the\n     * guest context. Moreover, P8 processor has split-core capability\n     * where, there can be 1,2 or 4 subcores per core. The primaries of the\n     * subcores alone will be online on the host for a subcore in the\n     * host. Even though the actual threads per core for P8 processor is 8,\n     * depending on the subcores_per_core = 1, 2 or 4, the threads per\n     * subcore will vary accordingly to 8, 4 and 2 respectively.\n     * So, On host threads_per_core what is arrived at from sysfs in the\n     * current logic is actually the subcores_per_core. Threads per subcore\n     * can only be obtained from the kvm device. For example, on P8 wih 1\n     * core having 8 threads, sub_cores_percore=4, the threads 0,2,4 & 6\n     * will be online. The sysfs reflects this and in the current logic\n     * variable 'threads' will be 4 which is nothing but subcores_per_core.\n     * If the user tampers the cpu online/offline states using chcpu or other\n     * means, then it is an unsupported configuration for kvm.\n     * The code below tries to keep in mind\n     *  - when the libvirtd is run inside a KVM guest or Phyp based guest.\n     *  - Or on the kvm host where user manually tampers the cpu states to\n     *    offline/online randomly.\n     * On hosts other than POWER this will be 0, in which case a simpler\n     * thread-counting logic will be used  */\n    if ((threads_per_subcore = virHostCPUGetThreadsPerSubcore(arch)) < 0)\n        goto cleanup;\n\n    /* If the subcore configuration is not valid, just pretend subcores\n     * are not in use and count threads one by one */\n    if (!virHostCPUHasValidSubcoreConfiguration(threads_per_subcore))\n        threads_per_subcore = 0;\n\n    while ((direrr = virDirRead(nodedir, &nodedirent, sysfs_nodedir)) > 0) {\n        if (sscanf(nodedirent->d_name, \"node%u\", &node) != 1)\n            continue;\n\n        (*nodes)++;\n\n        sysfs_cpudir = g_strdup_printf(\"%s/node/%s\", SYSFS_SYSTEM_PATH,\n                                       nodedirent->d_name);\n\n        if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                            present_cpus_map,\n                                            online_cpus_map,\n                                            threads_per_subcore,\n                                            &nodesockets, &nodecores,\n                                            &nodethreads, &offline)) < 0)\n            goto cleanup;\n\n        VIR_FREE(sysfs_cpudir);\n\n        *cpus += nodecpus;\n\n        if (nodesockets > *sockets)\n            *sockets = nodesockets;\n\n        if (nodecores > *cores)\n            *cores = nodecores;\n\n        if (nodethreads > *threads)\n            *threads = nodethreads;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    if (*cpus && *nodes)\n        goto done;\n\n fallback:\n    VIR_FREE(sysfs_cpudir);\n\n    sysfs_cpudir = g_strdup_printf(\"%s/cpu\", SYSFS_SYSTEM_PATH);\n\n    if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                        present_cpus_map,\n                                        online_cpus_map,\n                                        threads_per_subcore,\n                                        &nodesockets, &nodecores,\n                                        &nodethreads, &offline)) < 0)\n        goto cleanup;\n\n    *nodes = 1;\n    *cpus = nodecpus;\n    *sockets = nodesockets;\n    *cores = nodecores;\n    *threads = nodethreads;\n\n done:\n    /* There should always be at least one cpu, socket, node, and thread. */\n    if (*cpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no CPUs found\"));\n        goto cleanup;\n    }\n\n    if (*sockets == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no sockets found\"));\n        goto cleanup;\n    }\n\n    if (*threads == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no threads found\"));\n        goto cleanup;\n    }\n\n    /* Now check if the topology makes sense. There are machines that don't\n     * expose their real number of nodes or for example the AMD Bulldozer\n     * architecture that exposes their Clustered integer core modules as both\n     * threads and cores. This approach throws off our detection. Unfortunately\n     * the nodeinfo structure isn't designed to carry the full topology so\n     * we're going to lie about the detected topology to notify the user\n     * to check the host capabilities for the actual topology. */\n    if ((*nodes *\n         *sockets *\n         *cores *\n         *threads) != (*cpus + offline)) {\n        *nodes = 1;\n        *sockets = 1;\n        *cores = *cpus + offline;\n        *threads = 1;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(nodedir);\n    virBitmapFree(present_cpus_map);\n    virBitmapFree(online_cpus_map);\n    VIR_FREE(sysfs_nodedir);\n    VIR_FREE(sysfs_cpudir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open %s\")",
            "CPUINFO_PATH"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "CPUINFO_PATH",
            "\"r\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetInfo(virArch hostarch G_GNUC_UNUSED,\n                  unsigned int *cpus G_GNUC_UNUSED,\n                  unsigned int *mhz G_GNUC_UNUSED,\n                  unsigned int *nodes G_GNUC_UNUSED,\n                  unsigned int *sockets G_GNUC_UNUSED,\n                  unsigned int *cores G_GNUC_UNUSED,\n                  unsigned int *threads G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    int ret = -1;\n    FILE *cpuinfo = fopen(CPUINFO_PATH, \"r\");\n\n    if (!cpuinfo) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"), CPUINFO_PATH);\n        return -1;\n    }\n\n    ret = virHostCPUGetInfoPopulateLinux(cpuinfo, hostarch,\n                                         cpus, mhz, nodes,\n                                         sockets, cores, threads);\n    if (ret < 0)\n        goto cleanup;\n\n cleanup:\n    VIR_FORCE_FCLOSE(cpuinfo);\n    return ret;\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    unsigned long cpu_freq;\n    size_t cpu_freq_len = sizeof(cpu_freq);\n\n    *cpus = virHostCPUGetCountAppleFreeBSD();\n    if (*cpus == -1)\n        return -1;\n\n    *nodes = 1;\n    *sockets = 1;\n    *cores = *cpus;\n    *threads = 1;\n\n# ifdef __FreeBSD__\n    /* dev.cpu.%d.freq reports current active CPU frequency. It is provided by\n     * the cpufreq(4) framework. However, it might be disabled or no driver\n     * available. In this case fallback to \"hw.clockrate\" which reports boot time\n     * CPU frequency. */\n\n    if (sysctlbyname(\"dev.cpu.0.freq\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        if (sysctlbyname(\"hw.clockrate\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n            return -1;\n        }\n    }\n\n    *mhz = cpu_freq;\n# else\n    if (sysctlbyname(\"hw.cpufrequency\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n        return -1;\n    }\n\n    *mhz = cpu_freq / 1000000;\n# endif\n\n    return 0;\n#else\n    /* XXX Solaris will need an impl later if they port QEMU driver */\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node info not implemented on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virHostCPUStatsAssign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "908-921",
    "snippet": "int\nvirHostCPUStatsAssign(virNodeCPUStatsPtr param,\n                      const char *name,\n                      unsigned long long value)\n{\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"kernel cpu time field is too long\"\n                               \" for the destination\"));\n        return -1;\n    }\n    param->value = value;\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"kernel cpu time field is too long\"\n                               \" for the destination\")"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"kernel cpu time field is too long\"\n                               \" for the destination\""
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "param->field",
            "name"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUStatsAssign(virNodeCPUStatsPtr param,\n                      const char *name,\n                      unsigned long long value)\n{\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"kernel cpu time field is too long\"\n                               \" for the destination\"));\n        return -1;\n    }\n    param->value = value;\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetOnline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "889-906",
    "snippet": "int\nvirHostCPUGetOnline(unsigned int cpu, bool *online)\n{\n    unsigned int tmp = 0;\n    int ret = virFileReadValueUint(&tmp,\n                                   \"%s/cpu/cpu%u/online\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's online (doesn't support offlining) */\n    if (ret == -2)\n        tmp = 1;\n    else if (ret < 0)\n        return -1;\n\n    *online = tmp;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileReadValueUint",
          "args": [
            "&tmp",
            "\"%s/cpu/cpu%u/online\"",
            "SYSFS_SYSTEM_PATH",
            "cpu"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4117-4144",
          "snippet": "int\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetOnline(unsigned int cpu, bool *online)\n{\n    unsigned int tmp = 0;\n    int ret = virFileReadValueUint(&tmp,\n                                   \"%s/cpu/cpu%u/online\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's online (doesn't support offlining) */\n    if (ret == -2)\n        tmp = 1;\n    else if (ret < 0)\n        return -1;\n\n    *online = tmp;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUParseCountLinux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "861-886",
    "snippet": "static int\nvirHostCPUParseCountLinux(void)\n{\n    char *str = NULL;\n    char *tmp;\n    int ret = -1;\n\n    if (virFileReadValueString(&str, \"%s/cpu/present\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    tmp = str;\n    do {\n        if (virStrToLong_i(tmp, &tmp, 10, &ret) < 0 ||\n            !strchr(\",-\", *tmp)) {\n            virReportError(VIR_ERR_NO_SUPPORT,\n                           _(\"failed to parse %s\"), str);\n            ret = -1;\n            goto cleanup;\n        }\n    } while (*tmp++ && *tmp);\n    ret++;\n\n cleanup:\n    VIR_FREE(str);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"failed to parse %s\")",
            "str"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse %s\""
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\",-\"",
            "*tmp"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "&tmp",
            "10",
            "&ret"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueString",
          "args": [
            "&str",
            "\"%s/cpu/present\"",
            "SYSFS_SYSTEM_PATH"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4279-4299",
          "snippet": "int\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nstatic int\nvirHostCPUParseCountLinux(void)\n{\n    char *str = NULL;\n    char *tmp;\n    int ret = -1;\n\n    if (virFileReadValueString(&str, \"%s/cpu/present\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    tmp = str;\n    do {\n        if (virStrToLong_i(tmp, &tmp, 10, &ret) < 0 ||\n            !strchr(\",-\", *tmp)) {\n            virReportError(VIR_ERR_NO_SUPPORT,\n                           _(\"failed to parse %s\"), str);\n            ret = -1;\n            goto cleanup;\n        }\n    } while (*tmp++ && *tmp);\n    ret++;\n\n cleanup:\n    VIR_FREE(str);\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUGetStatsLinux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "789-856",
    "snippet": "int\nvirHostCPUGetStatsLinux(FILE *procstat,\n                        int cpuNum,\n                        virNodeCPUStatsPtr params,\n                        int *nparams)\n{\n    char line[1024];\n    unsigned long long usr, ni, sys, idle, iowait;\n    unsigned long long irq, softirq, steal, guest, guest_nice;\n    char cpu_header[4 + VIR_INT64_STR_BUFLEN];\n\n    if ((*nparams) == 0) {\n        /* Current number of cpu stats supported by linux */\n        *nparams = LINUX_NB_CPU_STATS;\n        return 0;\n    }\n\n    if ((*nparams) != LINUX_NB_CPU_STATS) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, LINUX_NB_CPU_STATS);\n        return -1;\n    }\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        strcpy(cpu_header, \"cpu \");\n    } else {\n        g_snprintf(cpu_header, sizeof(cpu_header), \"cpu%d \", cpuNum);\n    }\n\n    while (fgets(line, sizeof(line), procstat) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, cpu_header)) { /* aka logical CPU time */\n            if (sscanf(buf,\n                       \"%*s %llu %llu %llu %llu %llu\" /* user ~ iowait */\n                       \"%llu %llu %llu %llu %llu\",    /* irq  ~ guest_nice */\n                       &usr, &ni, &sys, &idle, &iowait,\n                       &irq, &softirq, &steal, &guest, &guest_nice) < 4) {\n                continue;\n            }\n\n            if (virHostCPUStatsAssign(&params[0], VIR_NODE_CPU_STATS_KERNEL,\n                                      (sys + irq + softirq) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[1], VIR_NODE_CPU_STATS_USER,\n                                      (usr + ni) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[2], VIR_NODE_CPU_STATS_IDLE,\n                                      idle * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[3], VIR_NODE_CPU_STATS_IOWAIT,\n                                      iowait * TICK_TO_NSEC) < 0)\n                return -1;\n\n            return 0;\n        }\n    }\n\n    virReportInvalidArg(cpuNum,\n                        _(\"Invalid cpuNum in %s\"),\n                        __FUNCTION__);\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "cpuNum",
            "_(\"Invalid cpuNum in %s\")",
            "__FUNCTION__"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid cpuNum in %s\""
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUStatsAssign",
          "args": [
            "&params[3]",
            "VIR_NODE_CPU_STATS_IOWAIT",
            "iowait * TICK_TO_NSEC"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUStatsAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "908-921",
          "snippet": "int\nvirHostCPUStatsAssign(virNodeCPUStatsPtr param,\n                      const char *name,\n                      unsigned long long value)\n{\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"kernel cpu time field is too long\"\n                               \" for the destination\"));\n        return -1;\n    }\n    param->value = value;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUStatsAssign(virNodeCPUStatsPtr param,\n                      const char *name,\n                      unsigned long long value)\n{\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"kernel cpu time field is too long\"\n                               \" for the destination\"));\n        return -1;\n    }\n    param->value = value;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%*s %llu %llu %llu %llu %llu\" /* user ~ iowait */\n                       \"%llu %llu %llu %llu %llu\"",
            "/* irq  ~ guest_nice */&usr",
            "&ni",
            "&sys",
            "&idle",
            "&iowait",
            "&irq",
            "&softirq",
            "&steal",
            "&guest",
            "&guest_nice"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "buf",
            "cpu_header"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "procstat"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "cpu_header",
            "sizeof(cpu_header)",
            "\"cpu%d \"",
            "cpuNum"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "cpu_header",
            "\"cpu \""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "*nparams",
            "_(\"nparams in %s must be equal to %d\")",
            "__FUNCTION__",
            "LINUX_NB_CPU_STATS"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetStatsLinux(FILE *procstat,\n                        int cpuNum,\n                        virNodeCPUStatsPtr params,\n                        int *nparams)\n{\n    char line[1024];\n    unsigned long long usr, ni, sys, idle, iowait;\n    unsigned long long irq, softirq, steal, guest, guest_nice;\n    char cpu_header[4 + VIR_INT64_STR_BUFLEN];\n\n    if ((*nparams) == 0) {\n        /* Current number of cpu stats supported by linux */\n        *nparams = LINUX_NB_CPU_STATS;\n        return 0;\n    }\n\n    if ((*nparams) != LINUX_NB_CPU_STATS) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, LINUX_NB_CPU_STATS);\n        return -1;\n    }\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        strcpy(cpu_header, \"cpu \");\n    } else {\n        g_snprintf(cpu_header, sizeof(cpu_header), \"cpu%d \", cpuNum);\n    }\n\n    while (fgets(line, sizeof(line), procstat) != NULL) {\n        char *buf = line;\n\n        if (STRPREFIX(buf, cpu_header)) { /* aka logical CPU time */\n            if (sscanf(buf,\n                       \"%*s %llu %llu %llu %llu %llu\" /* user ~ iowait */\n                       \"%llu %llu %llu %llu %llu\",    /* irq  ~ guest_nice */\n                       &usr, &ni, &sys, &idle, &iowait,\n                       &irq, &softirq, &steal, &guest, &guest_nice) < 4) {\n                continue;\n            }\n\n            if (virHostCPUStatsAssign(&params[0], VIR_NODE_CPU_STATS_KERNEL,\n                                      (sys + irq + softirq) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[1], VIR_NODE_CPU_STATS_USER,\n                                      (usr + ni) * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[2], VIR_NODE_CPU_STATS_IDLE,\n                                      idle * TICK_TO_NSEC) < 0)\n                return -1;\n\n            if (virHostCPUStatsAssign(&params[3], VIR_NODE_CPU_STATS_IOWAIT,\n                                      iowait * TICK_TO_NSEC) < 0)\n                return -1;\n\n            return 0;\n        }\n    }\n\n    virReportInvalidArg(cpuNum,\n                        _(\"Invalid cpuNum in %s\"),\n                        __FUNCTION__);\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetInfoPopulateLinux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "606-785",
    "snippet": "int\nvirHostCPUGetInfoPopulateLinux(FILE *cpuinfo,\n                               virArch arch,\n                               unsigned int *cpus,\n                               unsigned int *mhz,\n                               unsigned int *nodes,\n                               unsigned int *sockets,\n                               unsigned int *cores,\n                               unsigned int *threads)\n{\n    virBitmapPtr present_cpus_map = NULL;\n    virBitmapPtr online_cpus_map = NULL;\n    DIR *nodedir = NULL;\n    struct dirent *nodedirent = NULL;\n    int nodecpus, nodecores, nodesockets, nodethreads, offline = 0;\n    int threads_per_subcore = 0;\n    unsigned int node;\n    int ret = -1;\n    char *sysfs_nodedir = NULL;\n    char *sysfs_cpudir = NULL;\n    int direrr;\n\n    *mhz = 0;\n    *cpus = *nodes = *sockets = *cores = *threads = 0;\n\n    /* Start with parsing CPU clock speed from /proc/cpuinfo */\n    if (virHostCPUParseFrequency(cpuinfo, arch, mhz) < 0) {\n        VIR_WARN(\"Unable to parse CPU frequency information from %s\",\n                 CPUINFO_PATH);\n    }\n\n    /* Get information about what CPUs are present in the host and what\n     * CPUs are online, so that we don't have to so for each node */\n    present_cpus_map = virHostCPUGetPresentBitmap();\n    if (!present_cpus_map)\n        goto cleanup;\n    online_cpus_map = virHostCPUGetOnlineBitmap();\n    if (!online_cpus_map)\n        goto cleanup;\n\n    /* OK, we've parsed clock speed out of /proc/cpuinfo. Get the\n     * core, node, socket, thread and topology information from /sys\n     */\n    sysfs_nodedir = g_strdup_printf(\"%s/node\", SYSFS_SYSTEM_PATH);\n\n    if (virDirOpenQuiet(&nodedir, sysfs_nodedir) < 0) {\n        /* the host isn't probably running a NUMA architecture */\n        goto fallback;\n    }\n\n    /* PPC-KVM needs the secondary threads of a core to be offline on the\n     * host. The kvm scheduler brings the secondary threads online in the\n     * guest context. Moreover, P8 processor has split-core capability\n     * where, there can be 1,2 or 4 subcores per core. The primaries of the\n     * subcores alone will be online on the host for a subcore in the\n     * host. Even though the actual threads per core for P8 processor is 8,\n     * depending on the subcores_per_core = 1, 2 or 4, the threads per\n     * subcore will vary accordingly to 8, 4 and 2 respectively.\n     * So, On host threads_per_core what is arrived at from sysfs in the\n     * current logic is actually the subcores_per_core. Threads per subcore\n     * can only be obtained from the kvm device. For example, on P8 wih 1\n     * core having 8 threads, sub_cores_percore=4, the threads 0,2,4 & 6\n     * will be online. The sysfs reflects this and in the current logic\n     * variable 'threads' will be 4 which is nothing but subcores_per_core.\n     * If the user tampers the cpu online/offline states using chcpu or other\n     * means, then it is an unsupported configuration for kvm.\n     * The code below tries to keep in mind\n     *  - when the libvirtd is run inside a KVM guest or Phyp based guest.\n     *  - Or on the kvm host where user manually tampers the cpu states to\n     *    offline/online randomly.\n     * On hosts other than POWER this will be 0, in which case a simpler\n     * thread-counting logic will be used  */\n    if ((threads_per_subcore = virHostCPUGetThreadsPerSubcore(arch)) < 0)\n        goto cleanup;\n\n    /* If the subcore configuration is not valid, just pretend subcores\n     * are not in use and count threads one by one */\n    if (!virHostCPUHasValidSubcoreConfiguration(threads_per_subcore))\n        threads_per_subcore = 0;\n\n    while ((direrr = virDirRead(nodedir, &nodedirent, sysfs_nodedir)) > 0) {\n        if (sscanf(nodedirent->d_name, \"node%u\", &node) != 1)\n            continue;\n\n        (*nodes)++;\n\n        sysfs_cpudir = g_strdup_printf(\"%s/node/%s\", SYSFS_SYSTEM_PATH,\n                                       nodedirent->d_name);\n\n        if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                            present_cpus_map,\n                                            online_cpus_map,\n                                            threads_per_subcore,\n                                            &nodesockets, &nodecores,\n                                            &nodethreads, &offline)) < 0)\n            goto cleanup;\n\n        VIR_FREE(sysfs_cpudir);\n\n        *cpus += nodecpus;\n\n        if (nodesockets > *sockets)\n            *sockets = nodesockets;\n\n        if (nodecores > *cores)\n            *cores = nodecores;\n\n        if (nodethreads > *threads)\n            *threads = nodethreads;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    if (*cpus && *nodes)\n        goto done;\n\n fallback:\n    VIR_FREE(sysfs_cpudir);\n\n    sysfs_cpudir = g_strdup_printf(\"%s/cpu\", SYSFS_SYSTEM_PATH);\n\n    if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                        present_cpus_map,\n                                        online_cpus_map,\n                                        threads_per_subcore,\n                                        &nodesockets, &nodecores,\n                                        &nodethreads, &offline)) < 0)\n        goto cleanup;\n\n    *nodes = 1;\n    *cpus = nodecpus;\n    *sockets = nodesockets;\n    *cores = nodecores;\n    *threads = nodethreads;\n\n done:\n    /* There should always be at least one cpu, socket, node, and thread. */\n    if (*cpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no CPUs found\"));\n        goto cleanup;\n    }\n\n    if (*sockets == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no sockets found\"));\n        goto cleanup;\n    }\n\n    if (*threads == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no threads found\"));\n        goto cleanup;\n    }\n\n    /* Now check if the topology makes sense. There are machines that don't\n     * expose their real number of nodes or for example the AMD Bulldozer\n     * architecture that exposes their Clustered integer core modules as both\n     * threads and cores. This approach throws off our detection. Unfortunately\n     * the nodeinfo structure isn't designed to carry the full topology so\n     * we're going to lie about the detected topology to notify the user\n     * to check the host capabilities for the actual topology. */\n    if ((*nodes *\n         *sockets *\n         *cores *\n         *threads) != (*cpus + offline)) {\n        *nodes = 1;\n        *sockets = 1;\n        *cores = *cpus + offline;\n        *threads = 1;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(nodedir);\n    virBitmapFree(present_cpus_map);\n    virBitmapFree(online_cpus_map);\n    VIR_FREE(sysfs_nodedir);\n    VIR_FREE(sysfs_cpudir);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_cpudir"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_nodedir"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "online_cpus_map"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "nodedir"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no threads found\")"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no threads found\""
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no sockets found\")"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no CPUs found\")"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUParseNode",
          "args": [
            "sysfs_cpudir",
            "arch",
            "present_cpus_map",
            "online_cpus_map",
            "threads_per_subcore",
            "&nodesockets",
            "&nodecores",
            "&nodethreads",
            "&offline"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/cpu\"",
            "SYSFS_SYSTEM_PATH"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_cpudir"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_cpudir"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUParseNode",
          "args": [
            "sysfs_cpudir",
            "arch",
            "present_cpus_map",
            "online_cpus_map",
            "threads_per_subcore",
            "&nodesockets",
            "&nodecores",
            "&nodethreads",
            "&offline"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "nodedirent->d_name",
            "\"node%u\"",
            "&node"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "nodedir",
            "&nodedirent",
            "sysfs_nodedir"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUHasValidSubcoreConfiguration",
          "args": [
            "threads_per_subcore"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUHasValidSubcoreConfiguration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "465-493",
          "snippet": "static bool\nvirHostCPUHasValidSubcoreConfiguration(int threads_per_subcore)\n{\n    virBitmapPtr online_cpus = NULL;\n    int cpu = -1;\n    bool ret = false;\n\n    /* No point in checking if subcores are not in use */\n    if (threads_per_subcore <= 0)\n        goto cleanup;\n\n    if (!(online_cpus = virHostCPUGetOnlineBitmap()))\n        goto cleanup;\n\n    while ((cpu = virBitmapNextSetBit(online_cpus, cpu)) >= 0) {\n\n        /* A single online secondary thread is enough to\n         * make the configuration invalid */\n        if (cpu % threads_per_subcore != 0)\n            goto cleanup;\n    }\n\n    ret = true;\n\n cleanup:\n    virBitmapFree(online_cpus);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic bool\nvirHostCPUHasValidSubcoreConfiguration(int threads_per_subcore)\n{\n    virBitmapPtr online_cpus = NULL;\n    int cpu = -1;\n    bool ret = false;\n\n    /* No point in checking if subcores are not in use */\n    if (threads_per_subcore <= 0)\n        goto cleanup;\n\n    if (!(online_cpus = virHostCPUGetOnlineBitmap()))\n        goto cleanup;\n\n    while ((cpu = virBitmapNextSetBit(online_cpus, cpu)) >= 0) {\n\n        /* A single online secondary thread is enough to\n         * make the configuration invalid */\n        if (cpu % threads_per_subcore != 0)\n            goto cleanup;\n    }\n\n    ret = true;\n\n cleanup:\n    virBitmapFree(online_cpus);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetThreadsPerSubcore",
          "args": [
            "arch"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetThreadsPerSubcore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1172-1176",
          "snippet": "int\nvirHostCPUGetThreadsPerSubcore(virArch arch G_GNUC_UNUSED)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetThreadsPerSubcore(virArch arch G_GNUC_UNUSED)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpenQuiet",
          "args": [
            "&nodedir",
            "sysfs_nodedir"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetOnlineBitmap",
          "args": [],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetOnlineBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1070-1084",
          "snippet": "virBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetPresentBitmap",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetPresentBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1054-1068",
          "snippet": "virBitmapPtr\nvirHostCPUGetPresentBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/present\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node present CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetPresentBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/present\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node present CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to parse CPU frequency information from %s\"",
            "CPUINFO_PATH"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUParseFrequency",
          "args": [
            "cpuinfo",
            "arch",
            "mhz"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUParseFrequency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "571-603",
          "snippet": "static int\nvirHostCPUParseFrequency(FILE *cpuinfo,\n                         virArch arch,\n                         unsigned int *mhz)\n{\n    const char *prefix = NULL;\n    char line[1024];\n\n    /* No sensible way to retrieve CPU frequency */\n    if (ARCH_IS_ARM(arch))\n        return 0;\n\n    if (ARCH_IS_X86(arch))\n        prefix = \"cpu MHz\";\n    else if (ARCH_IS_PPC(arch))\n        prefix = \"clock\";\n    else if (ARCH_IS_S390(arch))\n        prefix = \"cpu MHz dynamic\";\n\n    if (!prefix) {\n        VIR_WARN(\"%s is not supported by the %s parser\",\n                 virArchToString(arch),\n                 CPUINFO_PATH);\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        if (virHostCPUParseFrequencyString(line, prefix, mhz) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUParseFrequency(FILE *cpuinfo,\n                         virArch arch,\n                         unsigned int *mhz)\n{\n    const char *prefix = NULL;\n    char line[1024];\n\n    /* No sensible way to retrieve CPU frequency */\n    if (ARCH_IS_ARM(arch))\n        return 0;\n\n    if (ARCH_IS_X86(arch))\n        prefix = \"cpu MHz\";\n    else if (ARCH_IS_PPC(arch))\n        prefix = \"clock\";\n    else if (ARCH_IS_S390(arch))\n        prefix = \"cpu MHz dynamic\";\n\n    if (!prefix) {\n        VIR_WARN(\"%s is not supported by the %s parser\",\n                 virArchToString(arch),\n                 CPUINFO_PATH);\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        if (virHostCPUParseFrequencyString(line, prefix, mhz) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetInfoPopulateLinux(FILE *cpuinfo,\n                               virArch arch,\n                               unsigned int *cpus,\n                               unsigned int *mhz,\n                               unsigned int *nodes,\n                               unsigned int *sockets,\n                               unsigned int *cores,\n                               unsigned int *threads)\n{\n    virBitmapPtr present_cpus_map = NULL;\n    virBitmapPtr online_cpus_map = NULL;\n    DIR *nodedir = NULL;\n    struct dirent *nodedirent = NULL;\n    int nodecpus, nodecores, nodesockets, nodethreads, offline = 0;\n    int threads_per_subcore = 0;\n    unsigned int node;\n    int ret = -1;\n    char *sysfs_nodedir = NULL;\n    char *sysfs_cpudir = NULL;\n    int direrr;\n\n    *mhz = 0;\n    *cpus = *nodes = *sockets = *cores = *threads = 0;\n\n    /* Start with parsing CPU clock speed from /proc/cpuinfo */\n    if (virHostCPUParseFrequency(cpuinfo, arch, mhz) < 0) {\n        VIR_WARN(\"Unable to parse CPU frequency information from %s\",\n                 CPUINFO_PATH);\n    }\n\n    /* Get information about what CPUs are present in the host and what\n     * CPUs are online, so that we don't have to so for each node */\n    present_cpus_map = virHostCPUGetPresentBitmap();\n    if (!present_cpus_map)\n        goto cleanup;\n    online_cpus_map = virHostCPUGetOnlineBitmap();\n    if (!online_cpus_map)\n        goto cleanup;\n\n    /* OK, we've parsed clock speed out of /proc/cpuinfo. Get the\n     * core, node, socket, thread and topology information from /sys\n     */\n    sysfs_nodedir = g_strdup_printf(\"%s/node\", SYSFS_SYSTEM_PATH);\n\n    if (virDirOpenQuiet(&nodedir, sysfs_nodedir) < 0) {\n        /* the host isn't probably running a NUMA architecture */\n        goto fallback;\n    }\n\n    /* PPC-KVM needs the secondary threads of a core to be offline on the\n     * host. The kvm scheduler brings the secondary threads online in the\n     * guest context. Moreover, P8 processor has split-core capability\n     * where, there can be 1,2 or 4 subcores per core. The primaries of the\n     * subcores alone will be online on the host for a subcore in the\n     * host. Even though the actual threads per core for P8 processor is 8,\n     * depending on the subcores_per_core = 1, 2 or 4, the threads per\n     * subcore will vary accordingly to 8, 4 and 2 respectively.\n     * So, On host threads_per_core what is arrived at from sysfs in the\n     * current logic is actually the subcores_per_core. Threads per subcore\n     * can only be obtained from the kvm device. For example, on P8 wih 1\n     * core having 8 threads, sub_cores_percore=4, the threads 0,2,4 & 6\n     * will be online. The sysfs reflects this and in the current logic\n     * variable 'threads' will be 4 which is nothing but subcores_per_core.\n     * If the user tampers the cpu online/offline states using chcpu or other\n     * means, then it is an unsupported configuration for kvm.\n     * The code below tries to keep in mind\n     *  - when the libvirtd is run inside a KVM guest or Phyp based guest.\n     *  - Or on the kvm host where user manually tampers the cpu states to\n     *    offline/online randomly.\n     * On hosts other than POWER this will be 0, in which case a simpler\n     * thread-counting logic will be used  */\n    if ((threads_per_subcore = virHostCPUGetThreadsPerSubcore(arch)) < 0)\n        goto cleanup;\n\n    /* If the subcore configuration is not valid, just pretend subcores\n     * are not in use and count threads one by one */\n    if (!virHostCPUHasValidSubcoreConfiguration(threads_per_subcore))\n        threads_per_subcore = 0;\n\n    while ((direrr = virDirRead(nodedir, &nodedirent, sysfs_nodedir)) > 0) {\n        if (sscanf(nodedirent->d_name, \"node%u\", &node) != 1)\n            continue;\n\n        (*nodes)++;\n\n        sysfs_cpudir = g_strdup_printf(\"%s/node/%s\", SYSFS_SYSTEM_PATH,\n                                       nodedirent->d_name);\n\n        if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                            present_cpus_map,\n                                            online_cpus_map,\n                                            threads_per_subcore,\n                                            &nodesockets, &nodecores,\n                                            &nodethreads, &offline)) < 0)\n            goto cleanup;\n\n        VIR_FREE(sysfs_cpudir);\n\n        *cpus += nodecpus;\n\n        if (nodesockets > *sockets)\n            *sockets = nodesockets;\n\n        if (nodecores > *cores)\n            *cores = nodecores;\n\n        if (nodethreads > *threads)\n            *threads = nodethreads;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    if (*cpus && *nodes)\n        goto done;\n\n fallback:\n    VIR_FREE(sysfs_cpudir);\n\n    sysfs_cpudir = g_strdup_printf(\"%s/cpu\", SYSFS_SYSTEM_PATH);\n\n    if ((nodecpus = virHostCPUParseNode(sysfs_cpudir, arch,\n                                        present_cpus_map,\n                                        online_cpus_map,\n                                        threads_per_subcore,\n                                        &nodesockets, &nodecores,\n                                        &nodethreads, &offline)) < 0)\n        goto cleanup;\n\n    *nodes = 1;\n    *cpus = nodecpus;\n    *sockets = nodesockets;\n    *cores = nodecores;\n    *threads = nodethreads;\n\n done:\n    /* There should always be at least one cpu, socket, node, and thread. */\n    if (*cpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no CPUs found\"));\n        goto cleanup;\n    }\n\n    if (*sockets == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no sockets found\"));\n        goto cleanup;\n    }\n\n    if (*threads == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"no threads found\"));\n        goto cleanup;\n    }\n\n    /* Now check if the topology makes sense. There are machines that don't\n     * expose their real number of nodes or for example the AMD Bulldozer\n     * architecture that exposes their Clustered integer core modules as both\n     * threads and cores. This approach throws off our detection. Unfortunately\n     * the nodeinfo structure isn't designed to carry the full topology so\n     * we're going to lie about the detected topology to notify the user\n     * to check the host capabilities for the actual topology. */\n    if ((*nodes *\n         *sockets *\n         *cores *\n         *threads) != (*cpus + offline)) {\n        *nodes = 1;\n        *sockets = 1;\n        *cores = *cpus + offline;\n        *threads = 1;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(nodedir);\n    virBitmapFree(present_cpus_map);\n    virBitmapFree(online_cpus_map);\n    VIR_FREE(sysfs_nodedir);\n    VIR_FREE(sysfs_cpudir);\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUParseFrequency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "571-603",
    "snippet": "static int\nvirHostCPUParseFrequency(FILE *cpuinfo,\n                         virArch arch,\n                         unsigned int *mhz)\n{\n    const char *prefix = NULL;\n    char line[1024];\n\n    /* No sensible way to retrieve CPU frequency */\n    if (ARCH_IS_ARM(arch))\n        return 0;\n\n    if (ARCH_IS_X86(arch))\n        prefix = \"cpu MHz\";\n    else if (ARCH_IS_PPC(arch))\n        prefix = \"clock\";\n    else if (ARCH_IS_S390(arch))\n        prefix = \"cpu MHz dynamic\";\n\n    if (!prefix) {\n        VIR_WARN(\"%s is not supported by the %s parser\",\n                 virArchToString(arch),\n                 CPUINFO_PATH);\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        if (virHostCPUParseFrequencyString(line, prefix, mhz) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostCPUParseFrequencyString",
          "args": [
            "line",
            "prefix",
            "mhz"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUParseFrequencyString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "517-568",
          "snippet": "static int\nvirHostCPUParseFrequencyString(const char *str,\n                               const char *prefix,\n                               unsigned int *mhz)\n{\n    char *p;\n    unsigned int ui;\n\n    /* If the string doesn't start with the expected prefix, then\n     * we're not looking at the right string and we should move on */\n    if (!STRPREFIX(str, prefix))\n        return 1;\n\n    /* Skip the prefix */\n    str += strlen(prefix);\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Skip the colon. If anything but a colon is found, then we're\n     * not looking at the right string and we should move on */\n    if (*str != ':')\n        return 1;\n    str++;\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Parse the frequency. We expect an unsigned value, optionally\n     * followed by a fractional part (which gets discarded) or some\n     * leading whitespace */\n    if (virStrToLong_ui(str, &p, 10, &ui) < 0 ||\n        (*p != '.' && *p != '\\0' && !g_ascii_isspace(*p))) {\n        goto error;\n    }\n\n    *mhz = ui;\n\n    return 0;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing or invalid CPU frequency in %s\"),\n                   CPUINFO_PATH);\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUParseFrequencyString(const char *str,\n                               const char *prefix,\n                               unsigned int *mhz)\n{\n    char *p;\n    unsigned int ui;\n\n    /* If the string doesn't start with the expected prefix, then\n     * we're not looking at the right string and we should move on */\n    if (!STRPREFIX(str, prefix))\n        return 1;\n\n    /* Skip the prefix */\n    str += strlen(prefix);\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Skip the colon. If anything but a colon is found, then we're\n     * not looking at the right string and we should move on */\n    if (*str != ':')\n        return 1;\n    str++;\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Parse the frequency. We expect an unsigned value, optionally\n     * followed by a fractional part (which gets discarded) or some\n     * leading whitespace */\n    if (virStrToLong_ui(str, &p, 10, &ui) < 0 ||\n        (*p != '.' && *p != '\\0' && !g_ascii_isspace(*p))) {\n        goto error;\n    }\n\n    *mhz = ui;\n\n    return 0;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing or invalid CPU frequency in %s\"),\n                   CPUINFO_PATH);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "cpuinfo"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"%s is not supported by the %s parser\"",
            "virArchToString(arch)",
            "CPUINFO_PATH"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "arch"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC",
          "args": [
            "arch"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "arch"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_ARM",
          "args": [
            "arch"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUParseFrequency(FILE *cpuinfo,\n                         virArch arch,\n                         unsigned int *mhz)\n{\n    const char *prefix = NULL;\n    char line[1024];\n\n    /* No sensible way to retrieve CPU frequency */\n    if (ARCH_IS_ARM(arch))\n        return 0;\n\n    if (ARCH_IS_X86(arch))\n        prefix = \"cpu MHz\";\n    else if (ARCH_IS_PPC(arch))\n        prefix = \"clock\";\n    else if (ARCH_IS_S390(arch))\n        prefix = \"cpu MHz dynamic\";\n\n    if (!prefix) {\n        VIR_WARN(\"%s is not supported by the %s parser\",\n                 virArchToString(arch),\n                 CPUINFO_PATH);\n        return 1;\n    }\n\n    while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        if (virHostCPUParseFrequencyString(line, prefix, mhz) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUParseFrequencyString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "517-568",
    "snippet": "static int\nvirHostCPUParseFrequencyString(const char *str,\n                               const char *prefix,\n                               unsigned int *mhz)\n{\n    char *p;\n    unsigned int ui;\n\n    /* If the string doesn't start with the expected prefix, then\n     * we're not looking at the right string and we should move on */\n    if (!STRPREFIX(str, prefix))\n        return 1;\n\n    /* Skip the prefix */\n    str += strlen(prefix);\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Skip the colon. If anything but a colon is found, then we're\n     * not looking at the right string and we should move on */\n    if (*str != ':')\n        return 1;\n    str++;\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Parse the frequency. We expect an unsigned value, optionally\n     * followed by a fractional part (which gets discarded) or some\n     * leading whitespace */\n    if (virStrToLong_ui(str, &p, 10, &ui) < 0 ||\n        (*p != '.' && *p != '\\0' && !g_ascii_isspace(*p))) {\n        goto error;\n    }\n\n    *mhz = ui;\n\n    return 0;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing or invalid CPU frequency in %s\"),\n                   CPUINFO_PATH);\n    return -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing or invalid CPU frequency in %s\")",
            "CPUINFO_PATH"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or invalid CPU frequency in %s\""
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*p"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "str",
            "&p",
            "10",
            "&ui"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*str"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*str"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "str",
            "prefix"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUParseFrequencyString(const char *str,\n                               const char *prefix,\n                               unsigned int *mhz)\n{\n    char *p;\n    unsigned int ui;\n\n    /* If the string doesn't start with the expected prefix, then\n     * we're not looking at the right string and we should move on */\n    if (!STRPREFIX(str, prefix))\n        return 1;\n\n    /* Skip the prefix */\n    str += strlen(prefix);\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Skip the colon. If anything but a colon is found, then we're\n     * not looking at the right string and we should move on */\n    if (*str != ':')\n        return 1;\n    str++;\n\n    /* Skip all whitespace */\n    while (g_ascii_isspace(*str))\n        str++;\n    if (*str == '\\0')\n        goto error;\n\n    /* Parse the frequency. We expect an unsigned value, optionally\n     * followed by a fractional part (which gets discarded) or some\n     * leading whitespace */\n    if (virStrToLong_ui(str, &p, 10, &ui) < 0 ||\n        (*p != '.' && *p != '\\0' && !g_ascii_isspace(*p))) {\n        goto error;\n    }\n\n    *mhz = ui;\n\n    return 0;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing or invalid CPU frequency in %s\"),\n                   CPUINFO_PATH);\n    return -1;\n}"
  },
  {
    "function_name": "virHostCPUHasValidSubcoreConfiguration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "465-493",
    "snippet": "static bool\nvirHostCPUHasValidSubcoreConfiguration(int threads_per_subcore)\n{\n    virBitmapPtr online_cpus = NULL;\n    int cpu = -1;\n    bool ret = false;\n\n    /* No point in checking if subcores are not in use */\n    if (threads_per_subcore <= 0)\n        goto cleanup;\n\n    if (!(online_cpus = virHostCPUGetOnlineBitmap()))\n        goto cleanup;\n\n    while ((cpu = virBitmapNextSetBit(online_cpus, cpu)) >= 0) {\n\n        /* A single online secondary thread is enough to\n         * make the configuration invalid */\n        if (cpu % threads_per_subcore != 0)\n            goto cleanup;\n    }\n\n    ret = true;\n\n cleanup:\n    virBitmapFree(online_cpus);\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "online_cpus"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "online_cpus",
            "cpu"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetOnlineBitmap",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetOnlineBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1070-1084",
          "snippet": "virBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetOnlineBitmap(void)\n{\n#ifdef __linux__\n    virBitmapPtr ret = NULL;\n\n    virFileReadValueBitmap(&ret, \"%s/cpu/online\", SYSFS_SYSTEM_PATH);\n\n    return ret;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node online CPU map not implemented on this platform\"));\n    return NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic bool\nvirHostCPUHasValidSubcoreConfiguration(int threads_per_subcore)\n{\n    virBitmapPtr online_cpus = NULL;\n    int cpu = -1;\n    bool ret = false;\n\n    /* No point in checking if subcores are not in use */\n    if (threads_per_subcore <= 0)\n        goto cleanup;\n\n    if (!(online_cpus = virHostCPUGetOnlineBitmap()))\n        goto cleanup;\n\n    while ((cpu = virBitmapNextSetBit(online_cpus, cpu)) >= 0) {\n\n        /* A single online secondary thread is enough to\n         * make the configuration invalid */\n        if (cpu % threads_per_subcore != 0)\n            goto cleanup;\n    }\n\n    ret = true;\n\n cleanup:\n    virBitmapFree(online_cpus);\n\n    return ret;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "296-459",
    "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "node_cpus_map"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cores_maps"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "cpudir"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapCountBits",
          "args": [
            "cores_maps[i]"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCountBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1122-1132",
          "snippet": "size_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "sockets_map",
            "i"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUCountThreadSiblings",
          "args": [
            "cpu"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUCountThreadSiblings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "278-292",
          "snippet": "static unsigned long\nvirHostCPUCountThreadSiblings(unsigned int cpu)\n{\n    virBitmapPtr siblings_map;\n    unsigned long ret = 0;\n\n    if (!(siblings_map = virHostCPUGetSiblingsList(cpu)))\n        goto cleanup;\n\n    ret = virBitmapCountBits(siblings_map);\n\n cleanup:\n    virBitmapFree(siblings_map);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic unsigned long\nvirHostCPUCountThreadSiblings(unsigned int cpu)\n{\n    virBitmapPtr siblings_map;\n    unsigned long ret = 0;\n\n    if (!(siblings_map = virHostCPUGetSiblingsList(cpu)))\n        goto cleanup;\n\n    ret = virBitmapCountBits(siblings_map);\n\n cleanup:\n    virBitmapFree(siblings_map);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSetBitExpand",
          "args": [
            "cores_maps[sock]",
            "core"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCore",
          "args": [
            "cpu",
            "&core"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "243-257",
          "snippet": "int\nvirHostCPUGetCore(unsigned int cpu, unsigned int *core)\n{\n    int ret = virFileReadValueUint(core,\n                                   \"%s/cpu/cpu%u/topology/core_id\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        *core = 0;\n    else if (ret < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetCore(unsigned int cpu, unsigned int *core)\n{\n    int ret = virFileReadValueUint(core,\n                                   \"%s/cpu/cpu%u/topology/core_id\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        *core = 0;\n    else if (ret < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "arch"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"CPU socket topology has changed\")"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU socket topology has changed\""
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetSocket",
          "args": [
            "cpu",
            "&sock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "195-218",
          "snippet": "int\nvirHostCPUGetSocket(unsigned int cpu, unsigned int *socket)\n{\n    int tmp;\n    int ret = virFileReadValueInt(&tmp,\n                                  \"%s/cpu/cpu%u/topology/physical_package_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        tmp = 0;\n    else if (ret < 0)\n        return -1;\n\n    /* Some architectures might have '-1' validly in the file, but that actually\n     * means there are no sockets, so from our point of view it's all one socket,\n     * i.e. socket 0.  Similarly when the file does not exist. */\n    if (tmp < 0)\n        tmp = 0;\n\n    *socket = tmp;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetSocket(unsigned int cpu, unsigned int *socket)\n{\n    int tmp;\n    int ret = virFileReadValueInt(&tmp,\n                                  \"%s/cpu/cpu%u/topology/physical_package_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        tmp = 0;\n    else if (ret < 0)\n        return -1;\n\n    /* Some architectures might have '-1' validly in the file, but that actually\n     * means there are no sockets, so from our point of view it's all one socket,\n     * i.e. socket 0.  Similarly when the file does not exist. */\n    if (tmp < 0)\n        tmp = 0;\n\n    *socket = tmp;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNewEmpty",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "115-119",
          "snippet": "virBitmapPtr\nvirBitmapNewEmpty(void)\n{\n    return g_new0(virBitmap, 1);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewEmpty(void)\n{\n    return g_new0(virBitmap, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cores_maps",
            "sock_max"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cpudirent->d_name",
            "\"cpu%u\"",
            "&cpu"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "cpudir",
            "&cpudirent",
            "node"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "npresent_cpus"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&cpudir",
            "node"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "present_cpus_map"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUParseNode",
          "args": [
            "const char *node",
            "virArcharch",
            "virBitmapPtrpresent_cpus_map",
            "virBitmapPtronline_cpus_map",
            "intthreads_per_subcore",
            "int *sockets",
            "int *cores",
            "int *threads",
            "int *offline"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUCountThreadSiblings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "278-292",
    "snippet": "static unsigned long\nvirHostCPUCountThreadSiblings(unsigned int cpu)\n{\n    virBitmapPtr siblings_map;\n    unsigned long ret = 0;\n\n    if (!(siblings_map = virHostCPUGetSiblingsList(cpu)))\n        goto cleanup;\n\n    ret = virBitmapCountBits(siblings_map);\n\n cleanup:\n    virBitmapFree(siblings_map);\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "siblings_map"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapCountBits",
          "args": [
            "siblings_map"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCountBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1122-1132",
          "snippet": "size_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetSiblingsList",
          "args": [
            "cpu"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetSiblingsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "259-276",
          "snippet": "virBitmapPtr\nvirHostCPUGetSiblingsList(unsigned int cpu)\n{\n    virBitmapPtr ret = NULL;\n    int rv = -1;\n\n    rv = virFileReadValueBitmap(&ret,\n                                \"%s/cpu/cpu%u/topology/thread_siblings_list\",\n                                SYSFS_SYSTEM_PATH, cpu);\n    if (rv == -2) {\n        /* If the file doesn't exist, the threadis its only sibling */\n        ret = virBitmapNew(cpu + 1);\n        if (ret)\n            ignore_value(virBitmapSetBit(ret, cpu));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetSiblingsList(unsigned int cpu)\n{\n    virBitmapPtr ret = NULL;\n    int rv = -1;\n\n    rv = virFileReadValueBitmap(&ret,\n                                \"%s/cpu/cpu%u/topology/thread_siblings_list\",\n                                SYSFS_SYSTEM_PATH, cpu);\n    if (rv == -2) {\n        /* If the file doesn't exist, the threadis its only sibling */\n        ret = virBitmapNew(cpu + 1);\n        if (ret)\n            ignore_value(virBitmapSetBit(ret, cpu));\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic unsigned long\nvirHostCPUCountThreadSiblings(unsigned int cpu)\n{\n    virBitmapPtr siblings_map;\n    unsigned long ret = 0;\n\n    if (!(siblings_map = virHostCPUGetSiblingsList(cpu)))\n        goto cleanup;\n\n    ret = virBitmapCountBits(siblings_map);\n\n cleanup:\n    virBitmapFree(siblings_map);\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUGetSiblingsList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "259-276",
    "snippet": "virBitmapPtr\nvirHostCPUGetSiblingsList(unsigned int cpu)\n{\n    virBitmapPtr ret = NULL;\n    int rv = -1;\n\n    rv = virFileReadValueBitmap(&ret,\n                                \"%s/cpu/cpu%u/topology/thread_siblings_list\",\n                                SYSFS_SYSTEM_PATH, cpu);\n    if (rv == -2) {\n        /* If the file doesn't exist, the threadis its only sibling */\n        ret = virBitmapNew(cpu + 1);\n        if (ret)\n            ignore_value(virBitmapSetBit(ret, cpu));\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(ret, cpu)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "ret",
            "cpu"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "cpu + 1"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueBitmap",
          "args": [
            "&ret",
            "\"%s/cpu/cpu%u/topology/thread_siblings_list\"",
            "SYSFS_SYSTEM_PATH",
            "cpu"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4241-4265",
          "snippet": "int\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetSiblingsList(unsigned int cpu)\n{\n    virBitmapPtr ret = NULL;\n    int rv = -1;\n\n    rv = virFileReadValueBitmap(&ret,\n                                \"%s/cpu/cpu%u/topology/thread_siblings_list\",\n                                SYSFS_SYSTEM_PATH, cpu);\n    if (rv == -2) {\n        /* If the file doesn't exist, the threadis its only sibling */\n        ret = virBitmapNew(cpu + 1);\n        if (ret)\n            ignore_value(virBitmapSetBit(ret, cpu));\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUGetCore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "243-257",
    "snippet": "int\nvirHostCPUGetCore(unsigned int cpu, unsigned int *core)\n{\n    int ret = virFileReadValueUint(core,\n                                   \"%s/cpu/cpu%u/topology/core_id\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        *core = 0;\n    else if (ret < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileReadValueUint",
          "args": [
            "core",
            "\"%s/cpu/cpu%u/topology/core_id\"",
            "SYSFS_SYSTEM_PATH",
            "cpu"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4117-4144",
          "snippet": "int\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetCore(unsigned int cpu, unsigned int *core)\n{\n    int ret = virFileReadValueUint(core,\n                                   \"%s/cpu/cpu%u/topology/core_id\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        *core = 0;\n    else if (ret < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetDie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "220-241",
    "snippet": "int\nvirHostCPUGetDie(unsigned int cpu, unsigned int *die)\n{\n    int die_id;\n    int ret = virFileReadValueInt(&die_id,\n                                  \"%s/cpu/cpu%u/topology/die_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    if (ret == -1)\n        return -1;\n\n    /* If the file is not there, it's 0.\n     * Another alternative is die_id set to -1, meaning that\n     * the arch does not have die_id support. Set @die to\n     * 0 in this case too. */\n    if (ret == -2 || die_id < 0)\n        *die = 0;\n    else\n        *die = die_id;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileReadValueInt",
          "args": [
            "&die_id",
            "\"%s/cpu/cpu%u/topology/die_id\"",
            "SYSFS_SYSTEM_PATH",
            "cpu"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4077-4104",
          "snippet": "int\nvirFileReadValueInt(int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_i(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueInt(int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_i(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetDie(unsigned int cpu, unsigned int *die)\n{\n    int die_id;\n    int ret = virFileReadValueInt(&die_id,\n                                  \"%s/cpu/cpu%u/topology/die_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    if (ret == -1)\n        return -1;\n\n    /* If the file is not there, it's 0.\n     * Another alternative is die_id set to -1, meaning that\n     * the arch does not have die_id support. Set @die to\n     * 0 in this case too. */\n    if (ret == -2 || die_id < 0)\n        *die = 0;\n    else\n        *die = die_id;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "195-218",
    "snippet": "int\nvirHostCPUGetSocket(unsigned int cpu, unsigned int *socket)\n{\n    int tmp;\n    int ret = virFileReadValueInt(&tmp,\n                                  \"%s/cpu/cpu%u/topology/physical_package_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        tmp = 0;\n    else if (ret < 0)\n        return -1;\n\n    /* Some architectures might have '-1' validly in the file, but that actually\n     * means there are no sockets, so from our point of view it's all one socket,\n     * i.e. socket 0.  Similarly when the file does not exist. */\n    if (tmp < 0)\n        tmp = 0;\n\n    *socket = tmp;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileReadValueInt",
          "args": [
            "&tmp",
            "\"%s/cpu/cpu%u/topology/physical_package_id\"",
            "SYSFS_SYSTEM_PATH",
            "cpu"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4077-4104",
          "snippet": "int\nvirFileReadValueInt(int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_i(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueInt(int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_i(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetSocket(unsigned int cpu, unsigned int *socket)\n{\n    int tmp;\n    int ret = virFileReadValueInt(&tmp,\n                                  \"%s/cpu/cpu%u/topology/physical_package_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        tmp = 0;\n    else if (ret < 0)\n        return -1;\n\n    /* Some architectures might have '-1' validly in the file, but that actually\n     * means there are no sockets, so from our point of view it's all one socket,\n     * i.e. socket 0.  Similarly when the file does not exist. */\n    if (tmp < 0)\n        tmp = 0;\n\n    *socket = tmp;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostCPUGetStatsFreeBSD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "84-179",
    "snippet": "static int\nvirHostCPUGetStatsFreeBSD(int cpuNum,\n                          virNodeCPUStatsPtr params,\n                          int *nparams)\n{\n    const char *sysctl_name;\n    long *cpu_times;\n    struct clockinfo clkinfo;\n    size_t i, j, cpu_times_size, clkinfo_size;\n    int cpu_times_num, offset, hz, stathz, ret = -1;\n    struct field_cpu_map {\n        const char *field;\n        int idx[CPUSTATES];\n    } cpu_map[] = {\n        {VIR_NODE_CPU_STATS_KERNEL, {CP_SYS}},\n        {VIR_NODE_CPU_STATS_USER, {CP_USER, CP_NICE}},\n        {VIR_NODE_CPU_STATS_IDLE, {CP_IDLE}},\n        {VIR_NODE_CPU_STATS_INTR, {CP_INTR}},\n        {NULL, {0}}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_CPU_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_CPU_STATS_ALL) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, BSD_CPU_STATS_ALL);\n        return -1;\n    }\n\n    clkinfo_size = sizeof(clkinfo);\n    if (sysctlbyname(\"kern.clockrate\", &clkinfo, &clkinfo_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             \"kern.clockrate\");\n        return -1;\n    }\n\n    stathz = clkinfo.stathz;\n    hz = clkinfo.hz;\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        sysctl_name = \"kern.cp_time\";\n        cpu_times_num = 1;\n        offset = 0;\n    } else {\n        sysctl_name = \"kern.cp_times\";\n        cpu_times_num = virHostCPUGetCountAppleFreeBSD();\n\n        if (cpuNum >= cpu_times_num) {\n            virReportInvalidArg(cpuNum,\n                                _(\"Invalid cpuNum in %s\"),\n                                __FUNCTION__);\n            return -1;\n        }\n\n        offset = cpu_times_num * CPUSTATES;\n    }\n\n    cpu_times_size = sizeof(long) * cpu_times_num * CPUSTATES;\n\n    if (VIR_ALLOC_N(cpu_times, cpu_times_num * CPUSTATES) < 0)\n        goto cleanup;\n\n    if (sysctlbyname(sysctl_name, cpu_times, &cpu_times_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             sysctl_name);\n        goto cleanup;\n    }\n\n    for (i = 0; cpu_map[i].field != NULL; i++) {\n        virNodeCPUStatsPtr param = &params[i];\n\n        if (virStrcpyStatic(param->field, cpu_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           cpu_map[i].field);\n            goto cleanup;\n        }\n\n        param->value = 0;\n        for (j = 0; j < G_N_ELEMENTS(cpu_map[i].idx); j++)\n            param->value += cpu_times[offset + cpu_map[i].idx[j]] * TICK_TO_NSEC;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpu_times);\n\n    return ret;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpu_times"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "cpu_map[i].idx"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Field '%s' too long for destination\")",
            "cpu_map[i].field"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Field '%s' too long for destination\""
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "param->field",
            "cpu_map[i].field"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"sysctl failed for '%s'\")",
            "sysctl_name"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "sysctl_name",
            "cpu_times",
            "&cpu_times_size",
            "NULL",
            "0"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpu_times",
            "cpu_times_num * CPUSTATES"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "cpuNum",
            "_(\"Invalid cpuNum in %s\")",
            "__FUNCTION__"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCountAppleFreeBSD",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCountAppleFreeBSD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "62-75",
          "snippet": "static int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"sysctl failed for '%s'\")",
            "\"kern.clockrate\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"kern.clockrate\"",
            "&clkinfo",
            "&clkinfo_size",
            "NULL",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportInvalidArg",
          "args": [
            "*nparams",
            "_(\"nparams in %s must be equal to %d\")",
            "__FUNCTION__",
            "BSD_CPU_STATS_ALL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUGetStatsFreeBSD(int cpuNum,\n                          virNodeCPUStatsPtr params,\n                          int *nparams)\n{\n    const char *sysctl_name;\n    long *cpu_times;\n    struct clockinfo clkinfo;\n    size_t i, j, cpu_times_size, clkinfo_size;\n    int cpu_times_num, offset, hz, stathz, ret = -1;\n    struct field_cpu_map {\n        const char *field;\n        int idx[CPUSTATES];\n    } cpu_map[] = {\n        {VIR_NODE_CPU_STATS_KERNEL, {CP_SYS}},\n        {VIR_NODE_CPU_STATS_USER, {CP_USER, CP_NICE}},\n        {VIR_NODE_CPU_STATS_IDLE, {CP_IDLE}},\n        {VIR_NODE_CPU_STATS_INTR, {CP_INTR}},\n        {NULL, {0}}\n    };\n\n    if ((*nparams) == 0) {\n        *nparams = BSD_CPU_STATS_ALL;\n        return 0;\n    }\n\n    if ((*nparams) != BSD_CPU_STATS_ALL) {\n        virReportInvalidArg(*nparams,\n                            _(\"nparams in %s must be equal to %d\"),\n                            __FUNCTION__, BSD_CPU_STATS_ALL);\n        return -1;\n    }\n\n    clkinfo_size = sizeof(clkinfo);\n    if (sysctlbyname(\"kern.clockrate\", &clkinfo, &clkinfo_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             \"kern.clockrate\");\n        return -1;\n    }\n\n    stathz = clkinfo.stathz;\n    hz = clkinfo.hz;\n\n    if (cpuNum == VIR_NODE_CPU_STATS_ALL_CPUS) {\n        sysctl_name = \"kern.cp_time\";\n        cpu_times_num = 1;\n        offset = 0;\n    } else {\n        sysctl_name = \"kern.cp_times\";\n        cpu_times_num = virHostCPUGetCountAppleFreeBSD();\n\n        if (cpuNum >= cpu_times_num) {\n            virReportInvalidArg(cpuNum,\n                                _(\"Invalid cpuNum in %s\"),\n                                __FUNCTION__);\n            return -1;\n        }\n\n        offset = cpu_times_num * CPUSTATES;\n    }\n\n    cpu_times_size = sizeof(long) * cpu_times_num * CPUSTATES;\n\n    if (VIR_ALLOC_N(cpu_times, cpu_times_num * CPUSTATES) < 0)\n        goto cleanup;\n\n    if (sysctlbyname(sysctl_name, cpu_times, &cpu_times_size, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"sysctl failed for '%s'\"),\n                             sysctl_name);\n        goto cleanup;\n    }\n\n    for (i = 0; cpu_map[i].field != NULL; i++) {\n        virNodeCPUStatsPtr param = &params[i];\n\n        if (virStrcpyStatic(param->field, cpu_map[i].field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field '%s' too long for destination\"),\n                           cpu_map[i].field);\n            goto cleanup;\n        }\n\n        param->value = 0;\n        for (j = 0; j < G_N_ELEMENTS(cpu_map[i].idx); j++)\n            param->value += cpu_times[offset + cpu_map[i].idx[j]] * TICK_TO_NSEC;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpu_times);\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostCPUGetCountAppleFreeBSD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
    "lines": "62-75",
    "snippet": "static int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"virnuma.h\"",
      "#include \"virstring.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virfile.h\"",
      "#include \"virarch.h\"",
      "#include \"virerror.h\"",
      "#include \"virhostcpupriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/resource.h>",
      "# include <sys/sysctl.h>",
      "# include <sys/types.h>",
      "# include <sys/time.h>",
      "# include <linux/kvm.h>",
      "#include <unistd.h>",
      "# include <sys/ioctl.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot obtain CPU count\")"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot obtain CPU count\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "296-459",
          "snippet": "static int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3)\nATTRIBUTE_NONNULL(4) ATTRIBUTE_NONNULL(6)\nATTRIBUTE_NONNULL(7) ATTRIBUTE_NONNULL(8)\nATTRIBUTE_NONNULL(9)\nvirHostCPUParseNode(const char *node,\n                    virArch arch,\n                    virBitmapPtr present_cpus_map,\n                    virBitmapPtr online_cpus_map,\n                    int threads_per_subcore,\n                    int *sockets,\n                    int *cores,\n                    int *threads,\n                    int *offline)\n{\n    int ret = -1;\n    int processors = 0;\n    DIR *cpudir = NULL;\n    struct dirent *cpudirent = NULL;\n    virBitmapPtr node_cpus_map = NULL;\n    virBitmapPtr sockets_map = NULL;\n    virBitmapPtr *cores_maps = NULL;\n    int npresent_cpus = virBitmapSize(present_cpus_map);\n    unsigned int sock_max = 0;\n    unsigned int sock;\n    unsigned int core;\n    size_t i;\n    int siblings;\n    unsigned int cpu;\n    int direrr;\n\n    *threads = 0;\n    *cores = 0;\n    *sockets = 0;\n\n    if (virDirOpen(&cpudir, node) < 0)\n        goto cleanup;\n\n    /* Keep track of the CPUs that belong to the current node */\n    if (!(node_cpus_map = virBitmapNew(npresent_cpus)))\n        goto cleanup;\n\n    /* enumerate sockets in the node */\n    sockets_map = virBitmapNewEmpty();\n\n    while ((direrr = virDirRead(cpudir, &cpudirent, node)) > 0) {\n        if (sscanf(cpudirent->d_name, \"cpu%u\", &cpu) != 1)\n            continue;\n\n        if (!virBitmapIsBitSet(present_cpus_map, cpu))\n            continue;\n\n        /* Mark this CPU as part of the current node */\n        if (virBitmapSetBit(node_cpus_map, cpu) < 0)\n            goto cleanup;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu))\n            continue;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n\n        if (virBitmapSetBitExpand(sockets_map, sock) < 0)\n            goto cleanup;\n\n        if (sock > sock_max)\n            sock_max = sock;\n    }\n\n    if (direrr < 0)\n        goto cleanup;\n\n    sock_max++;\n\n    /* allocate cores maps for each socket */\n    if (VIR_ALLOC_N(cores_maps, sock_max) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sock_max; i++)\n        cores_maps[i] = virBitmapNewEmpty();\n\n    /* Iterate over all CPUs in the node, in ascending order */\n    for (cpu = 0; cpu < npresent_cpus; cpu++) {\n\n        /* Skip CPUs that are not part of the current node */\n        if (!virBitmapIsBitSet(node_cpus_map, cpu))\n            continue;\n\n        if (!virBitmapIsBitSet(online_cpus_map, cpu)) {\n            if (threads_per_subcore > 0 &&\n                cpu % threads_per_subcore != 0 &&\n                virBitmapIsBitSet(online_cpus_map,\n                                  cpu - (cpu % threads_per_subcore))) {\n                /* Secondary offline threads are counted as online when\n                 * subcores are in use and the corresponding primary\n                 * thread is online */\n                processors++;\n            } else {\n                /* But they are counted as offline otherwise */\n                (*offline)++;\n            }\n            continue;\n        }\n\n        processors++;\n\n        if (virHostCPUGetSocket(cpu, &sock) < 0)\n            goto cleanup;\n        if (!virBitmapIsBitSet(sockets_map, sock)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"CPU socket topology has changed\"));\n            goto cleanup;\n        }\n\n        /* Parse core */\n        if (ARCH_IS_S390(arch)) {\n            /* logical cpu is equivalent to a core on s390 */\n            core = cpu;\n        } else {\n            if (virHostCPUGetCore(cpu, &core) < 0)\n                goto cleanup;\n        }\n\n        if (virBitmapSetBitExpand(cores_maps[sock], core) < 0)\n            goto cleanup;\n\n        if (!(siblings = virHostCPUCountThreadSiblings(cpu)))\n            goto cleanup;\n\n        if (siblings > *threads)\n            *threads = siblings;\n    }\n\n    /* finalize the returned data */\n    *sockets = virBitmapCountBits(sockets_map);\n\n    for (i = 0; i < sock_max; i++) {\n        if (!virBitmapIsBitSet(sockets_map, i))\n            continue;\n\n        core = virBitmapCountBits(cores_maps[i]);\n        if (core > *cores)\n            *cores = core;\n    }\n\n    if (threads_per_subcore > 0) {\n        /* The thread count ignores offline threads, which means that only\n         * only primary threads have been considered so far. If subcores\n         * are in use, we need to also account for secondary threads */\n        *threads *= threads_per_subcore;\n    }\n    ret = processors;\n\n cleanup:\n    VIR_DIR_CLOSE(cpudir);\n    if (cores_maps)\n        for (i = 0; i < sock_max; i++)\n            virBitmapFree(cores_maps[i]);\n    VIR_FREE(cores_maps);\n    virBitmapFree(sockets_map);\n    virBitmapFree(node_cpus_map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctl",
          "args": [
            "ncpu_mib",
            "2",
            "&ncpu",
            "&ncpu_len",
            "NULL",
            "0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirHostCPUGetCountAppleFreeBSD(void)\n{\n    int ncpu_mib[2] = { CTL_HW, HW_NCPU };\n    unsigned long ncpu;\n    size_t ncpu_len = sizeof(ncpu);\n\n    if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_len, NULL, 0) == -1) {\n        virReportSystemError(errno, \"%s\", _(\"Cannot obtain CPU count\"));\n        return -1;\n    }\n\n    return ncpu;\n}"
  }
]