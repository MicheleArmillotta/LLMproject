[
  {
    "function_name": "qemuVirtioFSPrepareDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "330-338",
    "snippet": "int\nqemuVirtioFSPrepareDomain(virQEMUDriverPtr driver,\n                          virDomainFSDefPtr fs)\n{\n    if (fs->binary)\n        return 0;\n\n    return qemuVhostUserFillDomainFS(driver, fs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuVhostUserFillDomainFS",
          "args": [
            "driver",
            "fs"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVhostUserFillDomainFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user.c",
          "lines": "421-457",
          "snippet": "int\nqemuVhostUserFillDomainFS(virQEMUDriverPtr driver,\n                          virDomainFSDefPtr fs)\n{\n    qemuVhostUserPtr *vus = NULL;\n    ssize_t nvus = 0;\n    ssize_t i;\n    int ret = -1;\n\n    if ((nvus = qemuVhostUserFetchParsedConfigs(driver->privileged,\n                                                &vus, NULL)) < 0)\n        goto end;\n\n    for (i = 0; i < nvus; i++) {\n        qemuVhostUserPtr vu = vus[i];\n\n        if (vu->type != QEMU_VHOST_USER_TYPE_FS)\n            continue;\n\n        fs->binary = g_strdup(vu->binary);\n        break;\n    }\n\n    if (i == nvus) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unable to find a satisfying virtiofsd\"));\n        goto end;\n    }\n\n    ret = 0;\n\n end:\n    for (i = 0; i < nvus; i++)\n        qemuVhostUserFree(vus[i]);\n    g_free(vus);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_vhost_user.h\"\n#include <config.h>\n\nint\nqemuVhostUserFillDomainFS(virQEMUDriverPtr driver,\n                          virDomainFSDefPtr fs)\n{\n    qemuVhostUserPtr *vus = NULL;\n    ssize_t nvus = 0;\n    ssize_t i;\n    int ret = -1;\n\n    if ((nvus = qemuVhostUserFetchParsedConfigs(driver->privileged,\n                                                &vus, NULL)) < 0)\n        goto end;\n\n    for (i = 0; i < nvus; i++) {\n        qemuVhostUserPtr vu = vus[i];\n\n        if (vu->type != QEMU_VHOST_USER_TYPE_FS)\n            continue;\n\n        fs->binary = g_strdup(vu->binary);\n        break;\n    }\n\n    if (i == nvus) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Unable to find a satisfying virtiofsd\"));\n        goto end;\n    }\n\n    ret = 0;\n\n end:\n    for (i = 0; i < nvus; i++)\n        qemuVhostUserFree(vus[i]);\n    g_free(vus);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuVirtioFSPrepareDomain(virQEMUDriverPtr driver,\n                          virDomainFSDefPtr fs)\n{\n    if (fs->binary)\n        return 0;\n\n    return qemuVhostUserFillDomainFS(driver, fs);\n}"
  },
  {
    "function_name": "qemuVirtioFSSetupCgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "305-328",
    "snippet": "int\nqemuVirtioFSSetupCgroup(virDomainObjPtr vm,\n                        virDomainFSDefPtr fs,\n                        virCgroupPtr cgroup)\n{\n    g_autofree char *pidfile = NULL;\n    pid_t pid = -1;\n    int rc;\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        return -1;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc < 0 || pid == (pid_t) -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virtiofsd died unexpectedly\"));\n        return -1;\n    }\n\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCgroupAddProcess",
          "args": [
            "cgroup",
            "pid"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupAddProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2919-2926",
          "snippet": "int\nvirCgroupAddProcess(virCgroupPtr group G_GNUC_UNUSED,\n                    pid_t pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupAddProcess(virCgroupPtr group G_GNUC_UNUSED,\n                    pid_t pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virtiofsd died unexpectedly\")"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virtiofsd died unexpectedly\""
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileReadPathIfAlive",
          "args": [
            "pidfile",
            "&pid",
            "NULL"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSCreatePidFilename",
          "args": [
            "vm",
            "fs->info.alias"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "40-54",
          "snippet": "char *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuVirtioFSSetupCgroup(virDomainObjPtr vm,\n                        virDomainFSDefPtr fs,\n                        virCgroupPtr cgroup)\n{\n    g_autofree char *pidfile = NULL;\n    pid_t pid = -1;\n    int rc;\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        return -1;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc < 0 || pid == (pid_t) -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virtiofsd died unexpectedly\"));\n        return -1;\n    }\n\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuVirtioFSStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "271-302",
    "snippet": "void\nqemuVirtioFSStop(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                    virDomainObjPtr vm,\n                    virDomainFSDefPtr fs)\n{\n    g_autofree char *pidfile = NULL;\n    virErrorPtr orig_err;\n    pid_t pid = -1;\n    int rc;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n\n    if (QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock)\n        unlink(QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_FS_PRIVATE",
          "args": [
            "fs"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_FS_PRIVATE",
          "args": [
            "fs"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to remove stale pidfile %s\")",
            "pidfile"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to remove stale pidfile %s\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pidfile"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "pid",
            "true"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileReadPathIfAlive",
          "args": [
            "pidfile",
            "&pid",
            "NULL"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSCreatePidFilename",
          "args": [
            "vm",
            "fs->info.alias"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "40-54",
          "snippet": "char *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nqemuVirtioFSStop(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                    virDomainObjPtr vm,\n                    virDomainFSDefPtr fs)\n{\n    g_autofree char *pidfile = NULL;\n    virErrorPtr orig_err;\n    pid_t pid = -1;\n    int rc;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n\n    if (QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock)\n        unlink(QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}"
  },
  {
    "function_name": "qemuVirtioFSStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "159-268",
    "snippet": "int\nqemuVirtioFSStart(virLogManagerPtr logManager,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  virDomainFSDefPtr fs)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *socket_path = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *logpath = NULL;\n    pid_t pid = (pid_t) -1;\n    VIR_AUTOCLOSE fd = -1;\n    VIR_AUTOCLOSE logfd = -1;\n    int ret = -1;\n    int rc;\n\n    if (!virFileExists(fs->src->path)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"the virtiofs export directory '%s' does not exist\"),\n                       fs->src->path);\n        return -1;\n    }\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if (!(socket_path = qemuVirtioFSCreateSocketFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if ((fd = qemuVirtioFSOpenChardev(driver, vm, socket_path)) < 0)\n        goto cleanup;\n\n    logpath = qemuVirtioFSCreateLogFilename(cfg, vm->def, fs->info.alias);\n\n    if (cfg->stdioLogD) {\n        if ((logfd = virLogManagerDomainOpenLogFile(logManager,\n                                                    \"qemu\",\n                                                    vm->def->uuid,\n                                                    vm->def->name,\n                                                    logpath,\n                                                    0,\n                                                    NULL, NULL)) < 0)\n            goto cleanup;\n    } else {\n        if ((logfd = open(logpath, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 logpath);\n            goto cleanup;\n        }\n        if (virSetCloseExec(logfd) < 0) {\n            virReportSystemError(errno, _(\"failed to set close-on-exec flag on %s\"),\n                                 logpath);\n            goto error;\n        }\n    }\n\n    if (!(cmd = qemuVirtioFSBuildCommandLine(cfg, fs, &fd)))\n        goto cleanup;\n\n    /* so far only running as root is supported */\n    virCommandSetUID(cmd, 0);\n    virCommandSetGID(cmd, 0);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandNonblockingFDs(cmd);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"virtiofsd\") < 0)\n        goto cleanup;\n\n    rc = virCommandRun(cmd, NULL);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not start 'virtiofsd'\"));\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read virtiofsd pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (virProcessKill(pid, 0) != 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"virtiofsd died unexpectedly\"));\n        goto error;\n    }\n\n    QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock = g_steal_pointer(&socket_path);\n    ret = 0;\n\n cleanup:\n    if (socket_path)\n        unlink(socket_path);\n    return ret;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pidfile"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "pid",
            "true"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "socket_path"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&socket_path"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_FS_PRIVATE",
          "args": [
            "fs"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"virtiofsd died unexpectedly\")"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virtiofsd died unexpectedly\""
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rc",
            "_(\"Unable to read virtiofsd pidfile '%s'\")",
            "pidfile"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "pidfile",
            "&pid"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not start 'virtiofsd'\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtDeviceLogCommand",
          "args": [
            "driver",
            "vm",
            "cmd",
            "\"virtiofsd\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtDeviceLogCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
          "lines": "42-57",
          "snippet": "int\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtpm.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNonblockingFDs",
          "args": [
            "cmd"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNonblockingFDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1279-1286",
          "snippet": "void\nvirCommandNonblockingFDs(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_NONBLOCK;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandNonblockingFDs(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_NONBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorFD",
          "args": [
            "cmd",
            "&logfd"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1984-1997",
          "snippet": "void\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputFD",
          "args": [
            "cmd",
            "&logfd"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1958-1971",
          "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetPidFile",
          "args": [
            "cmd",
            "pidfile"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1086-1094",
          "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetGID",
          "args": [
            "cmd",
            "0"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetGID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1111-1118",
          "snippet": "void\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetUID",
          "args": [
            "cmd",
            "0"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1120-1127",
          "snippet": "void\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSBuildCommandLine",
          "args": [
            "cfg",
            "fs",
            "&fd"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSBuildCommandLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "116-157",
          "snippet": "static virCommandPtr\nqemuVirtioFSBuildCommandLine(virQEMUDriverConfigPtr cfg,\n                             virDomainFSDefPtr fs,\n                             int *fd)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_auto(virBuffer) opts = VIR_BUFFER_INITIALIZER;\n\n    if (!(cmd = virCommandNew(fs->binary)))\n        return NULL;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", *fd);\n    virCommandPassFD(cmd, *fd, VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    *fd = -1;\n\n    virCommandAddArg(cmd, \"-o\");\n    virBufferAddLit(&opts, \"source=\");\n    virQEMUBuildBufferEscapeComma(&opts, fs->src->path);\n    if (fs->cache)\n        virBufferAsprintf(&opts, \",cache=%s\", virDomainFSCacheModeTypeToString(fs->cache));\n\n    if (fs->xattr == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",xattr\");\n    else if (fs->xattr == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_xattr\");\n\n    if (fs->flock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",flock\");\n    else if (fs->flock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_flock\");\n\n    if (fs->posix_lock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",posix_lock\");\n    else if (fs->posix_lock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_posix_lock\");\n\n    virCommandAddArgBuffer(cmd, &opts);\n    if (cfg->virtiofsdDebug)\n        virCommandAddArg(cmd, \"-d\");\n\n    return g_steal_pointer(&cmd);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virCommandPtr\nqemuVirtioFSBuildCommandLine(virQEMUDriverConfigPtr cfg,\n                             virDomainFSDefPtr fs,\n                             int *fd)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_auto(virBuffer) opts = VIR_BUFFER_INITIALIZER;\n\n    if (!(cmd = virCommandNew(fs->binary)))\n        return NULL;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", *fd);\n    virCommandPassFD(cmd, *fd, VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    *fd = -1;\n\n    virCommandAddArg(cmd, \"-o\");\n    virBufferAddLit(&opts, \"source=\");\n    virQEMUBuildBufferEscapeComma(&opts, fs->src->path);\n    if (fs->cache)\n        virBufferAsprintf(&opts, \",cache=%s\", virDomainFSCacheModeTypeToString(fs->cache));\n\n    if (fs->xattr == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",xattr\");\n    else if (fs->xattr == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_xattr\");\n\n    if (fs->flock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",flock\");\n    else if (fs->flock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_flock\");\n\n    if (fs->posix_lock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",posix_lock\");\n    else if (fs->posix_lock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_posix_lock\");\n\n    virCommandAddArgBuffer(cmd, &opts);\n    if (cfg->virtiofsdDebug)\n        virCommandAddArg(cmd, \"-d\");\n\n    return g_steal_pointer(&cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to set close-on-exec flag on %s\")",
            "logpath"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "logfd"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to create logfile %s\")",
            "logpath"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "logpath",
            "O_WRONLY | O_CREAT | O_APPEND",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogManagerDomainOpenLogFile",
          "args": [
            "logManager",
            "\"qemu\"",
            "vm->def->uuid",
            "vm->def->name",
            "logpath",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "virLogManagerDomainOpenLogFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
          "lines": "145-204",
          "snippet": "int\nvirLogManagerDomainOpenLogFile(virLogManagerPtr mgr,\n                               const char *driver,\n                               const unsigned char *domuuid,\n                               const char *domname,\n                               const char *path,\n                               unsigned int flags,\n                               ino_t *inode,\n                               off_t *offset)\n{\n    struct virLogManagerProtocolDomainOpenLogFileArgs args;\n    struct virLogManagerProtocolDomainOpenLogFileRet ret;\n    int *fdout = NULL;\n    size_t fdoutlen = 0;\n    int rv = -1;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.driver = (char *)driver;\n    memcpy(args.dom.uuid, domuuid, VIR_UUID_BUFLEN);\n    args.dom.name = (char *)domname;\n    args.path = (char *)path;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_OPEN_LOG_FILE,\n                                0, NULL, &fdoutlen, &fdout,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileRet, &ret) < 0)\n        goto cleanup;\n\n    if (fdoutlen != 1) {\n        if (fdoutlen) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"too many file descriptors received\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no file descriptor received\"));\n        }\n        goto cleanup;\n    }\n\n    if (inode)\n        *inode = ret.pos.inode;\n    if (offset)\n        *offset = ret.pos.offset;\n\n    rv = fdout[0];\n cleanup:\n    if (rv < 0) {\n        while (fdoutlen)\n            VIR_FORCE_CLOSE(fdout[--fdoutlen]);\n    }\n    VIR_FREE(fdout);\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nint\nvirLogManagerDomainOpenLogFile(virLogManagerPtr mgr,\n                               const char *driver,\n                               const unsigned char *domuuid,\n                               const char *domname,\n                               const char *path,\n                               unsigned int flags,\n                               ino_t *inode,\n                               off_t *offset)\n{\n    struct virLogManagerProtocolDomainOpenLogFileArgs args;\n    struct virLogManagerProtocolDomainOpenLogFileRet ret;\n    int *fdout = NULL;\n    size_t fdoutlen = 0;\n    int rv = -1;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.driver = (char *)driver;\n    memcpy(args.dom.uuid, domuuid, VIR_UUID_BUFLEN);\n    args.dom.name = (char *)domname;\n    args.path = (char *)path;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_OPEN_LOG_FILE,\n                                0, NULL, &fdoutlen, &fdout,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileRet, &ret) < 0)\n        goto cleanup;\n\n    if (fdoutlen != 1) {\n        if (fdoutlen) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"too many file descriptors received\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no file descriptor received\"));\n        }\n        goto cleanup;\n    }\n\n    if (inode)\n        *inode = ret.pos.inode;\n    if (offset)\n        *offset = ret.pos.offset;\n\n    rv = fdout[0];\n cleanup:\n    if (rv < 0) {\n        while (fdoutlen)\n            VIR_FORCE_CLOSE(fdout[--fdoutlen]);\n    }\n    VIR_FREE(fdout);\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSCreateLogFilename",
          "args": [
            "cfg",
            "vm->def",
            "fs->info.alias"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSCreateLogFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "67-77",
          "snippet": "static char *\nqemuVirtioFSCreateLogFilename(virQEMUDriverConfigPtr cfg,\n                              const virDomainDef *def,\n                              const char *alias)\n{\n    g_autofree char *name = NULL;\n\n    name = g_strdup_printf(\"%s-%s\", def->name, alias);\n\n    return virFileBuildPath(cfg->logDir, name, \"-virtiofsd.log\");\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nqemuVirtioFSCreateLogFilename(virQEMUDriverConfigPtr cfg,\n                              const virDomainDef *def,\n                              const char *alias)\n{\n    g_autofree char *name = NULL;\n\n    name = g_strdup_printf(\"%s-%s\", def->name, alias);\n\n    return virFileBuildPath(cfg->logDir, name, \"-virtiofsd.log\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSOpenChardev",
          "args": [
            "driver",
            "vm",
            "socket_path"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSOpenChardev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "80-113",
          "snippet": "static int\nqemuVirtioFSOpenChardev(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        const char *socket_path)\n{\n    virDomainChrSourceDefPtr chrdev = virDomainChrSourceDefNew(NULL);\n    virDomainChrDef chr = { .source = chrdev };\n    VIR_AUTOCLOSE fd = -1;\n    int ret = -1;\n\n    chrdev->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    chrdev->data.nix.listen = true;\n    chrdev->data.nix.path = g_strdup(socket_path);\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n    fd = qemuOpenChrChardevUNIXSocket(chrdev);\n    if (fd < 0) {\n        ignore_value(qemuSecurityClearSocketLabel(driver->securityManager, vm->def));\n        goto cleanup;\n    }\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (qemuSecuritySetChardevLabel(driver, vm, &chr) < 0)\n        goto cleanup;\n\n    ret = fd;\n    fd = -1;\n\n cleanup:\n    virObjectUnref(chrdev);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nqemuVirtioFSOpenChardev(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        const char *socket_path)\n{\n    virDomainChrSourceDefPtr chrdev = virDomainChrSourceDefNew(NULL);\n    virDomainChrDef chr = { .source = chrdev };\n    VIR_AUTOCLOSE fd = -1;\n    int ret = -1;\n\n    chrdev->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    chrdev->data.nix.listen = true;\n    chrdev->data.nix.path = g_strdup(socket_path);\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n    fd = qemuOpenChrChardevUNIXSocket(chrdev);\n    if (fd < 0) {\n        ignore_value(qemuSecurityClearSocketLabel(driver->securityManager, vm->def));\n        goto cleanup;\n    }\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (qemuSecuritySetChardevLabel(driver, vm, &chr) < 0)\n        goto cleanup;\n\n    ret = fd;\n    fd = -1;\n\n cleanup:\n    virObjectUnref(chrdev);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSCreateSocketFilename",
          "args": [
            "vm",
            "fs->info.alias"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSCreateSocketFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "57-64",
          "snippet": "char *\nqemuVirtioFSCreateSocketFilename(virDomainObjPtr vm,\n                                 const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    return virFileBuildPath(priv->libDir, alias, \"-virtiofsd.sock\");\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nqemuVirtioFSCreateSocketFilename(virDomainObjPtr vm,\n                                 const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    return virFileBuildPath(priv->libDir, alias, \"-virtiofsd.sock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuVirtioFSCreatePidFilename",
          "args": [
            "vm",
            "fs->info.alias"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "40-54",
          "snippet": "char *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"the virtiofs export directory '%s' does not exist\")",
            "fs->src->path"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "fs->src->path"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuVirtioFSStart(virLogManagerPtr logManager,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  virDomainFSDefPtr fs)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *socket_path = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *logpath = NULL;\n    pid_t pid = (pid_t) -1;\n    VIR_AUTOCLOSE fd = -1;\n    VIR_AUTOCLOSE logfd = -1;\n    int ret = -1;\n    int rc;\n\n    if (!virFileExists(fs->src->path)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"the virtiofs export directory '%s' does not exist\"),\n                       fs->src->path);\n        return -1;\n    }\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if (!(socket_path = qemuVirtioFSCreateSocketFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if ((fd = qemuVirtioFSOpenChardev(driver, vm, socket_path)) < 0)\n        goto cleanup;\n\n    logpath = qemuVirtioFSCreateLogFilename(cfg, vm->def, fs->info.alias);\n\n    if (cfg->stdioLogD) {\n        if ((logfd = virLogManagerDomainOpenLogFile(logManager,\n                                                    \"qemu\",\n                                                    vm->def->uuid,\n                                                    vm->def->name,\n                                                    logpath,\n                                                    0,\n                                                    NULL, NULL)) < 0)\n            goto cleanup;\n    } else {\n        if ((logfd = open(logpath, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 logpath);\n            goto cleanup;\n        }\n        if (virSetCloseExec(logfd) < 0) {\n            virReportSystemError(errno, _(\"failed to set close-on-exec flag on %s\"),\n                                 logpath);\n            goto error;\n        }\n    }\n\n    if (!(cmd = qemuVirtioFSBuildCommandLine(cfg, fs, &fd)))\n        goto cleanup;\n\n    /* so far only running as root is supported */\n    virCommandSetUID(cmd, 0);\n    virCommandSetGID(cmd, 0);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandNonblockingFDs(cmd);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"virtiofsd\") < 0)\n        goto cleanup;\n\n    rc = virCommandRun(cmd, NULL);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not start 'virtiofsd'\"));\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read virtiofsd pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (virProcessKill(pid, 0) != 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"virtiofsd died unexpectedly\"));\n        goto error;\n    }\n\n    QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock = g_steal_pointer(&socket_path);\n    ret = 0;\n\n cleanup:\n    if (socket_path)\n        unlink(socket_path);\n    return ret;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuVirtioFSBuildCommandLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "116-157",
    "snippet": "static virCommandPtr\nqemuVirtioFSBuildCommandLine(virQEMUDriverConfigPtr cfg,\n                             virDomainFSDefPtr fs,\n                             int *fd)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_auto(virBuffer) opts = VIR_BUFFER_INITIALIZER;\n\n    if (!(cmd = virCommandNew(fs->binary)))\n        return NULL;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", *fd);\n    virCommandPassFD(cmd, *fd, VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    *fd = -1;\n\n    virCommandAddArg(cmd, \"-o\");\n    virBufferAddLit(&opts, \"source=\");\n    virQEMUBuildBufferEscapeComma(&opts, fs->src->path);\n    if (fs->cache)\n        virBufferAsprintf(&opts, \",cache=%s\", virDomainFSCacheModeTypeToString(fs->cache));\n\n    if (fs->xattr == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",xattr\");\n    else if (fs->xattr == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_xattr\");\n\n    if (fs->flock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",flock\");\n    else if (fs->flock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_flock\");\n\n    if (fs->posix_lock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",posix_lock\");\n    else if (fs->posix_lock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_posix_lock\");\n\n    virCommandAddArgBuffer(cmd, &opts);\n    if (cfg->virtiofsdDebug)\n        virCommandAddArg(cmd, \"-d\");\n\n    return g_steal_pointer(&cmd);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cmd"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"-d\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgBuffer",
          "args": [
            "cmd",
            "&opts"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1539-1558",
          "snippet": "void\nvirCommandAddArgBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    cmd->args[cmd->nargs] = virBufferContentAndReset(buf);\n    if (!cmd->args[cmd->nargs])\n        cmd->args[cmd->nargs] = g_strdup(\"\");\n    cmd->nargs++;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    cmd->args[cmd->nargs] = virBufferContentAndReset(buf);\n    if (!cmd->args[cmd->nargs])\n        cmd->args[cmd->nargs] = g_strdup(\"\");\n    cmd->nargs++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\",no_posix_lock\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\",posix_lock\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\",no_flock\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\",flock\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\",no_xattr\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\",xattr\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&opts",
            "\",cache=%s\"",
            "virDomainFSCacheModeTypeToString(fs->cache)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainFSCacheModeTypeToString",
          "args": [
            "fs->cache"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUBuildBufferEscapeComma",
          "args": [
            "&opts",
            "fs->src->path"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildBufferEscapeComma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "293-297",
          "snippet": "void\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&opts",
            "\"source=\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandPassFD",
          "args": [
            "cmd",
            "*fd",
            "VIR_COMMAND_PASS_FD_CLOSE_PARENT"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1024-1049",
          "snippet": "void\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"--fd=%d\"",
            "*fd"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "fs->binary"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virCommandPtr\nqemuVirtioFSBuildCommandLine(virQEMUDriverConfigPtr cfg,\n                             virDomainFSDefPtr fs,\n                             int *fd)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_auto(virBuffer) opts = VIR_BUFFER_INITIALIZER;\n\n    if (!(cmd = virCommandNew(fs->binary)))\n        return NULL;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", *fd);\n    virCommandPassFD(cmd, *fd, VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    *fd = -1;\n\n    virCommandAddArg(cmd, \"-o\");\n    virBufferAddLit(&opts, \"source=\");\n    virQEMUBuildBufferEscapeComma(&opts, fs->src->path);\n    if (fs->cache)\n        virBufferAsprintf(&opts, \",cache=%s\", virDomainFSCacheModeTypeToString(fs->cache));\n\n    if (fs->xattr == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",xattr\");\n    else if (fs->xattr == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_xattr\");\n\n    if (fs->flock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",flock\");\n    else if (fs->flock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_flock\");\n\n    if (fs->posix_lock == VIR_TRISTATE_SWITCH_ON)\n        virBufferAddLit(&opts, \",posix_lock\");\n    else if (fs->posix_lock == VIR_TRISTATE_SWITCH_OFF)\n        virBufferAddLit(&opts, \",no_posix_lock\");\n\n    virCommandAddArgBuffer(cmd, &opts);\n    if (cfg->virtiofsdDebug)\n        virCommandAddArg(cmd, \"-d\");\n\n    return g_steal_pointer(&cmd);\n}"
  },
  {
    "function_name": "qemuVirtioFSOpenChardev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "80-113",
    "snippet": "static int\nqemuVirtioFSOpenChardev(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        const char *socket_path)\n{\n    virDomainChrSourceDefPtr chrdev = virDomainChrSourceDefNew(NULL);\n    virDomainChrDef chr = { .source = chrdev };\n    VIR_AUTOCLOSE fd = -1;\n    int ret = -1;\n\n    chrdev->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    chrdev->data.nix.listen = true;\n    chrdev->data.nix.path = g_strdup(socket_path);\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n    fd = qemuOpenChrChardevUNIXSocket(chrdev);\n    if (fd < 0) {\n        ignore_value(qemuSecurityClearSocketLabel(driver->securityManager, vm->def));\n        goto cleanup;\n    }\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (qemuSecuritySetChardevLabel(driver, vm, &chr) < 0)\n        goto cleanup;\n\n    ret = fd;\n    fd = -1;\n\n cleanup:\n    virObjectUnref(chrdev);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "chrdev"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetChardevLabel",
          "args": [
            "driver",
            "vm",
            "&chr"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSecuritySetChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_security.c",
          "lines": "378-407",
          "snippet": "int\nqemuSecuritySetChardevLabel(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            virDomainChrDefPtr chr)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    pid_t pid = -1;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT))\n        pid = vm->pid;\n\n    if (virSecurityManagerTransactionStart(driver->securityManager) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerSetChardevLabel(driver->securityManager,\n                                          vm->def,\n                                          chr->source,\n                                          priv->chardevStdioLogd) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerTransactionCommit(driver->securityManager,\n                                            pid, priv->rememberOwner) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecurityManagerTransactionAbort(driver->securityManager);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuSecuritySetChardevLabel(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            virDomainChrDefPtr chr)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    pid_t pid = -1;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT))\n        pid = vm->pid;\n\n    if (virSecurityManagerTransactionStart(driver->securityManager) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerSetChardevLabel(driver->securityManager,\n                                          vm->def,\n                                          chr->source,\n                                          priv->chardevStdioLogd) < 0)\n        goto cleanup;\n\n    if (virSecurityManagerTransactionCommit(driver->securityManager,\n                                            pid, priv->rememberOwner) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecurityManagerTransactionAbort(driver->securityManager);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecurityClearSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuSecurityClearSocketLabel(driver->securityManager, vm->def)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecurityClearSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuOpenChrChardevUNIXSocket",
          "args": [
            "chrdev"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "qemuOpenChrChardevUNIXSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_command.c",
          "lines": "5055-5109",
          "snippet": "int\nqemuOpenChrChardevUNIXSocket(const virDomainChrSourceDef *dev)\n{\n    struct sockaddr_un addr;\n    socklen_t addrlen = sizeof(addr);\n    int fd;\n\n    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create UNIX socket\"));\n        goto error;\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.sun_path, dev->data.nix.path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"UNIX socket path '%s' too long\"),\n                       dev->data.nix.path);\n        goto error;\n    }\n\n    if (unlink(dev->data.nix.path) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to unlink %s\"),\n                             dev->data.nix.path);\n        goto error;\n    }\n\n    if (bind(fd, (struct sockaddr *)&addr, addrlen) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to bind to UNIX socket path '%s'\"),\n                             dev->data.nix.path);\n        goto error;\n    }\n\n    if (listen(fd, 1) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to listen to UNIX socket path '%s'\"),\n                             dev->data.nix.path);\n        goto error;\n    }\n\n    /* We run QEMU with umask 0002. Compensate for the umask\n     * libvirtd might be running under to get the same permission\n     * QEMU would have. */\n    if (virFileUpdatePerm(dev->data.nix.path, 0002, 0664) < 0)\n        goto error;\n\n    return fd;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include \"virutil.h\"",
            "#include \"logging/log_manager.h\"",
            "# include <linux/capability.h>",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virgic.h\"",
            "#include \"virnuma.h\"",
            "#include \"virscsi.h\"",
            "#include \"virtpm.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"device_conf.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"secret_conf.h\"",
            "#include \"storage_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_addr.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/stat.h>\n#include \"virutil.h\"\n#include \"logging/log_manager.h\"\n# include <linux/capability.h>\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virgic.h\"\n#include \"virnuma.h\"\n#include \"virscsi.h\"\n#include \"virtpm.h\"\n#include \"virstoragefile.h\"\n#include \"device_conf.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"secret_conf.h\"\n#include \"storage_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_audit.h\"\n#include \"domain_addr.h\"\n#include \"domain_nwfilter.h\"\n#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virarch.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuOpenChrChardevUNIXSocket(const virDomainChrSourceDef *dev)\n{\n    struct sockaddr_un addr;\n    socklen_t addrlen = sizeof(addr);\n    int fd;\n\n    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create UNIX socket\"));\n        goto error;\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.sun_path, dev->data.nix.path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"UNIX socket path '%s' too long\"),\n                       dev->data.nix.path);\n        goto error;\n    }\n\n    if (unlink(dev->data.nix.path) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to unlink %s\"),\n                             dev->data.nix.path);\n        goto error;\n    }\n\n    if (bind(fd, (struct sockaddr *)&addr, addrlen) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to bind to UNIX socket path '%s'\"),\n                             dev->data.nix.path);\n        goto error;\n    }\n\n    if (listen(fd, 1) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to listen to UNIX socket path '%s'\"),\n                             dev->data.nix.path);\n        goto error;\n    }\n\n    /* We run QEMU with umask 0002. Compensate for the umask\n     * libvirtd might be running under to get the same permission\n     * QEMU would have. */\n    if (virFileUpdatePerm(dev->data.nix.path, 0002, 0664) < 0)\n        goto error;\n\n    return fd;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetDaemonSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "socket_path"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrSourceDefNew",
          "args": [
            "NULL"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrSourceDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13208-13226",
          "snippet": "virDomainChrSourceDefPtr\nvirDomainChrSourceDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrSourceDefPtr def = NULL;\n\n    if (virDomainChrSourceDefInitialize() < 0)\n        return NULL;\n\n    if (!(def = virObjectNew(virDomainChrSourceDefClass)))\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.chrSourceNew &&\n        !(def->privateData = xmlopt->privateData.chrSourceNew())) {\n        virObjectUnref(def);\n        def = NULL;\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainChrSourceDefClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainChrSourceDefClass;\n\nvirDomainChrSourceDefPtr\nvirDomainChrSourceDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrSourceDefPtr def = NULL;\n\n    if (virDomainChrSourceDefInitialize() < 0)\n        return NULL;\n\n    if (!(def = virObjectNew(virDomainChrSourceDefClass)))\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.chrSourceNew &&\n        !(def->privateData = xmlopt->privateData.chrSourceNew())) {\n        virObjectUnref(def);\n        def = NULL;\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nqemuVirtioFSOpenChardev(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        const char *socket_path)\n{\n    virDomainChrSourceDefPtr chrdev = virDomainChrSourceDefNew(NULL);\n    virDomainChrDef chr = { .source = chrdev };\n    VIR_AUTOCLOSE fd = -1;\n    int ret = -1;\n\n    chrdev->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    chrdev->data.nix.listen = true;\n    chrdev->data.nix.path = g_strdup(socket_path);\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n    fd = qemuOpenChrChardevUNIXSocket(chrdev);\n    if (fd < 0) {\n        ignore_value(qemuSecurityClearSocketLabel(driver->securityManager, vm->def));\n        goto cleanup;\n    }\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n\n    if (qemuSecuritySetChardevLabel(driver, vm, &chr) < 0)\n        goto cleanup;\n\n    ret = fd;\n    fd = -1;\n\n cleanup:\n    virObjectUnref(chrdev);\n    return ret;\n}"
  },
  {
    "function_name": "qemuVirtioFSCreateLogFilename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "67-77",
    "snippet": "static char *\nqemuVirtioFSCreateLogFilename(virQEMUDriverConfigPtr cfg,\n                              const virDomainDef *def,\n                              const char *alias)\n{\n    g_autofree char *name = NULL;\n\n    name = g_strdup_printf(\"%s-%s\", def->name, alias);\n\n    return virFileBuildPath(cfg->logDir, name, \"-virtiofsd.log\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileBuildPath",
          "args": [
            "cfg->logDir",
            "name",
            "\"-virtiofsd.log\""
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3116-3128",
          "snippet": "char *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s-%s\"",
            "def->name",
            "alias"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nqemuVirtioFSCreateLogFilename(virQEMUDriverConfigPtr cfg,\n                              const virDomainDef *def,\n                              const char *alias)\n{\n    g_autofree char *name = NULL;\n\n    name = g_strdup_printf(\"%s-%s\", def->name, alias);\n\n    return virFileBuildPath(cfg->logDir, name, \"-virtiofsd.log\");\n}"
  },
  {
    "function_name": "qemuVirtioFSCreateSocketFilename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "57-64",
    "snippet": "char *\nqemuVirtioFSCreateSocketFilename(virDomainObjPtr vm,\n                                 const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    return virFileBuildPath(priv->libDir, alias, \"-virtiofsd.sock\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileBuildPath",
          "args": [
            "priv->libDir",
            "alias",
            "\"-virtiofsd.sock\""
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "virFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3116-3128",
          "snippet": "char *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileBuildPath(const char *dir, const char *name, const char *ext)\n{\n    char *path;\n\n    if (ext == NULL) {\n        path = g_strdup_printf(\"%s/%s\", dir, name);\n    } else {\n        path = g_strdup_printf(\"%s/%s%s\", dir, name, ext);\n    }\n\n    return path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nqemuVirtioFSCreateSocketFilename(virDomainObjPtr vm,\n                                 const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    return virFileBuildPath(priv->libDir, alias, \"-virtiofsd.sock\");\n}"
  },
  {
    "function_name": "qemuVirtioFSCreatePidFilename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
    "lines": "40-54",
    "snippet": "char *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virqemu.h\"",
      "#include \"virpidfile.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_vhost_user.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_conf.h\"",
      "#include \"qemu_command.h\"",
      "#include \"virlog.h\"",
      "#include \"logging/log_manager.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "priv->libDir",
            "name"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s-%s-virtiofsd\"",
            "shortName",
            "alias"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "vm->def"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nqemuVirtioFSCreatePidFilename(virDomainObjPtr vm,\n                              const char *alias)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(vm->def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-virtiofsd\", shortName, alias);\n\n    return virPidFileBuildPath(priv->libDir, name);\n}"
  }
]