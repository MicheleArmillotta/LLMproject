[
  {
    "function_name": "virNetDevIPAddrFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "1115-1119",
    "snippet": "void\nvirNetDevIPAddrFree(virNetDevIPAddrPtr ip)\n{\n    VIR_FREE(ip);\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvoid\nvirNetDevIPAddrFree(virNetDevIPAddrPtr ip)\n{\n    VIR_FREE(ip);\n}"
  },
  {
    "function_name": "virNetDevIPInfoAddToDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "1071-1113",
    "snippet": "int\nvirNetDevIPInfoAddToDev(const char *ifname,\n                        virNetDevIPInfo const *ipInfo)\n{\n    size_t i;\n    int prefix;\n    g_autofree char *ipStr = NULL;\n\n    /* add all IP addresses */\n    for (i = 0; i < ipInfo->nips; i++) {\n        virNetDevIPAddrPtr ip = ipInfo->ips[i];\n\n        if ((prefix = virSocketAddrGetIPPrefix(&ip->address,\n                                               NULL, ip->prefix)) < 0) {\n            ipStr = virSocketAddrFormat(&ip->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for IP address '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPAddrAdd(ifname, &ip->address, &ip->peer, prefix) < 0)\n            return -1;\n    }\n\n    /* add all routes */\n    for (i = 0; i < ipInfo->nroutes; i++) {\n        virNetDevIPRoutePtr route = ipInfo->routes[i];\n\n        if ((prefix = virNetDevIPRouteGetPrefix(route)) < 0) {\n            ipStr = virSocketAddrFormat(&route->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for route with destination '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPRouteAdd(ifname, &route->address, prefix,\n                                &route->gateway,\n                                virNetDevIPRouteGetMetric(route)) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevIPRouteAdd",
          "args": [
            "ifname",
            "&route->address",
            "prefix",
            "&route->gateway",
            "virNetDevIPRouteGetMetric(route)"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "776-802",
          "snippet": "int\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *gatewaystr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n    if (!(gatewaystr = virSocketAddrFormat(gateway)))\n        return -1;\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"route\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"via\", gatewaystr, \"dev\", ifname,\n                         \"proto\", \"static\", \"metric\", NULL);\n    virCommandAddArgFormat(cmd, \"%u\", metric);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *gatewaystr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n    if (!(gatewaystr = virSocketAddrFormat(gateway)))\n        return -1;\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"route\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"via\", gatewaystr, \"dev\", ifname,\n                         \"proto\", \"static\", \"metric\", NULL);\n    virCommandAddArgFormat(cmd, \"%u\", metric);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetMetric",
          "args": [
            "route"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetMetric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1026-1033",
          "snippet": "unsigned int\nvirNetDevIPRouteGetMetric(virNetDevIPRoutePtr def)\n{\n    if (def && def->has_metric && def->metric > 0)\n        return def->metric;\n\n    return 1;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nunsigned int\nvirNetDevIPRouteGetMetric(virNetDevIPRoutePtr def)\n{\n    if (def && def->has_metric && def->metric > 0)\n        return def->metric;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to determine prefix for route with destination '%s'\")",
            "NULLSTR(ipStr)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ipStr"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to determine prefix for route with destination '%s'\""
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&route->address"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetPrefix",
          "args": [
            "route"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "993-1024",
          "snippet": "int\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPAddrAdd",
          "args": [
            "ifname",
            "&ip->address",
            "&ip->peer",
            "prefix"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPAddrAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "686-740",
          "snippet": "int\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    virSocketAddr broadcast;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *bcaststr = NULL;\n    g_autofree char *peerstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer) && !(peerstr = virSocketAddrFormat(peer)))\n        return -1;\n\n    /* format up a broadcast address if this is IPv4 */\n    if (!peerstr &&\n        ((VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) &&\n         ((virSocketAddrBroadcastByPrefix(addr, prefix, &broadcast) < 0) ||\n          !(bcaststr = virSocketAddrFormat(&broadcast))))) {\n        return -1;\n    }\n\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"pointopoint\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArg(cmd, \"alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"peer\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    virSocketAddr broadcast;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *bcaststr = NULL;\n    g_autofree char *peerstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer) && !(peerstr = virSocketAddrFormat(peer)))\n        return -1;\n\n    /* format up a broadcast address if this is IPv4 */\n    if (!peerstr &&\n        ((VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) &&\n         ((virSocketAddrBroadcastByPrefix(addr, prefix, &broadcast) < 0) ||\n          !(bcaststr = virSocketAddrFormat(&broadcast))))) {\n        return -1;\n    }\n\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"pointopoint\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArg(cmd, \"alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"peer\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to determine prefix for IP address '%s'\")",
            "NULLSTR(ipStr)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ipStr"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPPrefix",
          "args": [
            "&ip->address",
            "NULL",
            "ip->prefix"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1152-1198",
          "snippet": "int\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPInfoAddToDev(const char *ifname,\n                        virNetDevIPInfo const *ipInfo)\n{\n    size_t i;\n    int prefix;\n    g_autofree char *ipStr = NULL;\n\n    /* add all IP addresses */\n    for (i = 0; i < ipInfo->nips; i++) {\n        virNetDevIPAddrPtr ip = ipInfo->ips[i];\n\n        if ((prefix = virSocketAddrGetIPPrefix(&ip->address,\n                                               NULL, ip->prefix)) < 0) {\n            ipStr = virSocketAddrFormat(&ip->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for IP address '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPAddrAdd(ifname, &ip->address, &ip->peer, prefix) < 0)\n            return -1;\n    }\n\n    /* add all routes */\n    for (i = 0; i < ipInfo->nroutes; i++) {\n        virNetDevIPRoutePtr route = ipInfo->routes[i];\n\n        if ((prefix = virNetDevIPRouteGetPrefix(route)) < 0) {\n            ipStr = virSocketAddrFormat(&route->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine prefix for route with destination '%s'\"),\n                           NULLSTR(ipStr));\n            return -1;\n        }\n        if (virNetDevIPRouteAdd(ifname, &route->address, prefix,\n                                &route->gateway,\n                                virNetDevIPRouteGetMetric(route)) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevIPInfoClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "1045-1059",
    "snippet": "void\nvirNetDevIPInfoClear(virNetDevIPInfoPtr ip)\n{\n    size_t i;\n\n    for (i = 0; i < ip->nips; i++)\n        VIR_FREE(ip->ips[i]);\n    VIR_FREE(ip->ips);\n    ip->nips = 0;\n\n    for (i = 0; i < ip->nroutes; i++)\n        virNetDevIPRouteFree(ip->routes[i]);\n    VIR_FREE(ip->routes);\n    ip->nroutes = 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip->routes"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteFree",
          "args": [
            "ip->routes[i]"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "975-982",
          "snippet": "void\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvoid\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip->ips"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ip->ips[i]"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvoid\nvirNetDevIPInfoClear(virNetDevIPInfoPtr ip)\n{\n    size_t i;\n\n    for (i = 0; i < ip->nips; i++)\n        VIR_FREE(ip->ips[i]);\n    VIR_FREE(ip->ips);\n    ip->nips = 0;\n\n    for (i = 0; i < ip->nroutes; i++)\n        virNetDevIPRouteFree(ip->routes[i]);\n    VIR_FREE(ip->routes);\n    ip->nroutes = 0;\n}"
  },
  {
    "function_name": "virNetDevIPRouteGetGateway",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "1035-1041",
    "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}"
  },
  {
    "function_name": "virNetDevIPRouteGetMetric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "1026-1033",
    "snippet": "unsigned int\nvirNetDevIPRouteGetMetric(virNetDevIPRoutePtr def)\n{\n    if (def && def->has_metric && def->metric > 0)\n        return def->metric;\n\n    return 1;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nunsigned int\nvirNetDevIPRouteGetMetric(virNetDevIPRoutePtr def)\n{\n    if (def && def->has_metric && def->metric > 0)\n        return def->metric;\n\n    return 1;\n}"
  },
  {
    "function_name": "virNetDevIPRouteGetPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "993-1024",
    "snippet": "int\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrGetIPPrefix",
          "args": [
            "&def->address",
            "&def->netmask",
            "def->prefix"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1152-1198",
          "snippet": "int\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "&def->netmask",
            "&zero"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->netmask",
            "AF_INET"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address))"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&zero",
            "(VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL)",
            "VIR_SOCKET_ADDR_FAMILY(&def->address)"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&def->address"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&def->address",
            "AF_INET"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}"
  },
  {
    "function_name": "virNetDevIPRouteGetAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "984-991",
    "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}"
  },
  {
    "function_name": "virNetDevIPRouteFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "975-982",
    "snippet": "void\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->family"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvoid\nvirNetDevIPRouteFree(virNetDevIPRoutePtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->family);\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virNetDevIPAddrGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "954-972",
    "snippet": "int\nvirNetDevIPAddrGet(const char *ifname,\n                   virSocketAddrPtr addr)\n{\n    int ret;\n\n    memset(addr, 0, sizeof(*addr));\n    addr->data.stor.ss_family = AF_UNSPEC;\n\n    if ((ret = virNetDevGetifaddrsAddress(ifname, addr)) != -2)\n        return ret;\n\n    if ((ret = virNetDevGetIPv4AddressIoctl(ifname, addr)) != -2)\n        return ret;\n\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get IP address on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Unable to get IP address on this platform\")"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get IP address on this platform\""
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetIPv4AddressIoctl",
          "args": [
            "ifname",
            "addr"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIPv4AddressIoctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "866-871",
          "snippet": "static int\nvirNetDevGetIPv4AddressIoctl(const char *ifname G_GNUC_UNUSED,\n                             virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetIPv4AddressIoctl(const char *ifname G_GNUC_UNUSED,\n                             virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetifaddrsAddress",
          "args": [
            "ifname",
            "addr"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetifaddrsAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "935-940",
          "snippet": "static int\nvirNetDevGetifaddrsAddress(const char *ifname G_GNUC_UNUSED,\n                           virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetifaddrsAddress(const char *ifname G_GNUC_UNUSED,\n                           virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "0",
            "sizeof(*addr)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrGet(const char *ifname,\n                   virSocketAddrPtr addr)\n{\n    int ret;\n\n    memset(addr, 0, sizeof(*addr));\n    addr->data.stor.ss_family = AF_UNSPEC;\n\n    if ((ret = virNetDevGetifaddrsAddress(ifname, addr)) != -2)\n        return ret;\n\n    if ((ret = virNetDevGetIPv4AddressIoctl(ifname, addr)) != -2)\n        return ret;\n\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get IP address on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetDevGetifaddrsAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "935-940",
    "snippet": "static int\nvirNetDevGetifaddrsAddress(const char *ifname G_GNUC_UNUSED,\n                           virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetifaddrsAddress(const char *ifname G_GNUC_UNUSED,\n                           virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}"
  },
  {
    "function_name": "virNetDevGetifaddrsAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "886-931",
    "snippet": "static int\nvirNetDevGetifaddrsAddress(const char *ifname,\n                           virSocketAddrPtr addr)\n{\n    struct ifaddrs *ifap, *ifa;\n    int ret = -1;\n\n    if (getifaddrs(&ifap) < 0) {\n        virReportSystemError(errno,\n                             _(\"Could not get interface list for '%s'\"),\n                             ifname);\n        return -1;\n    }\n\n    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {\n        int family;\n\n        if (STRNEQ_NULLABLE(ifa->ifa_name, ifname))\n            continue;\n\n        if (!ifa->ifa_addr)\n            continue;\n        family = ifa->ifa_addr->sa_family;\n\n        if (family != AF_INET6 && family != AF_INET)\n            continue;\n\n        if (family == AF_INET6) {\n            addr->len = sizeof(addr->data.inet6);\n            memcpy(&addr->data.inet6, ifa->ifa_addr, addr->len);\n        } else {\n            addr->len = sizeof(addr->data.inet4);\n            memcpy(&addr->data.inet4, ifa->ifa_addr, addr->len);\n        }\n        addr->data.stor.ss_family = family;\n        ret = 0;\n        goto cleanup;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"no IP address found for interface '%s'\"),\n                   ifname);\n cleanup:\n    freeifaddrs(ifap);\n    return ret;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifap"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no IP address found for interface '%s'\")",
            "ifname"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no IP address found for interface '%s'\""
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr->data.inet4",
            "ifa->ifa_addr",
            "addr->len"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr->data.inet6",
            "ifa->ifa_addr",
            "addr->len"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "ifa->ifa_name",
            "ifname"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Could not get interface list for '%s'\")",
            "ifname"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifap"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetifaddrsAddress(const char *ifname,\n                           virSocketAddrPtr addr)\n{\n    struct ifaddrs *ifap, *ifa;\n    int ret = -1;\n\n    if (getifaddrs(&ifap) < 0) {\n        virReportSystemError(errno,\n                             _(\"Could not get interface list for '%s'\"),\n                             ifname);\n        return -1;\n    }\n\n    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {\n        int family;\n\n        if (STRNEQ_NULLABLE(ifa->ifa_name, ifname))\n            continue;\n\n        if (!ifa->ifa_addr)\n            continue;\n        family = ifa->ifa_addr->sa_family;\n\n        if (family != AF_INET6 && family != AF_INET)\n            continue;\n\n        if (family == AF_INET6) {\n            addr->len = sizeof(addr->data.inet6);\n            memcpy(&addr->data.inet6, ifa->ifa_addr, addr->len);\n        } else {\n            addr->len = sizeof(addr->data.inet4);\n            memcpy(&addr->data.inet4, ifa->ifa_addr, addr->len);\n        }\n        addr->data.stor.ss_family = family;\n        ret = 0;\n        goto cleanup;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"no IP address found for interface '%s'\"),\n                   ifname);\n cleanup:\n    freeifaddrs(ifap);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevGetIPv4AddressIoctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "866-871",
    "snippet": "static int\nvirNetDevGetIPv4AddressIoctl(const char *ifname G_GNUC_UNUSED,\n                             virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetIPv4AddressIoctl(const char *ifname G_GNUC_UNUSED,\n                             virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n    return -2;\n}"
  },
  {
    "function_name": "virNetDevGetIPv4AddressIoctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "836-862",
    "snippet": "static int\nvirNetDevGetIPv4AddressIoctl(const char *ifname,\n                             virSocketAddrPtr addr)\n{\n    int fd = -1;\n    int ret = -1;\n    struct ifreq ifr;\n\n    if ((fd = virNetDevSetupControl(ifname, &ifr)) < 0)\n        return -1;\n\n    if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get IPv4 address for interface %s via ioctl\"),\n                             ifname);\n        goto cleanup;\n    }\n\n    addr->data.stor.ss_family = AF_INET;\n    addr->len = sizeof(addr->data.inet4);\n    memcpy(&addr->data.inet4, &ifr.ifr_addr, addr->len);\n    ret = 0;\n\n cleanup:\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr->data.inet4",
            "&ifr.ifr_addr",
            "addr->len"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to get IPv4 address for interface %s via ioctl\")",
            "ifname"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get IPv4 address for interface %s via ioctl\""
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCGIFADDR",
            "(char *)&ifr"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevSetupControl",
          "args": [
            "ifname",
            "&ifr"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetupControl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "177-185",
          "snippet": "int\nvirNetDevSetupControl(const char *ifname G_GNUC_UNUSED,\n                      void *ifr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Network device configuration is not supported \"\n                           \"on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetupControl(const char *ifname G_GNUC_UNUSED,\n                      void *ifr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Network device configuration is not supported \"\n                           \"on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetIPv4AddressIoctl(const char *ifname,\n                             virSocketAddrPtr addr)\n{\n    int fd = -1;\n    int ret = -1;\n    struct ifreq ifr;\n\n    if ((fd = virNetDevSetupControl(ifname, &ifr)) < 0)\n        return -1;\n\n    if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to get IPv4 address for interface %s via ioctl\"),\n                             ifname);\n        goto cleanup;\n    }\n\n    addr->data.stor.ss_family = AF_INET;\n    addr->len = sizeof(addr->data.inet4);\n    memcpy(&addr->data.inet4, &ifr.ifr_addr, addr->len);\n    ret = 0;\n\n cleanup:\n    VIR_FORCE_CLOSE(fd);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevIPCheckIPv6Forwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "815-820",
    "snippet": "bool\nvirNetDevIPCheckIPv6Forwarding(void)\n{\n    VIR_WARN(\"built without libnl: unable to check if IPv6 forwarding can be safely enabled\");\n    return true;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"built without libnl: unable to check if IPv6 forwarding can be safely enabled\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nbool\nvirNetDevIPCheckIPv6Forwarding(void)\n{\n    VIR_WARN(\"built without libnl: unable to check if IPv6 forwarding can be safely enabled\");\n    return true;\n}"
  },
  {
    "function_name": "virNetDevIPWaitDadFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "806-813",
    "snippet": "int\nvirNetDevIPWaitDadFinish(virSocketAddrPtr *addrs G_GNUC_UNUSED,\n                         size_t count G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to wait for IPv6 DAD on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Unable to wait for IPv6 DAD on this platform\")"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to wait for IPv6 DAD on this platform\""
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPWaitDadFinish(virSocketAddrPtr *addrs G_GNUC_UNUSED,\n                         size_t count G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to wait for IPv6 DAD on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetDevIPRouteAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "776-802",
    "snippet": "int\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *gatewaystr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n    if (!(gatewaystr = virSocketAddrFormat(gateway)))\n        return -1;\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"route\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"via\", gatewaystr, \"dev\", ifname,\n                         \"proto\", \"static\", \"metric\", NULL);\n    virCommandAddArgFormat(cmd, \"%u\", metric);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%u\"",
            "metric"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"via\"",
            "gatewaystr",
            "\"dev\"",
            "ifname",
            "\"proto\"",
            "\"static\"",
            "\"metric\"",
            "NULL"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "IP_PATH"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "gateway"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *gatewaystr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n    if (!(gatewaystr = virSocketAddrFormat(gateway)))\n        return -1;\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"route\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"via\", gatewaystr, \"dev\", ifname,\n                         \"proto\", \"static\", \"metric\", NULL);\n    virCommandAddArgFormat(cmd, \"%u\", metric);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevIPAddrDel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "743-773",
    "snippet": "int\nvirNetDevIPAddrDel(const char *ifname,\n                   virSocketAddr *addr,\n                   unsigned int prefix)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArg(cmd, \"-alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"del\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"dev\"",
            "ifname",
            "NULL"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s/%u\"",
            "addrstr",
            "prefix"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "IP_PATH"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addr",
            "AF_INET6"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "addr"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrDel(const char *ifname,\n                   virSocketAddr *addr,\n                   unsigned int prefix)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArg(cmd, \"-alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"del\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevIPAddrAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "686-740",
    "snippet": "int\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    virSocketAddr broadcast;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *bcaststr = NULL;\n    g_autofree char *peerstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer) && !(peerstr = virSocketAddrFormat(peer)))\n        return -1;\n\n    /* format up a broadcast address if this is IPv4 */\n    if (!peerstr &&\n        ((VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) &&\n         ((virSocketAddrBroadcastByPrefix(addr, prefix, &broadcast) < 0) ||\n          !(bcaststr = virSocketAddrFormat(&broadcast))))) {\n        return -1;\n    }\n\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"pointopoint\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArg(cmd, \"alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"peer\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"dev\"",
            "ifname",
            "NULL"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s/%u\"",
            "addrstr",
            "prefix"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "IP_PATH"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addr",
            "AF_INET6"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&broadcast"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrBroadcastByPrefix",
          "args": [
            "addr",
            "prefix",
            "&broadcast"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrBroadcastByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "738-750",
          "snippet": "int\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addr",
            "AF_INET"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "peer"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    virSocketAddr broadcast;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *bcaststr = NULL;\n    g_autofree char *peerstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer) && !(peerstr = virSocketAddrFormat(peer)))\n        return -1;\n\n    /* format up a broadcast address if this is IPv4 */\n    if (!peerstr &&\n        ((VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) &&\n         ((virSocketAddrBroadcastByPrefix(addr, prefix, &broadcast) < 0) ||\n          !(bcaststr = virSocketAddrFormat(&broadcast))))) {\n        return -1;\n    }\n\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"pointopoint\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArg(cmd, \"alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"peer\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevIPCheckIPv6Forwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "614-681",
    "snippet": "bool\nvirNetDevIPCheckIPv6Forwarding(void)\n{\n    bool valid = false;\n    struct rtgenmsg genmsg;\n    size_t i;\n    struct virNetDevIPCheckIPv6ForwardingData data = {\n        .hasRARoutes = false,\n        .devices = NULL,\n        .ndevices = 0\n    };\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n\n\n    /* Prepare the request message */\n    if (!(nlmsg = nlmsg_alloc_simple(RTM_GETROUTE,\n                                     NLM_F_REQUEST | NLM_F_DUMP))) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    memset(&genmsg, 0, sizeof(genmsg));\n    genmsg.rtgen_family = AF_INET6;\n\n    if (nlmsg_append(nlmsg, &genmsg, sizeof(genmsg), NLMSG_ALIGNTO) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"allocated netlink buffer is too small\"));\n        goto cleanup;\n    }\n\n    /* Send the request and loop over the responses */\n    if (virNetlinkDumpCommand(nlmsg, virNetDevIPCheckIPv6ForwardingCallback,\n                              0, 0, NETLINK_ROUTE, 0, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to loop over IPv6 routes\"));\n        goto cleanup;\n    }\n\n    valid = !data.hasRARoutes || data.ndevices == 0;\n\n    /* Check the global accept_ra if at least one isn't set on a\n       per-device basis */\n    if (!valid && data.hasRARoutes) {\n        int accept_ra = virNetDevIPGetAcceptRA(NULL);\n        valid = accept_ra == 2;\n        VIR_DEBUG(\"Checked global accept_ra: %d\", accept_ra);\n    }\n\n    if (!valid) {\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        for (i = 0; i < data.ndevices; i++) {\n            virBufferAdd(&buf, data.devices[i], -1);\n            if (i < data.ndevices - 1)\n                virBufferAddLit(&buf, \", \");\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Check the host setup: enabling IPv6 forwarding with \"\n                         \"RA routes without accept_ra set to 2 is likely to cause \"\n                         \"routes loss. Interfaces to look at: %s\"),\n                       virBufferCurrentContent(&buf));\n        virBufferFreeAndReset(&buf);\n    }\n\n cleanup:\n    virStringListFreeCount(data.devices, data.ndevices);\n    return valid;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "data.devices",
            "data.ndevices"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Check the host setup: enabling IPv6 forwarding with \"\n                         \"RA routes without accept_ra set to 2 is likely to cause \"\n                         \"routes loss. Interfaces to look at: %s\")",
            "virBufferCurrentContent(&buf)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferCurrentContent",
          "args": [
            "&buf"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferCurrentContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "222-233",
          "snippet": "const char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Check the host setup: enabling IPv6 forwarding with \"\n                         \"RA routes without accept_ra set to 2 is likely to cause \"\n                         \"routes loss. Interfaces to look at: %s\""
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\", \""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "data.devices[i]",
            "-1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checked global accept_ra: %d\"",
            "accept_ra"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPGetAcceptRA",
          "args": [
            "NULL"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPGetAcceptRA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "485-501",
          "snippet": "static int\nvirNetDevIPGetAcceptRA(const char *ifname)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *suffix;\n    int accept_ra = -1;\n\n    path = g_strdup_printf(\"/proc/sys/net/ipv6/conf/%s/accept_ra\",\n                           ifname ? ifname : \"all\");\n\n    if ((virFileReadAll(path, 512, &buf) < 0) ||\n        (virStrToLong_i(buf, &suffix, 10, &accept_ra) < 0))\n        return -1;\n\n    return accept_ra;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevIPGetAcceptRA(const char *ifname)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *suffix;\n    int accept_ra = -1;\n\n    path = g_strdup_printf(\"/proc/sys/net/ipv6/conf/%s/accept_ra\",\n                           ifname ? ifname : \"all\");\n\n    if ((virFileReadAll(path, 512, &buf) < 0) ||\n        (virStrToLong_i(buf, &suffix, 10, &accept_ra) < 0))\n        return -1;\n\n    return accept_ra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to loop over IPv6 routes\")"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkDumpCommand",
          "args": [
            "nlmsg",
            "virNetDevIPCheckIPv6ForwardingCallback",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0",
            "&data"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkDumpCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1248-1259",
          "snippet": "int\nvirNetlinkDumpCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      virNetlinkDumpCallback callback G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED,\n                      void *opaque G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      virNetlinkDumpCallback callback G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED,\n                      void *opaque G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nlmsg",
            "&genmsg",
            "sizeof(genmsg)",
            "NLMSG_ALIGNTO"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&genmsg",
            "0",
            "sizeof(genmsg)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_GETROUTE",
            "NLM_F_REQUEST | NLM_F_DUMP"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nbool\nvirNetDevIPCheckIPv6Forwarding(void)\n{\n    bool valid = false;\n    struct rtgenmsg genmsg;\n    size_t i;\n    struct virNetDevIPCheckIPv6ForwardingData data = {\n        .hasRARoutes = false,\n        .devices = NULL,\n        .ndevices = 0\n    };\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n\n\n    /* Prepare the request message */\n    if (!(nlmsg = nlmsg_alloc_simple(RTM_GETROUTE,\n                                     NLM_F_REQUEST | NLM_F_DUMP))) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    memset(&genmsg, 0, sizeof(genmsg));\n    genmsg.rtgen_family = AF_INET6;\n\n    if (nlmsg_append(nlmsg, &genmsg, sizeof(genmsg), NLMSG_ALIGNTO) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"allocated netlink buffer is too small\"));\n        goto cleanup;\n    }\n\n    /* Send the request and loop over the responses */\n    if (virNetlinkDumpCommand(nlmsg, virNetDevIPCheckIPv6ForwardingCallback,\n                              0, 0, NETLINK_ROUTE, 0, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to loop over IPv6 routes\"));\n        goto cleanup;\n    }\n\n    valid = !data.hasRARoutes || data.ndevices == 0;\n\n    /* Check the global accept_ra if at least one isn't set on a\n       per-device basis */\n    if (!valid && data.hasRARoutes) {\n        int accept_ra = virNetDevIPGetAcceptRA(NULL);\n        valid = accept_ra == 2;\n        VIR_DEBUG(\"Checked global accept_ra: %d\", accept_ra);\n    }\n\n    if (!valid) {\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        for (i = 0; i < data.ndevices; i++) {\n            virBufferAdd(&buf, data.devices[i], -1);\n            if (i < data.ndevices - 1)\n                virBufferAddLit(&buf, \", \");\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Check the host setup: enabling IPv6 forwarding with \"\n                         \"RA routes without accept_ra set to 2 is likely to cause \"\n                         \"routes loss. Interfaces to look at: %s\"),\n                       virBufferCurrentContent(&buf));\n        virBufferFreeAndReset(&buf);\n    }\n\n cleanup:\n    virStringListFreeCount(data.devices, data.ndevices);\n    return valid;\n}"
  },
  {
    "function_name": "virNetDevIPCheckIPv6ForwardingCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "530-612",
    "snippet": "static int\nvirNetDevIPCheckIPv6ForwardingCallback(struct nlmsghdr *resp,\n                                       void *opaque)\n{\n    struct rtmsg *rtmsg = NLMSG_DATA(resp);\n    struct virNetDevIPCheckIPv6ForwardingData *data = opaque;\n    struct rtattr *rta_attr;\n    int accept_ra = -1;\n    int ifindex = -1;\n    g_autofree char *ifname = NULL;\n\n    /* Ignore messages other than route ones */\n    if (resp->nlmsg_type != RTM_NEWROUTE)\n        return 0;\n\n    /* No need to do anything else for non RA routes */\n    if (rtmsg->rtm_protocol != RTPROT_RA)\n        return 0;\n\n    rta_attr = (struct rtattr *)nlmsg_find_attr(resp, sizeof(struct rtmsg), RTA_OIF);\n    if (rta_attr) {\n        /* This is a single path route, with interface used to reach\n         * nexthop in the RTA_OIF attribute.\n         */\n        ifindex = *(int *)RTA_DATA(rta_attr);\n        ifname = virNetDevGetName(ifindex);\n\n        if (!ifname)\n           return -1;\n\n        accept_ra = virNetDevIPGetAcceptRA(ifname);\n\n        VIR_DEBUG(\"Checking route for device %s (%d), accept_ra: %d\",\n                  ifname, ifindex, accept_ra);\n\n        if (accept_ra != 2 && virNetDevIPCheckIPv6ForwardingAddIF(data, &ifname) < 0)\n            return -1;\n\n        data->hasRARoutes = true;\n        return 0;\n    }\n\n    /* if no RTA_OIF was found, see if this is a multipath route (one\n     * which has an array of nexthops, each with its own interface)\n     */\n\n    rta_attr = (struct rtattr *)nlmsg_find_attr(resp, sizeof(struct rtmsg), RTA_MULTIPATH);\n    if (rta_attr) {\n        /* The data of the attribute is an array of rtnexthop */\n        struct rtnexthop *nh = RTA_DATA(rta_attr);\n        size_t len = RTA_PAYLOAD(rta_attr);\n\n        /* validate the attribute array length */\n        len = MIN(len, ((char *)resp + NLMSG_PAYLOAD(resp, 0) - (char *)rta_attr));\n\n        while (len >= sizeof(*nh) && len >= nh->rtnh_len) {\n            /* check accept_ra for the interface of each nexthop */\n\n            ifname = virNetDevGetName(nh->rtnh_ifindex);\n\n            if (!ifname)\n                return -1;\n\n            accept_ra = virNetDevIPGetAcceptRA(ifname);\n\n            VIR_DEBUG(\"Checking multipath route nexthop device %s (%d), accept_ra: %d\",\n                      ifname, nh->rtnh_ifindex, accept_ra);\n\n            if (accept_ra != 2 && virNetDevIPCheckIPv6ForwardingAddIF(data, &ifname) < 0)\n                return -1;\n\n            VIR_FREE(ifname);\n            data->hasRARoutes = true;\n\n            len -= NLMSG_ALIGN(nh->rtnh_len);\n            VIR_WARNINGS_NO_CAST_ALIGN\n            nh = RTNH_NEXT(nh);\n            VIR_WARNINGS_RESET\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RTNH_NEXT",
          "args": [
            "nh"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "nh->rtnh_len"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ifname"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPCheckIPv6ForwardingAddIF",
          "args": [
            "data",
            "&ifname"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPCheckIPv6ForwardingAddIF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "512-527",
          "snippet": "static int\nvirNetDevIPCheckIPv6ForwardingAddIF(struct virNetDevIPCheckIPv6ForwardingData *data,\n                                    char **ifname)\n{\n    size_t i;\n\n    /* add ifname to the array if it's not already there\n     * (ifname is char** so VIR_APPEND_ELEMENT() will move the\n     * original pointer out of the way and avoid having it freed)\n     */\n    for (i = 0; i < data->ndevices; i++) {\n        if (STREQ(data->devices[i], *ifname))\n            return 0;\n    }\n    return VIR_APPEND_ELEMENT(data->devices, data->ndevices, *ifname);\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevIPCheckIPv6ForwardingAddIF(struct virNetDevIPCheckIPv6ForwardingData *data,\n                                    char **ifname)\n{\n    size_t i;\n\n    /* add ifname to the array if it's not already there\n     * (ifname is char** so VIR_APPEND_ELEMENT() will move the\n     * original pointer out of the way and avoid having it freed)\n     */\n    for (i = 0; i < data->ndevices; i++) {\n        if (STREQ(data->devices[i], *ifname))\n            return 0;\n    }\n    return VIR_APPEND_ELEMENT(data->devices, data->ndevices, *ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking multipath route nexthop device %s (%d), accept_ra: %d\"",
            "ifname",
            "nh->rtnh_ifindex",
            "accept_ra"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPGetAcceptRA",
          "args": [
            "ifname"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPGetAcceptRA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "485-501",
          "snippet": "static int\nvirNetDevIPGetAcceptRA(const char *ifname)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *suffix;\n    int accept_ra = -1;\n\n    path = g_strdup_printf(\"/proc/sys/net/ipv6/conf/%s/accept_ra\",\n                           ifname ? ifname : \"all\");\n\n    if ((virFileReadAll(path, 512, &buf) < 0) ||\n        (virStrToLong_i(buf, &suffix, 10, &accept_ra) < 0))\n        return -1;\n\n    return accept_ra;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevIPGetAcceptRA(const char *ifname)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *suffix;\n    int accept_ra = -1;\n\n    path = g_strdup_printf(\"/proc/sys/net/ipv6/conf/%s/accept_ra\",\n                           ifname ? ifname : \"all\");\n\n    if ((virFileReadAll(path, 512, &buf) < 0) ||\n        (virStrToLong_i(buf, &suffix, 10, &accept_ra) < 0))\n        return -1;\n\n    return accept_ra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetName",
          "args": [
            "nh->rtnh_ifindex"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "840-846",
          "snippet": "char *virNetDevGetName(int ifindex)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Cannot get interface name for index '%i'\"),\n                         ifindex);\n    return NULL;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "size_t i;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nsize_t i;\n\nchar *virNetDevGetName(int ifindex)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Cannot get interface name for index '%i'\"),\n                         ifindex);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "len",
            "((char *)resp + NLMSG_PAYLOAD(resp, 0) - (char *)rta_attr)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_PAYLOAD",
          "args": [
            "resp",
            "0"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "rta_attr"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rta_attr"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_find_attr",
          "args": [
            "resp",
            "sizeof(struct rtmsg)",
            "RTA_MULTIPATH"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking route for device %s (%d), accept_ra: %d\"",
            "ifname",
            "ifindex",
            "accept_ra"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rta_attr"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_find_attr",
          "args": [
            "resp",
            "sizeof(struct rtmsg)",
            "RTA_OIF"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevIPCheckIPv6ForwardingCallback(struct nlmsghdr *resp,\n                                       void *opaque)\n{\n    struct rtmsg *rtmsg = NLMSG_DATA(resp);\n    struct virNetDevIPCheckIPv6ForwardingData *data = opaque;\n    struct rtattr *rta_attr;\n    int accept_ra = -1;\n    int ifindex = -1;\n    g_autofree char *ifname = NULL;\n\n    /* Ignore messages other than route ones */\n    if (resp->nlmsg_type != RTM_NEWROUTE)\n        return 0;\n\n    /* No need to do anything else for non RA routes */\n    if (rtmsg->rtm_protocol != RTPROT_RA)\n        return 0;\n\n    rta_attr = (struct rtattr *)nlmsg_find_attr(resp, sizeof(struct rtmsg), RTA_OIF);\n    if (rta_attr) {\n        /* This is a single path route, with interface used to reach\n         * nexthop in the RTA_OIF attribute.\n         */\n        ifindex = *(int *)RTA_DATA(rta_attr);\n        ifname = virNetDevGetName(ifindex);\n\n        if (!ifname)\n           return -1;\n\n        accept_ra = virNetDevIPGetAcceptRA(ifname);\n\n        VIR_DEBUG(\"Checking route for device %s (%d), accept_ra: %d\",\n                  ifname, ifindex, accept_ra);\n\n        if (accept_ra != 2 && virNetDevIPCheckIPv6ForwardingAddIF(data, &ifname) < 0)\n            return -1;\n\n        data->hasRARoutes = true;\n        return 0;\n    }\n\n    /* if no RTA_OIF was found, see if this is a multipath route (one\n     * which has an array of nexthops, each with its own interface)\n     */\n\n    rta_attr = (struct rtattr *)nlmsg_find_attr(resp, sizeof(struct rtmsg), RTA_MULTIPATH);\n    if (rta_attr) {\n        /* The data of the attribute is an array of rtnexthop */\n        struct rtnexthop *nh = RTA_DATA(rta_attr);\n        size_t len = RTA_PAYLOAD(rta_attr);\n\n        /* validate the attribute array length */\n        len = MIN(len, ((char *)resp + NLMSG_PAYLOAD(resp, 0) - (char *)rta_attr));\n\n        while (len >= sizeof(*nh) && len >= nh->rtnh_len) {\n            /* check accept_ra for the interface of each nexthop */\n\n            ifname = virNetDevGetName(nh->rtnh_ifindex);\n\n            if (!ifname)\n                return -1;\n\n            accept_ra = virNetDevIPGetAcceptRA(ifname);\n\n            VIR_DEBUG(\"Checking multipath route nexthop device %s (%d), accept_ra: %d\",\n                      ifname, nh->rtnh_ifindex, accept_ra);\n\n            if (accept_ra != 2 && virNetDevIPCheckIPv6ForwardingAddIF(data, &ifname) < 0)\n                return -1;\n\n            VIR_FREE(ifname);\n            data->hasRARoutes = true;\n\n            len -= NLMSG_ALIGN(nh->rtnh_len);\n            VIR_WARNINGS_NO_CAST_ALIGN\n            nh = RTNH_NEXT(nh);\n            VIR_WARNINGS_RESET\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevIPCheckIPv6ForwardingAddIF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "512-527",
    "snippet": "static int\nvirNetDevIPCheckIPv6ForwardingAddIF(struct virNetDevIPCheckIPv6ForwardingData *data,\n                                    char **ifname)\n{\n    size_t i;\n\n    /* add ifname to the array if it's not already there\n     * (ifname is char** so VIR_APPEND_ELEMENT() will move the\n     * original pointer out of the way and avoid having it freed)\n     */\n    for (i = 0; i < data->ndevices; i++) {\n        if (STREQ(data->devices[i], *ifname))\n            return 0;\n    }\n    return VIR_APPEND_ELEMENT(data->devices, data->ndevices, *ifname);\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "data->devices",
            "data->ndevices",
            "*ifname"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "data->devices[i]",
            "*ifname"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevIPCheckIPv6ForwardingAddIF(struct virNetDevIPCheckIPv6ForwardingData *data,\n                                    char **ifname)\n{\n    size_t i;\n\n    /* add ifname to the array if it's not already there\n     * (ifname is char** so VIR_APPEND_ELEMENT() will move the\n     * original pointer out of the way and avoid having it freed)\n     */\n    for (i = 0; i < data->ndevices; i++) {\n        if (STREQ(data->devices[i], *ifname))\n            return 0;\n    }\n    return VIR_APPEND_ELEMENT(data->devices, data->ndevices, *ifname);\n}"
  },
  {
    "function_name": "virNetDevIPGetAcceptRA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "485-501",
    "snippet": "static int\nvirNetDevIPGetAcceptRA(const char *ifname)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *suffix;\n    int accept_ra = -1;\n\n    path = g_strdup_printf(\"/proc/sys/net/ipv6/conf/%s/accept_ra\",\n                           ifname ? ifname : \"all\");\n\n    if ((virFileReadAll(path, 512, &buf) < 0) ||\n        (virStrToLong_i(buf, &suffix, 10, &accept_ra) < 0))\n        return -1;\n\n    return accept_ra;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "buf",
            "&suffix",
            "10",
            "&accept_ra"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "path",
            "512",
            "&buf"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/sys/net/ipv6/conf/%s/accept_ra\"",
            "ifname ? ifname : \"all\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevIPGetAcceptRA(const char *ifname)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *buf = NULL;\n    char *suffix;\n    int accept_ra = -1;\n\n    path = g_strdup_printf(\"/proc/sys/net/ipv6/conf/%s/accept_ra\",\n                           ifname ? ifname : \"all\");\n\n    if ((virFileReadAll(path, 512, &buf) < 0) ||\n        (virStrToLong_i(buf, &suffix, 10, &accept_ra) < 0))\n        return -1;\n\n    return accept_ra;\n}"
  },
  {
    "function_name": "virNetDevIPWaitDadFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "430-483",
    "snippet": "int\nvirNetDevIPWaitDadFinish(virSocketAddrPtr *addrs, size_t count)\n{\n    struct ifaddrmsg ifa;\n    unsigned int recvbuflen;\n    bool dad = true;\n    time_t max_time = time(NULL) + VIR_DAD_WAIT_TIMEOUT;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(RTM_GETADDR,\n                                     NLM_F_REQUEST | NLM_F_DUMP))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n    /* DAD is for IPv6 addresses only. */\n    ifa.ifa_family = AF_INET6;\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"allocated netlink buffer is too small\"));\n        return -1;\n    }\n\n    /* Periodically query netlink until DAD finishes on all known addresses. */\n    while (dad && time(NULL) < max_time) {\n        g_autofree struct nlmsghdr *resp = NULL;\n\n        if (virNetlinkCommand(nlmsg, &resp, &recvbuflen, 0, 0,\n                              NETLINK_ROUTE, 0) < 0)\n            return -1;\n\n        if (virNetlinkGetErrorCode(resp, recvbuflen) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"error reading DAD state information\"));\n            return -1;\n        }\n\n        /* Parse response. */\n        dad = virNetDevIPParseDadStatus(resp, recvbuflen, addrs, count);\n        if (dad)\n            g_usleep(1000 * 10);\n    }\n    /* Check timeout. */\n    if (dad) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Duplicate Address Detection \"\n                         \"not finished in %d seconds\"), VIR_DAD_WAIT_TIMEOUT);\n    } else {\n        return 0;\n    }\n\n    return -1;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_DAD_WAIT_TIMEOUT 20 /* seconds */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Duplicate Address Detection \"\n                         \"not finished in %d seconds\")",
            "VIR_DAD_WAIT_TIMEOUT"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Duplicate Address Detection \"\n                         \"not finished in %d seconds\""
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "1000 * 10"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPParseDadStatus",
          "args": [
            "resp",
            "recvbuflen",
            "addrs",
            "count"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPParseDadStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "379-426",
          "snippet": "static bool\nvirNetDevIPParseDadStatus(struct nlmsghdr *nlh, int len,\n                          virSocketAddrPtr *addrs, size_t count)\n{\n    struct ifaddrmsg *ifaddrmsg_ptr;\n    unsigned int ifaddrmsg_len;\n    struct rtattr *rtattr_ptr;\n    size_t i;\n    struct in6_addr *addr;\n\n    VIR_WARNINGS_NO_CAST_ALIGN\n    for (; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) {\n        VIR_WARNINGS_RESET\n        if (NLMSG_PAYLOAD(nlh, 0) < sizeof(struct ifaddrmsg)) {\n            /* Message without payload is the last one. */\n            break;\n        }\n\n        ifaddrmsg_ptr = (struct ifaddrmsg *)NLMSG_DATA(nlh);\n        if (!(ifaddrmsg_ptr->ifa_flags & IFA_F_TENTATIVE)) {\n            /* Not tentative: we are not interested in this entry. */\n            continue;\n        }\n\n        ifaddrmsg_len = IFA_PAYLOAD(nlh);\n        VIR_WARNINGS_NO_CAST_ALIGN\n        rtattr_ptr = (struct rtattr *) IFA_RTA(ifaddrmsg_ptr);\n        for (; RTA_OK(rtattr_ptr, ifaddrmsg_len);\n             rtattr_ptr = RTA_NEXT(rtattr_ptr, ifaddrmsg_len)) {\n            VIR_WARNINGS_RESET\n            if (RTA_PAYLOAD(rtattr_ptr) != sizeof(struct in6_addr)) {\n                /* No address: ignore. */\n                continue;\n            }\n\n            /* We check only known addresses. */\n            for (i = 0; i < count; i++) {\n                addr = &addrs[i]->data.inet6.sin6_addr;\n                if (!memcmp(addr, RTA_DATA(rtattr_ptr),\n                            sizeof(struct in6_addr))) {\n                    /* We found matching tentative address. */\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic bool\nvirNetDevIPParseDadStatus(struct nlmsghdr *nlh, int len,\n                          virSocketAddrPtr *addrs, size_t count)\n{\n    struct ifaddrmsg *ifaddrmsg_ptr;\n    unsigned int ifaddrmsg_len;\n    struct rtattr *rtattr_ptr;\n    size_t i;\n    struct in6_addr *addr;\n\n    VIR_WARNINGS_NO_CAST_ALIGN\n    for (; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) {\n        VIR_WARNINGS_RESET\n        if (NLMSG_PAYLOAD(nlh, 0) < sizeof(struct ifaddrmsg)) {\n            /* Message without payload is the last one. */\n            break;\n        }\n\n        ifaddrmsg_ptr = (struct ifaddrmsg *)NLMSG_DATA(nlh);\n        if (!(ifaddrmsg_ptr->ifa_flags & IFA_F_TENTATIVE)) {\n            /* Not tentative: we are not interested in this entry. */\n            continue;\n        }\n\n        ifaddrmsg_len = IFA_PAYLOAD(nlh);\n        VIR_WARNINGS_NO_CAST_ALIGN\n        rtattr_ptr = (struct rtattr *) IFA_RTA(ifaddrmsg_ptr);\n        for (; RTA_OK(rtattr_ptr, ifaddrmsg_len);\n             rtattr_ptr = RTA_NEXT(rtattr_ptr, ifaddrmsg_len)) {\n            VIR_WARNINGS_RESET\n            if (RTA_PAYLOAD(rtattr_ptr) != sizeof(struct in6_addr)) {\n                /* No address: ignore. */\n                continue;\n            }\n\n            /* We check only known addresses. */\n            for (i = 0; i < count; i++) {\n                addr = &addrs[i]->data.inet6.sin6_addr;\n                if (!memcmp(addr, RTA_DATA(rtattr_ptr),\n                            sizeof(struct in6_addr))) {\n                    /* We found matching tentative address. */\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"error reading DAD state information\")"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkGetErrorCode",
          "args": [
            "resp",
            "recvbuflen"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkGetErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1378-1384",
          "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nlmsg",
            "&resp",
            "&recvbuflen",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nlmsg",
            "&ifa",
            "sizeof(ifa)",
            "NLMSG_ALIGNTO"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifa",
            "0",
            "sizeof(ifa)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_GETADDR",
            "NLM_F_REQUEST | NLM_F_DUMP"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\n#define VIR_DAD_WAIT_TIMEOUT 20 /* seconds */\n\nint\nvirNetDevIPWaitDadFinish(virSocketAddrPtr *addrs, size_t count)\n{\n    struct ifaddrmsg ifa;\n    unsigned int recvbuflen;\n    bool dad = true;\n    time_t max_time = time(NULL) + VIR_DAD_WAIT_TIMEOUT;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(RTM_GETADDR,\n                                     NLM_F_REQUEST | NLM_F_DUMP))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n    /* DAD is for IPv6 addresses only. */\n    ifa.ifa_family = AF_INET6;\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"allocated netlink buffer is too small\"));\n        return -1;\n    }\n\n    /* Periodically query netlink until DAD finishes on all known addresses. */\n    while (dad && time(NULL) < max_time) {\n        g_autofree struct nlmsghdr *resp = NULL;\n\n        if (virNetlinkCommand(nlmsg, &resp, &recvbuflen, 0, 0,\n                              NETLINK_ROUTE, 0) < 0)\n            return -1;\n\n        if (virNetlinkGetErrorCode(resp, recvbuflen) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"error reading DAD state information\"));\n            return -1;\n        }\n\n        /* Parse response. */\n        dad = virNetDevIPParseDadStatus(resp, recvbuflen, addrs, count);\n        if (dad)\n            g_usleep(1000 * 10);\n    }\n    /* Check timeout. */\n    if (dad) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Duplicate Address Detection \"\n                         \"not finished in %d seconds\"), VIR_DAD_WAIT_TIMEOUT);\n    } else {\n        return 0;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virNetDevIPParseDadStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "379-426",
    "snippet": "static bool\nvirNetDevIPParseDadStatus(struct nlmsghdr *nlh, int len,\n                          virSocketAddrPtr *addrs, size_t count)\n{\n    struct ifaddrmsg *ifaddrmsg_ptr;\n    unsigned int ifaddrmsg_len;\n    struct rtattr *rtattr_ptr;\n    size_t i;\n    struct in6_addr *addr;\n\n    VIR_WARNINGS_NO_CAST_ALIGN\n    for (; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) {\n        VIR_WARNINGS_RESET\n        if (NLMSG_PAYLOAD(nlh, 0) < sizeof(struct ifaddrmsg)) {\n            /* Message without payload is the last one. */\n            break;\n        }\n\n        ifaddrmsg_ptr = (struct ifaddrmsg *)NLMSG_DATA(nlh);\n        if (!(ifaddrmsg_ptr->ifa_flags & IFA_F_TENTATIVE)) {\n            /* Not tentative: we are not interested in this entry. */\n            continue;\n        }\n\n        ifaddrmsg_len = IFA_PAYLOAD(nlh);\n        VIR_WARNINGS_NO_CAST_ALIGN\n        rtattr_ptr = (struct rtattr *) IFA_RTA(ifaddrmsg_ptr);\n        for (; RTA_OK(rtattr_ptr, ifaddrmsg_len);\n             rtattr_ptr = RTA_NEXT(rtattr_ptr, ifaddrmsg_len)) {\n            VIR_WARNINGS_RESET\n            if (RTA_PAYLOAD(rtattr_ptr) != sizeof(struct in6_addr)) {\n                /* No address: ignore. */\n                continue;\n            }\n\n            /* We check only known addresses. */\n            for (i = 0; i < count; i++) {\n                addr = &addrs[i]->data.inet6.sin6_addr;\n                if (!memcmp(addr, RTA_DATA(rtattr_ptr),\n                            sizeof(struct in6_addr))) {\n                    /* We found matching tentative address. */\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "addr",
            "RTA_DATA(rtattr_ptr)",
            "sizeof(struct in6_addr)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rtattr_ptr"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "rtattr_ptr",
            "ifaddrmsg_len"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "rtattr_ptr",
            "ifaddrmsg_len"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFA_RTA",
          "args": [
            "ifaddrmsg_ptr"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFA_PAYLOAD",
          "args": [
            "nlh"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "nlh"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "nlh",
            "len"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "nlh",
            "len"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic bool\nvirNetDevIPParseDadStatus(struct nlmsghdr *nlh, int len,\n                          virSocketAddrPtr *addrs, size_t count)\n{\n    struct ifaddrmsg *ifaddrmsg_ptr;\n    unsigned int ifaddrmsg_len;\n    struct rtattr *rtattr_ptr;\n    size_t i;\n    struct in6_addr *addr;\n\n    VIR_WARNINGS_NO_CAST_ALIGN\n    for (; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) {\n        VIR_WARNINGS_RESET\n        if (NLMSG_PAYLOAD(nlh, 0) < sizeof(struct ifaddrmsg)) {\n            /* Message without payload is the last one. */\n            break;\n        }\n\n        ifaddrmsg_ptr = (struct ifaddrmsg *)NLMSG_DATA(nlh);\n        if (!(ifaddrmsg_ptr->ifa_flags & IFA_F_TENTATIVE)) {\n            /* Not tentative: we are not interested in this entry. */\n            continue;\n        }\n\n        ifaddrmsg_len = IFA_PAYLOAD(nlh);\n        VIR_WARNINGS_NO_CAST_ALIGN\n        rtattr_ptr = (struct rtattr *) IFA_RTA(ifaddrmsg_ptr);\n        for (; RTA_OK(rtattr_ptr, ifaddrmsg_len);\n             rtattr_ptr = RTA_NEXT(rtattr_ptr, ifaddrmsg_len)) {\n            VIR_WARNINGS_RESET\n            if (RTA_PAYLOAD(rtattr_ptr) != sizeof(struct in6_addr)) {\n                /* No address: ignore. */\n                continue;\n            }\n\n            /* We check only known addresses. */\n            for (i = 0; i < count; i++) {\n                addr = &addrs[i]->data.inet6.sin6_addr;\n                if (!memcmp(addr, RTA_DATA(rtattr_ptr),\n                            sizeof(struct in6_addr))) {\n                    /* We found matching tentative address. */\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "function_name": "virNetDevIPRouteAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "279-375",
    "snippet": "int\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    unsigned int recvbuflen;\n    unsigned int ifindex;\n    struct rtmsg rtmsg;\n    void *gatewayData = NULL;\n    void *addrData = NULL;\n    size_t addrDataLen;\n    int errCode;\n    virSocketAddr defaultAddr;\n    virSocketAddrPtr actualAddr;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n    g_autofree char *toStr = NULL;\n    g_autofree char *viaStr = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    actualAddr = addr;\n\n    /* If we have no valid network address, then use the default one */\n    if (!addr || !VIR_SOCKET_ADDR_VALID(addr)) {\n        VIR_DEBUG(\"computing default address\");\n        int family = VIR_SOCKET_ADDR_FAMILY(gateway);\n        if (family == AF_INET) {\n            if (virSocketAddrParseIPv4(&defaultAddr, VIR_SOCKET_ADDR_IPV4_ALL) < 0)\n                return -1;\n        } else {\n            if (virSocketAddrParseIPv6(&defaultAddr, VIR_SOCKET_ADDR_IPV6_ALL) < 0)\n                return -1;\n        }\n\n        actualAddr = &defaultAddr;\n    }\n\n    toStr = virSocketAddrFormat(actualAddr);\n    viaStr = virSocketAddrFormat(gateway);\n    VIR_DEBUG(\"Adding route %s/%d via %s\", toStr, prefix, viaStr);\n\n    if (virNetDevGetIPAddressBinary(actualAddr, &addrData, &addrDataLen) < 0 ||\n        virNetDevGetIPAddressBinary(gateway, &gatewayData, &addrDataLen) < 0)\n        return -1;\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return -1;\n\n    if (!(nlmsg = nlmsg_alloc_simple(RTM_NEWROUTE,\n                                     NLM_F_REQUEST | NLM_F_CREATE |\n                                     NLM_F_EXCL))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    memset(&rtmsg, 0, sizeof(rtmsg));\n\n    rtmsg.rtm_family = VIR_SOCKET_ADDR_FAMILY(gateway);\n    rtmsg.rtm_table = RT_TABLE_MAIN;\n    rtmsg.rtm_scope = RT_SCOPE_UNIVERSE;\n    rtmsg.rtm_protocol = RTPROT_BOOT;\n    rtmsg.rtm_type = RTN_UNICAST;\n    rtmsg.rtm_dst_len = prefix;\n\n    if (nlmsg_append(nlmsg, &rtmsg, sizeof(rtmsg), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (prefix > 0 && nla_put(nlmsg, RTA_DST, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, RTA_GATEWAY, addrDataLen, gatewayData) < 0)\n        goto buffer_too_small;\n\n    if (nla_put_u32(nlmsg, RTA_OIF, ifindex) < 0)\n        goto buffer_too_small;\n\n    if (metric > 0 && nla_put_u32(nlmsg, RTA_PRIORITY, metric) < 0)\n        goto buffer_too_small;\n\n    if (virNetlinkCommand(nlmsg, &resp, &recvbuflen, 0, 0,\n                          NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if ((errCode = virNetlinkGetErrorCode(resp, recvbuflen)) < 0) {\n        virReportSystemError(errCode, _(\"Error adding route to %s\"), ifname);\n        return -1;\n    }\n\n    return 0;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errCode",
            "_(\"Error adding route to %s\")",
            "ifname"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkGetErrorCode",
          "args": [
            "resp",
            "recvbuflen"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkGetErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1378-1384",
          "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nlmsg",
            "&resp",
            "&recvbuflen",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "RTA_PRIORITY",
            "metric"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put_u32",
          "args": [
            "nlmsg",
            "RTA_OIF",
            "ifindex"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nlmsg",
            "RTA_GATEWAY",
            "addrDataLen",
            "gatewayData"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nlmsg",
            "RTA_DST",
            "addrDataLen",
            "addrData"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nlmsg",
            "&rtmsg",
            "sizeof(rtmsg)",
            "NLMSG_ALIGNTO"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "gateway"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rtmsg",
            "0",
            "sizeof(rtmsg)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_NEWROUTE",
            "NLM_F_REQUEST | NLM_F_CREATE |\n                                     NLM_F_EXCL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "ifname"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetIPAddressBinary",
          "args": [
            "gateway",
            "&gatewayData",
            "&addrDataLen"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIPAddressBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "61-80",
          "snippet": "static int\nvirNetDevGetIPAddressBinary(virSocketAddr *addr, void **data, size_t *len)\n{\n    if (!addr)\n        return -1;\n\n    switch (VIR_SOCKET_ADDR_FAMILY(addr)) {\n    case AF_INET:\n        *data = &addr->data.inet4.sin_addr;\n        *len = sizeof(struct in_addr);\n        break;\n    case AF_INET6:\n        *data = &addr->data.inet6.sin6_addr;\n        *len = sizeof(struct in6_addr);\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetIPAddressBinary(virSocketAddr *addr, void **data, size_t *len)\n{\n    if (!addr)\n        return -1;\n\n    switch (VIR_SOCKET_ADDR_FAMILY(addr)) {\n    case AF_INET:\n        *data = &addr->data.inet4.sin_addr;\n        *len = sizeof(struct in_addr);\n        break;\n    case AF_INET6:\n        *data = &addr->data.inet6.sin6_addr;\n        *len = sizeof(struct in6_addr);\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding route %s/%d via %s\"",
            "toStr",
            "prefix",
            "viaStr"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "gateway"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseIPv6",
          "args": [
            "&defaultAddr",
            "VIR_SOCKET_ADDR_IPV6_ALL"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseIPv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "230-234",
          "snippet": "int\nvirSocketAddrParseIPv6(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET6);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv6(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseIPv4",
          "args": [
            "&defaultAddr",
            "VIR_SOCKET_ADDR_IPV4_ALL"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseIPv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "215-219",
          "snippet": "int\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "gateway"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"computing default address\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "addr"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    unsigned int recvbuflen;\n    unsigned int ifindex;\n    struct rtmsg rtmsg;\n    void *gatewayData = NULL;\n    void *addrData = NULL;\n    size_t addrDataLen;\n    int errCode;\n    virSocketAddr defaultAddr;\n    virSocketAddrPtr actualAddr;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n    g_autofree char *toStr = NULL;\n    g_autofree char *viaStr = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    actualAddr = addr;\n\n    /* If we have no valid network address, then use the default one */\n    if (!addr || !VIR_SOCKET_ADDR_VALID(addr)) {\n        VIR_DEBUG(\"computing default address\");\n        int family = VIR_SOCKET_ADDR_FAMILY(gateway);\n        if (family == AF_INET) {\n            if (virSocketAddrParseIPv4(&defaultAddr, VIR_SOCKET_ADDR_IPV4_ALL) < 0)\n                return -1;\n        } else {\n            if (virSocketAddrParseIPv6(&defaultAddr, VIR_SOCKET_ADDR_IPV6_ALL) < 0)\n                return -1;\n        }\n\n        actualAddr = &defaultAddr;\n    }\n\n    toStr = virSocketAddrFormat(actualAddr);\n    viaStr = virSocketAddrFormat(gateway);\n    VIR_DEBUG(\"Adding route %s/%d via %s\", toStr, prefix, viaStr);\n\n    if (virNetDevGetIPAddressBinary(actualAddr, &addrData, &addrDataLen) < 0 ||\n        virNetDevGetIPAddressBinary(gateway, &gatewayData, &addrDataLen) < 0)\n        return -1;\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return -1;\n\n    if (!(nlmsg = nlmsg_alloc_simple(RTM_NEWROUTE,\n                                     NLM_F_REQUEST | NLM_F_CREATE |\n                                     NLM_F_EXCL))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    memset(&rtmsg, 0, sizeof(rtmsg));\n\n    rtmsg.rtm_family = VIR_SOCKET_ADDR_FAMILY(gateway);\n    rtmsg.rtm_table = RT_TABLE_MAIN;\n    rtmsg.rtm_scope = RT_SCOPE_UNIVERSE;\n    rtmsg.rtm_protocol = RTPROT_BOOT;\n    rtmsg.rtm_type = RTN_UNICAST;\n    rtmsg.rtm_dst_len = prefix;\n\n    if (nlmsg_append(nlmsg, &rtmsg, sizeof(rtmsg), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (prefix > 0 && nla_put(nlmsg, RTA_DST, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, RTA_GATEWAY, addrDataLen, gatewayData) < 0)\n        goto buffer_too_small;\n\n    if (nla_put_u32(nlmsg, RTA_OIF, ifindex) < 0)\n        goto buffer_too_small;\n\n    if (metric > 0 && nla_put_u32(nlmsg, RTA_PRIORITY, metric) < 0)\n        goto buffer_too_small;\n\n    if (virNetlinkCommand(nlmsg, &resp, &recvbuflen, 0, 0,\n                          NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if ((errCode = virNetlinkGetErrorCode(resp, recvbuflen)) < 0) {\n        virReportSystemError(errCode, _(\"Error adding route to %s\"), ifname);\n        return -1;\n    }\n\n    return 0;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetDevIPAddrDel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "239-264",
    "snippet": "int\nvirNetDevIPAddrDel(const char *ifname,\n                   virSocketAddr *addr,\n                   unsigned int prefix)\n{\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    if (!(nlmsg = virNetDevCreateNetlinkAddressMessage(RTM_DELADDR, ifname,\n                                                       addr, prefix,\n                                                       NULL, NULL)))\n        return -1;\n\n    if (virNetlinkCommand(nlmsg, &resp, &recvbuflen, 0, 0,\n                          NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (virNetlinkGetErrorCode(resp, recvbuflen) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Error removing IP address from %s\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Error removing IP address from %s\")",
            "ifname"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Error removing IP address from %s\""
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkGetErrorCode",
          "args": [
            "resp",
            "recvbuflen"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkGetErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1378-1384",
          "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nlmsg",
            "&resp",
            "&recvbuflen",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevCreateNetlinkAddressMessage",
          "args": [
            "RTM_DELADDR",
            "ifname",
            "addr",
            "prefix",
            "NULL",
            "NULL"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevCreateNetlinkAddressMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "82-150",
          "snippet": "static struct nl_msg *\nvirNetDevCreateNetlinkAddressMessage(int messageType,\n                                     const char *ifname,\n                                     virSocketAddr *addr,\n                                     unsigned int prefix,\n                                     virSocketAddr *broadcast,\n                                     virSocketAddr *peer)\n{\n    struct nl_msg *nlmsg = NULL;\n    struct ifaddrmsg ifa;\n    unsigned int ifindex;\n    void *addrData = NULL;\n    void *peerData = NULL;\n    void *broadcastData = NULL;\n    size_t addrDataLen;\n\n    if (virNetDevGetIPAddressBinary(addr, &addrData, &addrDataLen) < 0)\n        return NULL;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer)) {\n        if (virNetDevGetIPAddressBinary(peer, &peerData, &addrDataLen) < 0)\n            return NULL;\n    } else if (broadcast) {\n        if (virNetDevGetIPAddressBinary(broadcast, &broadcastData,\n                                        &addrDataLen) < 0)\n            return NULL;\n    }\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(messageType,\n                                     NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n\n    ifa.ifa_prefixlen = prefix;\n    ifa.ifa_family = VIR_SOCKET_ADDR_FAMILY(addr);\n    ifa.ifa_index = ifindex;\n    ifa.ifa_scope = 0;\n\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, IFA_LOCAL, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (peerData) {\n        if (nla_put(nlmsg, IFA_ADDRESS, addrDataLen, peerData) < 0)\n            goto buffer_too_small;\n    }\n\n    if (broadcastData) {\n        if (nla_put(nlmsg, IFA_BROADCAST, addrDataLen, broadcastData) < 0)\n            goto buffer_too_small;\n    }\n\n    return nlmsg;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    nlmsg_free(nlmsg);\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic struct nl_msg *\nvirNetDevCreateNetlinkAddressMessage(int messageType,\n                                     const char *ifname,\n                                     virSocketAddr *addr,\n                                     unsigned int prefix,\n                                     virSocketAddr *broadcast,\n                                     virSocketAddr *peer)\n{\n    struct nl_msg *nlmsg = NULL;\n    struct ifaddrmsg ifa;\n    unsigned int ifindex;\n    void *addrData = NULL;\n    void *peerData = NULL;\n    void *broadcastData = NULL;\n    size_t addrDataLen;\n\n    if (virNetDevGetIPAddressBinary(addr, &addrData, &addrDataLen) < 0)\n        return NULL;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer)) {\n        if (virNetDevGetIPAddressBinary(peer, &peerData, &addrDataLen) < 0)\n            return NULL;\n    } else if (broadcast) {\n        if (virNetDevGetIPAddressBinary(broadcast, &broadcastData,\n                                        &addrDataLen) < 0)\n            return NULL;\n    }\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(messageType,\n                                     NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n\n    ifa.ifa_prefixlen = prefix;\n    ifa.ifa_family = VIR_SOCKET_ADDR_FAMILY(addr);\n    ifa.ifa_index = ifindex;\n    ifa.ifa_scope = 0;\n\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, IFA_LOCAL, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (peerData) {\n        if (nla_put(nlmsg, IFA_ADDRESS, addrDataLen, peerData) < 0)\n            goto buffer_too_small;\n    }\n\n    if (broadcastData) {\n        if (nla_put(nlmsg, IFA_BROADCAST, addrDataLen, broadcastData) < 0)\n            goto buffer_too_small;\n    }\n\n    return nlmsg;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    nlmsg_free(nlmsg);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrDel(const char *ifname,\n                   virSocketAddr *addr,\n                   unsigned int prefix)\n{\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    if (!(nlmsg = virNetDevCreateNetlinkAddressMessage(RTM_DELADDR, ifname,\n                                                       addr, prefix,\n                                                       NULL, NULL)))\n        return -1;\n\n    if (virNetlinkCommand(nlmsg, &resp, &recvbuflen, 0, 0,\n                          NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (virNetlinkGetErrorCode(resp, recvbuflen) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Error removing IP address from %s\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevIPAddrAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "165-226",
    "snippet": "int\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n    g_autoptr(virSocketAddr) broadcast = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n    g_autofree char *ipStr = NULL;\n    g_autofree char *peerStr = NULL;\n    g_autofree char *bcastStr = NULL;\n\n    ipStr = virSocketAddrFormat(addr);\n    if (peer && VIR_SOCKET_ADDR_VALID(peer))\n       peerStr = virSocketAddrFormat(peer);\n\n    /* The caller needs to provide a correct address */\n    if (VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET &&\n        !(peer && VIR_SOCKET_ADDR_VALID(peer))) {\n        /* compute a broadcast address if this is IPv4 */\n        if (VIR_ALLOC(broadcast) < 0)\n            return -1;\n\n        if (virSocketAddrBroadcastByPrefix(addr, prefix, broadcast) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine broadcast address for '%s/%d'\"),\n                           ipStr, prefix);\n            return -1;\n        }\n        bcastStr = virSocketAddrFormat(broadcast);\n    }\n\n    VIR_DEBUG(\"Adding IP address %s/%d%s%s%s%s to %s\",\n              NULLSTR(ipStr), prefix,\n              peerStr ? \" peer \" : \"\", peerStr ? peerStr : \"\",\n              bcastStr ? \" bcast \" : \"\", bcastStr ? bcastStr : \"\",\n              ifname);\n\n    if (!(nlmsg = virNetDevCreateNetlinkAddressMessage(RTM_NEWADDR, ifname,\n                                                       addr, prefix,\n                                                       broadcast, peer)))\n        return -1;\n\n    if (virNetlinkCommand(nlmsg, &resp, &recvbuflen,\n                          0, 0, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n\n    if (virNetlinkGetErrorCode(resp, recvbuflen) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to add IP address %s/%d%s%s%s%s to %s\"),\n                       ipStr, prefix,\n                       peerStr ? \" peer \" : \"\", peerStr ? peerStr : \"\",\n                       bcastStr ? \" bcast \" : \"\", bcastStr ? bcastStr : \"\",\n                       ifname);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Failed to add IP address %s/%d%s%s%s%s to %s\")",
            "ipStr",
            "prefix",
            "peerStr ? \" peer \" : \"\"",
            "peerStr ? peerStr : \"\"",
            "bcastStr ? \" bcast \" : \"\"",
            "bcastStr ? bcastStr : \"\"",
            "ifname"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to add IP address %s/%d%s%s%s%s to %s\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkGetErrorCode",
          "args": [
            "resp",
            "recvbuflen"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkGetErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1378-1384",
          "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nlmsg",
            "&resp",
            "&recvbuflen",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevCreateNetlinkAddressMessage",
          "args": [
            "RTM_NEWADDR",
            "ifname",
            "addr",
            "prefix",
            "broadcast",
            "peer"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevCreateNetlinkAddressMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "82-150",
          "snippet": "static struct nl_msg *\nvirNetDevCreateNetlinkAddressMessage(int messageType,\n                                     const char *ifname,\n                                     virSocketAddr *addr,\n                                     unsigned int prefix,\n                                     virSocketAddr *broadcast,\n                                     virSocketAddr *peer)\n{\n    struct nl_msg *nlmsg = NULL;\n    struct ifaddrmsg ifa;\n    unsigned int ifindex;\n    void *addrData = NULL;\n    void *peerData = NULL;\n    void *broadcastData = NULL;\n    size_t addrDataLen;\n\n    if (virNetDevGetIPAddressBinary(addr, &addrData, &addrDataLen) < 0)\n        return NULL;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer)) {\n        if (virNetDevGetIPAddressBinary(peer, &peerData, &addrDataLen) < 0)\n            return NULL;\n    } else if (broadcast) {\n        if (virNetDevGetIPAddressBinary(broadcast, &broadcastData,\n                                        &addrDataLen) < 0)\n            return NULL;\n    }\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(messageType,\n                                     NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n\n    ifa.ifa_prefixlen = prefix;\n    ifa.ifa_family = VIR_SOCKET_ADDR_FAMILY(addr);\n    ifa.ifa_index = ifindex;\n    ifa.ifa_scope = 0;\n\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, IFA_LOCAL, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (peerData) {\n        if (nla_put(nlmsg, IFA_ADDRESS, addrDataLen, peerData) < 0)\n            goto buffer_too_small;\n    }\n\n    if (broadcastData) {\n        if (nla_put(nlmsg, IFA_BROADCAST, addrDataLen, broadcastData) < 0)\n            goto buffer_too_small;\n    }\n\n    return nlmsg;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    nlmsg_free(nlmsg);\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic struct nl_msg *\nvirNetDevCreateNetlinkAddressMessage(int messageType,\n                                     const char *ifname,\n                                     virSocketAddr *addr,\n                                     unsigned int prefix,\n                                     virSocketAddr *broadcast,\n                                     virSocketAddr *peer)\n{\n    struct nl_msg *nlmsg = NULL;\n    struct ifaddrmsg ifa;\n    unsigned int ifindex;\n    void *addrData = NULL;\n    void *peerData = NULL;\n    void *broadcastData = NULL;\n    size_t addrDataLen;\n\n    if (virNetDevGetIPAddressBinary(addr, &addrData, &addrDataLen) < 0)\n        return NULL;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer)) {\n        if (virNetDevGetIPAddressBinary(peer, &peerData, &addrDataLen) < 0)\n            return NULL;\n    } else if (broadcast) {\n        if (virNetDevGetIPAddressBinary(broadcast, &broadcastData,\n                                        &addrDataLen) < 0)\n            return NULL;\n    }\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(messageType,\n                                     NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n\n    ifa.ifa_prefixlen = prefix;\n    ifa.ifa_family = VIR_SOCKET_ADDR_FAMILY(addr);\n    ifa.ifa_index = ifindex;\n    ifa.ifa_scope = 0;\n\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, IFA_LOCAL, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (peerData) {\n        if (nla_put(nlmsg, IFA_ADDRESS, addrDataLen, peerData) < 0)\n            goto buffer_too_small;\n    }\n\n    if (broadcastData) {\n        if (nla_put(nlmsg, IFA_BROADCAST, addrDataLen, broadcastData) < 0)\n            goto buffer_too_small;\n    }\n\n    return nlmsg;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    nlmsg_free(nlmsg);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding IP address %s/%d%s%s%s%s to %s\"",
            "NULLSTR(ipStr)",
            "prefix",
            "peerStr ? \" peer \" : \"\"",
            "peerStr ? peerStr : \"\"",
            "bcastStr ? \" bcast \" : \"\"",
            "bcastStr ? bcastStr : \"\"",
            "ifname"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "ipStr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "broadcast"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to determine broadcast address for '%s/%d'\")",
            "ipStr",
            "prefix"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrBroadcastByPrefix",
          "args": [
            "addr",
            "prefix",
            "broadcast"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrBroadcastByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "738-750",
          "snippet": "int\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "broadcast"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "peer"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "addr"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "peer"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nlmsg = NULL;\n    g_autoptr(virSocketAddr) broadcast = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n    g_autofree char *ipStr = NULL;\n    g_autofree char *peerStr = NULL;\n    g_autofree char *bcastStr = NULL;\n\n    ipStr = virSocketAddrFormat(addr);\n    if (peer && VIR_SOCKET_ADDR_VALID(peer))\n       peerStr = virSocketAddrFormat(peer);\n\n    /* The caller needs to provide a correct address */\n    if (VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET &&\n        !(peer && VIR_SOCKET_ADDR_VALID(peer))) {\n        /* compute a broadcast address if this is IPv4 */\n        if (VIR_ALLOC(broadcast) < 0)\n            return -1;\n\n        if (virSocketAddrBroadcastByPrefix(addr, prefix, broadcast) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to determine broadcast address for '%s/%d'\"),\n                           ipStr, prefix);\n            return -1;\n        }\n        bcastStr = virSocketAddrFormat(broadcast);\n    }\n\n    VIR_DEBUG(\"Adding IP address %s/%d%s%s%s%s to %s\",\n              NULLSTR(ipStr), prefix,\n              peerStr ? \" peer \" : \"\", peerStr ? peerStr : \"\",\n              bcastStr ? \" bcast \" : \"\", bcastStr ? bcastStr : \"\",\n              ifname);\n\n    if (!(nlmsg = virNetDevCreateNetlinkAddressMessage(RTM_NEWADDR, ifname,\n                                                       addr, prefix,\n                                                       broadcast, peer)))\n        return -1;\n\n    if (virNetlinkCommand(nlmsg, &resp, &recvbuflen,\n                          0, 0, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n\n    if (virNetlinkGetErrorCode(resp, recvbuflen) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to add IP address %s/%d%s%s%s%s to %s\"),\n                       ipStr, prefix,\n                       peerStr ? \" peer \" : \"\", peerStr ? peerStr : \"\",\n                       bcastStr ? \" bcast \" : \"\", bcastStr ? bcastStr : \"\",\n                       ifname);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevCreateNetlinkAddressMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "82-150",
    "snippet": "static struct nl_msg *\nvirNetDevCreateNetlinkAddressMessage(int messageType,\n                                     const char *ifname,\n                                     virSocketAddr *addr,\n                                     unsigned int prefix,\n                                     virSocketAddr *broadcast,\n                                     virSocketAddr *peer)\n{\n    struct nl_msg *nlmsg = NULL;\n    struct ifaddrmsg ifa;\n    unsigned int ifindex;\n    void *addrData = NULL;\n    void *peerData = NULL;\n    void *broadcastData = NULL;\n    size_t addrDataLen;\n\n    if (virNetDevGetIPAddressBinary(addr, &addrData, &addrDataLen) < 0)\n        return NULL;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer)) {\n        if (virNetDevGetIPAddressBinary(peer, &peerData, &addrDataLen) < 0)\n            return NULL;\n    } else if (broadcast) {\n        if (virNetDevGetIPAddressBinary(broadcast, &broadcastData,\n                                        &addrDataLen) < 0)\n            return NULL;\n    }\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(messageType,\n                                     NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n\n    ifa.ifa_prefixlen = prefix;\n    ifa.ifa_family = VIR_SOCKET_ADDR_FAMILY(addr);\n    ifa.ifa_index = ifindex;\n    ifa.ifa_scope = 0;\n\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, IFA_LOCAL, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (peerData) {\n        if (nla_put(nlmsg, IFA_ADDRESS, addrDataLen, peerData) < 0)\n            goto buffer_too_small;\n    }\n\n    if (broadcastData) {\n        if (nla_put(nlmsg, IFA_BROADCAST, addrDataLen, broadcastData) < 0)\n            goto buffer_too_small;\n    }\n\n    return nlmsg;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    nlmsg_free(nlmsg);\n    return NULL;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nlmsg"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nlmsg",
            "IFA_BROADCAST",
            "addrDataLen",
            "broadcastData"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nlmsg",
            "IFA_ADDRESS",
            "addrDataLen",
            "peerData"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nlmsg",
            "IFA_LOCAL",
            "addrDataLen",
            "addrData"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nlmsg",
            "&ifa",
            "sizeof(ifa)",
            "NLMSG_ALIGNTO"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "addr"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifa",
            "0",
            "sizeof(ifa)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "messageType",
            "NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "ifname"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetIPAddressBinary",
          "args": [
            "broadcast",
            "&broadcastData",
            "&addrDataLen"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIPAddressBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "61-80",
          "snippet": "static int\nvirNetDevGetIPAddressBinary(virSocketAddr *addr, void **data, size_t *len)\n{\n    if (!addr)\n        return -1;\n\n    switch (VIR_SOCKET_ADDR_FAMILY(addr)) {\n    case AF_INET:\n        *data = &addr->data.inet4.sin_addr;\n        *len = sizeof(struct in_addr);\n        break;\n    case AF_INET6:\n        *data = &addr->data.inet6.sin6_addr;\n        *len = sizeof(struct in6_addr);\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetIPAddressBinary(virSocketAddr *addr, void **data, size_t *len)\n{\n    if (!addr)\n        return -1;\n\n    switch (VIR_SOCKET_ADDR_FAMILY(addr)) {\n    case AF_INET:\n        *data = &addr->data.inet4.sin_addr;\n        *len = sizeof(struct in_addr);\n        break;\n    case AF_INET6:\n        *data = &addr->data.inet6.sin6_addr;\n        *len = sizeof(struct in6_addr);\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "peer"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic struct nl_msg *\nvirNetDevCreateNetlinkAddressMessage(int messageType,\n                                     const char *ifname,\n                                     virSocketAddr *addr,\n                                     unsigned int prefix,\n                                     virSocketAddr *broadcast,\n                                     virSocketAddr *peer)\n{\n    struct nl_msg *nlmsg = NULL;\n    struct ifaddrmsg ifa;\n    unsigned int ifindex;\n    void *addrData = NULL;\n    void *peerData = NULL;\n    void *broadcastData = NULL;\n    size_t addrDataLen;\n\n    if (virNetDevGetIPAddressBinary(addr, &addrData, &addrDataLen) < 0)\n        return NULL;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer)) {\n        if (virNetDevGetIPAddressBinary(peer, &peerData, &addrDataLen) < 0)\n            return NULL;\n    } else if (broadcast) {\n        if (virNetDevGetIPAddressBinary(broadcast, &broadcastData,\n                                        &addrDataLen) < 0)\n            return NULL;\n    }\n\n    /* Get the interface index */\n    if ((ifindex = if_nametoindex(ifname)) == 0)\n        return NULL;\n\n    if (!(nlmsg = nlmsg_alloc_simple(messageType,\n                                     NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    memset(&ifa, 0, sizeof(ifa));\n\n    ifa.ifa_prefixlen = prefix;\n    ifa.ifa_family = VIR_SOCKET_ADDR_FAMILY(addr);\n    ifa.ifa_index = ifindex;\n    ifa.ifa_scope = 0;\n\n    if (nlmsg_append(nlmsg, &ifa, sizeof(ifa), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nlmsg, IFA_LOCAL, addrDataLen, addrData) < 0)\n        goto buffer_too_small;\n\n    if (peerData) {\n        if (nla_put(nlmsg, IFA_ADDRESS, addrDataLen, peerData) < 0)\n            goto buffer_too_small;\n    }\n\n    if (broadcastData) {\n        if (nla_put(nlmsg, IFA_BROADCAST, addrDataLen, broadcastData) < 0)\n            goto buffer_too_small;\n    }\n\n    return nlmsg;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    nlmsg_free(nlmsg);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetDevGetIPAddressBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
    "lines": "61-80",
    "snippet": "static int\nvirNetDevGetIPAddressBinary(virSocketAddr *addr, void **data, size_t *len)\n{\n    if (!addr)\n        return -1;\n\n    switch (VIR_SOCKET_ADDR_FAMILY(addr)) {\n    case AF_INET:\n        *data = &addr->data.inet4.sin_addr;\n        *len = sizeof(struct in_addr);\n        break;\n    case AF_INET6:\n        *data = &addr->data.inet6.sin6_addr;\n        *len = sizeof(struct in6_addr);\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "# include <linux/if_vlan.h>",
      "# include <linux/sockios.h>",
      "#include <fcntl.h>",
      "# include <net/if.h>",
      "# include <sys/ioctl.h>",
      "# include <ifaddrs.h>",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetdevip.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "addr"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nstatic int\nvirNetDevGetIPAddressBinary(virSocketAddr *addr, void **data, size_t *len)\n{\n    if (!addr)\n        return -1;\n\n    switch (VIR_SOCKET_ADDR_FAMILY(addr)) {\n    case AF_INET:\n        *data = &addr->data.inet4.sin_addr;\n        *len = sizeof(struct in_addr);\n        break;\n    case AF_INET6:\n        *data = &addr->data.inet6.sin6_addr;\n        *len = sizeof(struct in6_addr);\n        break;\n    default:\n        return -1;\n    }\n    return 0;\n}"
  }
]