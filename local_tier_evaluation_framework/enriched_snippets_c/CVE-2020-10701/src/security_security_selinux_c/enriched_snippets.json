[
  {
    "function_name": "virSecuritySELinuxRestoreTPMLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3521-3542",
    "snippet": "static int\nvirSecuritySELinuxRestoreTPMLabels(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def)\n{\n    int ret = 0;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecuritySELinuxRestoreFileLabels(\n            mgr, def->tpm->data.emulator.storagepath);\n        if (ret == 0 && def->tpm->data.emulator.logfile)\n            ret = virSecuritySELinuxRestoreFileLabels(\n                mgr, def->tpm->data.emulator.logfile);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabels",
          "args": [
            "mgr",
            "def->tpm->data.emulator.logfile"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "3455-3487",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabels(virSecurityManagerPtr mgr,\n                                    const char *path)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, filename, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to restore file labels under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreFileLabels(virSecurityManagerPtr mgr,\n                                    const char *path)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, filename, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to restore file labels under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxRestoreTPMLabels(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def)\n{\n    int ret = 0;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecuritySELinuxRestoreFileLabels(\n            mgr, def->tpm->data.emulator.storagepath);\n        if (ret == 0 && def->tpm->data.emulator.logfile)\n            ret = virSecuritySELinuxRestoreFileLabels(\n                mgr, def->tpm->data.emulator.logfile);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetTPMLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3490-3518",
    "snippet": "static int\nvirSecuritySELinuxSetTPMLabels(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def)\n{\n    int ret = 0;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecuritySELinuxSetFileLabels(\n            mgr, def->tpm->data.emulator.storagepath,\n            seclabel);\n        if (ret == 0 && def->tpm->data.emulator.logfile)\n            ret = virSecuritySELinuxSetFileLabels(\n                mgr, def->tpm->data.emulator.logfile,\n                seclabel);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFileLabels",
          "args": [
            "mgr",
            "def->tpm->data.emulator.logfile",
            "seclabel"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFileLabels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "3408-3442",
          "snippet": "static int\nvirSecuritySELinuxSetFileLabels(virSecurityManagerPtr mgr,\n                                const char *path,\n                                virSecurityLabelDefPtr seclabel)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxSetFilecon(mgr, path, seclabel->imagelabel, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxSetFilecon(mgr, filename,\n                                           seclabel->imagelabel, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to label files under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetFileLabels(virSecurityManagerPtr mgr,\n                                const char *path,\n                                virSecurityLabelDefPtr seclabel)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxSetFilecon(mgr, path, seclabel->imagelabel, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxSetFilecon(mgr, filename,\n                                           seclabel->imagelabel, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to label files under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxSetTPMLabels(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def)\n{\n    int ret = 0;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecuritySELinuxSetFileLabels(\n            mgr, def->tpm->data.emulator.storagepath,\n            seclabel);\n        if (ret == 0 && def->tpm->data.emulator.logfile)\n            ret = virSecuritySELinuxSetFileLabels(\n                mgr, def->tpm->data.emulator.logfile,\n                seclabel);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreFileLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3455-3487",
    "snippet": "static int\nvirSecuritySELinuxRestoreFileLabels(virSecurityManagerPtr mgr,\n                                    const char *path)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, filename, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to restore file labels under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDirClose",
          "args": [
            "&dir"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "virDirClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2956-2963",
          "snippet": "void virDirClose(DIR **dirp)\n{\n    if (!*dirp)\n        return;\n\n    closedir(*dirp); /* exempt from syntax-check */\n    *dirp = NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nvoid virDirClose(DIR **dirp)\n{\n    if (!*dirp)\n        return;\n\n    closedir(*dirp); /* exempt from syntax-check */\n    *dirp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to restore file labels under %s\")",
            "path"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to restore file labels under %s\""
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filename"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "filename",
            "true"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "path",
            "ent->d_name"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&ent",
            "path"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dir",
            "path"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsDir",
          "args": [
            "path"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1850-1855",
          "snippet": "bool\nvirFileIsDir(const char *path)\n{\n    struct stat s;\n    return (stat(path, &s) == 0) && S_ISDIR(s.st_mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsDir(const char *path)\n{\n    struct stat s;\n    return (stat(path, &s) == 0) && S_ISDIR(s.st_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreFileLabels(virSecurityManagerPtr mgr,\n                                    const char *path)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, filename, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to restore file labels under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetFileLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3408-3442",
    "snippet": "static int\nvirSecuritySELinuxSetFileLabels(virSecurityManagerPtr mgr,\n                                const char *path,\n                                virSecurityLabelDefPtr seclabel)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxSetFilecon(mgr, path, seclabel->imagelabel, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxSetFilecon(mgr, filename,\n                                           seclabel->imagelabel, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to label files under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDirClose",
          "args": [
            "&dir"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "virDirClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2956-2963",
          "snippet": "void virDirClose(DIR **dirp)\n{\n    if (!*dirp)\n        return;\n\n    closedir(*dirp); /* exempt from syntax-check */\n    *dirp = NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nvoid virDirClose(DIR **dirp)\n{\n    if (!*dirp)\n        return;\n\n    closedir(*dirp); /* exempt from syntax-check */\n    *dirp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to label files under %s\")",
            "path"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to label files under %s\""
          ],
          "line": 3436
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filename"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "filename",
            "seclabel->imagelabel",
            "true"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "path",
            "ent->d_name"
          ],
          "line": 3428
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&ent",
            "path"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dir",
            "path"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsDir",
          "args": [
            "path"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1850-1855",
          "snippet": "bool\nvirFileIsDir(const char *path)\n{\n    struct stat s;\n    return (stat(path, &s) == 0) && S_ISDIR(s.st_mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsDir(const char *path)\n{\n    struct stat s;\n    return (stat(path, &s) == 0) && S_ISDIR(s.st_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetFileLabels(virSecurityManagerPtr mgr,\n                                const char *path,\n                                virSecurityLabelDefPtr seclabel)\n{\n    int ret = 0;\n    struct dirent *ent;\n    char *filename = NULL;\n    DIR *dir;\n\n    if ((ret = virSecuritySELinuxSetFilecon(mgr, path, seclabel->imagelabel, true)))\n        return ret;\n\n    if (!virFileIsDir(path))\n        return 0;\n\n    if (virDirOpen(&dir, path) < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &ent, path)) > 0) {\n        filename = g_strdup_printf(\"%s/%s\", path, ent->d_name);\n        ret = virSecuritySELinuxSetFilecon(mgr, filename,\n                                           seclabel->imagelabel, true);\n        VIR_FREE(filename);\n        if (ret < 0)\n            break;\n    }\n    if (ret < 0)\n        virReportSystemError(errno, _(\"Unable to label files under %s\"),\n                             path);\n\n    virDirClose(&dir);\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxDomainSetPathLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3381-3394",
    "snippet": "static int\nvirSecuritySELinuxDomainSetPathLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     const char *path,\n                                     bool allowSubtree G_GNUC_UNUSED)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    return virSecuritySELinuxSetFilecon(mgr, path, seclabel->imagelabel, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "path",
            "seclabel->imagelabel",
            "true"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxDomainSetPathLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     const char *path,\n                                     bool allowSubtree G_GNUC_UNUSED)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    return virSecuritySELinuxSetFilecon(mgr, path, seclabel->imagelabel, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxGetSecurityMountOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3355-3379",
    "snippet": "static char *\nvirSecuritySELinuxGetSecurityMountOptions(virSecurityManagerPtr mgr,\n                                          virDomainDefPtr def)\n{\n    char *opts = NULL;\n    virSecurityLabelDefPtr secdef;\n\n    if ((secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME))) {\n        if (!secdef->imagelabel)\n            secdef->imagelabel = virSecuritySELinuxGenImageLabel(mgr, def);\n\n        if (secdef->imagelabel) {\n            opts = g_strdup_printf(\n                                   \",context=\\\"%s\\\"\",\n                                   (const char*) secdef->imagelabel);\n        }\n    }\n\n    if (!opts)\n        opts = g_strdup(\"\");\n\n    VIR_DEBUG(\"imageLabel=%s opts=%s\",\n              secdef ? secdef->imagelabel : \"(null)\", opts);\n    return opts;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"imageLabel=%s opts=%s\"",
            "secdef ? secdef->imagelabel : \"(null)\"",
            "opts"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"\""
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxGenImageLabel",
          "args": [
            "mgr",
            "def"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxGenImageLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "3318-3353",
          "snippet": "static char *\nvirSecuritySELinuxGenImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    const char *range;\n    context_t ctx = NULL;\n    char *label = NULL;\n    char *mcs = NULL;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        goto cleanup;\n\n    if (secdef->label) {\n        ctx = context_new(secdef->label);\n        if (!ctx) {\n            virReportSystemError(errno, _(\"unable to create selinux context for: %s\"),\n                                 secdef->label);\n            goto cleanup;\n        }\n        range = context_range_get(ctx);\n        if (range) {\n            mcs = g_strdup(range);\n            if (!(label = virSecuritySELinuxGenNewContext(data->file_context,\n                                                          mcs, true)))\n                goto cleanup;\n        }\n    }\n\n cleanup:\n    context_free(ctx);\n    VIR_FREE(mcs);\n    return label;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic char *\nvirSecuritySELinuxGenImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    const char *range;\n    context_t ctx = NULL;\n    char *label = NULL;\n    char *mcs = NULL;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        goto cleanup;\n\n    if (secdef->label) {\n        ctx = context_new(secdef->label);\n        if (!ctx) {\n            virReportSystemError(errno, _(\"unable to create selinux context for: %s\"),\n                                 secdef->label);\n            goto cleanup;\n        }\n        range = context_range_get(ctx);\n        if (range) {\n            mcs = g_strdup(range);\n            if (!(label = virSecuritySELinuxGenNewContext(data->file_context,\n                                                          mcs, true)))\n                goto cleanup;\n        }\n    }\n\n cleanup:\n    context_free(ctx);\n    VIR_FREE(mcs);\n    return label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic char *\nvirSecuritySELinuxGetSecurityMountOptions(virSecurityManagerPtr mgr,\n                                          virDomainDefPtr def)\n{\n    char *opts = NULL;\n    virSecurityLabelDefPtr secdef;\n\n    if ((secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME))) {\n        if (!secdef->imagelabel)\n            secdef->imagelabel = virSecuritySELinuxGenImageLabel(mgr, def);\n\n        if (secdef->imagelabel) {\n            opts = g_strdup_printf(\n                                   \",context=\\\"%s\\\"\",\n                                   (const char*) secdef->imagelabel);\n        }\n    }\n\n    if (!opts)\n        opts = g_strdup(\"\");\n\n    VIR_DEBUG(\"imageLabel=%s opts=%s\",\n              secdef ? secdef->imagelabel : \"(null)\", opts);\n    return opts;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGenImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3318-3353",
    "snippet": "static char *\nvirSecuritySELinuxGenImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    const char *range;\n    context_t ctx = NULL;\n    char *label = NULL;\n    char *mcs = NULL;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        goto cleanup;\n\n    if (secdef->label) {\n        ctx = context_new(secdef->label);\n        if (!ctx) {\n            virReportSystemError(errno, _(\"unable to create selinux context for: %s\"),\n                                 secdef->label);\n            goto cleanup;\n        }\n        range = context_range_get(ctx);\n        if (range) {\n            mcs = g_strdup(range);\n            if (!(label = virSecuritySELinuxGenNewContext(data->file_context,\n                                                          mcs, true)))\n                goto cleanup;\n        }\n    }\n\n cleanup:\n    context_free(ctx);\n    VIR_FREE(mcs);\n    return label;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mcs"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "ctx"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxGenNewContext",
          "args": [
            "data->file_context",
            "mcs",
            "true"
          ],
          "line": 3343
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxGenNewContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "570-639",
          "snippet": "static char *\nvirSecuritySELinuxGenNewContext(const char *basecontext,\n                                const char *mcs,\n                                bool isObjectContext)\n{\n    context_t context = NULL;\n    char *ret = NULL;\n    char *str;\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n\n    VIR_DEBUG(\"basecontext=%s mcs=%s isObjectContext=%d\",\n              basecontext, mcs, isObjectContext);\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    VIR_DEBUG(\"process=%s\", ourSecContext);\n\n    if (!(context = context_new(basecontext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse base SELinux context '%s'\"),\n                             basecontext);\n        goto cleanup;\n    }\n\n    if (context_user_set(context,\n                         context_user_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context user '%s'\"),\n                             context_user_get(ourContext));\n        goto cleanup;\n    }\n\n    if (!isObjectContext &&\n        context_role_set(context,\n                         context_role_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context role '%s'\"),\n                             context_role_get(ourContext));\n        goto cleanup;\n    }\n\n    if (context_range_set(context, mcs) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context MCS '%s'\"),\n                             mcs);\n        goto cleanup;\n    }\n    if (!(str = context_str(context))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n    ret = g_strdup(str);\n    VIR_DEBUG(\"Generated context '%s'\",  ret);\n cleanup:\n    freecon(ourSecContext);\n    context_free(ourContext);\n    context_free(context);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxGenNewContext(const char *basecontext,\n                                const char *mcs,\n                                bool isObjectContext)\n{\n    context_t context = NULL;\n    char *ret = NULL;\n    char *str;\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n\n    VIR_DEBUG(\"basecontext=%s mcs=%s isObjectContext=%d\",\n              basecontext, mcs, isObjectContext);\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    VIR_DEBUG(\"process=%s\", ourSecContext);\n\n    if (!(context = context_new(basecontext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse base SELinux context '%s'\"),\n                             basecontext);\n        goto cleanup;\n    }\n\n    if (context_user_set(context,\n                         context_user_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context user '%s'\"),\n                             context_user_get(ourContext));\n        goto cleanup;\n    }\n\n    if (!isObjectContext &&\n        context_role_set(context,\n                         context_role_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context role '%s'\"),\n                             context_role_get(ourContext));\n        goto cleanup;\n    }\n\n    if (context_range_set(context, mcs) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context MCS '%s'\"),\n                             mcs);\n        goto cleanup;\n    }\n    if (!(str = context_str(context))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n    ret = g_strdup(str);\n    VIR_DEBUG(\"Generated context '%s'\",  ret);\n cleanup:\n    freecon(ourSecContext);\n    context_free(ourContext);\n    context_free(context);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "range"
          ],
          "line": 3342
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "ctx"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to create selinux context for: %s\")",
            "secdef->label"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to create selinux context for: %s\""
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "secdef->label"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic char *\nvirSecuritySELinuxGenImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    const char *range;\n    context_t ctx = NULL;\n    char *label = NULL;\n    char *mcs = NULL;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        goto cleanup;\n\n    if (secdef->label) {\n        ctx = context_new(secdef->label);\n        if (!ctx) {\n            virReportSystemError(errno, _(\"unable to create selinux context for: %s\"),\n                                 secdef->label);\n            goto cleanup;\n        }\n        range = context_range_get(ctx);\n        if (range) {\n            mcs = g_strdup(range);\n            if (!(label = virSecuritySELinuxGenNewContext(data->file_context,\n                                                          mcs, true)))\n                goto cleanup;\n        }\n    }\n\n cleanup:\n    context_free(ctx);\n    VIR_FREE(mcs);\n    return label;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetTapFDLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3256-3316",
    "snippet": "static int\nvirSecuritySELinuxSetTapFDLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                int fd)\n{\n    struct stat buf;\n    security_context_t fcon = NULL;\n    virSecurityLabelDefPtr secdef;\n    char *str = NULL, *proc = NULL, *fd_path = NULL;\n    int rc = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (fstat(fd, &buf) < 0) {\n        virReportSystemError(errno, _(\"cannot stat tap fd %d\"), fd);\n        goto cleanup;\n    }\n\n    if ((buf.st_mode & S_IFMT) != S_IFCHR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"tap fd %d is not character device\"), fd);\n        goto cleanup;\n    }\n\n    /* Label /dev/tap([0-9]+)? devices only. Leave /dev/net/tun alone! */\n    proc = g_strdup_printf(\"/proc/self/fd/%d\", fd);\n\n    if (virFileResolveLink(proc, &fd_path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to resolve link: %s\"), proc);\n        goto cleanup;\n    }\n\n    if (!STRPREFIX(fd_path, \"/dev/tap\")) {\n        VIR_DEBUG(\"fd=%d points to %s not setting SELinux label\",\n                  fd, fd_path);\n        rc = 0;\n        goto cleanup;\n    }\n\n    if (getContext(mgr, fd_path, buf.st_mode, &fcon) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot lookup default selinux label for tap fd %d\"), fd);\n        goto cleanup;\n    }\n\n    if (!(str = virSecuritySELinuxContextAddRange(secdef->label, fcon))) {\n        goto cleanup;\n    } else {\n        rc = virSecuritySELinuxFSetFilecon(fd, str);\n    }\n\n cleanup:\n    freecon(fcon);\n    VIR_FREE(fd_path);\n    VIR_FREE(proc);\n    VIR_FREE(str);\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "proc"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fd_path"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "fcon"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxFSetFilecon",
          "args": [
            "fd",
            "str"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxFSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1412-1438",
          "snippet": "static int\nvirSecuritySELinuxFSetFilecon(int fd, char *tcon)\n{\n    VIR_INFO(\"Setting SELinux context on fd %d to '%s'\", fd, tcon);\n\n    if (fsetfilecon_raw(fd, tcon) < 0) {\n        int fsetfilecon_errno = errno;\n\n        /* if the error complaint is related to an image hosted on\n         * an nfs mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.\n         * The user hopefully set one of the necessary SELinux\n         * virt_use_{nfs,usb,pci}  boolean tunables to allow it...\n         */\n        if (fsetfilecon_errno != EOPNOTSUPP) {\n            virReportSystemError(fsetfilecon_errno,\n                                 _(\"unable to set security context '%s' on fd %d\"),\n                                 tcon, fd);\n            if (security_getenforce() == 1)\n                return -1;\n        } else {\n            VIR_INFO(\"Setting security context '%s' on fd %d not supported\",\n                     tcon, fd);\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxFSetFilecon(int fd, char *tcon)\n{\n    VIR_INFO(\"Setting SELinux context on fd %d to '%s'\", fd, tcon);\n\n    if (fsetfilecon_raw(fd, tcon) < 0) {\n        int fsetfilecon_errno = errno;\n\n        /* if the error complaint is related to an image hosted on\n         * an nfs mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.\n         * The user hopefully set one of the necessary SELinux\n         * virt_use_{nfs,usb,pci}  boolean tunables to allow it...\n         */\n        if (fsetfilecon_errno != EOPNOTSUPP) {\n            virReportSystemError(fsetfilecon_errno,\n                                 _(\"unable to set security context '%s' on fd %d\"),\n                                 tcon, fd);\n            if (security_getenforce() == 1)\n                return -1;\n        } else {\n            VIR_INFO(\"Setting security context '%s' on fd %d not supported\",\n                     tcon, fd);\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextAddRange",
          "args": [
            "secdef->label",
            "fcon"
          ],
          "line": 3304
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextAddRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "532-568",
          "snippet": "static char *\nvirSecuritySELinuxContextAddRange(security_context_t src,\n                                  security_context_t dst)\n{\n    char *str = NULL;\n    char *ret = NULL;\n    context_t srccon = NULL;\n    context_t dstcon = NULL;\n\n    if (!src || !dst)\n        return ret;\n\n    if (!(srccon = context_new(src)) || !(dstcon = context_new(dst))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to allocate security context\"));\n        goto cleanup;\n    }\n\n    if (context_range_set(dstcon, context_range_get(srccon)) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context range '%s'\"), dst);\n        goto cleanup;\n    }\n\n    if (!(str = context_str(dstcon))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(str);\n\n cleanup:\n    if (srccon) context_free(srccon);\n    if (dstcon) context_free(dstcon);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxContextAddRange(security_context_t src,\n                                  security_context_t dst)\n{\n    char *str = NULL;\n    char *ret = NULL;\n    context_t srccon = NULL;\n    context_t dstcon = NULL;\n\n    if (!src || !dst)\n        return ret;\n\n    if (!(srccon = context_new(src)) || !(dstcon = context_new(dst))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to allocate security context\"));\n        goto cleanup;\n    }\n\n    if (context_range_set(dstcon, context_range_get(srccon)) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context range '%s'\"), dst);\n        goto cleanup;\n    }\n\n    if (!(str = context_str(dstcon))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(str);\n\n cleanup:\n    if (srccon) context_free(srccon);\n    if (dstcon) context_free(dstcon);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot lookup default selinux label for tap fd %d\")",
            "fd"
          ],
          "line": 3299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot lookup default selinux label for tap fd %d\""
          ],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getContext",
          "args": [
            "mgr",
            "fd_path",
            "buf.st_mode",
            "&fcon"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "getContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1441-1448",
          "snippet": "static int\ngetContext(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n           const char *newpath, mode_t mode, security_context_t *fcon)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    return selabel_lookup_raw(data->label_handle, fcon, newpath, mode);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\ngetContext(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n           const char *newpath, mode_t mode, security_context_t *fcon)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    return selabel_lookup_raw(data->label_handle, fcon, newpath, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"fd=%d points to %s not setting SELinux label\"",
            "fd",
            "fd_path"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "fd_path",
            "\"/dev/tap\""
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to resolve link: %s\")",
            "proc"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "proc",
            "&fd_path"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/self/fd/%d\"",
            "fd"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"tap fd %d is not character device\")",
            "fd"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat tap fd %d\")",
            "fd"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&buf"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetTapFDLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                int fd)\n{\n    struct stat buf;\n    security_context_t fcon = NULL;\n    virSecurityLabelDefPtr secdef;\n    char *str = NULL, *proc = NULL, *fd_path = NULL;\n    int rc = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (fstat(fd, &buf) < 0) {\n        virReportSystemError(errno, _(\"cannot stat tap fd %d\"), fd);\n        goto cleanup;\n    }\n\n    if ((buf.st_mode & S_IFMT) != S_IFCHR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"tap fd %d is not character device\"), fd);\n        goto cleanup;\n    }\n\n    /* Label /dev/tap([0-9]+)? devices only. Leave /dev/net/tun alone! */\n    proc = g_strdup_printf(\"/proc/self/fd/%d\", fd);\n\n    if (virFileResolveLink(proc, &fd_path) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to resolve link: %s\"), proc);\n        goto cleanup;\n    }\n\n    if (!STRPREFIX(fd_path, \"/dev/tap\")) {\n        VIR_DEBUG(\"fd=%d points to %s not setting SELinux label\",\n                  fd, fd_path);\n        rc = 0;\n        goto cleanup;\n    }\n\n    if (getContext(mgr, fd_path, buf.st_mode, &fcon) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot lookup default selinux label for tap fd %d\"), fd);\n        goto cleanup;\n    }\n\n    if (!(str = virSecuritySELinuxContextAddRange(secdef->label, fcon))) {\n        goto cleanup;\n    } else {\n        rc = virSecuritySELinuxFSetFilecon(fd, str);\n    }\n\n cleanup:\n    freecon(fcon);\n    VIR_FREE(fd_path);\n    VIR_FREE(proc);\n    VIR_FREE(str);\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetImageFDLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3242-3254",
    "snippet": "static int\nvirSecuritySELinuxSetImageFDLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                  virDomainDefPtr def,\n                                  int fd)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->imagelabel)\n        return 0;\n\n    return virSecuritySELinuxFSetFilecon(fd, secdef->imagelabel);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxFSetFilecon",
          "args": [
            "fd",
            "secdef->imagelabel"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxFSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1412-1438",
          "snippet": "static int\nvirSecuritySELinuxFSetFilecon(int fd, char *tcon)\n{\n    VIR_INFO(\"Setting SELinux context on fd %d to '%s'\", fd, tcon);\n\n    if (fsetfilecon_raw(fd, tcon) < 0) {\n        int fsetfilecon_errno = errno;\n\n        /* if the error complaint is related to an image hosted on\n         * an nfs mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.\n         * The user hopefully set one of the necessary SELinux\n         * virt_use_{nfs,usb,pci}  boolean tunables to allow it...\n         */\n        if (fsetfilecon_errno != EOPNOTSUPP) {\n            virReportSystemError(fsetfilecon_errno,\n                                 _(\"unable to set security context '%s' on fd %d\"),\n                                 tcon, fd);\n            if (security_getenforce() == 1)\n                return -1;\n        } else {\n            VIR_INFO(\"Setting security context '%s' on fd %d not supported\",\n                     tcon, fd);\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxFSetFilecon(int fd, char *tcon)\n{\n    VIR_INFO(\"Setting SELinux context on fd %d to '%s'\", fd, tcon);\n\n    if (fsetfilecon_raw(fd, tcon) < 0) {\n        int fsetfilecon_errno = errno;\n\n        /* if the error complaint is related to an image hosted on\n         * an nfs mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.\n         * The user hopefully set one of the necessary SELinux\n         * virt_use_{nfs,usb,pci}  boolean tunables to allow it...\n         */\n        if (fsetfilecon_errno != EOPNOTSUPP) {\n            virReportSystemError(fsetfilecon_errno,\n                                 _(\"unable to set security context '%s' on fd %d\"),\n                                 tcon, fd);\n            if (security_getenforce() == 1)\n                return -1;\n        } else {\n            VIR_INFO(\"Setting security context '%s' on fd %d not supported\",\n                     tcon, fd);\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetImageFDLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                  virDomainDefPtr def,\n                                  int fd)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->imagelabel)\n        return 0;\n\n    return virSecuritySELinuxFSetFilecon(fd, secdef->imagelabel);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3135-3240",
    "snippet": "static int\nvirSecuritySELinuxSetAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              const char *stdin_path,\n                              bool chardevStdioLogd,\n                              bool migrated G_GNUC_UNUSED)\n{\n    size_t i;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n\n    if (!secdef || !secdef->relabel || data->skipAllLabel)\n        return 0;\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* XXX fixme - we need to recursively label the entire tree :-( */\n        if (virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_DIR) {\n            VIR_WARN(\"Unable to relabel directory tree %s for disk %s\",\n                     virDomainDiskGetSource(def->disks[i]),\n                     def->disks[i]->dst);\n            continue;\n        }\n        if (virSecuritySELinuxSetImageLabel(mgr, def, def->disks[i]->src,\n                                            VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN |\n                                            VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP) < 0)\n            return -1;\n    }\n    /* XXX fixme process  def->fss if relabel == true */\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecuritySELinuxSetHostdevLabel(mgr,\n                                              def,\n                                              def->hostdevs[i],\n                                              NULL) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecuritySELinuxSetInputLabel(mgr, def, def->inputs[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecuritySELinuxSetMemoryLabel(mgr, def, def->mems[i]) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (virSecuritySELinuxSetTPMFileLabel(mgr, def, def->tpm) < 0)\n            return -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd\n    };\n\n    if (virDomainChrDefForeach(def,\n                               true,\n                               virSecuritySELinuxSetSecurityChardevCallback,\n                               &chardevData) < 0)\n        return -1;\n\n    if (virDomainSmartcardDefForeach(def,\n                                     true,\n                                     virSecuritySELinuxSetSecuritySmartcardCallback,\n                                     mgr) < 0)\n        return -1;\n\n    /* This is different than kernel or initrd. The nvram store\n     * is really a disk, qemu can read and write to it. */\n    if (def->os.loader && def->os.loader->nvram &&\n        secdef && secdef->imagelabel &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.loader->nvram,\n                                     secdef->imagelabel, true) < 0)\n        return -1;\n\n    if (def->os.kernel &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.kernel,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (def->os.initrd &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.initrd,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (def->os.dtb &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.dtb,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (def->os.slic_table &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.slic_table,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (stdin_path &&\n        virSecuritySELinuxSetFilecon(mgr, stdin_path,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "stdin_path",
            "data->content_context",
            "true"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSmartcardDefForeach",
          "args": [
            "def",
            "true",
            "virSecuritySELinuxSetSecuritySmartcardCallback",
            "mgr"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSmartcardDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29889-29909",
          "snippet": "int\nvirDomainSmartcardDefForeach(virDomainDefPtr def,\n                             bool abortOnError,\n                             virDomainSmartcardDefIterator iter,\n                             void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nsmartcards; i++) {\n        if ((iter)(def,\n                   def->smartcards[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSmartcardDefForeach(virDomainDefPtr def,\n                             bool abortOnError,\n                             virDomainSmartcardDefIterator iter,\n                             void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nsmartcards; i++) {\n        if ((iter)(def,\n                   def->smartcards[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefForeach",
          "args": [
            "def",
            "true",
            "virSecuritySELinuxSetSecurityChardevCallback",
            "&chardevData"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29835-29886",
          "snippet": "int\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetTPMFileLabel",
          "args": [
            "mgr",
            "def",
            "def->tpm"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetTPMFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1640-1685",
          "snippet": "static int\nvirSecuritySELinuxSetTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int rc;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            rc = virSecuritySELinuxSetFilecon(mgr,\n                                              cancel_path,\n                                              seclabel->imagelabel, false);\n            VIR_FREE(cancel_path);\n            if (rc < 0) {\n                virSecuritySELinuxRestoreTPMFileLabelInt(mgr, def, tpm);\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        tpmdev = tpm->data.emulator.source.data.nix.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxSetTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int rc;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            rc = virSecuritySELinuxSetFilecon(mgr,\n                                              cancel_path,\n                                              seclabel->imagelabel, false);\n            VIR_FREE(cancel_path);\n            if (rc < 0) {\n                virSecuritySELinuxRestoreTPMFileLabelInt(mgr, def, tpm);\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        tpmdev = tpm->data.emulator.source.data.nix.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetMemoryLabel",
          "args": [
            "mgr",
            "def",
            "def->mems[i]"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetMemoryLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1584-1609",
          "snippet": "static int\nvirSecuritySELinuxSetMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        if (virSecuritySELinuxSetFilecon(mgr, mem->nvdimmPath,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        if (virSecuritySELinuxSetFilecon(mgr, mem->nvdimmPath,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetInputLabel",
          "args": [
            "mgr",
            "def",
            "def->inputs[i]"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetInputLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1527-1553",
          "snippet": "static int\nvirSecuritySELinuxSetInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virDomainInputDefPtr input)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecuritySELinuxSetFilecon(mgr, input->source.evdev,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virDomainInputDefPtr input)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecuritySELinuxSetFilecon(mgr, input->source.evdev,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevLabel",
          "args": [
            "mgr",
            "def",
            "def->hostdevs[i]",
            "NULL"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2259-2282",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxSetHostdevSubsysLabel(mgr, def, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxSetHostdevCapsLabel(mgr, def, dev, vroot);\n\n    default:\n        return 0;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxSetHostdevSubsysLabel(mgr, def, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxSetHostdevCapsLabel(mgr, def, dev, vroot);\n\n    default:\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetImageLabel",
          "args": [
            "mgr",
            "def",
            "def->disks[i]->src",
            "VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN |\n                                            VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetImageLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1963-1970",
          "snippet": "static int\nvirSecuritySELinuxSetImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags)\n{\n    return virSecuritySELinuxSetImageLabelRelative(mgr, def, src, src, flags);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags)\n{\n    return virSecuritySELinuxSetImageLabelRelative(mgr, def, src, src, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to relabel directory tree %s for disk %s\"",
            "virDomainDiskGetSource(def->disks[i])",
            "def->disks[i]->dst"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def->disks[i]"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "def->disks[i]"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxSetAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              const char *stdin_path,\n                              bool chardevStdioLogd,\n                              bool migrated G_GNUC_UNUSED)\n{\n    size_t i;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n\n    if (!secdef || !secdef->relabel || data->skipAllLabel)\n        return 0;\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* XXX fixme - we need to recursively label the entire tree :-( */\n        if (virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_DIR) {\n            VIR_WARN(\"Unable to relabel directory tree %s for disk %s\",\n                     virDomainDiskGetSource(def->disks[i]),\n                     def->disks[i]->dst);\n            continue;\n        }\n        if (virSecuritySELinuxSetImageLabel(mgr, def, def->disks[i]->src,\n                                            VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN |\n                                            VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP) < 0)\n            return -1;\n    }\n    /* XXX fixme process  def->fss if relabel == true */\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecuritySELinuxSetHostdevLabel(mgr,\n                                              def,\n                                              def->hostdevs[i],\n                                              NULL) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecuritySELinuxSetInputLabel(mgr, def, def->inputs[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecuritySELinuxSetMemoryLabel(mgr, def, def->mems[i]) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (virSecuritySELinuxSetTPMFileLabel(mgr, def, def->tpm) < 0)\n            return -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd\n    };\n\n    if (virDomainChrDefForeach(def,\n                               true,\n                               virSecuritySELinuxSetSecurityChardevCallback,\n                               &chardevData) < 0)\n        return -1;\n\n    if (virDomainSmartcardDefForeach(def,\n                                     true,\n                                     virSecuritySELinuxSetSecuritySmartcardCallback,\n                                     mgr) < 0)\n        return -1;\n\n    /* This is different than kernel or initrd. The nvram store\n     * is really a disk, qemu can read and write to it. */\n    if (def->os.loader && def->os.loader->nvram &&\n        secdef && secdef->imagelabel &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.loader->nvram,\n                                     secdef->imagelabel, true) < 0)\n        return -1;\n\n    if (def->os.kernel &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.kernel,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (def->os.initrd &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.initrd,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (def->os.dtb &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.dtb,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (def->os.slic_table &&\n        virSecuritySELinuxSetFilecon(mgr, def->os.slic_table,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    if (stdin_path &&\n        virSecuritySELinuxSetFilecon(mgr, stdin_path,\n                                     data->content_context, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetSecuritySmartcardCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3101-3132",
    "snippet": "static int\nvirSecuritySELinuxSetSecuritySmartcardCallback(virDomainDefPtr def,\n                                               virDomainSmartcardDefPtr dev,\n                                               void *opaque)\n{\n    const char *database;\n    virSecurityManagerPtr mgr = opaque;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    switch (dev->type) {\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n        break;\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n        database = dev->data.cert.database;\n        if (!database)\n            database = VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        return virSecuritySELinuxSetFilecon(mgr, database, data->content_context, true);\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n        return virSecuritySELinuxSetChardevLabel(mgr, def,\n                                                 dev->data.passthru, false);\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown smartcard type %d\"),\n                       dev->type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown smartcard type %d\")",
            "dev->type"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown smartcard type %d\""
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetChardevLabel",
          "args": [
            "mgr",
            "def",
            "dev->data.passthru",
            "false"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2515-2594",
          "snippet": "static int\nvirSecuritySELinuxSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *imagelabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel)\n        imagelabel = chr_seclabel->label;\n    if (!imagelabel)\n        imagelabel = seclabel->imagelabel;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecuritySELinuxSetFilecon(mgr,\n                                           dev_source->data.file.path,\n                                           imagelabel,\n                                           true);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxSetFilecon(mgr,\n                                             dev_source->data.nix.path,\n                                             imagelabel,\n                                             true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxSetFilecon(mgr, in, imagelabel, true) < 0) ||\n                (virSecuritySELinuxSetFilecon(mgr, out, imagelabel, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxSetFilecon(mgr,\n                                                dev_source->data.file.path,\n                                                imagelabel,\n                                                true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *imagelabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel)\n        imagelabel = chr_seclabel->label;\n    if (!imagelabel)\n        imagelabel = seclabel->imagelabel;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecuritySELinuxSetFilecon(mgr,\n                                           dev_source->data.file.path,\n                                           imagelabel,\n                                           true);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxSetFilecon(mgr,\n                                             dev_source->data.nix.path,\n                                             imagelabel,\n                                             true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxSetFilecon(mgr, in, imagelabel, true) < 0) ||\n                (virSecuritySELinuxSetFilecon(mgr, out, imagelabel, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxSetFilecon(mgr,\n                                                dev_source->data.file.path,\n                                                imagelabel,\n                                                true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "database",
            "data->content_context",
            "true"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetSecuritySmartcardCallback(virDomainDefPtr def,\n                                               virDomainSmartcardDefPtr dev,\n                                               void *opaque)\n{\n    const char *database;\n    virSecurityManagerPtr mgr = opaque;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    switch (dev->type) {\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n        break;\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n        database = dev->data.cert.database;\n        if (!database)\n            database = VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        return virSecuritySELinuxSetFilecon(mgr, database, data->content_context, true);\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n        return virSecuritySELinuxSetChardevLabel(mgr, def,\n                                                 dev->data.passthru, false);\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown smartcard type %d\"),\n                       dev->type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetSecurityChardevCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3089-3098",
    "snippet": "static int\nvirSecuritySELinuxSetSecurityChardevCallback(virDomainDefPtr def,\n                                             virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                             void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecuritySELinuxSetChardevLabel(data->mgr, def, dev->source,\n                                             data->chardevStdioLogd);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetChardevLabel",
          "args": [
            "data->mgr",
            "def",
            "dev->source",
            "data->chardevStdioLogd"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2515-2594",
          "snippet": "static int\nvirSecuritySELinuxSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *imagelabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel)\n        imagelabel = chr_seclabel->label;\n    if (!imagelabel)\n        imagelabel = seclabel->imagelabel;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecuritySELinuxSetFilecon(mgr,\n                                           dev_source->data.file.path,\n                                           imagelabel,\n                                           true);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxSetFilecon(mgr,\n                                             dev_source->data.nix.path,\n                                             imagelabel,\n                                             true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxSetFilecon(mgr, in, imagelabel, true) < 0) ||\n                (virSecuritySELinuxSetFilecon(mgr, out, imagelabel, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxSetFilecon(mgr,\n                                                dev_source->data.file.path,\n                                                imagelabel,\n                                                true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *imagelabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel)\n        imagelabel = chr_seclabel->label;\n    if (!imagelabel)\n        imagelabel = seclabel->imagelabel;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecuritySELinuxSetFilecon(mgr,\n                                           dev_source->data.file.path,\n                                           imagelabel,\n                                           true);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxSetFilecon(mgr,\n                                             dev_source->data.nix.path,\n                                             imagelabel,\n                                             true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxSetFilecon(mgr, in, imagelabel, true) < 0) ||\n                (virSecuritySELinuxSetFilecon(mgr, out, imagelabel, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxSetFilecon(mgr,\n                                                dev_source->data.file.path,\n                                                imagelabel,\n                                                true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetSecurityChardevCallback(virDomainDefPtr def,\n                                             virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                             void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecuritySELinuxSetChardevLabel(data->mgr, def, dev->source,\n                                             data->chardevStdioLogd);\n}"
  },
  {
    "function_name": "virSecuritySELinuxClearSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3057-3086",
    "snippet": "static int\nvirSecuritySELinuxClearSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                   virDomainDefPtr def)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    if (setsockcreatecon_raw(NULL) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to clear socket security context '%s'\"),\n                             secdef->label);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to clear socket security context '%s'\")",
            "secdef->label"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to clear socket security context '%s'\""
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockcreatecon_raw",
          "args": [
            "NULL"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\")",
            "secdef->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "SECURITY_SELINUX_NAME",
            "secdef->model"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxClearSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                   virDomainDefPtr def)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    if (setsockcreatecon_raw(NULL) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to clear socket security context '%s'\"),\n                             secdef->label);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "3019-3055",
    "snippet": "static int\nvirSecuritySELinuxSetSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virDomainDefPtr vm)\n{\n    virSecurityLabelDefPtr secdef;\n    int rc = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(vm, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        goto done;\n    }\n\n    VIR_DEBUG(\"Setting VM %s socket context %s\",\n              vm->name, secdef->label);\n    if (setsockcreatecon_raw(secdef->label) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set socket security context '%s'\"),\n                             secdef->label);\n        goto done;\n    }\n\n    rc = 0;\n\n done:\n    if (security_getenforce() != 1)\n        rc = 0;\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set socket security context '%s'\")",
            "secdef->label"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to set socket security context '%s'\""
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockcreatecon_raw",
          "args": [
            "secdef->label"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting VM %s socket context %s\"",
            "vm->name",
            "secdef->label"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\")",
            "secdef->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "SECURITY_SELINUX_NAME",
            "secdef->model"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "vm",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virDomainDefPtr vm)\n{\n    virSecurityLabelDefPtr secdef;\n    int rc = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(vm, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        goto done;\n    }\n\n    VIR_DEBUG(\"Setting VM %s socket context %s\",\n              vm->name, secdef->label);\n    if (setsockcreatecon_raw(secdef->label) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set socket security context '%s'\"),\n                             secdef->label);\n        goto done;\n    }\n\n    rc = 0;\n\n done:\n    if (security_getenforce() != 1)\n        rc = 0;\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetDaemonSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2969-3017",
    "snippet": "static int\nvirSecuritySELinuxSetDaemonSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                       virDomainDefPtr def)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n    security_context_t scon = NULL;\n    char *str = NULL;\n    int rc = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        goto done;\n    }\n\n    if (getcon_raw(&scon) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to get current process context '%s'\"),\n                             secdef->label);\n        goto done;\n    }\n\n    if (!(str = virSecuritySELinuxContextAddRange(secdef->label, scon)))\n        goto done;\n\n    VIR_DEBUG(\"Setting VM %s socket context %s\", def->name, str);\n    if (setsockcreatecon_raw(str) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set socket security context '%s'\"), str);\n        goto done;\n    }\n\n    rc = 0;\n done:\n\n    if (security_getenforce() != 1)\n        rc = 0;\n    freecon(scon);\n    VIR_FREE(str);\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "scon"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set socket security context '%s'\")",
            "str"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to set socket security context '%s'\""
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockcreatecon_raw",
          "args": [
            "str"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting VM %s socket context %s\"",
            "def->name",
            "str"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextAddRange",
          "args": [
            "secdef->label",
            "scon"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextAddRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "532-568",
          "snippet": "static char *\nvirSecuritySELinuxContextAddRange(security_context_t src,\n                                  security_context_t dst)\n{\n    char *str = NULL;\n    char *ret = NULL;\n    context_t srccon = NULL;\n    context_t dstcon = NULL;\n\n    if (!src || !dst)\n        return ret;\n\n    if (!(srccon = context_new(src)) || !(dstcon = context_new(dst))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to allocate security context\"));\n        goto cleanup;\n    }\n\n    if (context_range_set(dstcon, context_range_get(srccon)) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context range '%s'\"), dst);\n        goto cleanup;\n    }\n\n    if (!(str = context_str(dstcon))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(str);\n\n cleanup:\n    if (srccon) context_free(srccon);\n    if (dstcon) context_free(dstcon);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxContextAddRange(security_context_t src,\n                                  security_context_t dst)\n{\n    char *str = NULL;\n    char *ret = NULL;\n    context_t srccon = NULL;\n    context_t dstcon = NULL;\n\n    if (!src || !dst)\n        return ret;\n\n    if (!(srccon = context_new(src)) || !(dstcon = context_new(dst))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to allocate security context\"));\n        goto cleanup;\n    }\n\n    if (context_range_set(dstcon, context_range_get(srccon)) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context range '%s'\"), dst);\n        goto cleanup;\n    }\n\n    if (!(str = context_str(dstcon))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(str);\n\n cleanup:\n    if (srccon) context_free(srccon);\n    if (dstcon) context_free(dstcon);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get current process context '%s'\")",
            "secdef->label"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcon_raw",
          "args": [
            "&scon"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\")",
            "secdef->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "SECURITY_SELINUX_NAME",
            "secdef->model"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetDaemonSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                       virDomainDefPtr def)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n    security_context_t scon = NULL;\n    char *str = NULL;\n    int rc = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        goto done;\n    }\n\n    if (getcon_raw(&scon) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to get current process context '%s'\"),\n                             secdef->label);\n        goto done;\n    }\n\n    if (!(str = virSecuritySELinuxContextAddRange(secdef->label, scon)))\n        goto done;\n\n    VIR_DEBUG(\"Setting VM %s socket context %s\", def->name, str);\n    if (setsockcreatecon_raw(str) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set socket security context '%s'\"), str);\n        goto done;\n    }\n\n    rc = 0;\n done:\n\n    if (security_getenforce() != 1)\n        rc = 0;\n    freecon(scon);\n    VIR_FREE(str);\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetChildProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2941-2967",
    "snippet": "static int\nvirSecuritySELinuxSetChildProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                       virDomainDefPtr def,\n                                       virCommandPtr cmd)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    VIR_DEBUG(\"label=%s\", secdef->label);\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    /* save in cmd to be set after fork/before child process is exec'ed */\n    virCommandSetSELinuxLabel(cmd, secdef->label);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandSetSELinuxLabel",
          "args": [
            "cmd",
            "secdef->label"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetSELinuxLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1216-1228",
          "snippet": "void\nvirCommandSetSELinuxLabel(virCommandPtr cmd,\n                          const char *label G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n    cmd->seLinuxLabel = g_strdup(label);\n#endif\n    return;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetSELinuxLabel(virCommandPtr cmd,\n                          const char *label G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n    cmd->seLinuxLabel = g_strdup(label);\n#endif\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\")",
            "secdef->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\""
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "SECURITY_SELINUX_NAME",
            "secdef->model"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"label=%s\"",
            "secdef->label"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetChildProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                       virDomainDefPtr def,\n                                       virCommandPtr cmd)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    VIR_DEBUG(\"label=%s\", secdef->label);\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    /* save in cmd to be set after fork/before child process is exec'ed */\n    virCommandSetSELinuxLabel(cmd, secdef->label);\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2908-2939",
    "snippet": "static int\nvirSecuritySELinuxSetProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                  virDomainDefPtr def)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    VIR_DEBUG(\"label=%s\", secdef->label);\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    if (setexeccon_raw(secdef->label) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context '%s'\"),\n                             secdef->label);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set security context '%s'\")",
            "secdef->label"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to set security context '%s'\""
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setexeccon_raw",
          "args": [
            "secdef->label"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\")",
            "secdef->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "SECURITY_SELINUX_NAME",
            "secdef->model"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"label=%s\"",
            "secdef->label"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                  virDomainDefPtr def)\n{\n    /* TODO: verify DOI */\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->label)\n        return 0;\n\n    VIR_DEBUG(\"label=%s\", secdef->label);\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    if (setexeccon_raw(secdef->label) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context '%s'\"),\n                             secdef->label);\n        if (security_getenforce() == 1)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxVerify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2879-2906",
    "snippet": "static int\nvirSecuritySELinuxVerify(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                         virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        return -1;\n    }\n\n    if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC) {\n        if (security_check_context(secdef->label) != 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid security label %s\"), secdef->label);\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid security label %s\")",
            "secdef->label"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid security label %s\""
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_check_context",
          "args": [
            "secdef->label"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\")",
            "secdef->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "SECURITY_SELINUX_NAME",
            "secdef->model"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxVerify(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                         virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    if (STRNEQ(SECURITY_SELINUX_NAME, secdef->model)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label driver mismatch: \"\n                         \"'%s' model configured for domain, but \"\n                         \"hypervisor driver is '%s'.\"),\n                       secdef->model, SECURITY_SELINUX_NAME);\n        return -1;\n    }\n\n    if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC) {\n        if (security_check_context(secdef->label) != 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid security label %s\"), secdef->label);\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreSavedStateLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2864-2876",
    "snippet": "static int\nvirSecuritySELinuxRestoreSavedStateLabel(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         const char *savefile)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, savefile, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "savefile",
            "true"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreSavedStateLabel(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         const char *savefile)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, savefile, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetSavedStateLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2849-2861",
    "snippet": "static int\nvirSecuritySELinuxSetSavedStateLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     const char *savefile)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    return virSecuritySELinuxSetFilecon(mgr, savefile, secdef->imagelabel, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "savefile",
            "secdef->imagelabel",
            "true"
          ],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetSavedStateLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     const char *savefile)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    return virSecuritySELinuxSetFilecon(mgr, savefile, secdef->imagelabel, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxReleaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2821-2846",
    "snippet": "static int\nvirSecuritySELinuxReleaseLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    if (secdef->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {\n        if (secdef->label != NULL) {\n            context_t con = context_new(secdef->label);\n            if (con) {\n                virSecuritySELinuxMCSRemove(mgr, context_range_get(con));\n                context_free(con);\n            }\n        }\n        VIR_FREE(secdef->label);\n        if (!secdef->baselabel)\n            VIR_FREE(secdef->model);\n    }\n    VIR_FREE(secdef->imagelabel);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secdef->imagelabel"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secdef->model"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secdef->label"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "con"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxMCSRemove",
          "args": [
            "mgr",
            "context_range_get(con)"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxMCSRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "354-361",
          "snippet": "static void\nvirSecuritySELinuxMCSRemove(virSecurityManagerPtr mgr,\n                            const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    virHashRemoveEntry(data->mcs, mcs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxMCSRemove(virSecurityManagerPtr mgr,\n                            const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    virHashRemoveEntry(data->mcs, mcs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "con"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "secdef->label"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxReleaseLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    if (secdef->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {\n        if (secdef->label != NULL) {\n            context_t con = context_new(secdef->label);\n            if (con) {\n                virSecuritySELinuxMCSRemove(mgr, context_range_get(con));\n                context_free(con);\n            }\n        }\n        VIR_FREE(secdef->label);\n        if (!secdef->baselabel)\n            VIR_FREE(secdef->model);\n    }\n    VIR_FREE(secdef->imagelabel);\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2732-2819",
    "snippet": "static int\nvirSecuritySELinuxRestoreAllLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  bool migrated,\n                                  bool chardevStdioLogd)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    size_t i;\n    int rc = 0;\n\n    VIR_DEBUG(\"Restoring security label on %s migrated=%d\", def->name, migrated);\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n\n    if (!secdef || !secdef->relabel || data->skipAllLabel)\n        return 0;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n\n        if (virSecuritySELinuxRestoreImageLabelInt(mgr, def, disk->src,\n                                                   migrated) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecuritySELinuxRestoreHostdevLabel(mgr,\n                                                  def,\n                                                  def->hostdevs[i],\n                                                  NULL) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecuritySELinuxRestoreInputLabel(mgr, def, def->inputs[i]) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecuritySELinuxRestoreMemoryLabel(mgr, def, def->mems[i]) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (virSecuritySELinuxRestoreTPMFileLabelInt(mgr, def, def->tpm) < 0)\n            rc = -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd\n    };\n\n    if (virDomainChrDefForeach(def,\n                               false,\n                               virSecuritySELinuxRestoreSecurityChardevCallback,\n                               &chardevData) < 0)\n        rc = -1;\n\n    if (virDomainSmartcardDefForeach(def,\n                                     false,\n                                     virSecuritySELinuxRestoreSecuritySmartcardCallback,\n                                     mgr) < 0)\n        rc = -1;\n\n    if (def->os.loader && def->os.loader->nvram &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.loader->nvram, true) < 0)\n        rc = -1;\n\n    if (def->os.kernel &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.kernel, true) < 0)\n        rc = -1;\n\n    if (def->os.initrd &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.initrd, true) < 0)\n        rc = -1;\n\n    if (def->os.dtb &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.dtb, true) < 0)\n        rc = -1;\n\n    if (def->os.slic_table &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.slic_table, true) < 0)\n        rc = -1;\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "def->os.slic_table",
            "true"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSmartcardDefForeach",
          "args": [
            "def",
            "false",
            "virSecuritySELinuxRestoreSecuritySmartcardCallback",
            "mgr"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSmartcardDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29889-29909",
          "snippet": "int\nvirDomainSmartcardDefForeach(virDomainDefPtr def,\n                             bool abortOnError,\n                             virDomainSmartcardDefIterator iter,\n                             void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nsmartcards; i++) {\n        if ((iter)(def,\n                   def->smartcards[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSmartcardDefForeach(virDomainDefPtr def,\n                             bool abortOnError,\n                             virDomainSmartcardDefIterator iter,\n                             void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nsmartcards; i++) {\n        if ((iter)(def,\n                   def->smartcards[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefForeach",
          "args": [
            "def",
            "false",
            "virSecuritySELinuxRestoreSecurityChardevCallback",
            "&chardevData"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29835-29886",
          "snippet": "int\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreTPMFileLabelInt",
          "args": [
            "mgr",
            "def",
            "def->tpm"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreTPMFileLabelInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1688-1720",
          "snippet": "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, tpmdev, false);\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr, cancel_path, false) < 0)\n                rc = -1;\n            VIR_FREE(cancel_path);\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, tpmdev, false);\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr, cancel_path, false) < 0)\n                rc = -1;\n            VIR_FREE(cancel_path);\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreMemoryLabel",
          "args": [
            "mgr",
            "def",
            "def->mems[i]"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreMemoryLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1612-1637",
          "snippet": "static int\nvirSecuritySELinuxRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreInputLabel",
          "args": [
            "mgr",
            "def",
            "def->inputs[i]"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreInputLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1556-1581",
          "snippet": "static int\nvirSecuritySELinuxRestoreInputLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainInputDefPtr input)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreInputLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainInputDefPtr input)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreHostdevLabel",
          "args": [
            "mgr",
            "def",
            "def->hostdevs[i]",
            "NULL"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreHostdevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2489-2512",
          "snippet": "static int\nvirSecuritySELinuxRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxRestoreHostdevSubsysLabel(mgr, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxRestoreHostdevCapsLabel(mgr, dev, vroot);\n\n    default:\n        return 0;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxRestoreHostdevSubsysLabel(mgr, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxRestoreHostdevCapsLabel(mgr, dev, vroot);\n\n    default:\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreImageLabelInt",
          "args": [
            "mgr",
            "def",
            "disk->src",
            "migrated"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreImageLabelInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1800-1817",
          "snippet": "static int\nvirSecuritySELinuxRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr def,\n                                       virStorageSourcePtr src,\n                                       bool migrated)\n{\n    if (virSecuritySELinuxRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecuritySELinuxRestoreImageLabelSingle(mgr,\n                                                  def,\n                                                  src->externalDataStore,\n                                                  migrated) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr def,\n                                       virStorageSourcePtr src,\n                                       bool migrated)\n{\n    if (virSecuritySELinuxRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecuritySELinuxRestoreImageLabelSingle(mgr,\n                                                  def,\n                                                  src->externalDataStore,\n                                                  migrated) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Restoring security label on %s migrated=%d\"",
            "def->name",
            "migrated"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxRestoreAllLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  bool migrated,\n                                  bool chardevStdioLogd)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    size_t i;\n    int rc = 0;\n\n    VIR_DEBUG(\"Restoring security label on %s migrated=%d\", def->name, migrated);\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n\n    if (!secdef || !secdef->relabel || data->skipAllLabel)\n        return 0;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n\n        if (virSecuritySELinuxRestoreImageLabelInt(mgr, def, disk->src,\n                                                   migrated) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecuritySELinuxRestoreHostdevLabel(mgr,\n                                                  def,\n                                                  def->hostdevs[i],\n                                                  NULL) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecuritySELinuxRestoreInputLabel(mgr, def, def->inputs[i]) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecuritySELinuxRestoreMemoryLabel(mgr, def, def->mems[i]) < 0)\n            return -1;\n    }\n\n    if (def->tpm) {\n        if (virSecuritySELinuxRestoreTPMFileLabelInt(mgr, def, def->tpm) < 0)\n            rc = -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd\n    };\n\n    if (virDomainChrDefForeach(def,\n                               false,\n                               virSecuritySELinuxRestoreSecurityChardevCallback,\n                               &chardevData) < 0)\n        rc = -1;\n\n    if (virDomainSmartcardDefForeach(def,\n                                     false,\n                                     virSecuritySELinuxRestoreSecuritySmartcardCallback,\n                                     mgr) < 0)\n        rc = -1;\n\n    if (def->os.loader && def->os.loader->nvram &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.loader->nvram, true) < 0)\n        rc = -1;\n\n    if (def->os.kernel &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.kernel, true) < 0)\n        rc = -1;\n\n    if (def->os.initrd &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.initrd, true) < 0)\n        rc = -1;\n\n    if (def->os.dtb &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.dtb, true) < 0)\n        rc = -1;\n\n    if (def->os.slic_table &&\n        virSecuritySELinuxRestoreFileLabel(mgr, def->os.slic_table, true) < 0)\n        rc = -1;\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGetBaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2721-2729",
    "snippet": "static const char *\nvirSecuritySELinuxGetBaseLabel(virSecurityManagerPtr mgr, int virtType)\n{\n    virSecuritySELinuxDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    if (virtType == VIR_DOMAIN_VIRT_QEMU && priv->alt_domain_context)\n        return priv->alt_domain_context;\n    else\n        return priv->domain_context;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic const char *\nvirSecuritySELinuxGetBaseLabel(virSecurityManagerPtr mgr, int virtType)\n{\n    virSecuritySELinuxDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    if (virtType == VIR_DOMAIN_VIRT_QEMU && priv->alt_domain_context)\n        return priv->alt_domain_context;\n    else\n        return priv->domain_context;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreSecuritySmartcardCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2688-2718",
    "snippet": "static int\nvirSecuritySELinuxRestoreSecuritySmartcardCallback(virDomainDefPtr def,\n                                                   virDomainSmartcardDefPtr dev,\n                                                   void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    const char *database;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n        break;\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n        database = dev->data.cert.database;\n        if (!database)\n            database = VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        return virSecuritySELinuxRestoreFileLabel(mgr, database, true);\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n        return virSecuritySELinuxRestoreChardevLabel(mgr, def,\n                                                     dev->data.passthru, false);\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown smartcard type %d\"),\n                       dev->type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown smartcard type %d\")",
            "dev->type"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown smartcard type %d\""
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreChardevLabel",
          "args": [
            "mgr",
            "def",
            "dev->data.passthru",
            "false"
          ],
          "line": 2707
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2596-2667",
          "snippet": "static int\nvirSecuritySELinuxRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                               dev_source->data.file.path,\n                                               true) < 0)\n            goto done;\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                   dev_source->data.file.path,\n                                                   true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxRestoreFileLabel(mgr, out, true) < 0) ||\n                (virSecuritySELinuxRestoreFileLabel(mgr, in, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                      dev_source->data.file.path,\n                                                      true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                               dev_source->data.file.path,\n                                               true) < 0)\n            goto done;\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                   dev_source->data.file.path,\n                                                   true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxRestoreFileLabel(mgr, out, true) < 0) ||\n                (virSecuritySELinuxRestoreFileLabel(mgr, in, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                      dev_source->data.file.path,\n                                                      true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "database",
            "true"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreSecuritySmartcardCallback(virDomainDefPtr def,\n                                                   virDomainSmartcardDefPtr dev,\n                                                   void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    const char *database;\n\n    switch (dev->type) {\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n        break;\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n        database = dev->data.cert.database;\n        if (!database)\n            database = VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        return virSecuritySELinuxRestoreFileLabel(mgr, database, true);\n\n    case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n        return virSecuritySELinuxRestoreChardevLabel(mgr, def,\n                                                     dev->data.passthru, false);\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown smartcard type %d\"),\n                       dev->type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreSecurityChardevCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2676-2685",
    "snippet": "static int\nvirSecuritySELinuxRestoreSecurityChardevCallback(virDomainDefPtr def,\n                                                 virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                                 void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecuritySELinuxRestoreChardevLabel(data->mgr, def, dev->source,\n                                                 data->chardevStdioLogd);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreChardevLabel",
          "args": [
            "data->mgr",
            "def",
            "dev->source",
            "data->chardevStdioLogd"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2596-2667",
          "snippet": "static int\nvirSecuritySELinuxRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                               dev_source->data.file.path,\n                                               true) < 0)\n            goto done;\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                   dev_source->data.file.path,\n                                                   true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxRestoreFileLabel(mgr, out, true) < 0) ||\n                (virSecuritySELinuxRestoreFileLabel(mgr, in, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                      dev_source->data.file.path,\n                                                      true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                               dev_source->data.file.path,\n                                               true) < 0)\n            goto done;\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                   dev_source->data.file.path,\n                                                   true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxRestoreFileLabel(mgr, out, true) < 0) ||\n                (virSecuritySELinuxRestoreFileLabel(mgr, in, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                      dev_source->data.file.path,\n                                                      true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreSecurityChardevCallback(virDomainDefPtr def,\n                                                 virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                                 void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecuritySELinuxRestoreChardevLabel(data->mgr, def, dev->source,\n                                                 data->chardevStdioLogd);\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2596-2667",
    "snippet": "static int\nvirSecuritySELinuxRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                               dev_source->data.file.path,\n                                               true) < 0)\n            goto done;\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                   dev_source->data.file.path,\n                                                   true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxRestoreFileLabel(mgr, out, true) < 0) ||\n                (virSecuritySELinuxRestoreFileLabel(mgr, in, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                      dev_source->data.file.path,\n                                                      true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "out"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "in"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "dev_source->data.file.path",
            "true"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "out"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.in\"",
            "dev_source->data.file.path"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrSourceDefGetSecurityLabelDef",
          "args": [
            "dev_source",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrSourceDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30603-30617",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                               dev_source->data.file.path,\n                                               true) < 0)\n            goto done;\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                   dev_source->data.file.path,\n                                                   true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxRestoreFileLabel(mgr, out, true) < 0) ||\n                (virSecuritySELinuxRestoreFileLabel(mgr, in, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxRestoreFileLabel(mgr,\n                                                      dev_source->data.file.path,\n                                                      true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2515-2594",
    "snippet": "static int\nvirSecuritySELinuxSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *imagelabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel)\n        imagelabel = chr_seclabel->label;\n    if (!imagelabel)\n        imagelabel = seclabel->imagelabel;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecuritySELinuxSetFilecon(mgr,\n                                           dev_source->data.file.path,\n                                           imagelabel,\n                                           true);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxSetFilecon(mgr,\n                                             dev_source->data.nix.path,\n                                             imagelabel,\n                                             true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxSetFilecon(mgr, in, imagelabel, true) < 0) ||\n                (virSecuritySELinuxSetFilecon(mgr, out, imagelabel, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxSetFilecon(mgr,\n                                                dev_source->data.file.path,\n                                                imagelabel,\n                                                true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "out"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "in"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "dev_source->data.file.path",
            "imagelabel",
            "true"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "out"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.out\"",
            "dev_source->data.file.path"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrSourceDefGetSecurityLabelDef",
          "args": [
            "dev_source",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrSourceDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30603-30617",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *imagelabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel || !seclabel->relabel)\n        return 0;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_SELINUX_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel)\n        imagelabel = chr_seclabel->label;\n    if (!imagelabel)\n        imagelabel = seclabel->imagelabel;\n\n    switch (dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecuritySELinuxSetFilecon(mgr,\n                                           dev_source->data.file.path,\n                                           imagelabel,\n                                           true);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen) {\n            if (virSecuritySELinuxSetFilecon(mgr,\n                                             dev_source->data.nix.path,\n                                             imagelabel,\n                                             true) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if ((virSecuritySELinuxSetFilecon(mgr, in, imagelabel, true) < 0) ||\n                (virSecuritySELinuxSetFilecon(mgr, out, imagelabel, true) < 0)) {\n                goto done;\n            }\n        } else if (virSecuritySELinuxSetFilecon(mgr,\n                                                dev_source->data.file.path,\n                                                imagelabel,\n                                                true) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    default:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreHostdevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2489-2512",
    "snippet": "static int\nvirSecuritySELinuxRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxRestoreHostdevSubsysLabel(mgr, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxRestoreHostdevCapsLabel(mgr, dev, vroot);\n\n    default:\n        return 0;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreHostdevCapsLabel",
          "args": [
            "mgr",
            "dev",
            "vroot"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreHostdevCapsLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2447-2486",
          "snippet": "static int\nvirSecuritySELinuxRestoreHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                          virDomainHostdevDefPtr dev,\n                                          const char *vroot)\n{\n    int ret = -1;\n    char *path;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                          virDomainHostdevDefPtr dev,\n                                          const char *vroot)\n{\n    int ret = -1;\n    char *path;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreHostdevSubsysLabel",
          "args": [
            "mgr",
            "dev",
            "vroot"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreHostdevSubsysLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2332-2444",
          "snippet": "static int\nvirSecuritySELinuxRestoreHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                            virDomainHostdevDefPtr dev,\n                                            const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    /* Like virSecuritySELinuxRestoreImageLabelInt() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxRestoreFileLabel(mgr, vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecuritySELinuxRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, vfiodev, true);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                            virDomainHostdevDefPtr dev,\n                                            const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    /* Like virSecuritySELinuxRestoreImageLabelInt() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxRestoreFileLabel(mgr, vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecuritySELinuxRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, vfiodev, true);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxRestoreHostdevSubsysLabel(mgr, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxRestoreHostdevCapsLabel(mgr, dev, vroot);\n\n    default:\n        return 0;\n    }\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreHostdevCapsLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2447-2486",
    "snippet": "static int\nvirSecuritySELinuxRestoreHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                          virDomainHostdevDefPtr dev,\n                                          const char *vroot)\n{\n    int ret = -1;\n    char *path;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "path",
            "true"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dev->source.caps.u.misc.chardev"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                          virDomainHostdevDefPtr dev,\n                                          const char *vroot)\n{\n    int ret = -1;\n    char *path;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreHostdevSubsysLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2332-2444",
    "snippet": "static int\nvirSecuritySELinuxRestoreHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                            virDomainHostdevDefPtr dev,\n                                            const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    /* Like virSecuritySELinuxRestoreImageLabelInt() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxRestoreFileLabel(mgr, vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecuritySELinuxRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, vfiodev, true);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfiodev"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "vfiodev",
            "true"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceGetIOMMUGroupDev",
          "args": [
            "mdevsrc->uuidstr"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "205-234",
          "snippet": "char *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nchar *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFree",
          "args": [
            "host"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "266-277",
          "snippet": "void\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFileIterate",
          "args": [
            "host",
            "virSecuritySELinuxRestoreHostLabel",
            "mgr"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "225-231",
          "snippet": "int\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceNew",
          "args": [
            "hostsrc->wwpn"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "248-263",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\"\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFree",
          "args": [
            "scsi"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "242-257",
          "snippet": "void\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFileIterate",
          "args": [
            "scsi",
            "virSecuritySELinuxRestoreSCSILabel",
            "mgr"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "331-337",
          "snippet": "int\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "dev->readonly",
            "dev->shareable"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pci"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFileIterate",
          "args": [
            "pci",
            "virSecuritySELinuxRestorePCILabel",
            "mgr"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1720-1762",
          "snippet": "int virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfioGroupDev"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetIOMMUGroupDev",
          "args": [
            "pci"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1971-1995",
          "snippet": "char *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFree",
          "args": [
            "usb"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "353-363",
          "snippet": "void\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFileIterate",
          "args": [
            "usb",
            "virSecuritySELinuxRestoreUSBLabel",
            "mgr"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "409-414",
          "snippet": "int virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "vroot"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                            virDomainHostdevDefPtr dev,\n                                            const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    /* Like virSecuritySELinuxRestoreImageLabelInt() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxRestoreFileLabel(mgr, vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecuritySELinuxRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, vfiodev, true);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreHostLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2321-2329",
    "snippet": "static int\nvirSecuritySELinuxRestoreHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                                   const char *file,\n                                   void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "file",
            "true"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                                   const char *file,\n                                   void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreSCSILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2305-2319",
    "snippet": "static int\nvirSecuritySELinuxRestoreSCSILabel(virSCSIDevicePtr dev,\n                                   const char *file,\n                                   void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    /* Don't restore labels on a shareable or readonly hostdev, because\n     * other VMs may still be accessing.\n     */\n    if (virSCSIDeviceGetShareable(dev) || virSCSIDeviceGetReadonly(dev))\n        return 0;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "file",
            "true"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceGetReadonly",
          "args": [
            "dev"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceGetReadonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "319-323",
          "snippet": "bool\nvirSCSIDeviceGetReadonly(virSCSIDevicePtr dev)\n{\n    return dev->readonly;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirSCSIDeviceGetReadonly(virSCSIDevicePtr dev)\n{\n    return dev->readonly;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceGetShareable",
          "args": [
            "dev"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceGetShareable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "325-329",
          "snippet": "bool\nvirSCSIDeviceGetShareable(virSCSIDevicePtr dev)\n{\n    return dev->shareable;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirSCSIDeviceGetShareable(virSCSIDevicePtr dev)\n{\n    return dev->shareable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreSCSILabel(virSCSIDevicePtr dev,\n                                   const char *file,\n                                   void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    /* Don't restore labels on a shareable or readonly hostdev, because\n     * other VMs may still be accessing.\n     */\n    if (virSCSIDeviceGetShareable(dev) || virSCSIDeviceGetReadonly(dev))\n        return 0;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreUSBLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2294-2302",
    "snippet": "static int\nvirSecuritySELinuxRestoreUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                                  const char *file,\n                                  void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "file",
            "true"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                                  const char *file,\n                                  void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestorePCILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2284-2292",
    "snippet": "static int\nvirSecuritySELinuxRestorePCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                                  const char *file,\n                                  void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "file",
            "true"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestorePCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                                  const char *file,\n                                  void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, file, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetHostdevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2259-2282",
    "snippet": "static int\nvirSecuritySELinuxSetHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxSetHostdevSubsysLabel(mgr, def, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxSetHostdevCapsLabel(mgr, def, dev, vroot);\n\n    default:\n        return 0;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevCapsLabel",
          "args": [
            "mgr",
            "def",
            "dev",
            "vroot"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevCapsLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2211-2256",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr secdef;\n    char *path;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr secdef;\n    char *path;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevSubsysLabel",
          "args": [
            "mgr",
            "def",
            "dev",
            "vroot"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevSubsysLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2090-2208",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virDomainHostdevDefPtr dev,\n                                        const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    virSecuritySELinuxCallbackData data = {.mgr = mgr, .def = def};\n\n    int ret = -1;\n\n    /* Like virSecuritySELinuxSetImageLabelInternal() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxSetUSBLabel, &data);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxSetHostdevLabelHelper(vfioGroupDev,\n                                                          false,\n                                                          &data);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxSetPCILabel, &data);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecuritySELinuxSetSCSILabel,\n                                       &data);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxSetHostLabel,\n                                            &data);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return ret;\n\n        ret = virSecuritySELinuxSetHostdevLabelHelper(vfiodev, true, &data);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virDomainHostdevDefPtr dev,\n                                        const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    virSecuritySELinuxCallbackData data = {.mgr = mgr, .def = def};\n\n    int ret = -1;\n\n    /* Like virSecuritySELinuxSetImageLabelInternal() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxSetUSBLabel, &data);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxSetHostdevLabelHelper(vfioGroupDev,\n                                                          false,\n                                                          &data);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxSetPCILabel, &data);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecuritySELinuxSetSCSILabel,\n                                       &data);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxSetHostLabel,\n                                            &data);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return ret;\n\n        ret = virSecuritySELinuxSetHostdevLabelHelper(vfiodev, true, &data);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityLabelDefPtr secdef;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxSetHostdevSubsysLabel(mgr, def, dev, vroot);\n\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxSetHostdevCapsLabel(mgr, def, dev, vroot);\n\n    default:\n        return 0;\n    }\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetHostdevCapsLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2211-2256",
    "snippet": "static int\nvirSecuritySELinuxSetHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr secdef;\n    char *path;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "path",
            "secdef->imagelabel",
            "true"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dev->source.caps.u.misc.chardev"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetHostdevCapsLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr secdef;\n    char *path;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    switch (dev->source.caps.type) {\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.storage.block);\n        } else {\n            path = g_strdup(dev->source.caps.u.storage.block);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: {\n        if (vroot) {\n            path = g_strdup_printf(\"%s/%s\", vroot,\n                                   dev->source.caps.u.misc.chardev);\n        } else {\n            path = g_strdup(dev->source.caps.u.misc.chardev);\n        }\n        ret = virSecuritySELinuxSetFilecon(mgr, path, secdef->imagelabel, true);\n        VIR_FREE(path);\n        break;\n    }\n\n    default:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetHostdevSubsysLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2090-2208",
    "snippet": "static int\nvirSecuritySELinuxSetHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virDomainHostdevDefPtr dev,\n                                        const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    virSecuritySELinuxCallbackData data = {.mgr = mgr, .def = def};\n\n    int ret = -1;\n\n    /* Like virSecuritySELinuxSetImageLabelInternal() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxSetUSBLabel, &data);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxSetHostdevLabelHelper(vfioGroupDev,\n                                                          false,\n                                                          &data);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxSetPCILabel, &data);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecuritySELinuxSetSCSILabel,\n                                       &data);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxSetHostLabel,\n                                            &data);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return ret;\n\n        ret = virSecuritySELinuxSetHostdevLabelHelper(vfiodev, true, &data);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfiodev"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevLabelHelper",
          "args": [
            "vfiodev",
            "true",
            "&data"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2028-2042",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceGetIOMMUGroupDev",
          "args": [
            "mdevsrc->uuidstr"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "205-234",
          "snippet": "char *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nchar *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFree",
          "args": [
            "host"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "266-277",
          "snippet": "void\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFileIterate",
          "args": [
            "host",
            "virSecuritySELinuxSetHostLabel",
            "&data"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "225-231",
          "snippet": "int\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceNew",
          "args": [
            "hostsrc->wwpn"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "248-263",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\"\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFree",
          "args": [
            "scsi"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "242-257",
          "snippet": "void\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFileIterate",
          "args": [
            "scsi",
            "virSecuritySELinuxSetSCSILabel",
            "&data"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "331-337",
          "snippet": "int\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "dev->readonly",
            "dev->shareable"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pci"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFileIterate",
          "args": [
            "pci",
            "virSecuritySELinuxSetPCILabel",
            "&data"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1720-1762",
          "snippet": "int virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfioGroupDev"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetIOMMUGroupDev",
          "args": [
            "pci"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1971-1995",
          "snippet": "char *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFree",
          "args": [
            "usb"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "353-363",
          "snippet": "void\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFileIterate",
          "args": [
            "usb",
            "virSecuritySELinuxSetUSBLabel",
            "&data"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "409-414",
          "snippet": "int virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "vroot"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetHostdevSubsysLabel(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virDomainHostdevDefPtr dev,\n                                        const char *vroot)\n\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    virSecuritySELinuxCallbackData data = {.mgr = mgr, .def = def};\n\n    int ret = -1;\n\n    /* Like virSecuritySELinuxSetImageLabelInternal() for a networked\n     * disk, do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        usb = virUSBDeviceNew(usbsrc->bus,\n                              usbsrc->device,\n                              vroot);\n        if (!usb)\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecuritySELinuxSetUSBLabel, &data);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecuritySELinuxSetHostdevLabelHelper(vfioGroupDev,\n                                                          false,\n                                                          &data);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecuritySELinuxSetPCILabel, &data);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecuritySELinuxSetSCSILabel,\n                                       &data);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecuritySELinuxSetHostLabel,\n                                            &data);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return ret;\n\n        ret = virSecuritySELinuxSetHostdevLabelHelper(vfiodev, true, &data);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetHostLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2082-2087",
    "snippet": "static int\nvirSecuritySELinuxSetHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                               const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2028-2042",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                               const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetSCSILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2058-2080",
    "snippet": "static int\nvirSecuritySELinuxSetSCSILabel(virSCSIDevicePtr dev,\n                               const char *file, void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr ptr = opaque;\n    virSecurityManagerPtr mgr = ptr->mgr;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    secdef = virDomainDefGetSecurityLabelDef(ptr->def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    if (virSCSIDeviceGetShareable(dev))\n        return virSecuritySELinuxSetFilecon(mgr, file,\n                                            data->file_context, true);\n    else if (virSCSIDeviceGetReadonly(dev))\n        return virSecuritySELinuxSetFilecon(mgr, file,\n                                            data->content_context, true);\n    else\n        return virSecuritySELinuxSetFilecon(mgr, file,\n                                            secdef->imagelabel, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "file",
            "secdef->imagelabel",
            "true"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceGetReadonly",
          "args": [
            "dev"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceGetReadonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "319-323",
          "snippet": "bool\nvirSCSIDeviceGetReadonly(virSCSIDevicePtr dev)\n{\n    return dev->readonly;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirSCSIDeviceGetReadonly(virSCSIDevicePtr dev)\n{\n    return dev->readonly;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceGetShareable",
          "args": [
            "dev"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceGetShareable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "325-329",
          "snippet": "bool\nvirSCSIDeviceGetShareable(virSCSIDevicePtr dev)\n{\n    return dev->shareable;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirSCSIDeviceGetShareable(virSCSIDevicePtr dev)\n{\n    return dev->shareable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "ptr->def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetSCSILabel(virSCSIDevicePtr dev,\n                               const char *file, void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr ptr = opaque;\n    virSecurityManagerPtr mgr = ptr->mgr;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    secdef = virDomainDefGetSecurityLabelDef(ptr->def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n\n    if (virSCSIDeviceGetShareable(dev))\n        return virSecuritySELinuxSetFilecon(mgr, file,\n                                            data->file_context, true);\n    else if (virSCSIDeviceGetReadonly(dev))\n        return virSecuritySELinuxSetFilecon(mgr, file,\n                                            data->content_context, true);\n    else\n        return virSecuritySELinuxSetFilecon(mgr, file,\n                                            secdef->imagelabel, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetUSBLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2051-2056",
    "snippet": "static int\nvirSecuritySELinuxSetUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                              const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2028-2042",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                              const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetPCILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2044-2049",
    "snippet": "static int\nvirSecuritySELinuxSetPCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                              const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "2028-2042",
          "snippet": "static int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetPCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                              const char *file, void *opaque)\n{\n    return virSecuritySELinuxSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetHostdevLabelHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "2028-2042",
    "snippet": "static int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "file",
            "secdef->imagelabel",
            "remember"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetHostdevLabelHelper(const char *file,\n                                        bool remember,\n                                        void *opaque)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecuritySELinuxCallbackDataPtr data = opaque;\n    virSecurityManagerPtr mgr = data->mgr;\n    virDomainDefPtr def = data->def;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (secdef == NULL)\n        return 0;\n    return virSecuritySELinuxSetFilecon(mgr, file, secdef->imagelabel, remember);\n}"
  },
  {
    "function_name": "virSecuritySELinuxMoveImageMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1997-2025",
    "snippet": "static int\nvirSecuritySELinuxMoveImageMetadata(virSecurityManagerPtr mgr,\n                                    pid_t pid,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr dst)\n{\n    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };\n    int rc;\n\n    if (src && virStorageSourceIsLocalStorage(src))\n        data.src = src->path;\n\n    if (dst && virStorageSourceIsLocalStorage(dst))\n        data.dst = dst->path;\n\n    if (!data.src)\n        return 0;\n\n    if (pid == -1) {\n        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,\n                                 &data);\n    } else {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxMoveImageMetadataHelper,\n                                           &data);\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virProcessRunInMountNamespace",
          "args": [
            "pid",
            "virSecuritySELinuxMoveImageMetadataHelper",
            "&data"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInMountNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1115-1123",
          "snippet": "int\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessRunInFork",
          "args": [
            "virSecuritySELinuxMoveImageMetadataHelper",
            "&data"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInFork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1267-1274",
          "snippet": "int\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "dst"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxMoveImageMetadata(virSecurityManagerPtr mgr,\n                                    pid_t pid,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr dst)\n{\n    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };\n    int rc;\n\n    if (src && virStorageSourceIsLocalStorage(src))\n        data.src = src->path;\n\n    if (dst && virStorageSourceIsLocalStorage(dst))\n        data.dst = dst->path;\n\n    if (!data.src)\n        return 0;\n\n    if (pid == -1) {\n        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,\n                                 &data);\n    } else {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxMoveImageMetadataHelper,\n                                           &data);\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxMoveImageMetadataHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1979-1994",
    "snippet": "static int\nvirSecuritySELinuxMoveImageMetadataHelper(pid_t pid G_GNUC_UNUSED,\n                                          void *opaque)\n{\n    struct virSecuritySELinuxMoveImageMetadataData *data = opaque;\n    const char *paths[2] = { data->src, data->dst };\n    virSecurityManagerMetadataLockStatePtr state;\n    int ret;\n\n    if (!(state = virSecurityManagerMetadataLock(data->mgr, paths, G_N_ELEMENTS(paths))))\n        return -1;\n\n    ret = virSecurityMoveRememberedLabel(SECURITY_SELINUX_NAME, data->src, data->dst);\n    virSecurityManagerMetadataUnlock(data->mgr, &state);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataUnlock",
          "args": [
            "data->mgr",
            "&state"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1400-1429",
          "snippet": "void\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvoid\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityMoveRememberedLabel",
          "args": [
            "SECURITY_SELINUX_NAME",
            "data->src",
            "data->dst"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityMoveRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "444-530",
          "snippet": "int\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataLock",
          "args": [
            "data->mgr",
            "paths",
            "G_N_ELEMENTS(paths)"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1283-1397",
          "snippet": "virSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvirSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "paths"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxMoveImageMetadataHelper(pid_t pid G_GNUC_UNUSED,\n                                          void *opaque)\n{\n    struct virSecuritySELinuxMoveImageMetadataData *data = opaque;\n    const char *paths[2] = { data->src, data->dst };\n    virSecurityManagerMetadataLockStatePtr state;\n    int ret;\n\n    if (!(state = virSecurityManagerMetadataLock(data->mgr, paths, G_N_ELEMENTS(paths))))\n        return -1;\n\n    ret = virSecurityMoveRememberedLabel(SECURITY_SELINUX_NAME, data->src, data->dst);\n    virSecurityManagerMetadataUnlock(data->mgr, &state);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1963-1970",
    "snippet": "static int\nvirSecuritySELinuxSetImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags)\n{\n    return virSecuritySELinuxSetImageLabelRelative(mgr, def, src, src, flags);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetImageLabelRelative",
          "args": [
            "mgr",
            "def",
            "src",
            "src",
            "flags"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetImageLabelRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1930-1960",
          "snippet": "static int\nvirSecuritySELinuxSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecuritySELinuxSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecuritySELinuxSetImageLabelRelative(mgr,\n                                                    def,\n                                                    n->externalDataStore,\n                                                    parent,\n                                                    flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecuritySELinuxSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecuritySELinuxSetImageLabelRelative(mgr,\n                                                    def,\n                                                    n->externalDataStore,\n                                                    parent,\n                                                    flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags)\n{\n    return virSecuritySELinuxSetImageLabelRelative(mgr, def, src, src, flags);\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetImageLabelRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1930-1960",
    "snippet": "static int\nvirSecuritySELinuxSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecuritySELinuxSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecuritySELinuxSetImageLabelRelative(mgr,\n                                                    def,\n                                                    n->externalDataStore,\n                                                    parent,\n                                                    flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetImageLabelRelative",
          "args": [
            "mgr",
            "def",
            "n->externalDataStore",
            "parent",
            "flags"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetImageLabelRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1930-1960",
          "snippet": "static int\nvirSecuritySELinuxSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecuritySELinuxSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecuritySELinuxSetImageLabelRelative(mgr,\n                                                    def,\n                                                    n->externalDataStore,\n                                                    parent,\n                                                    flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetImageLabelInternal",
          "args": [
            "mgr",
            "def",
            "n",
            "parent",
            "isChainTop"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetImageLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1830-1927",
          "snippet": "static int\nvirSecuritySELinuxSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        bool isChainTop)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    char *use_label = NULL;\n    bool remember;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n    int ret;\n\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_SELINUX_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        use_label = disk_seclabel->label;\n    } else if (parent_seclabel && (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        use_label = parent_seclabel->label;\n    } else if (parent == src || parent->externalDataStore == src) {\n        if (src->shared) {\n            use_label = data->file_context;\n        } else if (src->readonly) {\n            use_label = data->content_context;\n        } else if (secdef->imagelabel) {\n            use_label = secdef->imagelabel;\n        } else {\n            return 0;\n        }\n    } else {\n        use_label = data->content_context;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        path = vfioGroupDev;\n    }\n\n    ret = virSecuritySELinuxSetFilecon(mgr, path, use_label, remember);\n\n    if (ret == 1 && !disk_seclabel) {\n        /* If we failed to set a label, but virt_use_nfs let us\n         * proceed anyway, then we don't need to relabel later.  */\n        disk_seclabel = virSecurityDeviceLabelDefNew(SECURITY_SELINUX_NAME);\n        if (!disk_seclabel)\n            return -1;\n        disk_seclabel->labelskip = true;\n        if (VIR_APPEND_ELEMENT(src->seclabels, src->nseclabels,\n                               disk_seclabel) < 0) {\n            virSecurityDeviceLabelDefFree(disk_seclabel);\n            return -1;\n        }\n        ret = 0;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        bool isChainTop)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    char *use_label = NULL;\n    bool remember;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n    int ret;\n\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_SELINUX_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        use_label = disk_seclabel->label;\n    } else if (parent_seclabel && (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        use_label = parent_seclabel->label;\n    } else if (parent == src || parent->externalDataStore == src) {\n        if (src->shared) {\n            use_label = data->file_context;\n        } else if (src->readonly) {\n            use_label = data->content_context;\n        } else if (secdef->imagelabel) {\n            use_label = secdef->imagelabel;\n        } else {\n            return 0;\n        }\n    } else {\n        use_label = data->content_context;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        path = vfioGroupDev;\n    }\n\n    ret = virSecuritySELinuxSetFilecon(mgr, path, use_label, remember);\n\n    if (ret == 1 && !disk_seclabel) {\n        /* If we failed to set a label, but virt_use_nfs let us\n         * proceed anyway, then we don't need to relabel later.  */\n        disk_seclabel = virSecurityDeviceLabelDefNew(SECURITY_SELINUX_NAME);\n        if (!disk_seclabel)\n            return -1;\n        disk_seclabel->labelskip = true;\n        if (VIR_APPEND_ELEMENT(src->seclabels, src->nseclabels,\n                               disk_seclabel) < 0) {\n            virSecurityDeviceLabelDefFree(disk_seclabel);\n            return -1;\n        }\n        ret = 0;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "n"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecuritySELinuxSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecuritySELinuxSetImageLabelRelative(mgr,\n                                                    def,\n                                                    n->externalDataStore,\n                                                    parent,\n                                                    flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetImageLabelInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1830-1927",
    "snippet": "static int\nvirSecuritySELinuxSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        bool isChainTop)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    char *use_label = NULL;\n    bool remember;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n    int ret;\n\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_SELINUX_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        use_label = disk_seclabel->label;\n    } else if (parent_seclabel && (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        use_label = parent_seclabel->label;\n    } else if (parent == src || parent->externalDataStore == src) {\n        if (src->shared) {\n            use_label = data->file_context;\n        } else if (src->readonly) {\n            use_label = data->content_context;\n        } else if (secdef->imagelabel) {\n            use_label = secdef->imagelabel;\n        } else {\n            return 0;\n        }\n    } else {\n        use_label = data->content_context;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        path = vfioGroupDev;\n    }\n\n    ret = virSecuritySELinuxSetFilecon(mgr, path, use_label, remember);\n\n    if (ret == 1 && !disk_seclabel) {\n        /* If we failed to set a label, but virt_use_nfs let us\n         * proceed anyway, then we don't need to relabel later.  */\n        disk_seclabel = virSecurityDeviceLabelDefNew(SECURITY_SELINUX_NAME);\n        if (!disk_seclabel)\n            return -1;\n        disk_seclabel->labelskip = true;\n        if (VIR_APPEND_ELEMENT(src->seclabels, src->nseclabels,\n                               disk_seclabel) < 0) {\n            virSecurityDeviceLabelDefFree(disk_seclabel);\n            return -1;\n        }\n        ret = 0;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDeviceLabelDefFree",
          "args": [
            "disk_seclabel"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDeviceLabelDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virseclabel.c",
          "lines": "45-53",
          "snippet": "void\nvirSecurityDeviceLabelDefFree(virSecurityDeviceLabelDefPtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->model);\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virseclabel.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virseclabel.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirSecurityDeviceLabelDefFree(virSecurityDeviceLabelDefPtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->model);\n    VIR_FREE(def->label);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "src->seclabels",
            "src->nseclabels",
            "disk_seclabel"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDeviceLabelDefNew",
          "args": [
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDeviceLabelDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virseclabel.c",
          "lines": "73-86",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirSecurityDeviceLabelDefNew(const char *model)\n{\n    virSecurityDeviceLabelDefPtr seclabel = NULL;\n\n    if (VIR_ALLOC(seclabel) < 0) {\n        virSecurityDeviceLabelDefFree(seclabel);\n        seclabel = NULL;\n    }\n\n    seclabel->model = g_strdup(model);\n\n    return seclabel;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virseclabel.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virseclabel.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirSecurityDeviceLabelDefPtr\nvirSecurityDeviceLabelDefNew(const char *model)\n{\n    virSecurityDeviceLabelDefPtr seclabel = NULL;\n\n    if (VIR_ALLOC(seclabel) < 0) {\n        virSecurityDeviceLabelDefFree(seclabel);\n        seclabel = NULL;\n    }\n\n    seclabel->model = g_strdup(model);\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "path",
            "use_label",
            "remember"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupDev",
          "args": [
            "&nvme->pciAddr"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1953-1965",
          "snippet": "char *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetSecurityLabelDef",
          "args": [
            "parent",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2105-2117",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def,\n                                        virStorageSourcePtr src,\n                                        virStorageSourcePtr parent,\n                                        bool isChainTop)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    char *use_label = NULL;\n    bool remember;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n    int ret;\n\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_SELINUX_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        use_label = disk_seclabel->label;\n    } else if (parent_seclabel && (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        use_label = parent_seclabel->label;\n    } else if (parent == src || parent->externalDataStore == src) {\n        if (src->shared) {\n            use_label = data->file_context;\n        } else if (src->readonly) {\n            use_label = data->content_context;\n        } else if (secdef->imagelabel) {\n            use_label = secdef->imagelabel;\n        } else {\n            return 0;\n        }\n    } else {\n        use_label = data->content_context;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        path = vfioGroupDev;\n    }\n\n    ret = virSecuritySELinuxSetFilecon(mgr, path, use_label, remember);\n\n    if (ret == 1 && !disk_seclabel) {\n        /* If we failed to set a label, but virt_use_nfs let us\n         * proceed anyway, then we don't need to relabel later.  */\n        disk_seclabel = virSecurityDeviceLabelDefNew(SECURITY_SELINUX_NAME);\n        if (!disk_seclabel)\n            return -1;\n        disk_seclabel->labelskip = true;\n        if (VIR_APPEND_ELEMENT(src->seclabels, src->nseclabels,\n                               disk_seclabel) < 0) {\n            virSecurityDeviceLabelDefFree(disk_seclabel);\n            return -1;\n        }\n        ret = 0;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1820-1827",
    "snippet": "static int\nvirSecuritySELinuxRestoreImageLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virSecurityDomainImageLabelFlags flags G_GNUC_UNUSED)\n{\n    return virSecuritySELinuxRestoreImageLabelInt(mgr, def, src, false);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreImageLabelInt",
          "args": [
            "mgr",
            "def",
            "src",
            "false"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreImageLabelInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1800-1817",
          "snippet": "static int\nvirSecuritySELinuxRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr def,\n                                       virStorageSourcePtr src,\n                                       bool migrated)\n{\n    if (virSecuritySELinuxRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecuritySELinuxRestoreImageLabelSingle(mgr,\n                                                  def,\n                                                  src->externalDataStore,\n                                                  migrated) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr def,\n                                       virStorageSourcePtr src,\n                                       bool migrated)\n{\n    if (virSecuritySELinuxRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecuritySELinuxRestoreImageLabelSingle(mgr,\n                                                  def,\n                                                  src->externalDataStore,\n                                                  migrated) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreImageLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virSecurityDomainImageLabelFlags flags G_GNUC_UNUSED)\n{\n    return virSecuritySELinuxRestoreImageLabelInt(mgr, def, src, false);\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreImageLabelInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1800-1817",
    "snippet": "static int\nvirSecuritySELinuxRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr def,\n                                       virStorageSourcePtr src,\n                                       bool migrated)\n{\n    if (virSecuritySELinuxRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecuritySELinuxRestoreImageLabelSingle(mgr,\n                                                  def,\n                                                  src->externalDataStore,\n                                                  migrated) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreImageLabelSingle",
          "args": [
            "mgr",
            "def",
            "src->externalDataStore",
            "migrated"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreImageLabelSingle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1723-1797",
          "snippet": "static int\nvirSecuritySELinuxRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                          virDomainDefPtr def,\n                                          virStorageSourcePtr src,\n                                          bool migrated)\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    if (!seclabel->relabel || (disk_seclabel && !disk_seclabel->relabel))\n        return 0;\n\n    /* If labelskip is true and there are no backing files, then we\n     * know it is safe to skip the restore.  FIXME - backing files should\n     * be tracked in domain XML, at which point labelskip should be a\n     * per-file attribute instead of a disk attribute. */\n    if (disk_seclabel && disk_seclabel->labelskip &&\n        !virStorageSourceHasBacking(src))\n        return 0;\n\n    /* Don't restore labels on readonly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n        path = vfioGroupDev;\n    }\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                          virDomainDefPtr def,\n                                          virStorageSourcePtr src,\n                                          bool migrated)\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    if (!seclabel->relabel || (disk_seclabel && !disk_seclabel->relabel))\n        return 0;\n\n    /* If labelskip is true and there are no backing files, then we\n     * know it is safe to skip the restore.  FIXME - backing files should\n     * be tracked in domain XML, at which point labelskip should be a\n     * per-file attribute instead of a disk attribute. */\n    if (disk_seclabel && disk_seclabel->labelskip &&\n        !virStorageSourceHasBacking(src))\n        return 0;\n\n    /* Don't restore labels on readonly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n        path = vfioGroupDev;\n    }\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr def,\n                                       virStorageSourcePtr src,\n                                       bool migrated)\n{\n    if (virSecuritySELinuxRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecuritySELinuxRestoreImageLabelSingle(mgr,\n                                                  def,\n                                                  src->externalDataStore,\n                                                  migrated) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreImageLabelSingle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1723-1797",
    "snippet": "static int\nvirSecuritySELinuxRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                          virDomainDefPtr def,\n                                          virStorageSourcePtr src,\n                                          bool migrated)\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    if (!seclabel->relabel || (disk_seclabel && !disk_seclabel->relabel))\n        return 0;\n\n    /* If labelskip is true and there are no backing files, then we\n     * know it is safe to skip the restore.  FIXME - backing files should\n     * be tracked in domain XML, at which point labelskip should be a\n     * per-file attribute instead of a disk attribute. */\n    if (disk_seclabel && disk_seclabel->labelskip &&\n        !virStorageSourceHasBacking(src))\n        return 0;\n\n    /* Don't restore labels on readonly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n        path = vfioGroupDev;\n    }\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "path",
            "true"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupDev",
          "args": [
            "&nvme->pciAddr"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1953-1965",
          "snippet": "char *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping image label restore on %s because FS is shared\"",
            "src->path"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsSharedFS",
          "args": [
            "src->path"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsSharedFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3699-3712",
          "snippet": "int virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "src"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetSecurityLabelDef",
          "args": [
            "src",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2105-2117",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                          virDomainDefPtr def,\n                                          virStorageSourcePtr src,\n                                          bool migrated)\n{\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    g_autofree char *vfioGroupDev = NULL;\n    const char *path = src->path;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_SELINUX_NAME);\n    if (!seclabel->relabel || (disk_seclabel && !disk_seclabel->relabel))\n        return 0;\n\n    /* If labelskip is true and there are no backing files, then we\n     * know it is safe to skip the restore.  FIXME - backing files should\n     * be tracked in domain XML, at which point labelskip should be a\n     * per-file attribute instead of a disk attribute. */\n    if (disk_seclabel && disk_seclabel->labelskip &&\n        !virStorageSourceHasBacking(src))\n        return 0;\n\n    /* Don't restore labels on readonly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n        path = vfioGroupDev;\n    }\n\n    return virSecuritySELinuxRestoreFileLabel(mgr, path, true);\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreTPMFileLabelInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1688-1720",
    "snippet": "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, tpmdev, false);\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr, cancel_path, false) < 0)\n                rc = -1;\n            VIR_FREE(cancel_path);\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cancel_path"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "cancel_path",
            "false"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTPMCreateCancelPath",
          "args": [
            "tpmdev"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMCreateCancelPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "55-88",
          "snippet": "char *\nvirTPMCreateCancelPath(const char *devpath)\n{\n    char *path = NULL;\n    const char *dev;\n    const char *prefix[] = {\"misc/\", \"tpm/\"};\n    size_t i;\n    if (!devpath) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing TPM device path\"));\n        return NULL;\n    }\n\n    if (!(dev = strrchr(devpath, '/'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"TPM device path %s is invalid\"), devpath);\n        return NULL;\n    }\n\n    dev++;\n    for (i = 0; i < G_N_ELEMENTS(prefix); i++) {\n        path = g_strdup_printf(\"/sys/class/%s%s/device/cancel\", prefix[i],\n                               dev);\n\n        if (virFileExists(path))\n            break;\n\n        VIR_FREE(path);\n    }\n    if (!path)\n        path = g_strdup(\"/dev/null\");\n\n    return path;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirTPMCreateCancelPath(const char *devpath)\n{\n    char *path = NULL;\n    const char *dev;\n    const char *prefix[] = {\"misc/\", \"tpm/\"};\n    size_t i;\n    if (!devpath) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing TPM device path\"));\n        return NULL;\n    }\n\n    if (!(dev = strrchr(devpath, '/'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"TPM device path %s is invalid\"), devpath);\n        return NULL;\n    }\n\n    dev++;\n    for (i = 0; i < G_N_ELEMENTS(prefix); i++) {\n        path = g_strdup_printf(\"/sys/class/%s%s/device/cancel\", prefix[i],\n                               dev);\n\n        if (virFileExists(path))\n            break;\n\n        VIR_FREE(path);\n    }\n    if (!path)\n        path = g_strdup(\"/dev/null\");\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, tpmdev, false);\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr, cancel_path, false) < 0)\n                rc = -1;\n            VIR_FREE(cancel_path);\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetTPMFileLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1640-1685",
    "snippet": "static int\nvirSecuritySELinuxSetTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int rc;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            rc = virSecuritySELinuxSetFilecon(mgr,\n                                              cancel_path,\n                                              seclabel->imagelabel, false);\n            VIR_FREE(cancel_path);\n            if (rc < 0) {\n                virSecuritySELinuxRestoreTPMFileLabelInt(mgr, def, tpm);\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        tpmdev = tpm->data.emulator.source.data.nix.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [
      "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "tpmdev",
            "seclabel->imagelabel",
            "false"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreTPMFileLabelInt",
          "args": [
            "mgr",
            "def",
            "tpm"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreTPMFileLabelInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1688-1720",
          "snippet": "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, tpmdev, false);\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr, cancel_path, false) < 0)\n                rc = -1;\n            VIR_FREE(cancel_path);\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [
            "static int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, tpmdev, false);\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            if (virSecuritySELinuxRestoreFileLabel(mgr, cancel_path, false) < 0)\n                rc = -1;\n            VIR_FREE(cancel_path);\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cancel_path"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTPMCreateCancelPath",
          "args": [
            "tpmdev"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "virTPMCreateCancelPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtpm.c",
          "lines": "55-88",
          "snippet": "char *\nvirTPMCreateCancelPath(const char *devpath)\n{\n    char *path = NULL;\n    const char *dev;\n    const char *prefix[] = {\"misc/\", \"tpm/\"};\n    size_t i;\n    if (!devpath) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing TPM device path\"));\n        return NULL;\n    }\n\n    if (!(dev = strrchr(devpath, '/'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"TPM device path %s is invalid\"), devpath);\n        return NULL;\n    }\n\n    dev++;\n    for (i = 0; i < G_N_ELEMENTS(prefix); i++) {\n        path = g_strdup_printf(\"/sys/class/%s%s/device/cancel\", prefix[i],\n                               dev);\n\n        if (virFileExists(path))\n            break;\n\n        VIR_FREE(path);\n    }\n    if (!path)\n        path = g_strdup(\"/dev/null\");\n\n    return path;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"virtpm.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"virtpm.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirTPMCreateCancelPath(const char *devpath)\n{\n    char *path = NULL;\n    const char *dev;\n    const char *prefix[] = {\"misc/\", \"tpm/\"};\n    size_t i;\n    if (!devpath) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing TPM device path\"));\n        return NULL;\n    }\n\n    if (!(dev = strrchr(devpath, '/'))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"TPM device path %s is invalid\"), devpath);\n        return NULL;\n    }\n\n    dev++;\n    for (i = 0; i < G_N_ELEMENTS(prefix); i++) {\n        path = g_strdup_printf(\"/sys/class/%s%s/device/cancel\", prefix[i],\n                               dev);\n\n        if (virFileExists(path))\n            break;\n\n        VIR_FREE(path);\n    }\n    if (!path)\n        path = g_strdup(\"/dev/null\");\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreTPMFileLabelInt(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr def,\n                                         virDomainTPMDefPtr tpm);\n\nstatic int\nvirSecuritySELinuxSetTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int rc;\n    virSecurityLabelDefPtr seclabel;\n    char *cancel_path;\n    const char *tpmdev;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        tpmdev = tpm->data.passthrough.source.data.file.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n\n        if ((cancel_path = virTPMCreateCancelPath(tpmdev)) != NULL) {\n            rc = virSecuritySELinuxSetFilecon(mgr,\n                                              cancel_path,\n                                              seclabel->imagelabel, false);\n            VIR_FREE(cancel_path);\n            if (rc < 0) {\n                virSecuritySELinuxRestoreTPMFileLabelInt(mgr, def, tpm);\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        tpmdev = tpm->data.emulator.source.data.nix.path;\n        rc = virSecuritySELinuxSetFilecon(mgr, tpmdev, seclabel->imagelabel, false);\n        if (rc < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreMemoryLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1612-1637",
    "snippet": "static int\nvirSecuritySELinuxRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "mem->nvdimmPath",
            "true"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def,\n                                     virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetMemoryLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1584-1609",
    "snippet": "static int\nvirSecuritySELinuxSetMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        if (virSecuritySELinuxSetFilecon(mgr, mem->nvdimmPath,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "mem->nvdimmPath",
            "seclabel->imagelabel",
            "true"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n\n        if (virSecuritySELinuxSetFilecon(mgr, mem->nvdimmPath,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreInputLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1556-1581",
    "snippet": "static int\nvirSecuritySELinuxRestoreInputLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainInputDefPtr input)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "input->source.evdev",
            "true"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRestoreInputLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainInputDefPtr input)\n{\n    int rc = 0;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        rc = virSecuritySELinuxRestoreFileLabel(mgr, input->source.evdev, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetInputLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1527-1553",
    "snippet": "static int\nvirSecuritySELinuxSetInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virDomainInputDefPtr input)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecuritySELinuxSetFilecon(mgr, input->source.evdev,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "mgr",
            "input->source.evdev",
            "seclabel->imagelabel",
            "true"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxSetInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virDomainInputDefPtr input)\n{\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecuritySELinuxSetFilecon(mgr, input->source.evdev,\n                                         seclabel->imagelabel, true) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRestoreFileLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1453-1524",
    "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newpath"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "fcon"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFileconImpl",
          "args": [
            "newpath",
            "fcon",
            "privileged"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFileconImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1269-1323",
          "snippet": "static int\nvirSecuritySELinuxSetFileconImpl(const char *path,\n                                 const char *tcon,\n                                 bool privileged)\n{\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    VIR_INFO(\"Setting SELinux context on '%s' to '%s'\", path, tcon);\n\n    if (setfilecon_raw(path, (const char *)tcon) < 0) {\n        int setfilecon_errno = errno;\n\n        /* If the error complaint is related to an image hosted on a (possibly\n         * read-only) NFS mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.  The user\n         * hopefully sets one of the necessary SELinux virt_use_{nfs,usb,pci}\n         * boolean tunables to allow it ...\n         */\n        VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n        if (setfilecon_errno != EOPNOTSUPP && setfilecon_errno != ENOTSUP &&\n            setfilecon_errno != EROFS) {\n        VIR_WARNINGS_RESET\n            /* However, don't claim error if SELinux is in Enforcing mode and\n             * we are running as unprivileged user and we really did see EPERM.\n             * Otherwise we want to return error if SELinux is Enforcing. */\n            if (security_getenforce() == 1 &&\n                (setfilecon_errno != EPERM || privileged)) {\n                virReportSystemError(setfilecon_errno,\n                                     _(\"unable to set security context '%s' on '%s'\"),\n                                     tcon, path);\n                return -1;\n            }\n            VIR_WARN(\"unable to set security context '%s' on '%s' (errno %d)\",\n                     tcon, path, setfilecon_errno);\n        } else {\n            const char *msg;\n            if (virFileIsSharedFSType(path, VIR_FILE_SHFS_NFS) == 1 &&\n                security_get_boolean_active(\"virt_use_nfs\") != 1) {\n                msg = _(\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\");\n                if (security_getenforce() == 1)\n                    VIR_WARN(msg, tcon, path);\n                else\n                    VIR_INFO(msg, tcon, path);\n            } else {\n                VIR_INFO(\"Setting security context '%s' on '%s' not supported\",\n                         tcon, path);\n            }\n        }\n\n        return 1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetFileconImpl(const char *path,\n                                 const char *tcon,\n                                 bool privileged)\n{\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    VIR_INFO(\"Setting SELinux context on '%s' to '%s'\", path, tcon);\n\n    if (setfilecon_raw(path, (const char *)tcon) < 0) {\n        int setfilecon_errno = errno;\n\n        /* If the error complaint is related to an image hosted on a (possibly\n         * read-only) NFS mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.  The user\n         * hopefully sets one of the necessary SELinux virt_use_{nfs,usb,pci}\n         * boolean tunables to allow it ...\n         */\n        VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n        if (setfilecon_errno != EOPNOTSUPP && setfilecon_errno != ENOTSUP &&\n            setfilecon_errno != EROFS) {\n        VIR_WARNINGS_RESET\n            /* However, don't claim error if SELinux is in Enforcing mode and\n             * we are running as unprivileged user and we really did see EPERM.\n             * Otherwise we want to return error if SELinux is Enforcing. */\n            if (security_getenforce() == 1 &&\n                (setfilecon_errno != EPERM || privileged)) {\n                virReportSystemError(setfilecon_errno,\n                                     _(\"unable to set security context '%s' on '%s'\"),\n                                     tcon, path);\n                return -1;\n            }\n            VIR_WARN(\"unable to set security context '%s' on '%s' (errno %d)\",\n                     tcon, path, setfilecon_errno);\n        } else {\n            const char *msg;\n            if (virFileIsSharedFSType(path, VIR_FILE_SHFS_NFS) == 1 &&\n                security_get_boolean_active(\"virt_use_nfs\") != 1) {\n                msg = _(\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\");\n                if (security_getenforce() == 1)\n                    VIR_WARN(msg, tcon, path);\n                else\n                    VIR_INFO(msg, tcon, path);\n            } else {\n                VIR_INFO(\"Setting security context '%s' on '%s' not supported\",\n                         tcon, path);\n            }\n        }\n\n        return 1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"cannot lookup default selinux label for %s\"",
            "newpath"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getContext",
          "args": [
            "mgr",
            "newpath",
            "buf.st_mode",
            "&fcon"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "getContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1441-1448",
          "snippet": "static int\ngetContext(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n           const char *newpath, mode_t mode, security_context_t *fcon)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    return selabel_lookup_raw(data->label_handle, fcon, newpath, mode);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\ngetContext(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n           const char *newpath, mode_t mode, security_context_t *fcon)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    return selabel_lookup_raw(data->label_handle, fcon, newpath, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"cannot stat %s: %s\"",
            "newpath",
            "g_strerror(errno)"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "newpath",
            "&buf"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRecallLabel",
          "args": [
            "newpath",
            "&fcon"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRecallLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "208-222",
          "snippet": "static int\nvirSecuritySELinuxRecallLabel(const char *path,\n                              security_context_t *con)\n{\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_SELINUX_NAME, path, con);\n    if (rv < 0)\n        return rv;\n\n    if (!*con)\n        return 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRecallLabel(const char *path,\n                              security_context_t *con)\n{\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_SELINUX_NAME, path, con);\n    if (rv < 0)\n        return rv;\n\n    if (!*con)\n        return 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxTransactionAppend",
          "args": [
            "path",
            "NULL",
            "recall",
            "true"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxTransactionAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "179-196",
          "snippet": "static int\nvirSecuritySELinuxTransactionAppend(const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return 0;\n\n    if (virSecuritySELinuxContextListAppend(list, path, tcon,\n                                            remember, restore) < 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal contextList;",
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxTransactionAppend(const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return 0;\n\n    if (virSecuritySELinuxContextListAppend(list, path, tcon,\n                                            remember, restore) < 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"cannot resolve symlink %s: %s\"",
            "path",
            "g_strerror(errno)"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "path",
            "&newpath"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Restoring SELinux context on '%s'\"",
            "path"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivileged",
          "args": [
            "mgr"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "405-409",
          "snippet": "bool\nvirSecurityManagerGetPrivileged(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_PRIVILEGED;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetPrivileged(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_PRIVILEGED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
  },
  {
    "function_name": "getContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1441-1448",
    "snippet": "static int\ngetContext(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n           const char *newpath, mode_t mode, security_context_t *fcon)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    return selabel_lookup_raw(data->label_handle, fcon, newpath, mode);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selabel_lookup_raw",
          "args": [
            "data->label_handle",
            "fcon",
            "newpath",
            "mode"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\ngetContext(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n           const char *newpath, mode_t mode, security_context_t *fcon)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    return selabel_lookup_raw(data->label_handle, fcon, newpath, mode);\n}"
  },
  {
    "function_name": "virSecuritySELinuxFSetFilecon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1412-1438",
    "snippet": "static int\nvirSecuritySELinuxFSetFilecon(int fd, char *tcon)\n{\n    VIR_INFO(\"Setting SELinux context on fd %d to '%s'\", fd, tcon);\n\n    if (fsetfilecon_raw(fd, tcon) < 0) {\n        int fsetfilecon_errno = errno;\n\n        /* if the error complaint is related to an image hosted on\n         * an nfs mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.\n         * The user hopefully set one of the necessary SELinux\n         * virt_use_{nfs,usb,pci}  boolean tunables to allow it...\n         */\n        if (fsetfilecon_errno != EOPNOTSUPP) {\n            virReportSystemError(fsetfilecon_errno,\n                                 _(\"unable to set security context '%s' on fd %d\"),\n                                 tcon, fd);\n            if (security_getenforce() == 1)\n                return -1;\n        } else {\n            VIR_INFO(\"Setting security context '%s' on fd %d not supported\",\n                     tcon, fd);\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting security context '%s' on fd %d not supported\"",
            "tcon",
            "fd"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "fsetfilecon_errno",
            "_(\"unable to set security context '%s' on fd %d\")",
            "tcon",
            "fd"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to set security context '%s' on fd %d\""
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsetfilecon_raw",
          "args": [
            "fd",
            "tcon"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting SELinux context on fd %d to '%s'\"",
            "fd",
            "tcon"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxFSetFilecon(int fd, char *tcon)\n{\n    VIR_INFO(\"Setting SELinux context on fd %d to '%s'\", fd, tcon);\n\n    if (fsetfilecon_raw(fd, tcon) < 0) {\n        int fsetfilecon_errno = errno;\n\n        /* if the error complaint is related to an image hosted on\n         * an nfs mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.\n         * The user hopefully set one of the necessary SELinux\n         * virt_use_{nfs,usb,pci}  boolean tunables to allow it...\n         */\n        if (fsetfilecon_errno != EOPNOTSUPP) {\n            virReportSystemError(fsetfilecon_errno,\n                                 _(\"unable to set security context '%s' on fd %d\"),\n                                 tcon, fd);\n            if (security_getenforce() == 1)\n                return -1;\n        } else {\n            VIR_INFO(\"Setting security context '%s' on fd %d not supported\",\n                     tcon, fd);\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetFilecon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1326-1409",
    "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "econ"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&origerr"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\"",
            "path"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "mgr",
            "path",
            "remember"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&origerr"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFileconImpl",
          "args": [
            "path",
            "tcon",
            "privileged"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFileconImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1269-1323",
          "snippet": "static int\nvirSecuritySELinuxSetFileconImpl(const char *path,\n                                 const char *tcon,\n                                 bool privileged)\n{\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    VIR_INFO(\"Setting SELinux context on '%s' to '%s'\", path, tcon);\n\n    if (setfilecon_raw(path, (const char *)tcon) < 0) {\n        int setfilecon_errno = errno;\n\n        /* If the error complaint is related to an image hosted on a (possibly\n         * read-only) NFS mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.  The user\n         * hopefully sets one of the necessary SELinux virt_use_{nfs,usb,pci}\n         * boolean tunables to allow it ...\n         */\n        VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n        if (setfilecon_errno != EOPNOTSUPP && setfilecon_errno != ENOTSUP &&\n            setfilecon_errno != EROFS) {\n        VIR_WARNINGS_RESET\n            /* However, don't claim error if SELinux is in Enforcing mode and\n             * we are running as unprivileged user and we really did see EPERM.\n             * Otherwise we want to return error if SELinux is Enforcing. */\n            if (security_getenforce() == 1 &&\n                (setfilecon_errno != EPERM || privileged)) {\n                virReportSystemError(setfilecon_errno,\n                                     _(\"unable to set security context '%s' on '%s'\"),\n                                     tcon, path);\n                return -1;\n            }\n            VIR_WARN(\"unable to set security context '%s' on '%s' (errno %d)\",\n                     tcon, path, setfilecon_errno);\n        } else {\n            const char *msg;\n            if (virFileIsSharedFSType(path, VIR_FILE_SHFS_NFS) == 1 &&\n                security_get_boolean_active(\"virt_use_nfs\") != 1) {\n                msg = _(\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\");\n                if (security_getenforce() == 1)\n                    VIR_WARN(msg, tcon, path);\n                else\n                    VIR_INFO(msg, tcon, path);\n            } else {\n                VIR_INFO(\"Setting security context '%s' on '%s' not supported\",\n                         tcon, path);\n            }\n        }\n\n        return 1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetFileconImpl(const char *path,\n                                 const char *tcon,\n                                 bool privileged)\n{\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    VIR_INFO(\"Setting SELinux context on '%s' to '%s'\", path, tcon);\n\n    if (setfilecon_raw(path, (const char *)tcon) < 0) {\n        int setfilecon_errno = errno;\n\n        /* If the error complaint is related to an image hosted on a (possibly\n         * read-only) NFS mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.  The user\n         * hopefully sets one of the necessary SELinux virt_use_{nfs,usb,pci}\n         * boolean tunables to allow it ...\n         */\n        VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n        if (setfilecon_errno != EOPNOTSUPP && setfilecon_errno != ENOTSUP &&\n            setfilecon_errno != EROFS) {\n        VIR_WARNINGS_RESET\n            /* However, don't claim error if SELinux is in Enforcing mode and\n             * we are running as unprivileged user and we really did see EPERM.\n             * Otherwise we want to return error if SELinux is Enforcing. */\n            if (security_getenforce() == 1 &&\n                (setfilecon_errno != EPERM || privileged)) {\n                virReportSystemError(setfilecon_errno,\n                                     _(\"unable to set security context '%s' on '%s'\"),\n                                     tcon, path);\n                return -1;\n            }\n            VIR_WARN(\"unable to set security context '%s' on '%s' (errno %d)\",\n                     tcon, path, setfilecon_errno);\n        } else {\n            const char *msg;\n            if (virFileIsSharedFSType(path, VIR_FILE_SHFS_NFS) == 1 &&\n                security_get_boolean_active(\"virt_use_nfs\") != 1) {\n                msg = _(\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\");\n                if (security_getenforce() == 1)\n                    VIR_WARN(msg, tcon, path);\n                else\n                    VIR_INFO(msg, tcon, path);\n            } else {\n                VIR_INFO(\"Setting security context '%s' on '%s' not supported\",\n                         tcon, path);\n            }\n        }\n\n        return 1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\")",
            "path"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Setting different SELinux label on %s \"\n                                     \"which is already in use\""
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "econ",
            "tcon"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRememberLabel",
          "args": [
            "path",
            "econ"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRememberLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "199-205",
          "snippet": "static int\nvirSecuritySELinuxRememberLabel(const char *path,\n                                const security_context_t con)\n{\n    return virSecuritySetRememberedLabel(SECURITY_SELINUX_NAME,\n                                         path, con);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_SELINUX_NAME \"selinux\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRememberLabel(const char *path,\n                                const security_context_t con)\n{\n    return virSecuritySetRememberedLabel(SECURITY_SELINUX_NAME,\n                                         path, con);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get SELinux context of %s\")",
            "path"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getfilecon_raw",
          "args": [
            "path",
            "&econ"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxTransactionAppend",
          "args": [
            "path",
            "tcon",
            "remember",
            "false"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxTransactionAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "179-196",
          "snippet": "static int\nvirSecuritySELinuxTransactionAppend(const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return 0;\n\n    if (virSecuritySELinuxContextListAppend(list, path, tcon,\n                                            remember, restore) < 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal contextList;",
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxTransactionAppend(const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return 0;\n\n    if (virSecuritySELinuxContextListAppend(list, path, tcon,\n                                            remember, restore) < 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivileged",
          "args": [
            "mgr"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "405-409",
          "snippet": "bool\nvirSecurityManagerGetPrivileged(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_PRIVILEGED;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetPrivileged(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_PRIVILEGED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxSetFileconImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1269-1323",
    "snippet": "static int\nvirSecuritySELinuxSetFileconImpl(const char *path,\n                                 const char *tcon,\n                                 bool privileged)\n{\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    VIR_INFO(\"Setting SELinux context on '%s' to '%s'\", path, tcon);\n\n    if (setfilecon_raw(path, (const char *)tcon) < 0) {\n        int setfilecon_errno = errno;\n\n        /* If the error complaint is related to an image hosted on a (possibly\n         * read-only) NFS mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.  The user\n         * hopefully sets one of the necessary SELinux virt_use_{nfs,usb,pci}\n         * boolean tunables to allow it ...\n         */\n        VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n        if (setfilecon_errno != EOPNOTSUPP && setfilecon_errno != ENOTSUP &&\n            setfilecon_errno != EROFS) {\n        VIR_WARNINGS_RESET\n            /* However, don't claim error if SELinux is in Enforcing mode and\n             * we are running as unprivileged user and we really did see EPERM.\n             * Otherwise we want to return error if SELinux is Enforcing. */\n            if (security_getenforce() == 1 &&\n                (setfilecon_errno != EPERM || privileged)) {\n                virReportSystemError(setfilecon_errno,\n                                     _(\"unable to set security context '%s' on '%s'\"),\n                                     tcon, path);\n                return -1;\n            }\n            VIR_WARN(\"unable to set security context '%s' on '%s' (errno %d)\",\n                     tcon, path, setfilecon_errno);\n        } else {\n            const char *msg;\n            if (virFileIsSharedFSType(path, VIR_FILE_SHFS_NFS) == 1 &&\n                security_get_boolean_active(\"virt_use_nfs\") != 1) {\n                msg = _(\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\");\n                if (security_getenforce() == 1)\n                    VIR_WARN(msg, tcon, path);\n                else\n                    VIR_INFO(msg, tcon, path);\n            } else {\n                VIR_INFO(\"Setting security context '%s' on '%s' not supported\",\n                         tcon, path);\n            }\n        }\n\n        return 1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting security context '%s' on '%s' not supported\"",
            "tcon",
            "path"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "msg",
            "tcon",
            "path"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "msg",
            "tcon",
            "path"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\""
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_get_boolean_active",
          "args": [
            "\"virt_use_nfs\""
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsSharedFSType",
          "args": [
            "path",
            "VIR_FILE_SHFS_NFS"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsSharedFSType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3648-3653",
          "snippet": "int virFileIsSharedFSType(const char *path G_GNUC_UNUSED,\n                          int fstypes G_GNUC_UNUSED)\n{\n    /* XXX implement me :-) */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileIsSharedFSType(const char *path G_GNUC_UNUSED,\n                          int fstypes G_GNUC_UNUSED)\n{\n    /* XXX implement me :-) */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"unable to set security context '%s' on '%s' (errno %d)\"",
            "tcon",
            "path",
            "setfilecon_errno"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "setfilecon_errno",
            "_(\"unable to set security context '%s' on '%s'\")",
            "tcon",
            "path"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfilecon_raw",
          "args": [
            "path",
            "(const char *)tcon"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting SELinux context on '%s' to '%s'\"",
            "path",
            "tcon"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxSetFileconImpl(const char *path,\n                                 const char *tcon,\n                                 bool privileged)\n{\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    VIR_INFO(\"Setting SELinux context on '%s' to '%s'\", path, tcon);\n\n    if (setfilecon_raw(path, (const char *)tcon) < 0) {\n        int setfilecon_errno = errno;\n\n        /* If the error complaint is related to an image hosted on a (possibly\n         * read-only) NFS mount, or a usbfs/sysfs filesystem not supporting\n         * labelling, then just ignore it & hope for the best.  The user\n         * hopefully sets one of the necessary SELinux virt_use_{nfs,usb,pci}\n         * boolean tunables to allow it ...\n         */\n        VIR_WARNINGS_NO_WLOGICALOP_EQUAL_EXPR\n        if (setfilecon_errno != EOPNOTSUPP && setfilecon_errno != ENOTSUP &&\n            setfilecon_errno != EROFS) {\n        VIR_WARNINGS_RESET\n            /* However, don't claim error if SELinux is in Enforcing mode and\n             * we are running as unprivileged user and we really did see EPERM.\n             * Otherwise we want to return error if SELinux is Enforcing. */\n            if (security_getenforce() == 1 &&\n                (setfilecon_errno != EPERM || privileged)) {\n                virReportSystemError(setfilecon_errno,\n                                     _(\"unable to set security context '%s' on '%s'\"),\n                                     tcon, path);\n                return -1;\n            }\n            VIR_WARN(\"unable to set security context '%s' on '%s' (errno %d)\",\n                     tcon, path, setfilecon_errno);\n        } else {\n            const char *msg;\n            if (virFileIsSharedFSType(path, VIR_FILE_SHFS_NFS) == 1 &&\n                security_get_boolean_active(\"virt_use_nfs\") != 1) {\n                msg = _(\"Setting security context '%s' on '%s' not supported. \"\n                        \"Consider setting virt_use_nfs\");\n                if (security_getenforce() == 1)\n                    VIR_WARN(msg, tcon, path);\n                else\n                    VIR_INFO(msg, tcon, path);\n            } else {\n                VIR_INFO(\"Setting security context '%s' on '%s' not supported\",\n                         tcon, path);\n            }\n        }\n\n        return 1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGetProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1214-1250",
    "snippet": "static int\nvirSecuritySELinuxGetProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                  virDomainDefPtr def G_GNUC_UNUSED,\n                                  pid_t pid,\n                                  virSecurityLabelPtr sec)\n{\n    security_context_t ctx;\n\n    if (getpidcon_raw(pid, &ctx) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to get PID %d security context\"),\n                             pid);\n        return -1;\n    }\n\n    if (strlen((char *)ctx) >= VIR_SECURITY_LABEL_BUFLEN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label exceeds \"\n                         \"maximum length: %d\"),\n                       VIR_SECURITY_LABEL_BUFLEN - 1);\n        freecon(ctx);\n        return -1;\n    }\n\n    strcpy(sec->label, (char *)ctx);\n    freecon(ctx);\n\n    VIR_DEBUG(\"label=%s\", sec->label);\n    sec->enforcing = security_getenforce();\n    if (sec->enforcing == -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"error calling security_getenforce()\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"error calling security_getenforce()\")"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"error calling security_getenforce()\""
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"label=%s\"",
            "sec->label"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ctx"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sec->label",
            "(char *)ctx"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ctx"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label exceeds \"\n                         \"maximum length: %d\")",
            "VIR_SECURITY_LABEL_BUFLEN - 1"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(char *)ctx"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get PID %d security context\")",
            "pid"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpidcon_raw",
          "args": [
            "pid",
            "&ctx"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxGetProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                  virDomainDefPtr def G_GNUC_UNUSED,\n                                  pid_t pid,\n                                  virSecurityLabelPtr sec)\n{\n    security_context_t ctx;\n\n    if (getpidcon_raw(pid, &ctx) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to get PID %d security context\"),\n                             pid);\n        return -1;\n    }\n\n    if (strlen((char *)ctx) >= VIR_SECURITY_LABEL_BUFLEN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label exceeds \"\n                         \"maximum length: %d\"),\n                       VIR_SECURITY_LABEL_BUFLEN - 1);\n        freecon(ctx);\n        return -1;\n    }\n\n    strcpy(sec->label, (char *)ctx);\n    freecon(ctx);\n\n    VIR_DEBUG(\"label=%s\", sec->label);\n    sec->enforcing = security_getenforce();\n    if (sec->enforcing == -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"error calling security_getenforce()\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxTransactionAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1200-1212",
    "snippet": "static void\nvirSecuritySELinuxTransactionAbort(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return;\n\n    if (virThreadLocalSet(&contextList, NULL) < 0)\n        VIR_DEBUG(\"Unable to clear thread local variable\");\n    virSecuritySELinuxContextListFree(list);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal contextList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextListFree",
          "args": [
            "list"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "144-159",
          "snippet": "static void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to clear thread local variable\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadLocalSet",
          "args": [
            "&contextList",
            "NULL"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "352-360",
          "snippet": "int virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&contextList"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\n\nstatic void\nvirSecuritySELinuxTransactionAbort(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return;\n\n    if (virThreadLocalSet(&contextList, NULL) < 0)\n        VIR_DEBUG(\"Unable to clear thread local variable\");\n    virSecuritySELinuxContextListFree(list);\n}"
  },
  {
    "function_name": "virSecuritySELinuxTransactionCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1142-1192",
    "snippet": "static int\nvirSecuritySELinuxTransactionCommit(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                    pid_t pid,\n                                    bool lock)\n{\n    virSecuritySELinuxContextListPtr list;\n    int rc;\n    int ret = -1;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No transaction is set\"));\n        return -1;\n    }\n\n    if (virThreadLocalSet(&contextList, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to clear thread local variable\"));\n        goto cleanup;\n    }\n\n    list->lock = lock;\n\n    if (pid != -1) {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxTransactionRun,\n                                           list);\n        if (rc < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_SYSTEM_ERROR)\n                pid = -1;\n            else\n                goto cleanup;\n        }\n    }\n\n    if (pid == -1) {\n        if (lock)\n            rc = virProcessRunInFork(virSecuritySELinuxTransactionRun, list);\n        else\n            rc = virSecuritySELinuxTransactionRun(pid, list);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextListFree(list);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal contextList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextListFree",
          "args": [
            "list"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "144-159",
          "snippet": "static void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxTransactionRun",
          "args": [
            "pid",
            "list"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxTransactionRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "248-333",
          "snippet": "static int\nvirSecuritySELinuxTransactionRun(pid_t pid G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    rv = 0;\n    for (i = 0; i < list->nItems; i++) {\n        virSecuritySELinuxContextItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecuritySELinuxSetFilecon(list->manager,\n                                              item->path,\n                                              item->tcon,\n                                              remember);\n        } else {\n            rv = virSecuritySELinuxRestoreFileLabel(list->manager,\n                                                    item->path,\n                                                    remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecuritySELinuxContextItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecuritySELinuxRestoreFileLabel(list->manager,\n                                               item->path,\n                                               remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\", item->path);\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxTransactionRun(pid_t pid G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    rv = 0;\n    for (i = 0; i < list->nItems; i++) {\n        virSecuritySELinuxContextItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecuritySELinuxSetFilecon(list->manager,\n                                              item->path,\n                                              item->tcon,\n                                              remember);\n        } else {\n            rv = virSecuritySELinuxRestoreFileLabel(list->manager,\n                                                    item->path,\n                                                    remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecuritySELinuxContextItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecuritySELinuxRestoreFileLabel(list->manager,\n                                               item->path,\n                                               remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\", item->path);\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessRunInFork",
          "args": [
            "virSecuritySELinuxTransactionRun",
            "list"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInFork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1267-1274",
          "snippet": "int\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessRunInMountNamespace",
          "args": [
            "pid",
            "virSecuritySELinuxTransactionRun",
            "list"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInMountNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1115-1123",
          "snippet": "int\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to clear thread local variable\")"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to clear thread local variable\""
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalSet",
          "args": [
            "&contextList",
            "NULL"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "352-360",
          "snippet": "int virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No transaction is set\")"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&contextList"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\n\nstatic int\nvirSecuritySELinuxTransactionCommit(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                    pid_t pid,\n                                    bool lock)\n{\n    virSecuritySELinuxContextListPtr list;\n    int rc;\n    int ret = -1;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No transaction is set\"));\n        return -1;\n    }\n\n    if (virThreadLocalSet(&contextList, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to clear thread local variable\"));\n        goto cleanup;\n    }\n\n    list->lock = lock;\n\n    if (pid != -1) {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxTransactionRun,\n                                           list);\n        if (rc < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_SYSTEM_ERROR)\n                pid = -1;\n            else\n                goto cleanup;\n        }\n    }\n\n    if (pid == -1) {\n        if (lock)\n            rc = virProcessRunInFork(virSecuritySELinuxTransactionRun, list);\n        else\n            rc = virSecuritySELinuxTransactionRun(pid, list);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextListFree(list);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxTransactionStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1093-1118",
    "snippet": "static int\nvirSecuritySELinuxTransactionStart(virSecurityManagerPtr mgr)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Another relabel transaction is already started\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(list) < 0)\n        return -1;\n\n    list->manager = virObjectRef(mgr);\n\n    if (virThreadLocalSet(&contextList, list) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set thread local variable\"));\n        virSecuritySELinuxContextListFree(list);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal contextList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextListFree",
          "args": [
            "list"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "144-159",
          "snippet": "static void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to set thread local variable\")"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set thread local variable\""
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalSet",
          "args": [
            "&contextList",
            "list"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "352-360",
          "snippet": "int virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "mgr"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "list"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Another relabel transaction is already started\")"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&contextList"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\n\nstatic int\nvirSecuritySELinuxTransactionStart(virSecurityManagerPtr mgr)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Another relabel transaction is already started\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(list) < 0)\n        return -1;\n\n    list->manager = virObjectRef(mgr);\n\n    if (virThreadLocalSet(&contextList, list) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set thread local variable\"));\n        virSecuritySELinuxContextListFree(list);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGetDOI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1069-1077",
    "snippet": "static const char *\nvirSecuritySELinuxGetDOI(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    /*\n     * Where will the DOI come from?  SELinux configuration, or qemu\n     * configuration? For the moment, we'll just set it to \"0\".\n     */\n    return SECURITY_SELINUX_VOID_DOI;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_VOID_DOI       \"0\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_VOID_DOI       \"0\"\n\nstatic const char *\nvirSecuritySELinuxGetDOI(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    /*\n     * Where will the DOI come from?  SELinux configuration, or qemu\n     * configuration? For the moment, we'll just set it to \"0\".\n     */\n    return SECURITY_SELINUX_VOID_DOI;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGetModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1063-1067",
    "snippet": "static const char *\nvirSecuritySELinuxGetModel(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    return SECURITY_SELINUX_NAME;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic const char *\nvirSecuritySELinuxGetModel(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    return SECURITY_SELINUX_NAME;\n}"
  },
  {
    "function_name": "virSecuritySELinuxDriverClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1041-1060",
    "snippet": "static int\nvirSecuritySELinuxDriverClose(virSecurityManagerPtr mgr)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (!data)\n        return 0;\n\n    if (data->label_handle)\n        selabel_close(data->label_handle);\n\n    virHashFree(data->mcs);\n\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->alt_domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->content_context"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->file_context"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->alt_domain_context"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->domain_context"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "data->mcs"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selabel_close",
          "args": [
            "data->label_handle"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxDriverClose(virSecurityManagerPtr mgr)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (!data)\n        return 0;\n\n    if (data->label_handle)\n        selabel_close(data->label_handle);\n\n    virHashFree(data->mcs);\n\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->alt_domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxDriverOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1034-1038",
    "snippet": "static int\nvirSecuritySELinuxDriverOpen(virSecurityManagerPtr mgr)\n{\n    return virSecuritySELinuxInitialize(mgr);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxInitialize",
          "args": [
            "mgr"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "789-806",
          "snippet": "static int\nvirSecuritySELinuxInitialize(virSecurityManagerPtr mgr)\n{\n    VIR_DEBUG(\"SELinuxInitialize %s\", virSecurityManagerGetVirtDriver(mgr));\n\n    if (virThreadLocalInit(&contextList,\n                           virSecuritySELinuxContextListFree) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize thread local variable\"));\n        return -1;\n    }\n\n    if (STREQ(virSecurityManagerGetVirtDriver(mgr), \"LXC\")) {\n        return virSecuritySELinuxLXCInitialize(mgr);\n    } else {\n        return virSecuritySELinuxQEMUInitialize(mgr);\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal contextList;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\n\nstatic int\nvirSecuritySELinuxInitialize(virSecurityManagerPtr mgr)\n{\n    VIR_DEBUG(\"SELinuxInitialize %s\", virSecurityManagerGetVirtDriver(mgr));\n\n    if (virThreadLocalInit(&contextList,\n                           virSecuritySELinuxContextListFree) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize thread local variable\"));\n        return -1;\n    }\n\n    if (STREQ(virSecurityManagerGetVirtDriver(mgr), \"LXC\")) {\n        return virSecuritySELinuxLXCInitialize(mgr);\n    } else {\n        return virSecuritySELinuxQEMUInitialize(mgr);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxDriverOpen(virSecurityManagerPtr mgr)\n{\n    return virSecuritySELinuxInitialize(mgr);\n}"
  },
  {
    "function_name": "virSecuritySELinuxDriverProbe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "1017-1031",
    "snippet": "static int\nvirSecuritySELinuxDriverProbe(const char *virtDriver)\n{\n    if (is_selinux_enabled() <= 0)\n        return SECURITY_DRIVER_DISABLE;\n\n    if (virtDriver && STREQ(virtDriver, \"LXC\")) {\n#if HAVE_SELINUX_LXC_CONTEXTS_PATH\n        if (!virFileExists(selinux_lxc_contexts_path()))\n#endif\n            return SECURITY_DRIVER_DISABLE;\n    }\n\n    return SECURITY_DRIVER_ENABLE;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "selinux_lxc_contexts_path()"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_lxc_contexts_path",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "virtDriver",
            "\"LXC\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_selinux_enabled",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxDriverProbe(const char *virtDriver)\n{\n    if (is_selinux_enabled() <= 0)\n        return SECURITY_DRIVER_DISABLE;\n\n    if (virtDriver && STREQ(virtDriver, \"LXC\")) {\n#if HAVE_SELINUX_LXC_CONTEXTS_PATH\n        if (!virFileExists(selinux_lxc_contexts_path()))\n#endif\n            return SECURITY_DRIVER_DISABLE;\n    }\n\n    return SECURITY_DRIVER_ENABLE;\n}"
  },
  {
    "function_name": "virSecuritySELinuxReserveLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "965-1014",
    "snippet": "static int\nvirSecuritySELinuxReserveLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def,\n                               pid_t pid)\n{\n    security_context_t pctx;\n    context_t ctx = NULL;\n    const char *mcs;\n    int rv;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel ||\n        seclabel->type == VIR_DOMAIN_SECLABEL_NONE ||\n        seclabel->type == VIR_DOMAIN_SECLABEL_STATIC)\n        return 0;\n\n    if (getpidcon_raw(pid, &pctx) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to get PID %d security context\"), pid);\n        return -1;\n    }\n\n    ctx = context_new(pctx);\n    freecon(pctx);\n    if (!ctx)\n        goto error;\n\n    mcs = context_range_get(ctx);\n    if (!mcs)\n        goto error;\n\n    if ((rv = virSecuritySELinuxMCSAdd(mgr, mcs)) < 0)\n        goto error;\n\n    if (rv == 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"MCS level for existing domain label %s already reserved\"),\n                       (char*)pctx);\n        goto error;\n    }\n\n    context_free(ctx);\n\n    return 0;\n\n error:\n    context_free(ctx);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "ctx"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "ctx"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"MCS level for existing domain label %s already reserved\")",
            "(char*)pctx"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"MCS level for existing domain label %s already reserved\""
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxMCSAdd",
          "args": [
            "mgr",
            "mcs"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxMCSAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "339-352",
          "snippet": "static int\nvirSecuritySELinuxMCSAdd(virSecurityManagerPtr mgr,\n                         const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (virHashLookup(data->mcs, mcs))\n        return 1;\n\n    if (virHashAddEntry(data->mcs, mcs, (void*)0x1) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxMCSAdd(virSecurityManagerPtr mgr,\n                         const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (virHashLookup(data->mcs, mcs))\n        return 1;\n\n    if (virHashAddEntry(data->mcs, mcs, (void*)0x1) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "ctx"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "pctx"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "pctx"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get PID %d security context\")",
            "pid"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpidcon_raw",
          "args": [
            "pid",
            "&pctx"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxReserveLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def,\n                               pid_t pid)\n{\n    security_context_t pctx;\n    context_t ctx = NULL;\n    const char *mcs;\n    int rv;\n    virSecurityLabelDefPtr seclabel;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!seclabel ||\n        seclabel->type == VIR_DOMAIN_SECLABEL_NONE ||\n        seclabel->type == VIR_DOMAIN_SECLABEL_STATIC)\n        return 0;\n\n    if (getpidcon_raw(pid, &pctx) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to get PID %d security context\"), pid);\n        return -1;\n    }\n\n    ctx = context_new(pctx);\n    freecon(pctx);\n    if (!ctx)\n        goto error;\n\n    mcs = context_range_get(ctx);\n    if (!mcs)\n        goto error;\n\n    if ((rv = virSecuritySELinuxMCSAdd(mgr, mcs)) < 0)\n        goto error;\n\n    if (rv == 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"MCS level for existing domain label %s already reserved\"),\n                       (char*)pctx);\n        goto error;\n    }\n\n    context_free(ctx);\n\n    return 0;\n\n error:\n    context_free(ctx);\n    return -1;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGenLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "809-963",
    "snippet": "static int\nvirSecuritySELinuxGenLabel(virSecurityManagerPtr mgr,\n                           virDomainDefPtr def)\n{\n    int rc = -1;\n    char *mcs = NULL;\n    char *scontext = NULL;\n    context_t ctx = NULL;\n    const char *range;\n    virSecurityLabelDefPtr seclabel;\n    virSecuritySELinuxDataPtr data;\n    const char *baselabel;\n    char *sens = NULL;\n    int catMin, catMax;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    data = virSecurityManagerGetPrivateData(mgr);\n\n    VIR_DEBUG(\"label=%s\", virSecurityManagerGetVirtDriver(mgr));\n    if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC &&\n        seclabel->label) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"security label already defined for VM\"));\n        return rc;\n    }\n\n    if (seclabel->imagelabel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"security image label already defined for VM\"));\n        return rc;\n    }\n\n    if (seclabel->model &&\n        STRNEQ(seclabel->model, SECURITY_SELINUX_NAME)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label model %s is not supported with selinux\"),\n                       seclabel->model);\n        return rc;\n    }\n\n    VIR_DEBUG(\"type=%d\", seclabel->type);\n\n    switch (seclabel->type) {\n    case VIR_DOMAIN_SECLABEL_STATIC:\n        if (!(ctx = context_new(seclabel->label))) {\n            virReportSystemError(errno,\n                                 _(\"unable to allocate socket security context '%s'\"),\n                                 seclabel->label);\n            return rc;\n        }\n\n        if (!(range = context_range_get(ctx))) {\n            virReportSystemError(errno, \"%s\", _(\"unable to get selinux context range\"));\n            goto cleanup;\n        }\n        mcs = g_strdup(range);\n        break;\n\n    case VIR_DOMAIN_SECLABEL_DYNAMIC:\n        if (virSecuritySELinuxMCSGetProcessRange(&sens,\n                                                 &catMin,\n                                                 &catMax) < 0)\n            goto cleanup;\n\n        if (!(mcs = virSecuritySELinuxMCSFind(mgr,\n                                              sens,\n                                              catMin,\n                                              catMax)))\n            goto cleanup;\n\n        if (virSecuritySELinuxMCSAdd(mgr, mcs) < 0)\n            goto cleanup;\n\n        baselabel = seclabel->baselabel;\n        if (!baselabel) {\n            if (def->virtType == VIR_DOMAIN_VIRT_QEMU) {\n                if (data->alt_domain_context == NULL) {\n                    static bool warned;\n                    if (!warned) {\n                        VIR_WARN(\"SELinux policy does not define a domain type for QEMU TCG. \"\n                                 \"Guest startup may be denied due to missing 'execmem' privilege \"\n                                 \"unless the 'virt_use_execmem' policy boolean is enabled\");\n                        warned = true;\n                    }\n                    baselabel = data->domain_context;\n                } else {\n                    baselabel = data->alt_domain_context;\n                }\n            } else {\n                baselabel = data->domain_context;\n            }\n        }\n\n        seclabel->label = virSecuritySELinuxGenNewContext(baselabel, mcs, false);\n        if (!seclabel->label)\n            goto cleanup;\n\n        break;\n\n    case VIR_DOMAIN_SECLABEL_NONE:\n        if (virSecuritySELinuxMCSGetProcessRange(&sens,\n                                                 &catMin,\n                                                 &catMax) < 0)\n            goto cleanup;\n\n        mcs = g_strdup(sens);\n\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected security label type '%s'\"),\n                       virDomainSeclabelTypeToString(seclabel->type));\n        goto cleanup;\n    }\n\n    /* always generate a image label, needed to label new objects */\n    seclabel->imagelabel = virSecuritySELinuxGenNewContext(data->file_context,\n                                                           mcs,\n                                                           true);\n    if (!seclabel->imagelabel)\n        goto cleanup;\n\n    if (!seclabel->model)\n        seclabel->model = g_strdup(SECURITY_SELINUX_NAME);\n\n    rc = 0;\n\n cleanup:\n    if (rc != 0) {\n        if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(seclabel->label);\n        VIR_FREE(seclabel->imagelabel);\n        if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC &&\n            !seclabel->baselabel)\n            VIR_FREE(seclabel->model);\n    }\n\n    if (ctx)\n        context_free(ctx);\n    VIR_FREE(scontext);\n    VIR_FREE(mcs);\n    VIR_FREE(sens);\n\n    VIR_DEBUG(\"model=%s label=%s imagelabel=%s baselabel=%s\",\n              NULLSTR(seclabel->model),\n              NULLSTR(seclabel->label),\n              NULLSTR(seclabel->imagelabel),\n              NULLSTR(seclabel->baselabel));\n\n    return rc;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"model=%s label=%s imagelabel=%s baselabel=%s\"",
            "NULLSTR(seclabel->model)",
            "NULLSTR(seclabel->label)",
            "NULLSTR(seclabel->imagelabel)",
            "NULLSTR(seclabel->baselabel)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "seclabel->baselabel"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "seclabel->imagelabel"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "seclabel->label"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "seclabel->model"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sens"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mcs"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scontext"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "ctx"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "seclabel->model"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "seclabel->imagelabel"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "seclabel->label"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "SECURITY_SELINUX_NAME"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxGenNewContext",
          "args": [
            "data->file_context",
            "mcs",
            "true"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxGenNewContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "570-639",
          "snippet": "static char *\nvirSecuritySELinuxGenNewContext(const char *basecontext,\n                                const char *mcs,\n                                bool isObjectContext)\n{\n    context_t context = NULL;\n    char *ret = NULL;\n    char *str;\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n\n    VIR_DEBUG(\"basecontext=%s mcs=%s isObjectContext=%d\",\n              basecontext, mcs, isObjectContext);\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    VIR_DEBUG(\"process=%s\", ourSecContext);\n\n    if (!(context = context_new(basecontext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse base SELinux context '%s'\"),\n                             basecontext);\n        goto cleanup;\n    }\n\n    if (context_user_set(context,\n                         context_user_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context user '%s'\"),\n                             context_user_get(ourContext));\n        goto cleanup;\n    }\n\n    if (!isObjectContext &&\n        context_role_set(context,\n                         context_role_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context role '%s'\"),\n                             context_role_get(ourContext));\n        goto cleanup;\n    }\n\n    if (context_range_set(context, mcs) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context MCS '%s'\"),\n                             mcs);\n        goto cleanup;\n    }\n    if (!(str = context_str(context))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n    ret = g_strdup(str);\n    VIR_DEBUG(\"Generated context '%s'\",  ret);\n cleanup:\n    freecon(ourSecContext);\n    context_free(ourContext);\n    context_free(context);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxGenNewContext(const char *basecontext,\n                                const char *mcs,\n                                bool isObjectContext)\n{\n    context_t context = NULL;\n    char *ret = NULL;\n    char *str;\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n\n    VIR_DEBUG(\"basecontext=%s mcs=%s isObjectContext=%d\",\n              basecontext, mcs, isObjectContext);\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    VIR_DEBUG(\"process=%s\", ourSecContext);\n\n    if (!(context = context_new(basecontext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse base SELinux context '%s'\"),\n                             basecontext);\n        goto cleanup;\n    }\n\n    if (context_user_set(context,\n                         context_user_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context user '%s'\"),\n                             context_user_get(ourContext));\n        goto cleanup;\n    }\n\n    if (!isObjectContext &&\n        context_role_set(context,\n                         context_role_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context role '%s'\"),\n                             context_role_get(ourContext));\n        goto cleanup;\n    }\n\n    if (context_range_set(context, mcs) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context MCS '%s'\"),\n                             mcs);\n        goto cleanup;\n    }\n    if (!(str = context_str(context))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n    ret = g_strdup(str);\n    VIR_DEBUG(\"Generated context '%s'\",  ret);\n cleanup:\n    freecon(ourSecContext);\n    context_free(ourContext);\n    context_free(context);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected security label type '%s'\")",
            "virDomainSeclabelTypeToString(seclabel->type)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSeclabelTypeToString",
          "args": [
            "seclabel->type"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected security label type '%s'\""
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxMCSGetProcessRange",
          "args": [
            "&sens",
            "&catMin",
            "&catMax"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxMCSGetProcessRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "429-530",
          "snippet": "static int\nvirSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n\n    *sens = g_strdup(contextRange);\n\n    /* Find and blank out the category part (if any) */\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    /* Find and blank out the sensitivity upper bound */\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    /* sens now just contains the sensitivity lower bound */\n\n    /* If there was no category part, just assume c0.c1023 */\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Find & extract category min */\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    /* We *must* have a pair of categories otherwise\n     * there's no range to allocate VM categories from */\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n\n    /* Find & extract category max (if any) */\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n\n    *sens = g_strdup(contextRange);\n\n    /* Find and blank out the category part (if any) */\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    /* Find and blank out the sensitivity upper bound */\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    /* sens now just contains the sensitivity lower bound */\n\n    /* If there was no category part, just assume c0.c1023 */\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Find & extract category min */\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    /* We *must* have a pair of categories otherwise\n     * there's no range to allocate VM categories from */\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n\n    /* Find & extract category max (if any) */\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"SELinux policy does not define a domain type for QEMU TCG. \"\n                                 \"Guest startup may be denied due to missing 'execmem' privilege \"\n                                 \"unless the 'virt_use_execmem' policy boolean is enabled\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxMCSAdd",
          "args": [
            "mgr",
            "mcs"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxMCSAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "339-352",
          "snippet": "static int\nvirSecuritySELinuxMCSAdd(virSecurityManagerPtr mgr,\n                         const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (virHashLookup(data->mcs, mcs))\n        return 1;\n\n    if (virHashAddEntry(data->mcs, mcs, (void*)0x1) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxMCSAdd(virSecurityManagerPtr mgr,\n                         const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (virHashLookup(data->mcs, mcs))\n        return 1;\n\n    if (virHashAddEntry(data->mcs, mcs, (void*)0x1) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxMCSFind",
          "args": [
            "mgr",
            "sens",
            "catMin",
            "catMax"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxMCSFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "364-411",
          "snippet": "static char *\nvirSecuritySELinuxMCSFind(virSecurityManagerPtr mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n\n    /* +1 since virRandomInt range is exclusive of the upper bound */\n    catRange = (catMax - catMin) + 1;\n\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n\n        if (c1 == c2) {\n            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n\n        VIR_FREE(mcs);\n    }\n\n    return mcs;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxMCSFind(virSecurityManagerPtr mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n\n    /* +1 since virRandomInt range is exclusive of the upper bound */\n    catRange = (catMax - catMin) + 1;\n\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n\n        if (c1 == c2) {\n            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n\n        VIR_FREE(mcs);\n    }\n\n    return mcs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to get selinux context range\")"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "ctx"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to allocate socket security context '%s'\")",
            "seclabel->label"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "seclabel->label"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"type=%d\"",
            "seclabel->type"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label model %s is not supported with selinux\")",
            "seclabel->model"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "seclabel->model",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"security image label already defined for VM\")"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"security label already defined for VM\")"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"label=%s\"",
            "virSecurityManagerGetVirtDriver(mgr)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetVirtDriver",
          "args": [
            "mgr"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetVirtDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "328-332",
          "snippet": "const char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_SELINUX_NAME"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxGenLabel(virSecurityManagerPtr mgr,\n                           virDomainDefPtr def)\n{\n    int rc = -1;\n    char *mcs = NULL;\n    char *scontext = NULL;\n    context_t ctx = NULL;\n    const char *range;\n    virSecurityLabelDefPtr seclabel;\n    virSecuritySELinuxDataPtr data;\n    const char *baselabel;\n    char *sens = NULL;\n    int catMin, catMax;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (seclabel == NULL)\n        return 0;\n\n    data = virSecurityManagerGetPrivateData(mgr);\n\n    VIR_DEBUG(\"label=%s\", virSecurityManagerGetVirtDriver(mgr));\n    if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC &&\n        seclabel->label) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"security label already defined for VM\"));\n        return rc;\n    }\n\n    if (seclabel->imagelabel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"security image label already defined for VM\"));\n        return rc;\n    }\n\n    if (seclabel->model &&\n        STRNEQ(seclabel->model, SECURITY_SELINUX_NAME)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label model %s is not supported with selinux\"),\n                       seclabel->model);\n        return rc;\n    }\n\n    VIR_DEBUG(\"type=%d\", seclabel->type);\n\n    switch (seclabel->type) {\n    case VIR_DOMAIN_SECLABEL_STATIC:\n        if (!(ctx = context_new(seclabel->label))) {\n            virReportSystemError(errno,\n                                 _(\"unable to allocate socket security context '%s'\"),\n                                 seclabel->label);\n            return rc;\n        }\n\n        if (!(range = context_range_get(ctx))) {\n            virReportSystemError(errno, \"%s\", _(\"unable to get selinux context range\"));\n            goto cleanup;\n        }\n        mcs = g_strdup(range);\n        break;\n\n    case VIR_DOMAIN_SECLABEL_DYNAMIC:\n        if (virSecuritySELinuxMCSGetProcessRange(&sens,\n                                                 &catMin,\n                                                 &catMax) < 0)\n            goto cleanup;\n\n        if (!(mcs = virSecuritySELinuxMCSFind(mgr,\n                                              sens,\n                                              catMin,\n                                              catMax)))\n            goto cleanup;\n\n        if (virSecuritySELinuxMCSAdd(mgr, mcs) < 0)\n            goto cleanup;\n\n        baselabel = seclabel->baselabel;\n        if (!baselabel) {\n            if (def->virtType == VIR_DOMAIN_VIRT_QEMU) {\n                if (data->alt_domain_context == NULL) {\n                    static bool warned;\n                    if (!warned) {\n                        VIR_WARN(\"SELinux policy does not define a domain type for QEMU TCG. \"\n                                 \"Guest startup may be denied due to missing 'execmem' privilege \"\n                                 \"unless the 'virt_use_execmem' policy boolean is enabled\");\n                        warned = true;\n                    }\n                    baselabel = data->domain_context;\n                } else {\n                    baselabel = data->alt_domain_context;\n                }\n            } else {\n                baselabel = data->domain_context;\n            }\n        }\n\n        seclabel->label = virSecuritySELinuxGenNewContext(baselabel, mcs, false);\n        if (!seclabel->label)\n            goto cleanup;\n\n        break;\n\n    case VIR_DOMAIN_SECLABEL_NONE:\n        if (virSecuritySELinuxMCSGetProcessRange(&sens,\n                                                 &catMin,\n                                                 &catMax) < 0)\n            goto cleanup;\n\n        mcs = g_strdup(sens);\n\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected security label type '%s'\"),\n                       virDomainSeclabelTypeToString(seclabel->type));\n        goto cleanup;\n    }\n\n    /* always generate a image label, needed to label new objects */\n    seclabel->imagelabel = virSecuritySELinuxGenNewContext(data->file_context,\n                                                           mcs,\n                                                           true);\n    if (!seclabel->imagelabel)\n        goto cleanup;\n\n    if (!seclabel->model)\n        seclabel->model = g_strdup(SECURITY_SELINUX_NAME);\n\n    rc = 0;\n\n cleanup:\n    if (rc != 0) {\n        if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(seclabel->label);\n        VIR_FREE(seclabel->imagelabel);\n        if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC &&\n            !seclabel->baselabel)\n            VIR_FREE(seclabel->model);\n    }\n\n    if (ctx)\n        context_free(ctx);\n    VIR_FREE(scontext);\n    VIR_FREE(mcs);\n    VIR_FREE(sens);\n\n    VIR_DEBUG(\"model=%s label=%s imagelabel=%s baselabel=%s\",\n              NULLSTR(seclabel->model),\n              NULLSTR(seclabel->label),\n              NULLSTR(seclabel->imagelabel),\n              NULLSTR(seclabel->baselabel));\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecuritySELinuxInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "789-806",
    "snippet": "static int\nvirSecuritySELinuxInitialize(virSecurityManagerPtr mgr)\n{\n    VIR_DEBUG(\"SELinuxInitialize %s\", virSecurityManagerGetVirtDriver(mgr));\n\n    if (virThreadLocalInit(&contextList,\n                           virSecuritySELinuxContextListFree) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize thread local variable\"));\n        return -1;\n    }\n\n    if (STREQ(virSecurityManagerGetVirtDriver(mgr), \"LXC\")) {\n        return virSecuritySELinuxLXCInitialize(mgr);\n    } else {\n        return virSecuritySELinuxQEMUInitialize(mgr);\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal contextList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxQEMUInitialize",
          "args": [
            "mgr"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxQEMUInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "716-786",
          "snippet": "static int\nvirSecuritySELinuxQEMUInitialize(virSecurityManagerPtr mgr)\n{\n    char *ptr;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    data->skipAllLabel = false;\n\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n\n    if (virFileReadAll(selinux_virtual_domain_context_path(), MAX_CONTEXT, &(data->domain_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual domain context file '%s'\"),\n                             selinux_virtual_domain_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->domain_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        ptr++;\n        if (*ptr != '\\0') {\n            data->alt_domain_context = g_strdup(ptr);\n            ptr = strchr(data->alt_domain_context, '\\n');\n            if (ptr)\n                *ptr = '\\0';\n        }\n    }\n    VIR_DEBUG(\"Loaded domain context '%s', alt domain context '%s'\",\n              data->domain_context, NULLSTR(data->alt_domain_context));\n\n\n    if (virFileReadAll(selinux_virtual_image_context_path(), 2*MAX_CONTEXT, &(data->file_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual image context file %s\"),\n                             selinux_virtual_image_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->file_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        data->content_context = g_strdup(ptr + 1);\n        ptr = strchr(data->content_context, '\\n');\n        if (ptr)\n            *ptr = '\\0';\n    }\n\n    VIR_DEBUG(\"Loaded file context '%s', content context '%s'\",\n              data->file_context, data->content_context);\n\n    if (!(data->mcs = virHashCreate(10, NULL)))\n        goto error;\n\n    return 0;\n\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->alt_domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CONTEXT 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define MAX_CONTEXT 1024\n\nstatic int\nvirSecuritySELinuxQEMUInitialize(virSecurityManagerPtr mgr)\n{\n    char *ptr;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    data->skipAllLabel = false;\n\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n\n    if (virFileReadAll(selinux_virtual_domain_context_path(), MAX_CONTEXT, &(data->domain_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual domain context file '%s'\"),\n                             selinux_virtual_domain_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->domain_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        ptr++;\n        if (*ptr != '\\0') {\n            data->alt_domain_context = g_strdup(ptr);\n            ptr = strchr(data->alt_domain_context, '\\n');\n            if (ptr)\n                *ptr = '\\0';\n        }\n    }\n    VIR_DEBUG(\"Loaded domain context '%s', alt domain context '%s'\",\n              data->domain_context, NULLSTR(data->alt_domain_context));\n\n\n    if (virFileReadAll(selinux_virtual_image_context_path(), 2*MAX_CONTEXT, &(data->file_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual image context file %s\"),\n                             selinux_virtual_image_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->file_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        data->content_context = g_strdup(ptr + 1);\n        ptr = strchr(data->content_context, '\\n');\n        if (ptr)\n            *ptr = '\\0';\n    }\n\n    VIR_DEBUG(\"Loaded file context '%s', content context '%s'\",\n              data->file_context, data->content_context);\n\n    if (!(data->mcs = virHashCreate(10, NULL)))\n        goto error;\n\n    return 0;\n\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->alt_domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxLXCInitialize",
          "args": [
            "mgr"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxLXCInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "706-712",
          "snippet": "static int\nvirSecuritySELinuxLXCInitialize(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libselinux does not support LXC contexts path\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxLXCInitialize(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libselinux does not support LXC contexts path\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "virSecurityManagerGetVirtDriver(mgr)",
            "\"LXC\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetVirtDriver",
          "args": [
            "mgr"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetVirtDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "328-332",
          "snippet": "const char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to initialize thread local variable\")"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to initialize thread local variable\""
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalInit",
          "args": [
            "&contextList",
            "virSecuritySELinuxContextListFree"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "336-345",
          "snippet": "int virThreadLocalInit(virThreadLocalPtr l,\n                       virThreadLocalCleanup c)\n{\n    int ret;\n    if ((ret = pthread_key_create(&l->key, c)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalInit(virThreadLocalPtr l,\n                       virThreadLocalCleanup c)\n{\n    int ret;\n    if ((ret = pthread_key_create(&l->key, c)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"SELinuxInitialize %s\"",
            "virSecurityManagerGetVirtDriver(mgr)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\n\nstatic int\nvirSecuritySELinuxInitialize(virSecurityManagerPtr mgr)\n{\n    VIR_DEBUG(\"SELinuxInitialize %s\", virSecurityManagerGetVirtDriver(mgr));\n\n    if (virThreadLocalInit(&contextList,\n                           virSecuritySELinuxContextListFree) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize thread local variable\"));\n        return -1;\n    }\n\n    if (STREQ(virSecurityManagerGetVirtDriver(mgr), \"LXC\")) {\n        return virSecuritySELinuxLXCInitialize(mgr);\n    } else {\n        return virSecuritySELinuxQEMUInitialize(mgr);\n    }\n}"
  },
  {
    "function_name": "virSecuritySELinuxQEMUInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "716-786",
    "snippet": "static int\nvirSecuritySELinuxQEMUInitialize(virSecurityManagerPtr mgr)\n{\n    char *ptr;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    data->skipAllLabel = false;\n\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n\n    if (virFileReadAll(selinux_virtual_domain_context_path(), MAX_CONTEXT, &(data->domain_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual domain context file '%s'\"),\n                             selinux_virtual_domain_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->domain_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        ptr++;\n        if (*ptr != '\\0') {\n            data->alt_domain_context = g_strdup(ptr);\n            ptr = strchr(data->alt_domain_context, '\\n');\n            if (ptr)\n                *ptr = '\\0';\n        }\n    }\n    VIR_DEBUG(\"Loaded domain context '%s', alt domain context '%s'\",\n              data->domain_context, NULLSTR(data->alt_domain_context));\n\n\n    if (virFileReadAll(selinux_virtual_image_context_path(), 2*MAX_CONTEXT, &(data->file_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual image context file %s\"),\n                             selinux_virtual_image_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->file_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        data->content_context = g_strdup(ptr + 1);\n        ptr = strchr(data->content_context, '\\n');\n        if (ptr)\n            *ptr = '\\0';\n    }\n\n    VIR_DEBUG(\"Loaded file context '%s', content context '%s'\",\n              data->file_context, data->content_context);\n\n    if (!(data->mcs = virHashCreate(10, NULL)))\n        goto error;\n\n    return 0;\n\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->alt_domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_CONTEXT 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "data->mcs"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->content_context"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->file_context"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->alt_domain_context"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->domain_context"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_close",
          "args": [
            "data->label_handle"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "NULL"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Loaded file context '%s', content context '%s'\"",
            "data->file_context",
            "data->content_context"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data->content_context",
            "'\\n'"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "ptr + 1"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data->file_context",
            "'\\n'"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read SELinux virtual image context file %s\")",
            "selinux_virtual_image_context_path()"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_virtual_image_context_path",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot read SELinux virtual image context file %s\""
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "selinux_virtual_image_context_path()",
            "2*MAX_CONTEXT",
            "&(data->file_context)"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_virtual_image_context_path",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Loaded domain context '%s', alt domain context '%s'\"",
            "data->domain_context",
            "NULLSTR(data->alt_domain_context)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "data->alt_domain_context"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data->alt_domain_context",
            "'\\n'"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data->domain_context",
            "'\\n'"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot read SELinux virtual domain context file '%s'\")",
            "selinux_virtual_domain_context_path()"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_virtual_domain_context_path",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_virtual_domain_context_path",
          "args": [],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot open SELinux label_handle\")"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_open",
          "args": [
            "SELABEL_CTX_FILE",
            "NULL",
            "0"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define MAX_CONTEXT 1024\n\nstatic int\nvirSecuritySELinuxQEMUInitialize(virSecurityManagerPtr mgr)\n{\n    char *ptr;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    data->skipAllLabel = false;\n\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n\n    if (virFileReadAll(selinux_virtual_domain_context_path(), MAX_CONTEXT, &(data->domain_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual domain context file '%s'\"),\n                             selinux_virtual_domain_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->domain_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        ptr++;\n        if (*ptr != '\\0') {\n            data->alt_domain_context = g_strdup(ptr);\n            ptr = strchr(data->alt_domain_context, '\\n');\n            if (ptr)\n                *ptr = '\\0';\n        }\n    }\n    VIR_DEBUG(\"Loaded domain context '%s', alt domain context '%s'\",\n              data->domain_context, NULLSTR(data->alt_domain_context));\n\n\n    if (virFileReadAll(selinux_virtual_image_context_path(), 2*MAX_CONTEXT, &(data->file_context)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot read SELinux virtual image context file %s\"),\n                             selinux_virtual_image_context_path());\n        goto error;\n    }\n\n    ptr = strchr(data->file_context, '\\n');\n    if (ptr) {\n        *ptr = '\\0';\n        data->content_context = g_strdup(ptr + 1);\n        ptr = strchr(data->content_context, '\\n');\n        if (ptr)\n            *ptr = '\\0';\n    }\n\n    VIR_DEBUG(\"Loaded file context '%s', content context '%s'\",\n              data->file_context, data->content_context);\n\n    if (!(data->mcs = virHashCreate(10, NULL)))\n        goto error;\n\n    return 0;\n\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->alt_domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}"
  },
  {
    "function_name": "virSecuritySELinuxLXCInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "706-712",
    "snippet": "static int\nvirSecuritySELinuxLXCInitialize(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libselinux does not support LXC contexts path\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"libselinux does not support LXC contexts path\")"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libselinux does not support LXC contexts path\""
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxLXCInitialize(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libselinux does not support LXC contexts path\"));\n    return -1;\n}"
  },
  {
    "function_name": "virSecuritySELinuxLXCInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "643-704",
    "snippet": "static int\nvirSecuritySELinuxLXCInitialize(virSecurityManagerPtr mgr)\n{\n    g_autoptr(virConf) selinux_conf = NULL;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    data->skipAllLabel = true;\n\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n\n    if (!(selinux_conf = virConfReadFile(selinux_lxc_contexts_path(), 0)))\n        goto error;\n\n    if (virConfGetValueString(selinux_conf, \"process\", &data->domain_context) < 0)\n        goto error;\n\n    if (!data->domain_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'process' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n\n    if (virConfGetValueString(selinux_conf, \"file\", &data->file_context) < 0)\n        goto error;\n\n    if (!data->file_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'file' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n\n    if (virConfGetValueString(selinux_conf, \"content\", &data->content_context) < 0)\n        goto error;\n\n    if (!data->content_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'content' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n\n    if (!(data->mcs = virHashCreate(10, NULL)))\n        goto error;\n\n    return 0;\n\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "data->mcs"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->content_context"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->file_context"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->domain_context"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_close",
          "args": [
            "data->label_handle"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "NULL"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'content' value in selinux lxc contexts file '%s'\")",
            "selinux_lxc_contexts_path()"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_lxc_contexts_path",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'content' value in selinux lxc contexts file '%s'\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "selinux_conf",
            "\"content\"",
            "&data->content_context"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'file' value in selinux lxc contexts file '%s'\")",
            "selinux_lxc_contexts_path()"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_lxc_contexts_path",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'process' value in selinux lxc contexts file '%s'\")",
            "selinux_lxc_contexts_path()"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_lxc_contexts_path",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfReadFile",
          "args": [
            "selinux_lxc_contexts_path()",
            "0"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "virConfReadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "730-752",
          "snippet": "virConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CONFIG_FILE_SIZE (1024*1024*10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CONFIG_FILE_SIZE (1024*1024*10)\n\nvirConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_lxc_contexts_path",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot open SELinux label_handle\")"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selabel_open",
          "args": [
            "SELABEL_CTX_FILE",
            "NULL",
            "0"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxLXCInitialize(virSecurityManagerPtr mgr)\n{\n    g_autoptr(virConf) selinux_conf = NULL;\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    data->skipAllLabel = true;\n\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n\n    if (!(selinux_conf = virConfReadFile(selinux_lxc_contexts_path(), 0)))\n        goto error;\n\n    if (virConfGetValueString(selinux_conf, \"process\", &data->domain_context) < 0)\n        goto error;\n\n    if (!data->domain_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'process' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n\n    if (virConfGetValueString(selinux_conf, \"file\", &data->file_context) < 0)\n        goto error;\n\n    if (!data->file_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'file' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n\n    if (virConfGetValueString(selinux_conf, \"content\", &data->content_context) < 0)\n        goto error;\n\n    if (!data->content_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'content' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n\n    if (!(data->mcs = virHashCreate(10, NULL)))\n        goto error;\n\n    return 0;\n\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}"
  },
  {
    "function_name": "virSecuritySELinuxGenNewContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "570-639",
    "snippet": "static char *\nvirSecuritySELinuxGenNewContext(const char *basecontext,\n                                const char *mcs,\n                                bool isObjectContext)\n{\n    context_t context = NULL;\n    char *ret = NULL;\n    char *str;\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n\n    VIR_DEBUG(\"basecontext=%s mcs=%s isObjectContext=%d\",\n              basecontext, mcs, isObjectContext);\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    VIR_DEBUG(\"process=%s\", ourSecContext);\n\n    if (!(context = context_new(basecontext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse base SELinux context '%s'\"),\n                             basecontext);\n        goto cleanup;\n    }\n\n    if (context_user_set(context,\n                         context_user_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context user '%s'\"),\n                             context_user_get(ourContext));\n        goto cleanup;\n    }\n\n    if (!isObjectContext &&\n        context_role_set(context,\n                         context_role_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context role '%s'\"),\n                             context_role_get(ourContext));\n        goto cleanup;\n    }\n\n    if (context_range_set(context, mcs) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context MCS '%s'\"),\n                             mcs);\n        goto cleanup;\n    }\n    if (!(str = context_str(context))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n    ret = g_strdup(str);\n    VIR_DEBUG(\"Generated context '%s'\",  ret);\n cleanup:\n    freecon(ourSecContext);\n    context_free(ourContext);\n    context_free(context);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "context"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "ourContext"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ourSecContext"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Generated context '%s'\"",
            "ret"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "str"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to format SELinux context\")"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to format SELinux context\""
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_str",
          "args": [
            "context"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to set SELinux context MCS '%s'\")",
            "mcs"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_range_set",
          "args": [
            "context",
            "mcs"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to set SELinux context role '%s'\")",
            "context_role_get(ourContext)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_role_get",
          "args": [
            "ourContext"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_role_set",
          "args": [
            "context",
            "context_role_get(ourContext)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_role_get",
          "args": [
            "ourContext"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to set SELinux context user '%s'\")",
            "context_user_get(ourContext)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_user_get",
          "args": [
            "ourContext"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_user_set",
          "args": [
            "context",
            "context_user_get(ourContext)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_user_get",
          "args": [
            "ourContext"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to parse base SELinux context '%s'\")",
            "basecontext"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "basecontext"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"process=%s\"",
            "ourSecContext"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to parse current SELinux context '%s'\")",
            "ourSecContext"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "ourSecContext"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get current process SELinux context\")"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcon_raw",
          "args": [
            "&ourSecContext"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"basecontext=%s mcs=%s isObjectContext=%d\"",
            "basecontext",
            "mcs",
            "isObjectContext"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxGenNewContext(const char *basecontext,\n                                const char *mcs,\n                                bool isObjectContext)\n{\n    context_t context = NULL;\n    char *ret = NULL;\n    char *str;\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n\n    VIR_DEBUG(\"basecontext=%s mcs=%s isObjectContext=%d\",\n              basecontext, mcs, isObjectContext);\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    VIR_DEBUG(\"process=%s\", ourSecContext);\n\n    if (!(context = context_new(basecontext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse base SELinux context '%s'\"),\n                             basecontext);\n        goto cleanup;\n    }\n\n    if (context_user_set(context,\n                         context_user_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context user '%s'\"),\n                             context_user_get(ourContext));\n        goto cleanup;\n    }\n\n    if (!isObjectContext &&\n        context_role_set(context,\n                         context_role_get(ourContext)) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context role '%s'\"),\n                             context_role_get(ourContext));\n        goto cleanup;\n    }\n\n    if (context_range_set(context, mcs) != 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to set SELinux context MCS '%s'\"),\n                             mcs);\n        goto cleanup;\n    }\n    if (!(str = context_str(context))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n    ret = g_strdup(str);\n    VIR_DEBUG(\"Generated context '%s'\",  ret);\n cleanup:\n    freecon(ourSecContext);\n    context_free(ourContext);\n    context_free(context);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxContextAddRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "532-568",
    "snippet": "static char *\nvirSecuritySELinuxContextAddRange(security_context_t src,\n                                  security_context_t dst)\n{\n    char *str = NULL;\n    char *ret = NULL;\n    context_t srccon = NULL;\n    context_t dstcon = NULL;\n\n    if (!src || !dst)\n        return ret;\n\n    if (!(srccon = context_new(src)) || !(dstcon = context_new(dst))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to allocate security context\"));\n        goto cleanup;\n    }\n\n    if (context_range_set(dstcon, context_range_get(srccon)) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context range '%s'\"), dst);\n        goto cleanup;\n    }\n\n    if (!(str = context_str(dstcon))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(str);\n\n cleanup:\n    if (srccon) context_free(srccon);\n    if (dstcon) context_free(dstcon);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "dstcon"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "srccon"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "str"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to format SELinux context\")"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to format SELinux context\""
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_str",
          "args": [
            "dstcon"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set security context range '%s'\")",
            "dst"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_range_set",
          "args": [
            "dstcon",
            "context_range_get(srccon)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "srccon"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to allocate security context\")"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "dst"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "src"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxContextAddRange(security_context_t src,\n                                  security_context_t dst)\n{\n    char *str = NULL;\n    char *ret = NULL;\n    context_t srccon = NULL;\n    context_t dstcon = NULL;\n\n    if (!src || !dst)\n        return ret;\n\n    if (!(srccon = context_new(src)) || !(dstcon = context_new(dst))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to allocate security context\"));\n        goto cleanup;\n    }\n\n    if (context_range_set(dstcon, context_range_get(srccon)) == -1) {\n        virReportSystemError(errno,\n                             _(\"unable to set security context range '%s'\"), dst);\n        goto cleanup;\n    }\n\n    if (!(str = context_str(dstcon))) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format SELinux context\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup(str);\n\n cleanup:\n    if (srccon) context_free(srccon);\n    if (dstcon) context_free(dstcon);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxMCSGetProcessRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "429-530",
    "snippet": "static int\nvirSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n\n    *sens = g_strdup(contextRange);\n\n    /* Find and blank out the category part (if any) */\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    /* Find and blank out the sensitivity upper bound */\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    /* sens now just contains the sensitivity lower bound */\n\n    /* If there was no category part, just assume c0.c1023 */\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Find & extract category min */\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    /* We *must* have a pair of categories otherwise\n     * there's no range to allocate VM categories from */\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n\n    /* Find & extract category max (if any) */\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_free",
          "args": [
            "ourContext"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ourSecContext"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*sens"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse category in %s\")",
            "cat"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot parse category in %s\""
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "&tmp",
            "10",
            "catMax"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse category in %s\")",
            "cat"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse category in %s\")",
            "cat"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No category range available\")"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse category in %s\")",
            "cat"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse category in %s\")",
            "cat"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*sens",
            "'-'"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*sens",
            "':'"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "contextRange"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_range_get",
          "args": [
            "ourContext"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to parse current SELinux context '%s'\")",
            "ourSecContext"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_new",
          "args": [
            "ourSecContext"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get current process SELinux context\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcon_raw",
          "args": [
            "&ourSecContext"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    security_context_t ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n\n    *sens = g_strdup(contextRange);\n\n    /* Find and blank out the category part (if any) */\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    /* Find and blank out the sensitivity upper bound */\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    /* sens now just contains the sensitivity lower bound */\n\n    /* If there was no category part, just assume c0.c1023 */\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Find & extract category min */\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    /* We *must* have a pair of categories otherwise\n     * there's no range to allocate VM categories from */\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n\n    /* Find & extract category max (if any) */\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxMCSFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "364-411",
    "snippet": "static char *\nvirSecuritySELinuxMCSFind(virSecurityManagerPtr mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n\n    /* +1 since virRandomInt range is exclusive of the upper bound */\n    catRange = (catMax - catMin) + 1;\n\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n\n        if (c1 == c2) {\n            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n\n        VIR_FREE(mcs);\n    }\n\n    return mcs;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mcs"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "data->mcs",
            "mcs"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s:c%d,c%d\"",
            "sens",
            "catMin + c1",
            "catMin + c2"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Try cat %s:c%d,c%d\"",
            "sens",
            "c1 + catMin",
            "c2 + catMin"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virRandomInt",
          "args": [
            "catRange"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "virRandomInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrandom.c",
          "lines": "90-97",
          "snippet": "uint32_t virRandomInt(uint32_t max)\n{\n    if ((max & (max - 1)) == 0)\n        return virRandomBits(__builtin_ffs(max) - 1);\n\n    double val = virRandom();\n    return val * max;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virrandom.h\"",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <inttypes.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virrandom.h\"\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <math.h>\n#include <inttypes.h>\n#include <config.h>\n\nuint32_t virRandomInt(uint32_t max)\n{\n    if ((max & (max - 1)) == 0)\n        return virRandomBits(__builtin_ffs(max) - 1);\n\n    double val = virRandom();\n    return val * max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using sensitivity level '%s' cat min %d max %d range %d\"",
            "sens",
            "catMin",
            "catMax",
            "catRange"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Category range c%d-c%d too small\")",
            "catMin",
            "catMax"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Category range c%d-c%d too small\""
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic char *\nvirSecuritySELinuxMCSFind(virSecurityManagerPtr mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n\n    /* +1 since virRandomInt range is exclusive of the upper bound */\n    catRange = (catMax - catMin) + 1;\n\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n\n        if (c1 == c2) {\n            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n\n        VIR_FREE(mcs);\n    }\n\n    return mcs;\n}"
  },
  {
    "function_name": "virSecuritySELinuxMCSRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "354-361",
    "snippet": "static void\nvirSecuritySELinuxMCSRemove(virSecurityManagerPtr mgr,\n                            const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    virHashRemoveEntry(data->mcs, mcs);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "data->mcs",
            "mcs"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxMCSRemove(virSecurityManagerPtr mgr,\n                            const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    virHashRemoveEntry(data->mcs, mcs);\n}"
  },
  {
    "function_name": "virSecuritySELinuxMCSAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "339-352",
    "snippet": "static int\nvirSecuritySELinuxMCSAdd(virSecurityManagerPtr mgr,\n                         const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (virHashLookup(data->mcs, mcs))\n        return 1;\n\n    if (virHashAddEntry(data->mcs, mcs, (void*)0x1) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "data->mcs",
            "mcs",
            "(void*)0x1"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "data->mcs",
            "mcs"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int\nvirSecuritySELinuxMCSAdd(virSecurityManagerPtr mgr,\n                         const char *mcs)\n{\n    virSecuritySELinuxDataPtr data = virSecurityManagerGetPrivateData(mgr);\n\n    if (virHashLookup(data->mcs, mcs))\n        return 1;\n\n    if (virHashAddEntry(data->mcs, mcs, (void*)0x1) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxTransactionRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "248-333",
    "snippet": "static int\nvirSecuritySELinuxTransactionRun(pid_t pid G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    rv = 0;\n    for (i = 0; i < list->nItems; i++) {\n        virSecuritySELinuxContextItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecuritySELinuxSetFilecon(list->manager,\n                                              item->path,\n                                              item->tcon,\n                                              remember);\n        } else {\n            rv = virSecuritySELinuxRestoreFileLabel(list->manager,\n                                                    item->path,\n                                                    remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecuritySELinuxContextItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecuritySELinuxRestoreFileLabel(list->manager,\n                                               item->path,\n                                               remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\", item->path);\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "paths"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataUnlock",
          "args": [
            "list->manager",
            "&state"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1400-1429",
          "snippet": "void\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvoid\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring failed restore attempt on %s\"",
            "item->path"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxRestoreFileLabel",
          "args": [
            "list->manager",
            "item->path",
            "remember"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1453-1524",
          "snippet": "static int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                              const char *path,\n                                              bool recall);\n\nstatic int\nvirSecuritySELinuxRestoreFileLabel(virSecurityManagerPtr mgr,\n                                   const char *path,\n                                   bool recall)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    struct stat buf;\n    security_context_t fcon = NULL;\n    char *newpath = NULL;\n    int rc;\n    int ret = -1;\n\n    /* Some paths are auto-generated, so let's be safe here and do\n     * nothing if nothing is needed.\n     */\n    if (!path)\n        return 0;\n\n    VIR_INFO(\"Restoring SELinux context on '%s'\", path);\n\n    if (virFileResolveLink(path, &newpath) < 0) {\n        VIR_WARN(\"cannot resolve symlink %s: %s\", path,\n                 g_strerror(errno));\n        goto cleanup;\n    }\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, NULL,\n                                                  recall, true)) < 0) {\n        goto cleanup;\n    } else if (rc > 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (recall) {\n        rc = virSecuritySELinuxRecallLabel(newpath, &fcon);\n        if (rc == -2) {\n            /* Not supported. Lookup the default label below. */\n        } else if (rc < 0) {\n            goto cleanup;\n        } else if (rc > 0) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (!recall || rc == -2) {\n        if (stat(newpath, &buf) != 0) {\n            VIR_WARN(\"cannot stat %s: %s\", newpath,\n                     g_strerror(errno));\n            goto cleanup;\n        }\n\n        if (getContext(mgr, newpath, buf.st_mode, &fcon) < 0) {\n            /* Any user created path likely does not have a default label,\n             * which makes this an expected non error\n             */\n            VIR_WARN(\"cannot lookup default selinux label for %s\", newpath);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    if (virSecuritySELinuxSetFileconImpl(newpath, fcon, privileged) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    freecon(fcon);\n    VIR_FREE(newpath);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxSetFilecon",
          "args": [
            "list->manager",
            "item->path",
            "item->tcon",
            "remember"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxSetFilecon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "1326-1409",
          "snippet": "static int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                             const char *path,\n                             const char *tcon,\n                             bool remember)\n{\n    bool privileged = virSecurityManagerGetPrivileged(mgr);\n    security_context_t econ = NULL;\n    int refcount;\n    int rc;\n    bool rollback = false;\n    int ret = -1;\n\n    if ((rc = virSecuritySELinuxTransactionAppend(path, tcon,\n                                                  remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember) {\n        if (getfilecon_raw(path, &econ) < 0 &&\n            errno != ENOTSUP && errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"unable to get SELinux context of %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (econ) {\n            refcount = virSecuritySELinuxRememberLabel(path, econ);\n            if (refcount > 0)\n                rollback = true;\n            if (refcount == -2) {\n                /* Not supported. Don't error though. */\n            } else if (refcount < 0) {\n                goto cleanup;\n            } else if (refcount > 1) {\n                /* Refcount is greater than 1 which means that there\n                 * is @refcount domains using the @path. Do not\n                 * change the label (as it would almost certainly\n                 * cause the other domains to lose access to the\n                 * @path). However, the refcounter was\n                 * incremented in XATTRs so decrease it. */\n                if (STRNEQ(econ, tcon)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID,\n                                   _(\"Setting different SELinux label on %s \"\n                                     \"which is already in use\"), path);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    rc = virSecuritySELinuxSetFileconImpl(path, tcon, privileged);\n    if (rc < 0)\n        goto cleanup;\n\n    /* Do not try restoring the label if it was not changed\n     * (setting it failed in a non-critical fashion) */\n    if (rc == 0)\n        rollback = false;\n\n    ret = 0;\n cleanup:\n    if (rollback) {\n        virErrorPtr origerr;\n\n        virErrorPreserveLast(&origerr);\n        /* Try to restore the label. This is done so that XATTRs\n         * are left in the same state as when the control entered\n         * this function. However, if our attempt fails, there's\n         * not much we can do. XATTRs refcounting is fubar'ed and\n         * the only option we have is warn users. */\n        if (virSecuritySELinuxRestoreFileLabel(mgr, path, remember) < 0)\n            VIR_WARN(\"Unable to restore label on '%s'. \"\n                     \"XATTRs might have been left in inconsistent state.\",\n                     path);\n\n        virErrorRestore(&origerr);\n\n    }\n    freecon(econ);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "item->path",
            "state->paths[j]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataLock",
          "args": [
            "list->manager",
            "paths",
            "npaths"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1283-1397",
          "snippet": "virSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvirSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY_INPLACE",
          "args": [
            "paths",
            "npaths",
            "p"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "paths",
            "list->nItems"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxTransactionRun(pid_t pid G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecuritySELinuxContextItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    rv = 0;\n    for (i = 0; i < list->nItems; i++) {\n        virSecuritySELinuxContextItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecuritySELinuxSetFilecon(list->manager,\n                                              item->path,\n                                              item->tcon,\n                                              remember);\n        } else {\n            rv = virSecuritySELinuxRestoreFileLabel(list->manager,\n                                                    item->path,\n                                                    remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecuritySELinuxContextItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecuritySELinuxRestoreFileLabel(list->manager,\n                                               item->path,\n                                               remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\", item->path);\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRecallLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "208-222",
    "snippet": "static int\nvirSecuritySELinuxRecallLabel(const char *path,\n                              security_context_t *con)\n{\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_SELINUX_NAME, path, con);\n    if (rv < 0)\n        return rv;\n\n    if (!*con)\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityGetRememberedLabel",
          "args": [
            "SECURITY_SELINUX_NAME",
            "path",
            "con"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "263-337",
          "snippet": "int\nvirSecurityGetRememberedLabel(const char *name,\n                              const char *path,\n                              char **label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    *label = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENODATA || errno == ENOTSUP)\n            return -2;\n\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             ref_name,\n                             path);\n        return -1;\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            return -2;\n    }\n\n    if (virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount--;\n\n    if (refcount > 0) {\n        value = g_strdup_printf(\"%u\", refcount);\n\n        if (virFileSetXAttr(path, ref_name, value) < 0)\n            return -1;\n    } else {\n        if (virFileRemoveXAttr(path, ref_name) < 0)\n            return -1;\n\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileGetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virFileRemoveXAttr(path, attr_name) < 0)\n            return -1;\n\n        if (virSecurityRemoveTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityGetRememberedLabel(const char *name,\n                              const char *path,\n                              char **label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    *label = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENODATA || errno == ENOTSUP)\n            return -2;\n\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             ref_name,\n                             path);\n        return -1;\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            return -2;\n    }\n\n    if (virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount--;\n\n    if (refcount > 0) {\n        value = g_strdup_printf(\"%u\", refcount);\n\n        if (virFileSetXAttr(path, ref_name, value) < 0)\n            return -1;\n    } else {\n        if (virFileRemoveXAttr(path, ref_name) < 0)\n            return -1;\n\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileGetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virFileRemoveXAttr(path, attr_name) < 0)\n            return -1;\n\n        if (virSecurityRemoveTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRecallLabel(const char *path,\n                              security_context_t *con)\n{\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_SELINUX_NAME, path, con);\n    if (rv < 0)\n        return rv;\n\n    if (!*con)\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecuritySELinuxRememberLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "199-205",
    "snippet": "static int\nvirSecuritySELinuxRememberLabel(const char *path,\n                                const security_context_t con)\n{\n    return virSecuritySetRememberedLabel(SECURITY_SELINUX_NAME,\n                                         path, con);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_SELINUX_NAME \"selinux\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySetRememberedLabel",
          "args": [
            "SECURITY_SELINUX_NAME",
            "path",
            "con"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySetRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "360-428",
          "snippet": "int\nvirSecuritySetRememberedLabel(const char *name,\n                              const char *path,\n                              const char *label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name,\n                                 path);\n            return -1;\n        }\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            VIR_FREE(value);\n    }\n\n    if (value &&\n        virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount++;\n\n    if (refcount == 1) {\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileSetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virSecurityAddTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    value = g_strdup_printf(\"%u\", refcount);\n\n    if (virFileSetXAttr(path, ref_name, value) < 0)\n        return -1;\n\n    return refcount;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecuritySetRememberedLabel(const char *name,\n                              const char *path,\n                              const char *label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name,\n                                 path);\n            return -1;\n        }\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            VIR_FREE(value);\n    }\n\n    if (value &&\n        virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount++;\n\n    if (refcount == 1) {\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileSetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virSecurityAddTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    value = g_strdup_printf(\"%u\", refcount);\n\n    if (virFileSetXAttr(path, ref_name, value) < 0)\n        return -1;\n\n    return refcount;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\n#define SECURITY_SELINUX_NAME \"selinux\"\n\nstatic int\nvirSecuritySELinuxRememberLabel(const char *path,\n                                const security_context_t con)\n{\n    return virSecuritySetRememberedLabel(SECURITY_SELINUX_NAME,\n                                         path, con);\n}"
  },
  {
    "function_name": "virSecuritySELinuxTransactionAppend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "179-196",
    "snippet": "static int\nvirSecuritySELinuxTransactionAppend(const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return 0;\n\n    if (virSecuritySELinuxContextListAppend(list, path, tcon,\n                                            remember, restore) < 0)\n        return -1;\n\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal contextList;",
      "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextListAppend",
          "args": [
            "list",
            "path",
            "tcon",
            "remember",
            "restore"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextListAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "116-142",
          "snippet": "static int\nvirSecuritySELinuxContextListAppend(virSecuritySELinuxContextListPtr list,\n                                    const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    int ret = -1;\n    virSecuritySELinuxContextItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    item->path = g_strdup(path);\n    item->tcon = g_strdup(tcon);\n\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextItemFree(item);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxContextListAppend(virSecuritySELinuxContextListPtr list,\n                                    const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    int ret = -1;\n    virSecuritySELinuxContextItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    item->path = g_strdup(path);\n    item->tcon = g_strdup(tcon);\n\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextItemFree(item);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&contextList"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nvirThreadLocal contextList;\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxTransactionAppend(const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    virSecuritySELinuxContextListPtr list;\n\n    list = virThreadLocalGet(&contextList);\n    if (!list)\n        return 0;\n\n    if (virSecuritySELinuxContextListAppend(list, path, tcon,\n                                            remember, restore) < 0)\n        return -1;\n\n    return 1;\n}"
  },
  {
    "function_name": "virSecuritySELinuxContextListFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "144-159",
    "snippet": "static void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "list->manager"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list->items"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextItemFree",
          "args": [
            "list->items[i]"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextItemFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "105-114",
          "snippet": "static void\nvirSecuritySELinuxContextItemFree(virSecuritySELinuxContextItemPtr item)\n{\n    if (!item)\n        return;\n\n    VIR_FREE(item->path);\n    VIR_FREE(item->tcon);\n    VIR_FREE(item);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextItemFree(virSecuritySELinuxContextItemPtr item)\n{\n    if (!item)\n        return;\n\n    VIR_FREE(item->path);\n    VIR_FREE(item->tcon);\n    VIR_FREE(item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextListFree(void *opaque)\n{\n    virSecuritySELinuxContextListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++)\n        virSecuritySELinuxContextItemFree(list->items[i]);\n\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
  },
  {
    "function_name": "virSecuritySELinuxContextListAppend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "116-142",
    "snippet": "static int\nvirSecuritySELinuxContextListAppend(virSecuritySELinuxContextListPtr list,\n                                    const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    int ret = -1;\n    virSecuritySELinuxContextItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    item->path = g_strdup(path);\n    item->tcon = g_strdup(tcon);\n\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextItemFree(item);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecuritySELinuxContextItemFree",
          "args": [
            "item"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySELinuxContextItemFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
          "lines": "105-114",
          "snippet": "static void\nvirSecuritySELinuxContextItemFree(virSecuritySELinuxContextItemPtr item)\n{\n    if (!item)\n        return;\n\n    VIR_FREE(item->path);\n    VIR_FREE(item->tcon);\n    VIR_FREE(item);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virtpm.h\"",
            "#include \"virconf.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include <selinux/label.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <selinux/context.h>",
            "#include <selinux/selinux.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextItemFree(virSecuritySELinuxContextItemPtr item)\n{\n    if (!item)\n        return;\n\n    VIR_FREE(item->path);\n    VIR_FREE(item->tcon);\n    VIR_FREE(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "list->items",
            "list->nItems",
            "item"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "tcon"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "item"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic int virSecuritySELinuxSetFilecon(virSecurityManagerPtr mgr,\n                                        const char *path,\n                                        const char *tcon,\n                                        bool remember);\n\nstatic int\nvirSecuritySELinuxContextListAppend(virSecuritySELinuxContextListPtr list,\n                                    const char *path,\n                                    const char *tcon,\n                                    bool remember,\n                                    bool restore)\n{\n    int ret = -1;\n    virSecuritySELinuxContextItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    item->path = g_strdup(path);\n    item->tcon = g_strdup(tcon);\n\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextItemFree(item);\n    return ret;\n}"
  },
  {
    "function_name": "virSecuritySELinuxContextItemFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_selinux.c",
    "lines": "105-114",
    "snippet": "static void\nvirSecuritySELinuxContextItemFree(virSecuritySELinuxContextItemPtr item)\n{\n    if (!item)\n        return;\n\n    VIR_FREE(item->path);\n    VIR_FREE(item->tcon);\n    VIR_FREE(item);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virtpm.h\"",
      "#include \"virconf.h\"",
      "#include \"virrandom.h\"",
      "#include \"virhash.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include <selinux/label.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <selinux/context.h>",
      "#include <selinux/selinux.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->tcon"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->path"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virtpm.h\"\n#include \"virconf.h\"\n#include \"virrandom.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include <selinux/label.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <selinux/context.h>\n#include <selinux/selinux.h>\n#include <config.h>\n\nstatic void\nvirSecuritySELinuxContextItemFree(virSecuritySELinuxContextItemPtr item)\n{\n    if (!item)\n        return;\n\n    VIR_FREE(item->path);\n    VIR_FREE(item->tcon);\n    VIR_FREE(item);\n}"
  }
]