[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "996-1483",
    "snippet": "int main(int argc, char **argv) {\n    virNetDaemonPtr dmn = NULL;\n    virNetServerPtr srv = NULL;\n    virNetServerPtr srvAdm = NULL;\n    virNetServerProgramPtr adminProgram = NULL;\n    virNetServerProgramPtr lxcProgram = NULL;\n    char *remote_config_file = NULL;\n    int statuswrite = -1;\n    int ret = 1;\n    int pid_file_fd = -1;\n    char *pid_file = NULL;\n    char *sock_file = NULL;\n    char *sock_file_ro = NULL;\n    char *sock_file_adm = NULL;\n    int timeout = -1;        /* -t: Shutdown timeout */\n    int verbose = 0;\n    int godaemon = 0;\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    int ipsock = 0;\n# else /* ! LIBVIRTD */\n    int ipsock = 1; /* listen_tcp/listen_tls default to 0 */\n# endif /* ! LIBVIRTD */\n#endif /* ! WITH_IP */\n    struct daemonConfig *config;\n    bool privileged = geteuid() == 0 ? true : false;\n    bool implicit_conf = false;\n    char *run_dir = NULL;\n    mode_t old_umask;\n\n    struct option opts[] = {\n        { \"verbose\", no_argument, &verbose, 'v'},\n        { \"daemon\", no_argument, &godaemon, 'd'},\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        { \"listen\", no_argument, &ipsock, 'l'},\n#endif /* !(WITH_IP && LIBVIRTD) */\n        { \"config\", required_argument, NULL, 'f'},\n        { \"timeout\", required_argument, NULL, 't'},\n        { \"pid-file\", required_argument, NULL, 'p'},\n        { \"version\", no_argument, NULL, 'V' },\n        { \"help\", no_argument, NULL, 'h' },\n        {0, 0, 0, 0}\n    };\n\n    if (virGettextInitialize() < 0 ||\n        virInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    virUpdateSelfLastChanged(argv[0]);\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    while (1) {\n        int optidx = 0;\n        int c;\n        char *tmp;\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        const char *optstr = \"ldf:p:t:vVh\";\n#else /* !(WITH_IP && LIBVIRTD) */\n        const char *optstr = \"df:p:t:vVh\";\n#endif /* !(WITH_IP && LIBVIRTD) */\n\n        c = getopt_long(argc, argv, optstr, opts, &optidx);\n\n        if (c == -1)\n            break;\n\n        switch (c) {\n        case 0:\n            /* Got one of the flags */\n            break;\n        case 'v':\n            verbose = 1;\n            break;\n        case 'd':\n            godaemon = 1;\n            break;\n\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        case 'l':\n            ipsock = 1;\n            break;\n#endif /* !(WITH_IP && LIBVIRTD) */\n\n        case 't':\n            if (virStrToLong_i(optarg, &tmp, 10, &timeout) != 0\n                || timeout <= 0\n                /* Ensure that we can multiply by 1000 without overflowing.  */\n                || timeout > INT_MAX / 1000) {\n                VIR_ERROR(_(\"Invalid value for timeout\"));\n                exit(EXIT_FAILURE);\n            }\n            break;\n\n        case 'p':\n            VIR_FREE(pid_file);\n            pid_file = g_strdup(optarg);\n            break;\n\n        case 'f':\n            VIR_FREE(remote_config_file);\n            remote_config_file = g_strdup(optarg);\n            break;\n\n        case 'V':\n            daemonVersion(argv[0]);\n            exit(EXIT_SUCCESS);\n\n        case 'h':\n            daemonUsage(argv[0], privileged);\n            exit(EXIT_SUCCESS);\n\n        case '?':\n        default:\n            daemonUsage(argv[0], privileged);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (optind != argc) {\n        fprintf(stderr, \"%s: unexpected, non-option, command line arguments\\n\",\n                argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    if (!(config = daemonConfigNew(privileged))) {\n        VIR_ERROR(_(\"Can't create initial configuration\"));\n        exit(EXIT_FAILURE);\n    }\n\n    /* No explicit config, so try and find a default one */\n    if (remote_config_file == NULL) {\n        implicit_conf = true;\n        if (daemonConfigFilePath(privileged,\n                                 &remote_config_file) < 0) {\n            VIR_ERROR(_(\"Can't determine config path\"));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* Read the config file if it exists */\n    if (remote_config_file &&\n        daemonConfigLoadFile(config, remote_config_file, implicit_conf) < 0) {\n        VIR_ERROR(_(\"Can't load config file: %s: %s\"),\n                  virGetLastErrorMessage(), remote_config_file);\n        exit(EXIT_FAILURE);\n    }\n\n    if (daemonSetupHostUUID(config) < 0) {\n        VIR_ERROR(_(\"Can't setup host uuid\"));\n        exit(EXIT_FAILURE);\n    }\n\n    if (daemonSetupLogging(config, privileged, verbose, godaemon) < 0) {\n        VIR_ERROR(_(\"Can't initialize logging\"));\n        exit(EXIT_FAILURE);\n    }\n\n    /* Let's try to initialize global variable that holds the host's boot time. */\n    if (virHostBootTimeInit() < 0) {\n        /* This is acceptable failure. Maybe we won't need the boot time\n         * anyway, and if we do, then virHostGetBootTime() returns an\n         * appropriate error. */\n        VIR_DEBUG(\"Ignoring failed boot time init\");\n    }\n\n    daemonSetupNetDevOpenvswitch(config);\n\n    if (daemonSetupAccessManager(config) < 0) {\n        VIR_ERROR(_(\"Can't initialize access manager\"));\n        exit(EXIT_FAILURE);\n    }\n\n    if (!pid_file &&\n        virPidFileConstructPath(privileged,\n                                RUNSTATEDIR,\n                                DAEMON_NAME,\n                                &pid_file) < 0) {\n        VIR_ERROR(_(\"Can't determine pid file path.\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on pid file path '%s'\", NULLSTR(pid_file));\n\n    if (daemonUnixSocketPaths(config,\n                              privileged,\n                              &sock_file,\n                              &sock_file_ro,\n                              &sock_file_adm) < 0) {\n        VIR_ERROR(_(\"Can't determine socket paths\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on socket paths '%s', '%s' and '%s'\",\n              sock_file,\n              NULLSTR(sock_file_ro),\n              NULLSTR(sock_file_adm));\n\n    if (godaemon) {\n        if (chdir(\"/\") < 0) {\n            VIR_ERROR(_(\"cannot change to root directory: %s\"),\n                      g_strerror(errno));\n            goto cleanup;\n        }\n\n        if ((statuswrite = daemonForkIntoBackground(argv[0])) < 0) {\n            VIR_ERROR(_(\"Failed to fork as daemon: %s\"),\n                      g_strerror(errno));\n            goto cleanup;\n        }\n    }\n\n    /* Try to claim the pidfile, exiting if we can't */\n    if ((pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0) {\n        ret = VIR_DAEMON_ERR_PIDFILE;\n        goto cleanup;\n    }\n\n    /* Ensure the rundir exists (on tmpfs on some systems) */\n    if (privileged) {\n        run_dir = g_strdup(RUNSTATEDIR \"/libvirt\");\n    } else {\n        run_dir = virGetUserRuntimeDirectory();\n    }\n    if (privileged)\n        old_umask = umask(022);\n    else\n        old_umask = umask(077);\n    VIR_DEBUG(\"Ensuring run dir '%s' exists\", run_dir);\n    if (virFileMakePath(run_dir) < 0) {\n        VIR_ERROR(_(\"unable to create rundir %s: %s\"), run_dir,\n                  g_strerror(errno));\n        ret = VIR_DAEMON_ERR_RUNDIR;\n        goto cleanup;\n    }\n    umask(old_umask);\n\n    if (virNetlinkStartup() < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(dmn = virNetDaemonNew())) {\n        ret = VIR_DAEMON_ERR_DRIVER;\n        goto cleanup;\n    }\n\n    if (!(srv = virNetServerNew(DAEMON_NAME, 1,\n                                config->min_workers,\n                                config->max_workers,\n                                config->prio_workers,\n                                config->max_clients,\n                                config->max_anonymous_clients,\n                                config->keepalive_interval,\n                                config->keepalive_count,\n                                remoteClientNew,\n                                NULL,\n                                remoteClientFree,\n                                NULL))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (virNetDaemonAddServer(dmn, srv) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (daemonInitialize() < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    remoteProcs[REMOTE_PROC_AUTH_LIST].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_SASL_INIT].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_SASL_STEP].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_SASL_START].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_POLKIT].needAuth = false;\n    if (!(remoteProgram = virNetServerProgramNew(REMOTE_PROGRAM,\n                                                 REMOTE_PROTOCOL_VERSION,\n                                                 remoteProcs,\n                                                 remoteNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srv, remoteProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(lxcProgram = virNetServerProgramNew(LXC_PROGRAM,\n                                              LXC_PROTOCOL_VERSION,\n                                              lxcProcs,\n                                              lxcNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srv, lxcProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(qemuProgram = virNetServerProgramNew(QEMU_PROGRAM,\n                                               QEMU_PROTOCOL_VERSION,\n                                               qemuProcs,\n                                               qemuNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srv, qemuProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(srvAdm = virNetServerNew(\"admin\", 1,\n                                   config->admin_min_workers,\n                                   config->admin_max_workers,\n                                   0,\n                                   config->admin_max_clients,\n                                   0,\n                                   config->admin_keepalive_interval,\n                                   config->admin_keepalive_count,\n                                   remoteAdmClientNew,\n                                   NULL,\n                                   remoteAdmClientFree,\n                                   dmn))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (virNetDaemonAddServer(dmn, srvAdm) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(adminProgram = virNetServerProgramNew(ADMIN_PROGRAM,\n                                                ADMIN_PROTOCOL_VERSION,\n                                                adminProcs,\n                                                adminNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srvAdm, adminProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (timeout != -1) {\n        VIR_DEBUG(\"Registering shutdown timeout %d\", timeout);\n        virNetDaemonAutoShutdown(dmn, timeout);\n    }\n\n    if ((daemonSetupSignals(dmn)) < 0) {\n        ret = VIR_DAEMON_ERR_SIGNAL;\n        goto cleanup;\n    }\n\n    if (config->audit_level) {\n        VIR_DEBUG(\"Attempting to configure auditing subsystem\");\n        if (virAuditOpen(config->audit_level) < 0) {\n            if (config->audit_level > 1) {\n                ret = VIR_DAEMON_ERR_AUDIT;\n                goto cleanup;\n            }\n            VIR_DEBUG(\"Proceeding without auditing\");\n        }\n    }\n    virAuditLog(config->audit_logging > 0);\n\n    /* setup the hooks if any */\n    if (virHookInitialize() < 0) {\n        ret = VIR_DAEMON_ERR_HOOKS;\n        goto cleanup;\n    }\n\n    /* Disable error func, now logging is setup */\n    virSetErrorFunc(NULL, daemonErrorHandler);\n    virSetErrorLogPriorityFunc(daemonErrorLogFilter);\n\n    /*\n     * Call the daemon startup hook\n     * TODO: should we abort the daemon startup if the script returned\n     *       an error ?\n     */\n    virHookCall(VIR_HOOK_DRIVER_DAEMON, \"-\", VIR_HOOK_DAEMON_OP_START,\n                0, \"start\", NULL, NULL);\n\n    if (daemonSetupNetworking(srv, srvAdm,\n                              config,\n#ifdef WITH_IP\n                              ipsock,\n                              privileged,\n#endif /* !WITH_IP */\n                              sock_file,\n                              sock_file_ro,\n                              sock_file_adm) < 0) {\n        ret = VIR_DAEMON_ERR_NETWORK;\n        goto cleanup;\n    }\n\n    /* Tell parent of daemon that basic initialization is complete\n     * In particular we're ready to accept net connections & have\n     * written the pidfile\n     */\n    if (statuswrite != -1) {\n        char status = 0;\n        ignore_value(safewrite(statuswrite, &status, 1));\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n\n    /* Initialize drivers & then start accepting new clients from network */\n    if (daemonStateInit(dmn) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n#if defined(__linux__) && defined(NETLINK_ROUTE)\n    /* Register the netlink event service for NETLINK_ROUTE */\n    if (virNetlinkEventServiceStart(NETLINK_ROUTE, 0) < 0) {\n        ret = VIR_DAEMON_ERR_NETWORK;\n        goto cleanup;\n    }\n#endif\n\n#if defined(__linux__) && defined(NETLINK_KOBJECT_UEVENT)\n    /* Register the netlink event service for NETLINK_KOBJECT_UEVENT */\n    if (virNetlinkEventServiceStart(NETLINK_KOBJECT_UEVENT, 1) < 0) {\n        ret = VIR_DAEMON_ERR_NETWORK;\n        goto cleanup;\n    }\n#endif\n\n    /* Run event loop. */\n    virNetDaemonRun(dmn);\n\n    ret = 0;\n\n    virHookCall(VIR_HOOK_DRIVER_DAEMON, \"-\", VIR_HOOK_DAEMON_OP_SHUTDOWN,\n                0, \"shutdown\", NULL, NULL);\n\n cleanup:\n    /* Keep cleanup order in inverse order of startup */\n    virNetDaemonClose(dmn);\n\n    virNetlinkEventServiceStopAll();\n\n    if (driversInitialized) {\n        /* NB: Possible issue with timing window between driversInitialized\n         * setting if virNetlinkEventServerStart fails */\n        driversInitialized = false;\n        virStateCleanup();\n    }\n\n    virObjectUnref(adminProgram);\n    virObjectUnref(srvAdm);\n    virObjectUnref(qemuProgram);\n    virObjectUnref(lxcProgram);\n    virObjectUnref(remoteProgram);\n    virObjectUnref(srv);\n    virObjectUnref(dmn);\n\n    virNetlinkShutdown();\n\n    if (pid_file_fd != -1)\n        virPidFileReleasePath(pid_file, pid_file_fd);\n\n    VIR_FREE(run_dir);\n\n    if (statuswrite != -1) {\n        if (ret != 0) {\n            /* Tell parent of daemon what failed */\n            char status = ret;\n            ignore_value(safewrite(statuswrite, &status, 1));\n        }\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n\n    VIR_FREE(sock_file);\n    VIR_FREE(sock_file_ro);\n    VIR_FREE(sock_file_adm);\n\n    VIR_FREE(pid_file);\n\n    VIR_FREE(remote_config_file);\n    daemonConfigFree(config);\n\n    return ret;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virNetServerProgramPtr remoteProgram = NULL;",
      "virNetServerProgramPtr qemuProgram = NULL;",
      "volatile bool driversInitialized = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "daemonConfigFree",
          "args": [
            "config"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "daemonConfigFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_config.c",
          "lines": "168-224",
          "snippet": "void\ndaemonConfigFree(struct daemonConfig *data)\n{\n    char **tmp;\n\n    if (!data)\n        return;\n\n#ifdef WITH_IP\n    VIR_FREE(data->listen_addr);\n    VIR_FREE(data->tls_port);\n    VIR_FREE(data->tcp_port);\n#endif /* ! WITH_IP */\n\n    tmp = data->access_drivers;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(data->access_drivers);\n\n    VIR_FREE(data->unix_sock_admin_perms);\n    VIR_FREE(data->unix_sock_ro_perms);\n    VIR_FREE(data->unix_sock_rw_perms);\n    VIR_FREE(data->unix_sock_group);\n    VIR_FREE(data->unix_sock_dir);\n\n    tmp = data->sasl_allowed_username_list;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(data->sasl_allowed_username_list);\n\n#ifdef WITH_IP\n    tmp = data->tls_allowed_dn_list;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(data->tls_allowed_dn_list);\n\n    VIR_FREE(data->tls_priority);\n\n    VIR_FREE(data->key_file);\n    VIR_FREE(data->ca_file);\n    VIR_FREE(data->cert_file);\n    VIR_FREE(data->crl_file);\n#endif /* ! WITH_IP */\n\n    VIR_FREE(data->host_uuid);\n    VIR_FREE(data->host_uuid_source);\n    VIR_FREE(data->log_filters);\n    VIR_FREE(data->log_outputs);\n\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"remote_driver.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"remote_driver.h\"\n#include \"remote_protocol.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetserver.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"remote_daemon_config.h\"\n#include <config.h>\n\nvoid\ndaemonConfigFree(struct daemonConfig *data)\n{\n    char **tmp;\n\n    if (!data)\n        return;\n\n#ifdef WITH_IP\n    VIR_FREE(data->listen_addr);\n    VIR_FREE(data->tls_port);\n    VIR_FREE(data->tcp_port);\n#endif /* ! WITH_IP */\n\n    tmp = data->access_drivers;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(data->access_drivers);\n\n    VIR_FREE(data->unix_sock_admin_perms);\n    VIR_FREE(data->unix_sock_ro_perms);\n    VIR_FREE(data->unix_sock_rw_perms);\n    VIR_FREE(data->unix_sock_group);\n    VIR_FREE(data->unix_sock_dir);\n\n    tmp = data->sasl_allowed_username_list;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(data->sasl_allowed_username_list);\n\n#ifdef WITH_IP\n    tmp = data->tls_allowed_dn_list;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(data->tls_allowed_dn_list);\n\n    VIR_FREE(data->tls_priority);\n\n    VIR_FREE(data->key_file);\n    VIR_FREE(data->ca_file);\n    VIR_FREE(data->cert_file);\n    VIR_FREE(data->crl_file);\n#endif /* ! WITH_IP */\n\n    VIR_FREE(data->host_uuid);\n    VIR_FREE(data->host_uuid_source);\n    VIR_FREE(data->log_filters);\n    VIR_FREE(data->log_outputs);\n\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "remote_config_file"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pid_file"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock_file_adm"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock_file_ro"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock_file"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuswrite"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "safewrite(statuswrite, &status, 1)"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "statuswrite",
            "&status",
            "1"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "run_dir"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReleasePath",
          "args": [
            "pid_file",
            "pid_file_fd"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReleasePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "430-450",
          "snippet": "int virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkShutdown",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1230-1234",
          "snippet": "void\nvirNetlinkShutdown(void)\n{\n    return;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetlinkShutdown(void)\n{\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dmn"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStateCleanup",
          "args": [],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "virStateCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "682-694",
          "snippet": "int\nvirStateCleanup(void)\n{\n    int r;\n    int ret = 0;\n\n    for (r = virStateDriverTabCount - 1; r >= 0; r--) {\n        if (virStateDriverTab[r]->stateCleanup &&\n            virStateDriverTab[r]->stateCleanup() < 0)\n            ret = -1;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateCleanup(void)\n{\n    int r;\n    int ret = 0;\n\n    for (r = virStateDriverTabCount - 1; r >= 0; r--) {\n        if (virStateDriverTab[r]->stateCleanup &&\n            virStateDriverTab[r]->stateCleanup() < 0)\n            ret = -1;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServiceStopAll",
          "args": [],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServiceStopAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1319-1323",
          "snippet": "int virNetlinkEventServiceStopAll(void)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceStopAll(void)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonClose",
          "args": [
            "dmn"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "889-900",
          "snippet": "void\nvirNetDaemonClose(virNetDaemonPtr dmn)\n{\n    if (!dmn)\n        return;\n\n    virObjectLock(dmn);\n\n    virHashForEach(dmn->servers, daemonServerClose, NULL);\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonClose(virNetDaemonPtr dmn)\n{\n    if (!dmn)\n        return;\n\n    virObjectLock(dmn);\n\n    virHashForEach(dmn->servers, daemonServerClose, NULL);\n\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_DAEMON",
            "\"-\"",
            "VIR_HOOK_DAEMON_OP_SHUTDOWN",
            "0",
            "\"shutdown\"",
            "NULL",
            "NULL"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonRun",
          "args": [
            "dmn"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "799-864",
          "snippet": "void\nvirNetDaemonRun(virNetDaemonPtr dmn)\n{\n    int timerid = -1;\n    bool timerActive = false;\n\n    virObjectLock(dmn);\n\n    if (dmn->srvObject) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Not all servers restored, cannot run server\"));\n        goto cleanup;\n    }\n\n    dmn->quit = false;\n\n    if (dmn->autoShutdownTimeout &&\n        (timerid = virEventAddTimeout(-1,\n                                      virNetDaemonAutoShutdownTimer,\n                                      dmn, NULL)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register shutdown timeout\"));\n        goto cleanup;\n    }\n\n    /* We are accepting connections now. Notify systemd\n     * so it can start dependent services. */\n    virSystemdNotifyStartup();\n\n    VIR_DEBUG(\"dmn=%p quit=%d\", dmn, dmn->quit);\n    while (!dmn->quit) {\n        /* A shutdown timeout is specified, so check\n         * if any drivers have active state, if not\n         * shutdown after timeout seconds\n         */\n        if (dmn->autoShutdownTimeout) {\n            if (timerActive) {\n                if (virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Deactivating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid, -1);\n                    timerActive = false;\n                }\n            } else {\n                if (!virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Activating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid,\n                                          dmn->autoShutdownTimeout * 1000);\n                    timerActive = true;\n                }\n            }\n        }\n\n        virObjectUnlock(dmn);\n        if (virEventRunDefaultImpl() < 0) {\n            virObjectLock(dmn);\n            VIR_DEBUG(\"Loop iteration error, exiting\");\n            break;\n        }\n        virObjectLock(dmn);\n\n        virHashForEach(dmn->servers, daemonServerProcessClients, NULL);\n    }\n\n cleanup:\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonRun(virNetDaemonPtr dmn)\n{\n    int timerid = -1;\n    bool timerActive = false;\n\n    virObjectLock(dmn);\n\n    if (dmn->srvObject) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Not all servers restored, cannot run server\"));\n        goto cleanup;\n    }\n\n    dmn->quit = false;\n\n    if (dmn->autoShutdownTimeout &&\n        (timerid = virEventAddTimeout(-1,\n                                      virNetDaemonAutoShutdownTimer,\n                                      dmn, NULL)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register shutdown timeout\"));\n        goto cleanup;\n    }\n\n    /* We are accepting connections now. Notify systemd\n     * so it can start dependent services. */\n    virSystemdNotifyStartup();\n\n    VIR_DEBUG(\"dmn=%p quit=%d\", dmn, dmn->quit);\n    while (!dmn->quit) {\n        /* A shutdown timeout is specified, so check\n         * if any drivers have active state, if not\n         * shutdown after timeout seconds\n         */\n        if (dmn->autoShutdownTimeout) {\n            if (timerActive) {\n                if (virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Deactivating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid, -1);\n                    timerActive = false;\n                }\n            } else {\n                if (!virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Activating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid,\n                                          dmn->autoShutdownTimeout * 1000);\n                    timerActive = true;\n                }\n            }\n        }\n\n        virObjectUnlock(dmn);\n        if (virEventRunDefaultImpl() < 0) {\n            virObjectLock(dmn);\n            VIR_DEBUG(\"Loop iteration error, exiting\");\n            break;\n        }\n        virObjectLock(dmn);\n\n        virHashForEach(dmn->servers, daemonServerProcessClients, NULL);\n    }\n\n cleanup:\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServiceStart",
          "args": [
            "NETLINK_KOBJECT_UEVENT",
            "1"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServiceStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1329-1334",
          "snippet": "int virNetlinkEventServiceStart(unsigned int protocol G_GNUC_UNUSED,\n                                unsigned int groups G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceStart(unsigned int protocol G_GNUC_UNUSED,\n                                unsigned int groups G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStateInit",
          "args": [
            "dmn"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStateInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "875-885",
          "snippet": "static int daemonStateInit(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonRunStateInit,\n                            \"daemon-init\", false, dmn) < 0) {\n        virObjectUnref(dmn);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonStateInit(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonRunStateInit,\n                            \"daemon-init\", false, dmn) < 0) {\n        virObjectUnref(dmn);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuswrite"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "safewrite(statuswrite, &status, 1)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonSetupNetworking",
          "args": [
            "srv",
            "srvAdm",
            "config",
            "#ifdef WITH_IPipsock",
            "privileged",
            "#endif/* !WITH_IP */sock_file",
            "sock_file_ro",
            "sock_file_adm"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetErrorLogPriorityFunc",
          "args": [
            "daemonErrorLogFilter"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetErrorFunc",
          "args": [
            "NULL",
            "daemonErrorHandler"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "609-614",
          "snippet": "void\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookInitialize",
          "args": [],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "virHookInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "181-199",
          "snippet": "int\nvirHookInitialize(void)\n{\n    size_t i;\n    int res, ret = 0;\n\n    virHooksFound = 0;\n    for (i = 0; i < VIR_HOOK_DRIVER_LAST; i++) {\n        res = virHookCheck(i, virHookDriverTypeToString(i));\n        if (res < 0)\n            return -1;\n\n        if (res == 1) {\n            virHooksFound |= (1 << i);\n            ret++;\n        }\n    }\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookInitialize(void)\n{\n    size_t i;\n    int res, ret = 0;\n\n    virHooksFound = 0;\n    for (i = 0; i < VIR_HOOK_DRIVER_LAST; i++) {\n        res = virHookCheck(i, virHookDriverTypeToString(i));\n        if (res < 0)\n            return -1;\n\n        if (res == 1) {\n            virHooksFound |= (1 << i);\n            ret++;\n        }\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuditLog",
          "args": [
            "config->audit_logging > 0"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "virAuditLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viraudit.c",
          "lines": "69-72",
          "snippet": "void virAuditLog(bool logging)\n{\n    auditlog = logging;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"viraudit.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <libaudit.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool auditlog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"viraudit.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <libaudit.h>\n#include <config.h>\n\nstatic bool auditlog;\n\nvoid virAuditLog(bool logging)\n{\n    auditlog = logging;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Proceeding without auditing\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virAuditOpen",
          "args": [
            "config->audit_level"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "virAuditOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viraudit.c",
          "lines": "42-66",
          "snippet": "int virAuditOpen(unsigned int audit_level G_GNUC_UNUSED)\n{\n#if WITH_AUDIT\n    if ((auditfd = audit_open()) < 0) {\n        /* You get these error codes only when the kernel does not\n         * have audit compiled in or it's disabled (e.g. by the kernel\n         * cmdline) */\n        if (errno == EINVAL || errno == EPROTONOSUPPORT ||\n            errno == EAFNOSUPPORT) {\n            if (audit_level < 2)\n                VIR_INFO(\"Audit is not supported by the kernel\");\n            else\n                virReportError(VIR_FROM_THIS, \"%s\", _(\"Audit is not supported by the kernel\"));\n        } else {\n            virReportSystemError(errno, \"%s\", _(\"Unable to initialize audit layer\"));\n        }\n\n        return -1;\n    }\n\n    return 0;\n#else\n    return -1;\n#endif\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"viraudit.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <libaudit.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FROM_THIS VIR_FROM_AUDIT"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"viraudit.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <libaudit.h>\n#include <config.h>\n\n#define VIR_FROM_THIS VIR_FROM_AUDIT\n\nint virAuditOpen(unsigned int audit_level G_GNUC_UNUSED)\n{\n#if WITH_AUDIT\n    if ((auditfd = audit_open()) < 0) {\n        /* You get these error codes only when the kernel does not\n         * have audit compiled in or it's disabled (e.g. by the kernel\n         * cmdline) */\n        if (errno == EINVAL || errno == EPROTONOSUPPORT ||\n            errno == EAFNOSUPPORT) {\n            if (audit_level < 2)\n                VIR_INFO(\"Audit is not supported by the kernel\");\n            else\n                virReportError(VIR_FROM_THIS, \"%s\", _(\"Audit is not supported by the kernel\"));\n        } else {\n            virReportSystemError(errno, \"%s\", _(\"Unable to initialize audit layer\"));\n        }\n\n        return -1;\n    }\n\n    return 0;\n#else\n    return -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Attempting to configure auditing subsystem\""
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonSetupSignals",
          "args": [
            "dmn"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "daemonSetupSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "723-734",
          "snippet": "static int daemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGHUP, daemonReloadHandler, NULL) < 0)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGHUP, daemonReloadHandler, NULL) < 0)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonAutoShutdown",
          "args": [
            "dmn",
            "timeout"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAutoShutdownTimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "751-765",
          "snippet": "static void\nvirNetDaemonAutoShutdownTimer(int timerid G_GNUC_UNUSED,\n                              void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    virObjectLock(dmn);\n\n    if (!dmn->autoShutdownInhibitions) {\n        VIR_DEBUG(\"Automatic shutdown triggered\");\n        dmn->quit = true;\n    }\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetDaemonAutoShutdownTimer(int timerid G_GNUC_UNUSED,\n                              void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    virObjectLock(dmn);\n\n    if (!dmn->autoShutdownInhibitions) {\n        VIR_DEBUG(\"Automatic shutdown triggered\");\n        dmn->quit = true;\n    }\n\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Registering shutdown timeout %d\"",
            "timeout"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerAddProgram",
          "args": [
            "srvAdm",
            "adminProgram"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "820-836",
          "snippet": "int virNetServerAddProgram(virNetServerPtr srv,\n                           virNetServerProgramPtr prog)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->programs, srv->nprograms, 1) < 0)\n        goto error;\n\n    srv->programs[srv->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddProgram(virNetServerPtr srv,\n                           virNetServerProgramPtr prog)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->programs, srv->nprograms, 1) < 0)\n        goto error;\n\n    srv->programs[srv->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramNew",
          "args": [
            "ADMIN_PROGRAM",
            "ADMIN_PROTOCOL_VERSION",
            "adminProcs",
            "adminNProcs"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "61-82",
          "snippet": "virNetServerProgramPtr virNetServerProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetServerProgramProcPtr procs,\n                                              size_t nprocs)\n{\n    virNetServerProgramPtr prog;\n\n    if (virNetServerProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetServerProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->procs = procs;\n    prog->nprocs = nprocs;\n\n    VIR_DEBUG(\"prog=%p\", prog);\n\n    return prog;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerProgramClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerProgramClass;\n\nvirNetServerProgramPtr virNetServerProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetServerProgramProcPtr procs,\n                                              size_t nprocs)\n{\n    virNetServerProgramPtr prog;\n\n    if (virNetServerProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetServerProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->procs = procs;\n    prog->nprocs = nprocs;\n\n    VIR_DEBUG(\"prog=%p\", prog);\n\n    return prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonAddServer",
          "args": [
            "dmn",
            "srvAdm"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAddServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "161-179",
          "snippet": "int\nvirNetDaemonAddServer(virNetDaemonPtr dmn,\n                      virNetServerPtr srv)\n{\n    int ret = -1;\n    const char *serverName = virNetServerGetName(srv);\n\n    virObjectLock(dmn);\n\n    if (virHashAddEntry(dmn->servers, serverName, srv) < 0)\n        goto cleanup;\n\n    virObjectRef(srv);\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDaemonAddServer(virNetDaemonPtr dmn,\n                      virNetServerPtr srv)\n{\n    int ret = -1;\n    const char *serverName = virNetServerGetName(srv);\n\n    virObjectLock(dmn);\n\n    if (virHashAddEntry(dmn->servers, serverName, srv) < 0)\n        goto cleanup;\n\n    virObjectRef(srv);\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerNew",
          "args": [
            "\"admin\"",
            "1",
            "config->admin_min_workers",
            "config->admin_max_workers",
            "0",
            "config->admin_max_clients",
            "0",
            "config->admin_keepalive_interval",
            "config->admin_keepalive_count",
            "remoteAdmClientNew",
            "NULL",
            "remoteAdmClientFree",
            "dmn"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "349-394",
          "snippet": "virNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerClass;",
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerClass;\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonInitialize",
          "args": [],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "daemonInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "304-375",
          "snippet": "static int daemonInitialize(void)\n{\n#ifndef LIBVIRTD\n# ifdef MODULE_NAME\n    /* This a dedicated per-driver daemon build */\n    if (virDriverLoadModule(MODULE_NAME, MODULE_NAME \"Register\", true) < 0)\n        return -1;\n# else\n    /* This is virtproxyd which merely proxies to the per-driver\n     * daemons for back compat, and also allows IP connectivity.\n     */\n# endif\n#else\n    /* This is the legacy monolithic libvirtd built with all drivers\n     *\n     * Note that the order is important: the first ones have a higher\n     * priority when calling virStateInitialize. We must register the\n     * network, storage and nodedev drivers before any stateful domain\n     * driver, since their resources must be auto-started before any\n     * domains can be auto-started.\n     */\n# ifdef WITH_NETWORK\n    if (virDriverLoadModule(\"network\", \"networkRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_INTERFACE\n    if (virDriverLoadModule(\"interface\", \"interfaceRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_SECRETS\n    if (virDriverLoadModule(\"secret\", \"secretRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_STORAGE\n    if (virDriverLoadModule(\"storage\", \"storageRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NODE_DEVICES\n    if (virDriverLoadModule(\"nodedev\", \"nodedevRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NWFILTER\n    if (virDriverLoadModule(\"nwfilter\", \"nwfilterRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LIBXL\n    if (virDriverLoadModule(\"libxl\", \"libxlRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_QEMU\n    if (virDriverLoadModule(\"qemu\", \"qemuRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LXC\n    if (virDriverLoadModule(\"lxc\", \"lxcRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VBOX\n    if (virDriverLoadModule(\"vbox\", \"vboxRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_BHYVE\n    if (virDriverLoadModule(\"bhyve\", \"bhyveRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VZ\n    if (virDriverLoadModule(\"vz\", \"vzRegister\", false) < 0)\n        return -1;\n# endif\n#endif\n    return 0;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonInitialize(void)\n{\n#ifndef LIBVIRTD\n# ifdef MODULE_NAME\n    /* This a dedicated per-driver daemon build */\n    if (virDriverLoadModule(MODULE_NAME, MODULE_NAME \"Register\", true) < 0)\n        return -1;\n# else\n    /* This is virtproxyd which merely proxies to the per-driver\n     * daemons for back compat, and also allows IP connectivity.\n     */\n# endif\n#else\n    /* This is the legacy monolithic libvirtd built with all drivers\n     *\n     * Note that the order is important: the first ones have a higher\n     * priority when calling virStateInitialize. We must register the\n     * network, storage and nodedev drivers before any stateful domain\n     * driver, since their resources must be auto-started before any\n     * domains can be auto-started.\n     */\n# ifdef WITH_NETWORK\n    if (virDriverLoadModule(\"network\", \"networkRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_INTERFACE\n    if (virDriverLoadModule(\"interface\", \"interfaceRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_SECRETS\n    if (virDriverLoadModule(\"secret\", \"secretRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_STORAGE\n    if (virDriverLoadModule(\"storage\", \"storageRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NODE_DEVICES\n    if (virDriverLoadModule(\"nodedev\", \"nodedevRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NWFILTER\n    if (virDriverLoadModule(\"nwfilter\", \"nwfilterRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LIBXL\n    if (virDriverLoadModule(\"libxl\", \"libxlRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_QEMU\n    if (virDriverLoadModule(\"qemu\", \"qemuRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LXC\n    if (virDriverLoadModule(\"lxc\", \"lxcRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VBOX\n    if (virDriverLoadModule(\"vbox\", \"vboxRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_BHYVE\n    if (virDriverLoadModule(\"bhyve\", \"bhyveRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VZ\n    if (virDriverLoadModule(\"vz\", \"vzRegister\", false) < 0)\n        return -1;\n# endif\n#endif\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonNew",
          "args": [],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "120-158",
          "snippet": "virNetDaemonPtr\nvirNetDaemonNew(void)\n{\n    virNetDaemonPtr dmn;\n#ifndef WIN32\n    struct sigaction sig_action;\n#endif /* !WIN32 */\n\n    if (virNetDaemonInitialize() < 0)\n        return NULL;\n\n    if (!(dmn = virObjectLockableNew(virNetDaemonClass)))\n        return NULL;\n\n    if (!(dmn->servers = virHashCreate(5, virObjectFreeHashData)))\n        goto error;\n\n#ifndef WIN32\n    dmn->sigwrite = dmn->sigread = -1;\n#endif /* !WIN32 */\n\n    dmn->privileged = geteuid() == 0;\n    dmn->autoShutdownInhibitFd = -1;\n\n    if (virEventRegisterDefaultImpl() < 0)\n        goto error;\n\n#ifndef WIN32\n    memset(&sig_action, 0, sizeof(sig_action));\n    sig_action.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &sig_action, NULL);\n#endif /* !WIN32 */\n\n    return dmn;\n\n error:\n    virObjectUnref(dmn);\n    return NULL;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetDaemonClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetDaemonClass;\n\nvirNetDaemonPtr\nvirNetDaemonNew(void)\n{\n    virNetDaemonPtr dmn;\n#ifndef WIN32\n    struct sigaction sig_action;\n#endif /* !WIN32 */\n\n    if (virNetDaemonInitialize() < 0)\n        return NULL;\n\n    if (!(dmn = virObjectLockableNew(virNetDaemonClass)))\n        return NULL;\n\n    if (!(dmn->servers = virHashCreate(5, virObjectFreeHashData)))\n        goto error;\n\n#ifndef WIN32\n    dmn->sigwrite = dmn->sigread = -1;\n#endif /* !WIN32 */\n\n    dmn->privileged = geteuid() == 0;\n    dmn->autoShutdownInhibitFd = -1;\n\n    if (virEventRegisterDefaultImpl() < 0)\n        goto error;\n\n#ifndef WIN32\n    memset(&sig_action, 0, sizeof(sig_action));\n    sig_action.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &sig_action, NULL);\n#endif /* !WIN32 */\n\n    return dmn;\n\n error:\n    virObjectUnref(dmn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkStartup",
          "args": [],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkStartup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1224-1228",
          "snippet": "int\nvirNetlinkStartup(void)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkStartup(void)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"unable to create rundir %s: %s\")",
            "run_dir",
            "g_strerror(errno)"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to create rundir %s: %s\""
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "run_dir"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ensuring run dir '%s' exists\"",
            "run_dir"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "022"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "RUNSTATEDIR \"/libvirt\""
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquirePath",
          "args": [
            "pid_file",
            "false",
            "getpid()"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquirePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "330-410",
          "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to fork as daemon: %s\")",
            "g_strerror(errno)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonForkIntoBackground",
          "args": [
            "argv[0]"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "daemonForkIntoBackground",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "113-212",
          "snippet": "static int daemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            /* intermediate child */\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0: /* grandchild */\n                return statuspipe[1];\n            case -1: /* error */\n                goto cleanup;\n            default: /* intermediate child succeeded */\n                _exit(EXIT_SUCCESS);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            VIR_FORCE_CLOSE(statuspipe[1]);\n            _exit(EXIT_FAILURE);\n\n        }\n\n    case -1: /* error in parent */\n        goto error;\n\n    default:\n        {\n            /* parent */\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if (virProcessWait(pid, NULL, false) < 0)\n                goto error;\n\n            /* If we get here, then the grandchild was spawned, so we\n             * must exit.  Block until the second child initializes\n             * successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if (ret != 1) {\n                fprintf(stderr,\n                        _(\"%s: error: unable to determine if daemon is \"\n                          \"running: %s\\n\"), argv0,\n                        g_strerror(errno));\n                exit(EXIT_FAILURE);\n            } else if (status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run \"\n                          \"without --daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n                exit(EXIT_FAILURE);\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n error:\n    VIR_FORCE_CLOSE(statuspipe[0]);\n    VIR_FORCE_CLOSE(statuspipe[1]);\n    return -1;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            /* intermediate child */\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0: /* grandchild */\n                return statuspipe[1];\n            case -1: /* error */\n                goto cleanup;\n            default: /* intermediate child succeeded */\n                _exit(EXIT_SUCCESS);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            VIR_FORCE_CLOSE(statuspipe[1]);\n            _exit(EXIT_FAILURE);\n\n        }\n\n    case -1: /* error in parent */\n        goto error;\n\n    default:\n        {\n            /* parent */\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if (virProcessWait(pid, NULL, false) < 0)\n                goto error;\n\n            /* If we get here, then the grandchild was spawned, so we\n             * must exit.  Block until the second child initializes\n             * successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if (ret != 1) {\n                fprintf(stderr,\n                        _(\"%s: error: unable to determine if daemon is \"\n                          \"running: %s\\n\"), argv0,\n                        g_strerror(errno));\n                exit(EXIT_FAILURE);\n            } else if (status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run \"\n                          \"without --daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n                exit(EXIT_FAILURE);\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n error:\n    VIR_FORCE_CLOSE(statuspipe[0]);\n    VIR_FORCE_CLOSE(statuspipe[1]);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"cannot change to root directory: %s\")",
            "g_strerror(errno)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Decided on socket paths '%s', '%s' and '%s'\"",
            "sock_file",
            "NULLSTR(sock_file_ro)",
            "NULLSTR(sock_file_adm)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "sock_file_adm"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "sock_file_ro"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine socket paths\")"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonUnixSocketPaths",
          "args": [
            "config",
            "privileged",
            "&sock_file",
            "&sock_file_ro",
            "&sock_file_adm"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "daemonUnixSocketPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "215-264",
          "snippet": "static int\ndaemonUnixSocketPaths(struct daemonConfig *config,\n                      bool privileged,\n                      char **sockfile,\n                      char **rosockfile,\n                      char **admsockfile)\n{\n    int ret = -1;\n    char *rundir = NULL;\n\n    if (config->unix_sock_dir) {\n        *sockfile = g_strdup_printf(\"%s/%s-sock\", config->unix_sock_dir,\n                                    SOCK_PREFIX);\n\n        if (privileged) {\n            *rosockfile = g_strdup_printf(\"%s/%s-sock-ro\",\n                                          config->unix_sock_dir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\",\n                                           config->unix_sock_dir, SOCK_PREFIX);\n        }\n    } else {\n        if (privileged) {\n            *sockfile = g_strdup_printf(\"%s/libvirt/%s-sock\",\n                                        RUNSTATEDIR, SOCK_PREFIX);\n            *rosockfile = g_strdup_printf(\"%s/libvirt/%s-sock-ro\",\n                                          RUNSTATEDIR, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/libvirt/%s-admin-sock\",\n                                           RUNSTATEDIR, SOCK_PREFIX);\n        } else {\n            mode_t old_umask;\n\n            rundir = virGetUserRuntimeDirectory();\n\n            old_umask = umask(077);\n            if (virFileMakePath(rundir) < 0) {\n                umask(old_umask);\n                goto cleanup;\n            }\n            umask(old_umask);\n\n            *sockfile = g_strdup_printf(\"%s/%s-sock\", rundir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\", rundir, SOCK_PREFIX);\n        }\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(rundir);\n    return ret;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonUnixSocketPaths(struct daemonConfig *config,\n                      bool privileged,\n                      char **sockfile,\n                      char **rosockfile,\n                      char **admsockfile)\n{\n    int ret = -1;\n    char *rundir = NULL;\n\n    if (config->unix_sock_dir) {\n        *sockfile = g_strdup_printf(\"%s/%s-sock\", config->unix_sock_dir,\n                                    SOCK_PREFIX);\n\n        if (privileged) {\n            *rosockfile = g_strdup_printf(\"%s/%s-sock-ro\",\n                                          config->unix_sock_dir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\",\n                                           config->unix_sock_dir, SOCK_PREFIX);\n        }\n    } else {\n        if (privileged) {\n            *sockfile = g_strdup_printf(\"%s/libvirt/%s-sock\",\n                                        RUNSTATEDIR, SOCK_PREFIX);\n            *rosockfile = g_strdup_printf(\"%s/libvirt/%s-sock-ro\",\n                                          RUNSTATEDIR, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/libvirt/%s-admin-sock\",\n                                           RUNSTATEDIR, SOCK_PREFIX);\n        } else {\n            mode_t old_umask;\n\n            rundir = virGetUserRuntimeDirectory();\n\n            old_umask = umask(077);\n            if (virFileMakePath(rundir) < 0) {\n                umask(old_umask);\n                goto cleanup;\n            }\n            umask(old_umask);\n\n            *sockfile = g_strdup_printf(\"%s/%s-sock\", rundir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\", rundir, SOCK_PREFIX);\n        }\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(rundir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Decided on pid file path '%s'\"",
            "NULLSTR(pid_file)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "pid_file"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine pid file path.\")"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileConstructPath",
          "args": [
            "privileged",
            "RUNSTATEDIR",
            "DAEMON_NAME",
            "&pid_file"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileConstructPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "469-502",
          "snippet": "int\nvirPidFileConstructPath(bool privileged,\n                        const char *runstatedir,\n                        const char *progname,\n                        char **pidfile)\n{\n    g_autofree char *rundir = NULL;\n\n    if (privileged) {\n        /*\n         * This is here just to allow calling this function with\n         * statedir == NULL; of course only when !privileged.\n         */\n        if (!runstatedir) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"No runstatedir specified\"));\n            return -1;\n        }\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", runstatedir, progname);\n    } else {\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            return -1;\n        }\n\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", rundir, progname);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirPidFileConstructPath(bool privileged,\n                        const char *runstatedir,\n                        const char *progname,\n                        char **pidfile)\n{\n    g_autofree char *rundir = NULL;\n\n    if (privileged) {\n        /*\n         * This is here just to allow calling this function with\n         * statedir == NULL; of course only when !privileged.\n         */\n        if (!runstatedir) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"No runstatedir specified\"));\n            return -1;\n        }\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", runstatedir, progname);\n    } else {\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            return -1;\n        }\n\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", rundir, progname);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't initialize access manager\")"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonSetupAccessManager",
          "args": [
            "config"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "daemonSetupAccessManager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "659-676",
          "snippet": "static int\ndaemonSetupAccessManager(struct daemonConfig *config)\n{\n    virAccessManagerPtr mgr;\n    const char *none[] = { \"none\", NULL };\n    const char **drv = (const char **)config->access_drivers;\n\n    if (!drv ||\n        !drv[0])\n        drv = none;\n\n    if (!(mgr = virAccessManagerNewStack(drv)))\n        return -1;\n\n    virAccessManagerSetDefault(mgr);\n    virObjectUnref(mgr);\n    return 0;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonSetupAccessManager(struct daemonConfig *config)\n{\n    virAccessManagerPtr mgr;\n    const char *none[] = { \"none\", NULL };\n    const char **drv = (const char **)config->access_drivers;\n\n    if (!drv ||\n        !drv[0])\n        drv = none;\n\n    if (!(mgr = virAccessManagerNewStack(drv)))\n        return -1;\n\n    virAccessManagerSetDefault(mgr);\n    virObjectUnref(mgr);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonSetupNetDevOpenvswitch",
          "args": [
            "config"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "daemonSetupNetDevOpenvswitch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "600-604",
          "snippet": "static void\ndaemonSetupNetDevOpenvswitch(struct daemonConfig *config)\n{\n    virNetDevOpenvswitchSetTimeout(config->ovs_timeout);\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\ndaemonSetupNetDevOpenvswitch(struct daemonConfig *config)\n{\n    virNetDevOpenvswitchSetTimeout(config->ovs_timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ignoring failed boot time init\""
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostBootTimeInit",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "virHostBootTimeInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostuptime.c",
          "lines": "142-149",
          "snippet": "int\nvirHostBootTimeInit(void)\n{\n    if (virOnce(&virHostGetBootTimeOnce, virHostGetBootTimeOnceInit) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostuptime.h\"",
            "# include <utmpx.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virOnceControl virHostGetBootTimeOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virhostuptime.h\"\n# include <utmpx.h>\n#include <config.h>\n\nstatic virOnceControl virHostGetBootTimeOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirHostBootTimeInit(void)\n{\n    if (virOnce(&virHostGetBootTimeOnce, virHostGetBootTimeOnceInit) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't initialize logging\")"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonSetupLogging",
          "args": [
            "config",
            "privileged",
            "verbose",
            "godaemon"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "daemonSetupLogging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "613-656",
          "snippet": "static int\ndaemonSetupLogging(struct daemonConfig *config,\n                   bool privileged,\n                   bool verbose,\n                   bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Logging setup order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(DAEMON_NAME, godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonSetupLogging(struct daemonConfig *config,\n                   bool privileged,\n                   bool verbose,\n                   bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Logging setup order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(DAEMON_NAME, godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't setup host uuid\")"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonSetupHostUUID",
          "args": [
            "config"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "daemonSetupHostUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "887-918",
          "snippet": "static int\ndaemonSetupHostUUID(const struct daemonConfig *config)\n{\n    static const char *machine_id = \"/etc/machine-id\";\n    char buf[VIR_UUID_STRING_BUFLEN];\n    const char *uuid;\n\n    if (config->host_uuid) {\n        uuid = config->host_uuid;\n    } else if (!config->host_uuid_source ||\n               STREQ(config->host_uuid_source, \"smbios\")) {\n        /* smbios UUID is fetched on demand in virGetHostUUID */\n        return 0;\n    } else if (STREQ(config->host_uuid_source, \"machine-id\")) {\n        if (virFileReadBufQuiet(machine_id, buf, sizeof(buf)) < 0) {\n            VIR_ERROR(_(\"Can't read %s\"), machine_id);\n            return -1;\n        }\n\n        uuid = buf;\n    } else {\n        VIR_ERROR(_(\"invalid UUID source: %s\"), config->host_uuid_source);\n        return -1;\n    }\n\n    if (virSetHostUUIDStr(uuid)) {\n        VIR_ERROR(_(\"invalid host UUID: %s\"), uuid);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonSetupHostUUID(const struct daemonConfig *config)\n{\n    static const char *machine_id = \"/etc/machine-id\";\n    char buf[VIR_UUID_STRING_BUFLEN];\n    const char *uuid;\n\n    if (config->host_uuid) {\n        uuid = config->host_uuid;\n    } else if (!config->host_uuid_source ||\n               STREQ(config->host_uuid_source, \"smbios\")) {\n        /* smbios UUID is fetched on demand in virGetHostUUID */\n        return 0;\n    } else if (STREQ(config->host_uuid_source, \"machine-id\")) {\n        if (virFileReadBufQuiet(machine_id, buf, sizeof(buf)) < 0) {\n            VIR_ERROR(_(\"Can't read %s\"), machine_id);\n            return -1;\n        }\n\n        uuid = buf;\n    } else {\n        VIR_ERROR(_(\"invalid UUID source: %s\"), config->host_uuid_source);\n        return -1;\n    }\n\n    if (virSetHostUUIDStr(uuid)) {\n        VIR_ERROR(_(\"invalid host UUID: %s\"), uuid);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't load config file: %s: %s\")",
            "virGetLastErrorMessage()",
            "remote_config_file"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonConfigLoadFile",
          "args": [
            "config",
            "remote_config_file",
            "implicit_conf"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "daemonConfigLoadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_config.c",
          "lines": "378-395",
          "snippet": "int\ndaemonConfigLoadFile(struct daemonConfig *data,\n                     const char *filename,\n                     bool allow_missing)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (allow_missing &&\n        access(filename, R_OK) == -1 &&\n        errno == ENOENT)\n        return 0;\n\n    conf = virConfReadFile(filename, 0);\n    if (!conf)\n        return -1;\n\n    return daemonConfigLoadOptions(data, filename, conf);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"remote_driver.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"remote_driver.h\"\n#include \"remote_protocol.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetserver.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"remote_daemon_config.h\"\n#include <config.h>\n\nint\ndaemonConfigLoadFile(struct daemonConfig *data,\n                     const char *filename,\n                     bool allow_missing)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (allow_missing &&\n        access(filename, R_OK) == -1 &&\n        errno == ENOENT)\n        return 0;\n\n    conf = virConfReadFile(filename, 0);\n    if (!conf)\n        return -1;\n\n    return daemonConfigLoadOptions(data, filename, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine config path\")"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonConfigFilePath",
          "args": [
            "privileged",
            "&remote_config_file"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "daemonConfigFilePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_config.c",
          "lines": "76-90",
          "snippet": "int\ndaemonConfigFilePath(bool privileged, char **configfile)\n{\n    if (privileged) {\n        *configfile = g_strdup(SYSCONFDIR \"/libvirt/\" DAEMON_NAME \".conf\");\n    } else {\n        g_autofree char *configdir = NULL;\n\n        configdir = virGetUserConfigDirectory();\n\n        *configfile = g_strdup_printf(\"%s/%s.conf\", configdir, DAEMON_NAME);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"remote_driver.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"remote_driver.h\"\n#include \"remote_protocol.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetserver.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"remote_daemon_config.h\"\n#include <config.h>\n\nint\ndaemonConfigFilePath(bool privileged, char **configfile)\n{\n    if (privileged) {\n        *configfile = g_strdup(SYSCONFDIR \"/libvirt/\" DAEMON_NAME \".conf\");\n    } else {\n        g_autofree char *configdir = NULL;\n\n        configdir = virGetUserConfigDirectory();\n\n        *configfile = g_strdup_printf(\"%s/%s.conf\", configdir, DAEMON_NAME);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't create initial configuration\")"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonConfigNew",
          "args": [
            "privileged"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected, non-option, command line arguments\\n\"",
            "argv[0]"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonUsage",
          "args": [
            "argv[0]",
            "privileged"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "daemonUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "926-994",
          "snippet": "static void\ndaemonUsage(const char *argv0, bool privileged)\n{\n    size_t i;\n    virOptionHelp opthelp[] = {\n        { \"-h | --help\", N_(\"Display program help\") },\n        { \"-v | --verbose\", N_(\"Verbose messages\") },\n        { \"-d | --daemon\", N_(\"Run as a daemon & write PID file\") },\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        { \"-l | --listen\", N_(\"Listen for TCP/IP connections\") },\n#endif /* !(WITH_IP && LIBVIRTD) */\n        { \"-t | --timeout <secs>\", N_(\"Exit after timeout period\") },\n        { \"-f | --config <file>\", N_(\"Configuration file\") },\n        { \"-V | --version\", N_(\"Display version information\") },\n        { \"-p | --pid-file <file>\", N_(\"Change name of PID file\") },\n    };\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"%s\\n\", _(\"Usage:\"));\n    fprintf(stderr, \"  %s [%s]\\n\", argv0, _(\"options\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"Options:\"));\n    for (i = 0; i < G_N_ELEMENTS(opthelp); i++)\n        fprintf(stderr, \"  %-22s %s\\n\", opthelp[i].opts,\n                _(opthelp[i].help));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"libvirt management daemon:\"));\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s\\n\", _(\"Default paths:\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Configuration file (unless overridden by -f):\"));\n    fprintf(stderr, \"      %s/libvirt/%s.conf\\n\",\n            privileged ? SYSCONFDIR : \"$XDG_CONFIG_HOME\", DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Sockets:\"));\n    fprintf(stderr, \"      %s/libvirt/%s-sock\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR\",\n            SOCK_PREFIX);\n    if (privileged)\n        fprintf(stderr, \"      %s/libvirt/%s-sock-ro\\n\",\n                RUNSTATEDIR, SOCK_PREFIX);\n    fprintf(stderr, \"\\n\");\n\n#ifdef WITH_IP\n    fprintf(stderr, \"    %s\\n\", _(\"TLS:\"));\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"CA certificate:\"),\n            privileged ? LIBVIRT_CACERT : \"$HOME/.pki/libvirt/cacert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server certificate:\"),\n            privileged ? LIBVIRT_SERVERCERT : \"$HOME/.pki/libvirt/servercert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server private key:\"),\n            privileged ? LIBVIRT_SERVERKEY : \"$HOME/.pki/libvirt/serverkey.pem\");\n    fprintf(stderr, \"\\n\");\n#endif /* ! WITH_IP */\n\n    fprintf(stderr, \"    %s\\n\",\n            _(\"PID file (unless overridden by -p):\"));\n    fprintf(stderr, \"      %s/%s.pid\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR/libvirt\",\n            DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\ndaemonUsage(const char *argv0, bool privileged)\n{\n    size_t i;\n    virOptionHelp opthelp[] = {\n        { \"-h | --help\", N_(\"Display program help\") },\n        { \"-v | --verbose\", N_(\"Verbose messages\") },\n        { \"-d | --daemon\", N_(\"Run as a daemon & write PID file\") },\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        { \"-l | --listen\", N_(\"Listen for TCP/IP connections\") },\n#endif /* !(WITH_IP && LIBVIRTD) */\n        { \"-t | --timeout <secs>\", N_(\"Exit after timeout period\") },\n        { \"-f | --config <file>\", N_(\"Configuration file\") },\n        { \"-V | --version\", N_(\"Display version information\") },\n        { \"-p | --pid-file <file>\", N_(\"Change name of PID file\") },\n    };\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"%s\\n\", _(\"Usage:\"));\n    fprintf(stderr, \"  %s [%s]\\n\", argv0, _(\"options\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"Options:\"));\n    for (i = 0; i < G_N_ELEMENTS(opthelp); i++)\n        fprintf(stderr, \"  %-22s %s\\n\", opthelp[i].opts,\n                _(opthelp[i].help));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"libvirt management daemon:\"));\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s\\n\", _(\"Default paths:\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Configuration file (unless overridden by -f):\"));\n    fprintf(stderr, \"      %s/libvirt/%s.conf\\n\",\n            privileged ? SYSCONFDIR : \"$XDG_CONFIG_HOME\", DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Sockets:\"));\n    fprintf(stderr, \"      %s/libvirt/%s-sock\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR\",\n            SOCK_PREFIX);\n    if (privileged)\n        fprintf(stderr, \"      %s/libvirt/%s-sock-ro\\n\",\n                RUNSTATEDIR, SOCK_PREFIX);\n    fprintf(stderr, \"\\n\");\n\n#ifdef WITH_IP\n    fprintf(stderr, \"    %s\\n\", _(\"TLS:\"));\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"CA certificate:\"),\n            privileged ? LIBVIRT_CACERT : \"$HOME/.pki/libvirt/cacert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server certificate:\"),\n            privileged ? LIBVIRT_SERVERCERT : \"$HOME/.pki/libvirt/servercert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server private key:\"),\n            privileged ? LIBVIRT_SERVERKEY : \"$HOME/.pki/libvirt/serverkey.pem\");\n    fprintf(stderr, \"\\n\");\n#endif /* ! WITH_IP */\n\n    fprintf(stderr, \"    %s\\n\",\n            _(\"PID file (unless overridden by -p):\"));\n    fprintf(stderr, \"      %s/%s.pid\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR/libvirt\",\n            DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonVersion",
          "args": [
            "argv[0]"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "daemonVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "680-684",
          "snippet": "static void\ndaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\ndaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "remote_config_file"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pid_file"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Invalid value for timeout\")"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "optarg",
            "&tmp",
            "10",
            "&timeout"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "optstr",
            "opts",
            "&optidx"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileActivateDirOverrideForProg",
          "args": [
            "argv[0]"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "virFileActivateDirOverrideForProg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1788-1800",
          "snippet": "void\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nvoid\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUpdateSelfLastChanged",
          "args": [
            "argv[0]"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "virUpdateSelfLastChanged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1574-1586",
          "snippet": "void virUpdateSelfLastChanged(const char *path)\n{\n    struct stat sb;\n\n    if (stat(path, &sb) < 0)\n        return;\n\n    if (sb.st_ctime > selfLastChanged) {\n        VIR_DEBUG(\"Setting self last changed to %lld for '%s'\",\n                  (long long)sb.st_ctime, path);\n        selfLastChanged = sb.st_ctime;\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static time_t selfLastChanged;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic time_t selfLastChanged;\n\nvoid virUpdateSelfLastChanged(const char *path)\n{\n    struct stat sb;\n\n    if (stat(path, &sb) < 0)\n        return;\n\n    if (sb.st_ctime > selfLastChanged) {\n        VIR_DEBUG(\"Setting self last changed to %lld for '%s'\",\n                  (long long)sb.st_ctime, path);\n        selfLastChanged = sb.st_ctime;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: initialization failed\\n\")",
            "argv[0]"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "LIBVIRTD"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetServerProgramPtr remoteProgram = NULL;\nvirNetServerProgramPtr qemuProgram = NULL;\nvolatile bool driversInitialized = false;\n\nint main(int argc, char **argv) {\n    virNetDaemonPtr dmn = NULL;\n    virNetServerPtr srv = NULL;\n    virNetServerPtr srvAdm = NULL;\n    virNetServerProgramPtr adminProgram = NULL;\n    virNetServerProgramPtr lxcProgram = NULL;\n    char *remote_config_file = NULL;\n    int statuswrite = -1;\n    int ret = 1;\n    int pid_file_fd = -1;\n    char *pid_file = NULL;\n    char *sock_file = NULL;\n    char *sock_file_ro = NULL;\n    char *sock_file_adm = NULL;\n    int timeout = -1;        /* -t: Shutdown timeout */\n    int verbose = 0;\n    int godaemon = 0;\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    int ipsock = 0;\n# else /* ! LIBVIRTD */\n    int ipsock = 1; /* listen_tcp/listen_tls default to 0 */\n# endif /* ! LIBVIRTD */\n#endif /* ! WITH_IP */\n    struct daemonConfig *config;\n    bool privileged = geteuid() == 0 ? true : false;\n    bool implicit_conf = false;\n    char *run_dir = NULL;\n    mode_t old_umask;\n\n    struct option opts[] = {\n        { \"verbose\", no_argument, &verbose, 'v'},\n        { \"daemon\", no_argument, &godaemon, 'd'},\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        { \"listen\", no_argument, &ipsock, 'l'},\n#endif /* !(WITH_IP && LIBVIRTD) */\n        { \"config\", required_argument, NULL, 'f'},\n        { \"timeout\", required_argument, NULL, 't'},\n        { \"pid-file\", required_argument, NULL, 'p'},\n        { \"version\", no_argument, NULL, 'V' },\n        { \"help\", no_argument, NULL, 'h' },\n        {0, 0, 0, 0}\n    };\n\n    if (virGettextInitialize() < 0 ||\n        virInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    virUpdateSelfLastChanged(argv[0]);\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    while (1) {\n        int optidx = 0;\n        int c;\n        char *tmp;\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        const char *optstr = \"ldf:p:t:vVh\";\n#else /* !(WITH_IP && LIBVIRTD) */\n        const char *optstr = \"df:p:t:vVh\";\n#endif /* !(WITH_IP && LIBVIRTD) */\n\n        c = getopt_long(argc, argv, optstr, opts, &optidx);\n\n        if (c == -1)\n            break;\n\n        switch (c) {\n        case 0:\n            /* Got one of the flags */\n            break;\n        case 'v':\n            verbose = 1;\n            break;\n        case 'd':\n            godaemon = 1;\n            break;\n\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        case 'l':\n            ipsock = 1;\n            break;\n#endif /* !(WITH_IP && LIBVIRTD) */\n\n        case 't':\n            if (virStrToLong_i(optarg, &tmp, 10, &timeout) != 0\n                || timeout <= 0\n                /* Ensure that we can multiply by 1000 without overflowing.  */\n                || timeout > INT_MAX / 1000) {\n                VIR_ERROR(_(\"Invalid value for timeout\"));\n                exit(EXIT_FAILURE);\n            }\n            break;\n\n        case 'p':\n            VIR_FREE(pid_file);\n            pid_file = g_strdup(optarg);\n            break;\n\n        case 'f':\n            VIR_FREE(remote_config_file);\n            remote_config_file = g_strdup(optarg);\n            break;\n\n        case 'V':\n            daemonVersion(argv[0]);\n            exit(EXIT_SUCCESS);\n\n        case 'h':\n            daemonUsage(argv[0], privileged);\n            exit(EXIT_SUCCESS);\n\n        case '?':\n        default:\n            daemonUsage(argv[0], privileged);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (optind != argc) {\n        fprintf(stderr, \"%s: unexpected, non-option, command line arguments\\n\",\n                argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    if (!(config = daemonConfigNew(privileged))) {\n        VIR_ERROR(_(\"Can't create initial configuration\"));\n        exit(EXIT_FAILURE);\n    }\n\n    /* No explicit config, so try and find a default one */\n    if (remote_config_file == NULL) {\n        implicit_conf = true;\n        if (daemonConfigFilePath(privileged,\n                                 &remote_config_file) < 0) {\n            VIR_ERROR(_(\"Can't determine config path\"));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* Read the config file if it exists */\n    if (remote_config_file &&\n        daemonConfigLoadFile(config, remote_config_file, implicit_conf) < 0) {\n        VIR_ERROR(_(\"Can't load config file: %s: %s\"),\n                  virGetLastErrorMessage(), remote_config_file);\n        exit(EXIT_FAILURE);\n    }\n\n    if (daemonSetupHostUUID(config) < 0) {\n        VIR_ERROR(_(\"Can't setup host uuid\"));\n        exit(EXIT_FAILURE);\n    }\n\n    if (daemonSetupLogging(config, privileged, verbose, godaemon) < 0) {\n        VIR_ERROR(_(\"Can't initialize logging\"));\n        exit(EXIT_FAILURE);\n    }\n\n    /* Let's try to initialize global variable that holds the host's boot time. */\n    if (virHostBootTimeInit() < 0) {\n        /* This is acceptable failure. Maybe we won't need the boot time\n         * anyway, and if we do, then virHostGetBootTime() returns an\n         * appropriate error. */\n        VIR_DEBUG(\"Ignoring failed boot time init\");\n    }\n\n    daemonSetupNetDevOpenvswitch(config);\n\n    if (daemonSetupAccessManager(config) < 0) {\n        VIR_ERROR(_(\"Can't initialize access manager\"));\n        exit(EXIT_FAILURE);\n    }\n\n    if (!pid_file &&\n        virPidFileConstructPath(privileged,\n                                RUNSTATEDIR,\n                                DAEMON_NAME,\n                                &pid_file) < 0) {\n        VIR_ERROR(_(\"Can't determine pid file path.\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on pid file path '%s'\", NULLSTR(pid_file));\n\n    if (daemonUnixSocketPaths(config,\n                              privileged,\n                              &sock_file,\n                              &sock_file_ro,\n                              &sock_file_adm) < 0) {\n        VIR_ERROR(_(\"Can't determine socket paths\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on socket paths '%s', '%s' and '%s'\",\n              sock_file,\n              NULLSTR(sock_file_ro),\n              NULLSTR(sock_file_adm));\n\n    if (godaemon) {\n        if (chdir(\"/\") < 0) {\n            VIR_ERROR(_(\"cannot change to root directory: %s\"),\n                      g_strerror(errno));\n            goto cleanup;\n        }\n\n        if ((statuswrite = daemonForkIntoBackground(argv[0])) < 0) {\n            VIR_ERROR(_(\"Failed to fork as daemon: %s\"),\n                      g_strerror(errno));\n            goto cleanup;\n        }\n    }\n\n    /* Try to claim the pidfile, exiting if we can't */\n    if ((pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0) {\n        ret = VIR_DAEMON_ERR_PIDFILE;\n        goto cleanup;\n    }\n\n    /* Ensure the rundir exists (on tmpfs on some systems) */\n    if (privileged) {\n        run_dir = g_strdup(RUNSTATEDIR \"/libvirt\");\n    } else {\n        run_dir = virGetUserRuntimeDirectory();\n    }\n    if (privileged)\n        old_umask = umask(022);\n    else\n        old_umask = umask(077);\n    VIR_DEBUG(\"Ensuring run dir '%s' exists\", run_dir);\n    if (virFileMakePath(run_dir) < 0) {\n        VIR_ERROR(_(\"unable to create rundir %s: %s\"), run_dir,\n                  g_strerror(errno));\n        ret = VIR_DAEMON_ERR_RUNDIR;\n        goto cleanup;\n    }\n    umask(old_umask);\n\n    if (virNetlinkStartup() < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(dmn = virNetDaemonNew())) {\n        ret = VIR_DAEMON_ERR_DRIVER;\n        goto cleanup;\n    }\n\n    if (!(srv = virNetServerNew(DAEMON_NAME, 1,\n                                config->min_workers,\n                                config->max_workers,\n                                config->prio_workers,\n                                config->max_clients,\n                                config->max_anonymous_clients,\n                                config->keepalive_interval,\n                                config->keepalive_count,\n                                remoteClientNew,\n                                NULL,\n                                remoteClientFree,\n                                NULL))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (virNetDaemonAddServer(dmn, srv) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (daemonInitialize() < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    remoteProcs[REMOTE_PROC_AUTH_LIST].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_SASL_INIT].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_SASL_STEP].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_SASL_START].needAuth = false;\n    remoteProcs[REMOTE_PROC_AUTH_POLKIT].needAuth = false;\n    if (!(remoteProgram = virNetServerProgramNew(REMOTE_PROGRAM,\n                                                 REMOTE_PROTOCOL_VERSION,\n                                                 remoteProcs,\n                                                 remoteNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srv, remoteProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(lxcProgram = virNetServerProgramNew(LXC_PROGRAM,\n                                              LXC_PROTOCOL_VERSION,\n                                              lxcProcs,\n                                              lxcNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srv, lxcProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(qemuProgram = virNetServerProgramNew(QEMU_PROGRAM,\n                                               QEMU_PROTOCOL_VERSION,\n                                               qemuProcs,\n                                               qemuNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srv, qemuProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(srvAdm = virNetServerNew(\"admin\", 1,\n                                   config->admin_min_workers,\n                                   config->admin_max_workers,\n                                   0,\n                                   config->admin_max_clients,\n                                   0,\n                                   config->admin_keepalive_interval,\n                                   config->admin_keepalive_count,\n                                   remoteAdmClientNew,\n                                   NULL,\n                                   remoteAdmClientFree,\n                                   dmn))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (virNetDaemonAddServer(dmn, srvAdm) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (!(adminProgram = virNetServerProgramNew(ADMIN_PROGRAM,\n                                                ADMIN_PROTOCOL_VERSION,\n                                                adminProcs,\n                                                adminNProcs))) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n    if (virNetServerAddProgram(srvAdm, adminProgram) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (timeout != -1) {\n        VIR_DEBUG(\"Registering shutdown timeout %d\", timeout);\n        virNetDaemonAutoShutdown(dmn, timeout);\n    }\n\n    if ((daemonSetupSignals(dmn)) < 0) {\n        ret = VIR_DAEMON_ERR_SIGNAL;\n        goto cleanup;\n    }\n\n    if (config->audit_level) {\n        VIR_DEBUG(\"Attempting to configure auditing subsystem\");\n        if (virAuditOpen(config->audit_level) < 0) {\n            if (config->audit_level > 1) {\n                ret = VIR_DAEMON_ERR_AUDIT;\n                goto cleanup;\n            }\n            VIR_DEBUG(\"Proceeding without auditing\");\n        }\n    }\n    virAuditLog(config->audit_logging > 0);\n\n    /* setup the hooks if any */\n    if (virHookInitialize() < 0) {\n        ret = VIR_DAEMON_ERR_HOOKS;\n        goto cleanup;\n    }\n\n    /* Disable error func, now logging is setup */\n    virSetErrorFunc(NULL, daemonErrorHandler);\n    virSetErrorLogPriorityFunc(daemonErrorLogFilter);\n\n    /*\n     * Call the daemon startup hook\n     * TODO: should we abort the daemon startup if the script returned\n     *       an error ?\n     */\n    virHookCall(VIR_HOOK_DRIVER_DAEMON, \"-\", VIR_HOOK_DAEMON_OP_START,\n                0, \"start\", NULL, NULL);\n\n    if (daemonSetupNetworking(srv, srvAdm,\n                              config,\n#ifdef WITH_IP\n                              ipsock,\n                              privileged,\n#endif /* !WITH_IP */\n                              sock_file,\n                              sock_file_ro,\n                              sock_file_adm) < 0) {\n        ret = VIR_DAEMON_ERR_NETWORK;\n        goto cleanup;\n    }\n\n    /* Tell parent of daemon that basic initialization is complete\n     * In particular we're ready to accept net connections & have\n     * written the pidfile\n     */\n    if (statuswrite != -1) {\n        char status = 0;\n        ignore_value(safewrite(statuswrite, &status, 1));\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n\n    /* Initialize drivers & then start accepting new clients from network */\n    if (daemonStateInit(dmn) < 0) {\n        ret = VIR_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n#if defined(__linux__) && defined(NETLINK_ROUTE)\n    /* Register the netlink event service for NETLINK_ROUTE */\n    if (virNetlinkEventServiceStart(NETLINK_ROUTE, 0) < 0) {\n        ret = VIR_DAEMON_ERR_NETWORK;\n        goto cleanup;\n    }\n#endif\n\n#if defined(__linux__) && defined(NETLINK_KOBJECT_UEVENT)\n    /* Register the netlink event service for NETLINK_KOBJECT_UEVENT */\n    if (virNetlinkEventServiceStart(NETLINK_KOBJECT_UEVENT, 1) < 0) {\n        ret = VIR_DAEMON_ERR_NETWORK;\n        goto cleanup;\n    }\n#endif\n\n    /* Run event loop. */\n    virNetDaemonRun(dmn);\n\n    ret = 0;\n\n    virHookCall(VIR_HOOK_DRIVER_DAEMON, \"-\", VIR_HOOK_DAEMON_OP_SHUTDOWN,\n                0, \"shutdown\", NULL, NULL);\n\n cleanup:\n    /* Keep cleanup order in inverse order of startup */\n    virNetDaemonClose(dmn);\n\n    virNetlinkEventServiceStopAll();\n\n    if (driversInitialized) {\n        /* NB: Possible issue with timing window between driversInitialized\n         * setting if virNetlinkEventServerStart fails */\n        driversInitialized = false;\n        virStateCleanup();\n    }\n\n    virObjectUnref(adminProgram);\n    virObjectUnref(srvAdm);\n    virObjectUnref(qemuProgram);\n    virObjectUnref(lxcProgram);\n    virObjectUnref(remoteProgram);\n    virObjectUnref(srv);\n    virObjectUnref(dmn);\n\n    virNetlinkShutdown();\n\n    if (pid_file_fd != -1)\n        virPidFileReleasePath(pid_file, pid_file_fd);\n\n    VIR_FREE(run_dir);\n\n    if (statuswrite != -1) {\n        if (ret != 0) {\n            /* Tell parent of daemon what failed */\n            char status = ret;\n            ignore_value(safewrite(statuswrite, &status, 1));\n        }\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n\n    VIR_FREE(sock_file);\n    VIR_FREE(sock_file_ro);\n    VIR_FREE(sock_file_adm);\n\n    VIR_FREE(pid_file);\n\n    VIR_FREE(remote_config_file);\n    daemonConfigFree(config);\n\n    return ret;\n}"
  },
  {
    "function_name": "daemonUsage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "926-994",
    "snippet": "static void\ndaemonUsage(const char *argv0, bool privileged)\n{\n    size_t i;\n    virOptionHelp opthelp[] = {\n        { \"-h | --help\", N_(\"Display program help\") },\n        { \"-v | --verbose\", N_(\"Verbose messages\") },\n        { \"-d | --daemon\", N_(\"Run as a daemon & write PID file\") },\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        { \"-l | --listen\", N_(\"Listen for TCP/IP connections\") },\n#endif /* !(WITH_IP && LIBVIRTD) */\n        { \"-t | --timeout <secs>\", N_(\"Exit after timeout period\") },\n        { \"-f | --config <file>\", N_(\"Configuration file\") },\n        { \"-V | --version\", N_(\"Display version information\") },\n        { \"-p | --pid-file <file>\", N_(\"Change name of PID file\") },\n    };\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"%s\\n\", _(\"Usage:\"));\n    fprintf(stderr, \"  %s [%s]\\n\", argv0, _(\"options\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"Options:\"));\n    for (i = 0; i < G_N_ELEMENTS(opthelp); i++)\n        fprintf(stderr, \"  %-22s %s\\n\", opthelp[i].opts,\n                _(opthelp[i].help));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"libvirt management daemon:\"));\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s\\n\", _(\"Default paths:\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Configuration file (unless overridden by -f):\"));\n    fprintf(stderr, \"      %s/libvirt/%s.conf\\n\",\n            privileged ? SYSCONFDIR : \"$XDG_CONFIG_HOME\", DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Sockets:\"));\n    fprintf(stderr, \"      %s/libvirt/%s-sock\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR\",\n            SOCK_PREFIX);\n    if (privileged)\n        fprintf(stderr, \"      %s/libvirt/%s-sock-ro\\n\",\n                RUNSTATEDIR, SOCK_PREFIX);\n    fprintf(stderr, \"\\n\");\n\n#ifdef WITH_IP\n    fprintf(stderr, \"    %s\\n\", _(\"TLS:\"));\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"CA certificate:\"),\n            privileged ? LIBVIRT_CACERT : \"$HOME/.pki/libvirt/cacert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server certificate:\"),\n            privileged ? LIBVIRT_SERVERCERT : \"$HOME/.pki/libvirt/servercert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server private key:\"),\n            privileged ? LIBVIRT_SERVERKEY : \"$HOME/.pki/libvirt/serverkey.pem\");\n    fprintf(stderr, \"\\n\");\n#endif /* ! WITH_IP */\n\n    fprintf(stderr, \"    %s\\n\",\n            _(\"PID file (unless overridden by -p):\"));\n    fprintf(stderr, \"      %s/%s.pid\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR/libvirt\",\n            DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s/%s.pid\\n\"",
            "privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR/libvirt\"",
            "DAEMON_NAME"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    %s\\n\"",
            "_(\"PID file (unless overridden by -p):\")"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"PID file (unless overridden by -p):\""
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s %s\\n\"",
            "_(\"Server private key:\")",
            "privileged ? LIBVIRT_SERVERKEY : \"$HOME/.pki/libvirt/serverkey.pem\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s %s\\n\"",
            "_(\"Server certificate:\")",
            "privileged ? LIBVIRT_SERVERCERT : \"$HOME/.pki/libvirt/servercert.pem\""
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s %s\\n\"",
            "_(\"CA certificate:\")",
            "privileged ? LIBVIRT_CACERT : \"$HOME/.pki/libvirt/cacert.pem\""
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    %s\\n\"",
            "_(\"TLS:\")"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s/libvirt/%s-sock-ro\\n\"",
            "RUNSTATEDIR",
            "SOCK_PREFIX"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s/libvirt/%s-sock\\n\"",
            "privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR\"",
            "SOCK_PREFIX"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    %s\\n\"",
            "_(\"Sockets:\")"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"      %s/libvirt/%s.conf\\n\"",
            "privileged ? SYSCONFDIR : \"$XDG_CONFIG_HOME\"",
            "DAEMON_NAME"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    %s\\n\"",
            "_(\"Configuration file (unless overridden by -f):\")"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %s\\n\"",
            "_(\"Default paths:\")"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "_(\"libvirt management daemon:\")"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %-22s %s\\n\"",
            "opthelp[i].opts",
            "_(opthelp[i].help)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "opthelp"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "_(\"Options:\")"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %s [%s]\\n\"",
            "argv0",
            "_(\"options\")"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "_(\"Usage:\")"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_",
          "args": [
            "\"Change name of PID file\""
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ESX_VI__TEMPLATE__ENUMERATION__DESERIALIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "886-906",
          "snippet": "ESX_VI__TEMPLATE__ENUMERATION__SERIALIZE(Boolean)\n\n/* esxVI_Boolean_Deserialize */\nESX_VI__TEMPLATE__ENUMERATION__DESERIALIZE(Boolean)\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * XSD: AnyType\n */\n\n/* esxVI_AnyType_Alloc */\nESX_VI__TEMPLATE__ALLOC(AnyType)\n\n/* esxVI_AnyType_Free */\nESX_VI__TEMPLATE__FREE(AnyType,\n{\n    xmlFreeNode(item->node);\n    VIR_FREE(item->other);\n    VIR_FREE(item->value);\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ENUMERATION__SERIALIZE(Boolean)\n\n/* esxVI_Boolean_Deserialize */\nESX_VI__TEMPLATE__ENUMERATION__DESERIALIZE(Boolean)\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * XSD: AnyType\n */\n\n/* esxVI_AnyType_Alloc */\nESX_VI__TEMPLATE__ALLOC(AnyType)\n\n/* esxVI_AnyType_Free */\nESX_VI__TEMPLATE__FREE(AnyType,\n{\n    xmlFreeNode(item->node);\n    VIR_FREE(item->other);\n    VIR_FREE(item->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "LIBVIRTD"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\ndaemonUsage(const char *argv0, bool privileged)\n{\n    size_t i;\n    virOptionHelp opthelp[] = {\n        { \"-h | --help\", N_(\"Display program help\") },\n        { \"-v | --verbose\", N_(\"Verbose messages\") },\n        { \"-d | --daemon\", N_(\"Run as a daemon & write PID file\") },\n#if defined(WITH_IP) && defined(LIBVIRTD)\n        { \"-l | --listen\", N_(\"Listen for TCP/IP connections\") },\n#endif /* !(WITH_IP && LIBVIRTD) */\n        { \"-t | --timeout <secs>\", N_(\"Exit after timeout period\") },\n        { \"-f | --config <file>\", N_(\"Configuration file\") },\n        { \"-V | --version\", N_(\"Display version information\") },\n        { \"-p | --pid-file <file>\", N_(\"Change name of PID file\") },\n    };\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"%s\\n\", _(\"Usage:\"));\n    fprintf(stderr, \"  %s [%s]\\n\", argv0, _(\"options\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"Options:\"));\n    for (i = 0; i < G_N_ELEMENTS(opthelp); i++)\n        fprintf(stderr, \"  %-22s %s\\n\", opthelp[i].opts,\n                _(opthelp[i].help));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%s\\n\", _(\"libvirt management daemon:\"));\n\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"  %s\\n\", _(\"Default paths:\"));\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Configuration file (unless overridden by -f):\"));\n    fprintf(stderr, \"      %s/libvirt/%s.conf\\n\",\n            privileged ? SYSCONFDIR : \"$XDG_CONFIG_HOME\", DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"    %s\\n\", _(\"Sockets:\"));\n    fprintf(stderr, \"      %s/libvirt/%s-sock\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR\",\n            SOCK_PREFIX);\n    if (privileged)\n        fprintf(stderr, \"      %s/libvirt/%s-sock-ro\\n\",\n                RUNSTATEDIR, SOCK_PREFIX);\n    fprintf(stderr, \"\\n\");\n\n#ifdef WITH_IP\n    fprintf(stderr, \"    %s\\n\", _(\"TLS:\"));\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"CA certificate:\"),\n            privileged ? LIBVIRT_CACERT : \"$HOME/.pki/libvirt/cacert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server certificate:\"),\n            privileged ? LIBVIRT_SERVERCERT : \"$HOME/.pki/libvirt/servercert.pem\");\n    fprintf(stderr, \"      %s %s\\n\",\n            _(\"Server private key:\"),\n            privileged ? LIBVIRT_SERVERKEY : \"$HOME/.pki/libvirt/serverkey.pem\");\n    fprintf(stderr, \"\\n\");\n#endif /* ! WITH_IP */\n\n    fprintf(stderr, \"    %s\\n\",\n            _(\"PID file (unless overridden by -p):\"));\n    fprintf(stderr, \"      %s/%s.pid\\n\",\n            privileged ? RUNSTATEDIR : \"$XDG_RUNTIME_DIR/libvirt\",\n            DAEMON_NAME);\n    fprintf(stderr, \"\\n\");\n}"
  },
  {
    "function_name": "daemonSetupHostUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "887-918",
    "snippet": "static int\ndaemonSetupHostUUID(const struct daemonConfig *config)\n{\n    static const char *machine_id = \"/etc/machine-id\";\n    char buf[VIR_UUID_STRING_BUFLEN];\n    const char *uuid;\n\n    if (config->host_uuid) {\n        uuid = config->host_uuid;\n    } else if (!config->host_uuid_source ||\n               STREQ(config->host_uuid_source, \"smbios\")) {\n        /* smbios UUID is fetched on demand in virGetHostUUID */\n        return 0;\n    } else if (STREQ(config->host_uuid_source, \"machine-id\")) {\n        if (virFileReadBufQuiet(machine_id, buf, sizeof(buf)) < 0) {\n            VIR_ERROR(_(\"Can't read %s\"), machine_id);\n            return -1;\n        }\n\n        uuid = buf;\n    } else {\n        VIR_ERROR(_(\"invalid UUID source: %s\"), config->host_uuid_source);\n        return -1;\n    }\n\n    if (virSetHostUUIDStr(uuid)) {\n        VIR_ERROR(_(\"invalid host UUID: %s\"), uuid);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"invalid host UUID: %s\")",
            "uuid"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid host UUID: %s\""
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virSetHostUUIDStr",
          "args": [
            "uuid"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "virSetHostUUIDStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "220-247",
          "snippet": "int\nvirSetHostUUIDStr(const char *uuid)\n{\n    int rc;\n    char dmiuuid[VIR_UUID_STRING_BUFLEN];\n\n    if (virUUIDIsValid(host_uuid))\n        return EEXIST;\n\n    if (!uuid) {\n        memset(dmiuuid, 0, sizeof(dmiuuid));\n        if (!getDMISystemUUID(dmiuuid, sizeof(dmiuuid))) {\n            if (!virUUIDParse(dmiuuid, host_uuid))\n                return 0;\n        }\n\n        if (!virUUIDIsValid(host_uuid))\n            return virUUIDGenerate(host_uuid);\n    } else {\n        rc = virUUIDParse(uuid, host_uuid);\n        if (rc)\n            return rc;\n        if (!virUUIDIsValid(host_uuid))\n            return EINVAL;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char host_uuid[VIR_UUID_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic unsigned char host_uuid[VIR_UUID_BUFLEN];\n\nint\nvirSetHostUUIDStr(const char *uuid)\n{\n    int rc;\n    char dmiuuid[VIR_UUID_STRING_BUFLEN];\n\n    if (virUUIDIsValid(host_uuid))\n        return EEXIST;\n\n    if (!uuid) {\n        memset(dmiuuid, 0, sizeof(dmiuuid));\n        if (!getDMISystemUUID(dmiuuid, sizeof(dmiuuid))) {\n            if (!virUUIDParse(dmiuuid, host_uuid))\n                return 0;\n        }\n\n        if (!virUUIDIsValid(host_uuid))\n            return virUUIDGenerate(host_uuid);\n    } else {\n        rc = virUUIDParse(uuid, host_uuid);\n        if (rc)\n            return rc;\n        if (!virUUIDIsValid(host_uuid))\n            return EINVAL;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"invalid UUID source: %s\")",
            "config->host_uuid_source"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't read %s\")",
            "machine_id"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadBufQuiet",
          "args": [
            "machine_id",
            "buf",
            "sizeof(buf)"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadBufQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1479-1496",
          "snippet": "int\nvirFileReadBufQuiet(const char *file, char *buf, int len)\n{\n    int fd;\n    ssize_t sz;\n\n    fd = open(file, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    sz = saferead(fd, buf, len - 1);\n    VIR_FORCE_CLOSE(fd);\n    if (sz < 0)\n        return -errno;\n\n    buf[sz] = '\\0';\n    return sz;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadBufQuiet(const char *file, char *buf, int len)\n{\n    int fd;\n    ssize_t sz;\n\n    fd = open(file, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    sz = saferead(fd, buf, len - 1);\n    VIR_FORCE_CLOSE(fd);\n    if (sz < 0)\n        return -errno;\n\n    buf[sz] = '\\0';\n    return sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "config->host_uuid_source",
            "\"machine-id\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "config->host_uuid_source",
            "\"smbios\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonSetupHostUUID(const struct daemonConfig *config)\n{\n    static const char *machine_id = \"/etc/machine-id\";\n    char buf[VIR_UUID_STRING_BUFLEN];\n    const char *uuid;\n\n    if (config->host_uuid) {\n        uuid = config->host_uuid;\n    } else if (!config->host_uuid_source ||\n               STREQ(config->host_uuid_source, \"smbios\")) {\n        /* smbios UUID is fetched on demand in virGetHostUUID */\n        return 0;\n    } else if (STREQ(config->host_uuid_source, \"machine-id\")) {\n        if (virFileReadBufQuiet(machine_id, buf, sizeof(buf)) < 0) {\n            VIR_ERROR(_(\"Can't read %s\"), machine_id);\n            return -1;\n        }\n\n        uuid = buf;\n    } else {\n        VIR_ERROR(_(\"invalid UUID source: %s\"), config->host_uuid_source);\n        return -1;\n    }\n\n    if (virSetHostUUIDStr(uuid)) {\n        VIR_ERROR(_(\"invalid host UUID: %s\"), uuid);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "daemonStateInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "875-885",
    "snippet": "static int daemonStateInit(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonRunStateInit,\n                            \"daemon-init\", false, dmn) < 0) {\n        virObjectUnref(dmn);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dmn"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&thr",
            "false",
            "daemonRunStateInit",
            "\"daemon-init\"",
            "false",
            "dmn"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "dmn"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonStateInit(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonRunStateInit,\n                            \"daemon-init\", false, dmn) < 0) {\n        virObjectUnref(dmn);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "daemonRunStateInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "815-873",
    "snippet": "static void daemonRunStateInit(void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n    g_autoptr(virIdentity) sysident = virIdentityGetSystem();\n#ifdef MODULE_NAME\n    bool mandatory = true;\n#else /* ! MODULE_NAME */\n    bool mandatory = false;\n#endif /* ! MODULE_NAME */\n\n    virIdentitySetCurrent(sysident);\n\n    /* Since driver initialization can take time inhibit daemon shutdown until\n       we're done so clients get a chance to connect */\n    daemonInhibitCallback(true, dmn);\n\n    /* Start the stateful HV drivers\n     * This is deliberately done after telling the parent process\n     * we're ready, since it can take a long time and this will\n     * seriously delay OS bootup process */\n    if (virStateInitialize(virNetDaemonIsPrivileged(dmn),\n                           mandatory,\n                           NULL,\n                           daemonInhibitCallback,\n                           dmn) < 0) {\n        VIR_ERROR(_(\"Driver state initialization failed\"));\n        /* Ensure the main event loop quits */\n        kill(getpid(), SIGTERM);\n        goto cleanup;\n    }\n\n    driversInitialized = true;\n\n#ifdef WITH_DBUS\n    /* Tie the non-privileged daemons to the session/shutdown lifecycle */\n    if (!virNetDaemonIsPrivileged(dmn)) {\n\n        sessionBus = virDBusGetSessionBus();\n        if (sessionBus != NULL)\n            dbus_connection_add_filter(sessionBus,\n                                       handleSessionMessageFunc, dmn, NULL);\n\n        systemBus = virDBusGetSystemBus();\n        if (systemBus != NULL) {\n            dbus_connection_add_filter(systemBus,\n                                       handleSystemMessageFunc, dmn, NULL);\n            dbus_bus_add_match(systemBus,\n                               \"type='signal',sender='org.freedesktop.login1', interface='org.freedesktop.login1.Manager'\",\n                               NULL);\n        }\n    }\n#endif\n    /* Only now accept clients from network */\n    virNetDaemonUpdateServices(dmn, true);\n cleanup:\n    daemonInhibitCallback(false, dmn);\n    virObjectUnref(dmn);\n    virIdentitySetCurrent(NULL);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "volatile bool driversInitialized = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virIdentitySetCurrent",
          "args": [
            "NULL"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "virIdentitySetCurrent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viridentity.c",
          "lines": "123-142",
          "snippet": "int virIdentitySetCurrent(virIdentityPtr ident)\n{\n    g_autoptr(virIdentity) old = NULL;\n\n    if (virIdentityInitialize() < 0)\n        return -1;\n\n    old = virThreadLocalGet(&virIdentityCurrent);\n\n    if (virThreadLocalSet(&virIdentityCurrent,\n                          ident ? g_object_ref(ident) : NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to set thread local identity\"));\n        if (ident)\n            g_object_unref(ident);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "# include <selinux/selinux.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virThreadLocal virIdentityCurrent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n# include <selinux/selinux.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virThreadLocal virIdentityCurrent;\n\nint virIdentitySetCurrent(virIdentityPtr ident)\n{\n    g_autoptr(virIdentity) old = NULL;\n\n    if (virIdentityInitialize() < 0)\n        return -1;\n\n    old = virThreadLocalGet(&virIdentityCurrent);\n\n    if (virThreadLocalSet(&virIdentityCurrent,\n                          ident ? g_object_ref(ident) : NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to set thread local identity\"));\n        if (ident)\n            g_object_unref(ident);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dmn"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonInhibitCallback",
          "args": [
            "false",
            "dmn"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "daemonInhibitCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "737-745",
          "snippet": "static void daemonInhibitCallback(bool inhibit, void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    if (inhibit)\n        virNetDaemonAddShutdownInhibition(dmn);\n    else\n        virNetDaemonRemoveShutdownInhibition(dmn);\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonInhibitCallback(bool inhibit, void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    if (inhibit)\n        virNetDaemonAddShutdownInhibition(dmn);\n    else\n        virNetDaemonRemoveShutdownInhibition(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonUpdateServices",
          "args": [
            "dmn",
            "true"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonUpdateServices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "779-786",
          "snippet": "void\nvirNetDaemonUpdateServices(virNetDaemonPtr dmn,\n                           bool enabled)\n{\n    virObjectLock(dmn);\n    virHashForEach(dmn->servers, daemonServerUpdateServices, &enabled);\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonUpdateServices(virNetDaemonPtr dmn,\n                           bool enabled)\n{\n    virObjectLock(dmn);\n    virHashForEach(dmn->servers, daemonServerUpdateServices, &enabled);\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_bus_add_match",
          "args": [
            "systemBus",
            "\"type='signal',sender='org.freedesktop.login1', interface='org.freedesktop.login1.Manager'\"",
            "NULL"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_add_filter",
          "args": [
            "systemBus",
            "handleSystemMessageFunc",
            "dmn",
            "NULL"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusGetSystemBus",
          "args": [],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSystemBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1744-1749",
          "snippet": "DBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_connection_add_filter",
          "args": [
            "sessionBus",
            "handleSessionMessageFunc",
            "dmn",
            "NULL"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusGetSessionBus",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSessionBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1764-1769",
          "snippet": "DBusConnection *virDBusGetSessionBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSessionBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonIsPrivileged",
          "args": [
            "dmn"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonIsPrivileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "429-437",
          "snippet": "bool\nvirNetDaemonIsPrivileged(virNetDaemonPtr dmn)\n{\n    bool priv;\n    virObjectLock(dmn);\n    priv = dmn->privileged;\n    virObjectUnlock(dmn);\n    return priv;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirNetDaemonIsPrivileged(virNetDaemonPtr dmn)\n{\n    bool priv;\n    virObjectLock(dmn);\n    priv = dmn->privileged;\n    virObjectUnlock(dmn);\n    return priv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGTERM"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Driver state initialization failed\")"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Driver state initialization failed\""
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virStateInitialize",
          "args": [
            "virNetDaemonIsPrivileged(dmn)",
            "mandatory",
            "NULL",
            "daemonInhibitCallback",
            "dmn"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "virStateInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "635-672",
          "snippet": "int\nvirStateInitialize(bool privileged,\n                   bool mandatory,\n                   const char *root,\n                   virStateInhibitCallback callback,\n                   void *opaque)\n{\n    size_t i;\n\n    if (virInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateInitialize &&\n            !virStateDriverTab[i]->initialized) {\n            virDrvStateInitResult ret;\n            VIR_DEBUG(\"Running global init for %s state driver\",\n                      virStateDriverTab[i]->name);\n            virStateDriverTab[i]->initialized = true;\n            ret = virStateDriverTab[i]->stateInitialize(privileged,\n                                                        root,\n                                                        callback,\n                                                        opaque);\n            VIR_DEBUG(\"State init result %d (mandatory=%d)\", ret, mandatory);\n            if (ret == VIR_DRV_STATE_INIT_ERROR) {\n                VIR_ERROR(_(\"Initialization of %s state driver failed: %s\"),\n                          virStateDriverTab[i]->name,\n                          virGetLastErrorMessage());\n                return -1;\n            } else if (ret == VIR_DRV_STATE_INIT_SKIPPED && mandatory) {\n                VIR_ERROR(_(\"Initialization of mandatory %s state driver skipped\"),\n                          virStateDriverTab[i]->name);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateInitialize(bool privileged,\n                   bool mandatory,\n                   const char *root,\n                   virStateInhibitCallback callback,\n                   void *opaque)\n{\n    size_t i;\n\n    if (virInitialize() < 0)\n        return -1;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateInitialize &&\n            !virStateDriverTab[i]->initialized) {\n            virDrvStateInitResult ret;\n            VIR_DEBUG(\"Running global init for %s state driver\",\n                      virStateDriverTab[i]->name);\n            virStateDriverTab[i]->initialized = true;\n            ret = virStateDriverTab[i]->stateInitialize(privileged,\n                                                        root,\n                                                        callback,\n                                                        opaque);\n            VIR_DEBUG(\"State init result %d (mandatory=%d)\", ret, mandatory);\n            if (ret == VIR_DRV_STATE_INIT_ERROR) {\n                VIR_ERROR(_(\"Initialization of %s state driver failed: %s\"),\n                          virStateDriverTab[i]->name,\n                          virGetLastErrorMessage());\n                return -1;\n            } else if (ret == VIR_DRV_STATE_INIT_SKIPPED && mandatory) {\n                VIR_ERROR(_(\"Initialization of mandatory %s state driver skipped\"),\n                          virStateDriverTab[i]->name);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virIdentityGetSystem",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "virIdentityGetSystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viridentity.c",
          "lines": "153-205",
          "snippet": "virIdentityPtr virIdentityGetSystem(void)\n{\n    g_autofree char *username = NULL;\n    g_autofree char *groupname = NULL;\n    unsigned long long startTime;\n    g_autoptr(virIdentity) ret = NULL;\n#if WITH_SELINUX\n    security_context_t con;\n#endif\n\n    if (!(ret = virIdentityNew()))\n        return NULL;\n\n    if (virIdentitySetProcessID(ret, getpid()) < 0)\n        return NULL;\n\n    if (virProcessGetStartTime(getpid(), &startTime) < 0)\n        return NULL;\n    if (startTime != 0 &&\n        virIdentitySetProcessTime(ret, startTime) < 0)\n        return NULL;\n\n    if (!(username = virGetUserName(geteuid())))\n        return ret;\n    if (virIdentitySetUserName(ret, username) < 0)\n        return NULL;\n    if (virIdentitySetUNIXUserID(ret, getuid()) < 0)\n        return NULL;\n\n    if (!(groupname = virGetGroupName(getegid())))\n        return ret;\n    if (virIdentitySetGroupName(ret, groupname) < 0)\n        return NULL;\n    if (virIdentitySetUNIXGroupID(ret, getgid()) < 0)\n        return NULL;\n\n#if WITH_SELINUX\n    if (is_selinux_enabled() > 0) {\n        if (getcon(&con) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to lookup SELinux process context\"));\n            return NULL;\n        }\n        if (virIdentitySetSELinuxContext(ret, con) < 0) {\n            freecon(con);\n            return NULL;\n        }\n        freecon(con);\n    }\n#endif\n\n    return g_steal_pointer(&ret);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "# include <selinux/selinux.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n# include <selinux/selinux.h>\n#include <unistd.h>\n#include <config.h>\n\nvirIdentityPtr virIdentityGetSystem(void)\n{\n    g_autofree char *username = NULL;\n    g_autofree char *groupname = NULL;\n    unsigned long long startTime;\n    g_autoptr(virIdentity) ret = NULL;\n#if WITH_SELINUX\n    security_context_t con;\n#endif\n\n    if (!(ret = virIdentityNew()))\n        return NULL;\n\n    if (virIdentitySetProcessID(ret, getpid()) < 0)\n        return NULL;\n\n    if (virProcessGetStartTime(getpid(), &startTime) < 0)\n        return NULL;\n    if (startTime != 0 &&\n        virIdentitySetProcessTime(ret, startTime) < 0)\n        return NULL;\n\n    if (!(username = virGetUserName(geteuid())))\n        return ret;\n    if (virIdentitySetUserName(ret, username) < 0)\n        return NULL;\n    if (virIdentitySetUNIXUserID(ret, getuid()) < 0)\n        return NULL;\n\n    if (!(groupname = virGetGroupName(getegid())))\n        return ret;\n    if (virIdentitySetGroupName(ret, groupname) < 0)\n        return NULL;\n    if (virIdentitySetUNIXGroupID(ret, getgid()) < 0)\n        return NULL;\n\n#if WITH_SELINUX\n    if (is_selinux_enabled() > 0) {\n        if (getcon(&con) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to lookup SELinux process context\"));\n            return NULL;\n        }\n        if (virIdentitySetSELinuxContext(ret, con) < 0) {\n            freecon(con);\n            return NULL;\n        }\n        freecon(con);\n    }\n#endif\n\n    return g_steal_pointer(&ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvolatile bool driversInitialized = false;\n\nstatic void daemonRunStateInit(void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n    g_autoptr(virIdentity) sysident = virIdentityGetSystem();\n#ifdef MODULE_NAME\n    bool mandatory = true;\n#else /* ! MODULE_NAME */\n    bool mandatory = false;\n#endif /* ! MODULE_NAME */\n\n    virIdentitySetCurrent(sysident);\n\n    /* Since driver initialization can take time inhibit daemon shutdown until\n       we're done so clients get a chance to connect */\n    daemonInhibitCallback(true, dmn);\n\n    /* Start the stateful HV drivers\n     * This is deliberately done after telling the parent process\n     * we're ready, since it can take a long time and this will\n     * seriously delay OS bootup process */\n    if (virStateInitialize(virNetDaemonIsPrivileged(dmn),\n                           mandatory,\n                           NULL,\n                           daemonInhibitCallback,\n                           dmn) < 0) {\n        VIR_ERROR(_(\"Driver state initialization failed\"));\n        /* Ensure the main event loop quits */\n        kill(getpid(), SIGTERM);\n        goto cleanup;\n    }\n\n    driversInitialized = true;\n\n#ifdef WITH_DBUS\n    /* Tie the non-privileged daemons to the session/shutdown lifecycle */\n    if (!virNetDaemonIsPrivileged(dmn)) {\n\n        sessionBus = virDBusGetSessionBus();\n        if (sessionBus != NULL)\n            dbus_connection_add_filter(sessionBus,\n                                       handleSessionMessageFunc, dmn, NULL);\n\n        systemBus = virDBusGetSystemBus();\n        if (systemBus != NULL) {\n            dbus_connection_add_filter(systemBus,\n                                       handleSystemMessageFunc, dmn, NULL);\n            dbus_bus_add_match(systemBus,\n                               \"type='signal',sender='org.freedesktop.login1', interface='org.freedesktop.login1.Manager'\",\n                               NULL);\n        }\n    }\n#endif\n    /* Only now accept clients from network */\n    virNetDaemonUpdateServices(dmn, true);\n cleanup:\n    daemonInhibitCallback(false, dmn);\n    virObjectUnref(dmn);\n    virIdentitySetCurrent(NULL);\n}"
  },
  {
    "function_name": "handleSystemMessageFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "796-811",
    "snippet": "static DBusHandlerResult\nhandleSystemMessageFunc(DBusConnection *connection G_GNUC_UNUSED,\n                        DBusMessage *message,\n                        void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    VIR_DEBUG(\"dmn=%p\", dmn);\n\n    if (dbus_message_is_signal(message,\n                               \"org.freedesktop.login1.Manager\",\n                               \"PrepareForShutdown\"))\n        daemonStop(dmn);\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "daemonStop",
          "args": [
            "dmn"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "768-775",
          "snippet": "static void daemonStop(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonStopWorker,\n                            \"daemon-stop\", false, dmn) < 0)\n        virObjectUnref(dmn);\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonStop(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonStopWorker,\n                            \"daemon-stop\", false, dmn) < 0)\n        virObjectUnref(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_is_signal",
          "args": [
            "message",
            "\"org.freedesktop.login1.Manager\"",
            "\"PrepareForShutdown\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dmn=%p\"",
            "dmn"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic DBusHandlerResult\nhandleSystemMessageFunc(DBusConnection *connection G_GNUC_UNUSED,\n                        DBusMessage *message,\n                        void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    VIR_DEBUG(\"dmn=%p\", dmn);\n\n    if (dbus_message_is_signal(message,\n                               \"org.freedesktop.login1.Manager\",\n                               \"PrepareForShutdown\"))\n        daemonStop(dmn);\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}"
  },
  {
    "function_name": "handleSessionMessageFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "778-793",
    "snippet": "static DBusHandlerResult\nhandleSessionMessageFunc(DBusConnection *connection G_GNUC_UNUSED,\n                         DBusMessage *message,\n                         void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    VIR_DEBUG(\"dmn=%p\", dmn);\n\n    if (dbus_message_is_signal(message,\n                               DBUS_INTERFACE_LOCAL,\n                               \"Disconnected\"))\n        daemonStop(dmn);\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "daemonStop",
          "args": [
            "dmn"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "768-775",
          "snippet": "static void daemonStop(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonStopWorker,\n                            \"daemon-stop\", false, dmn) < 0)\n        virObjectUnref(dmn);\n}",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonStop(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonStopWorker,\n                            \"daemon-stop\", false, dmn) < 0)\n        virObjectUnref(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_is_signal",
          "args": [
            "message",
            "DBUS_INTERFACE_LOCAL",
            "\"Disconnected\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dmn=%p\"",
            "dmn"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic DBusHandlerResult\nhandleSessionMessageFunc(DBusConnection *connection G_GNUC_UNUSED,\n                         DBusMessage *message,\n                         void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    VIR_DEBUG(\"dmn=%p\", dmn);\n\n    if (dbus_message_is_signal(message,\n                               DBUS_INTERFACE_LOCAL,\n                               \"Disconnected\"))\n        daemonStop(dmn);\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}"
  },
  {
    "function_name": "daemonStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "768-775",
    "snippet": "static void daemonStop(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonStopWorker,\n                            \"daemon-stop\", false, dmn) < 0)\n        virObjectUnref(dmn);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dmn"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&thr",
            "false",
            "daemonStopWorker",
            "\"daemon-stop\"",
            "false",
            "dmn"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "dmn"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonStop(virNetDaemonPtr dmn)\n{\n    virThread thr;\n    virObjectRef(dmn);\n    if (virThreadCreateFull(&thr, false, daemonStopWorker,\n                            \"daemon-stop\", false, dmn) < 0)\n        virObjectUnref(dmn);\n}"
  },
  {
    "function_name": "daemonStopWorker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "752-764",
    "snippet": "static void daemonStopWorker(void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    VIR_DEBUG(\"Begin stop dmn=%p\", dmn);\n\n    ignore_value(virStateStop());\n\n    VIR_DEBUG(\"Completed stop dmn=%p\", dmn);\n\n    /* Exit daemon cleanly */\n    virNetDaemonQuit(dmn);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonQuit",
          "args": [
            "dmn"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonQuit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "867-876",
          "snippet": "void\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Completed stop dmn=%p\"",
            "dmn"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStateStop()"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStateStop",
          "args": [],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "virStateStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "726-738",
          "snippet": "int\nvirStateStop(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateStop &&\n            virStateDriverTab[i]->stateStop())\n            ret = 1;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateStop(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateStop &&\n            virStateDriverTab[i]->stateStop())\n            ret = 1;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Begin stop dmn=%p\"",
            "dmn"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonStopWorker(void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    VIR_DEBUG(\"Begin stop dmn=%p\", dmn);\n\n    ignore_value(virStateStop());\n\n    VIR_DEBUG(\"Completed stop dmn=%p\", dmn);\n\n    /* Exit daemon cleanly */\n    virNetDaemonQuit(dmn);\n}"
  },
  {
    "function_name": "daemonInhibitCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "737-745",
    "snippet": "static void daemonInhibitCallback(bool inhibit, void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    if (inhibit)\n        virNetDaemonAddShutdownInhibition(dmn);\n    else\n        virNetDaemonRemoveShutdownInhibition(dmn);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonRemoveShutdownInhibition",
          "args": [
            "dmn"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonRemoveShutdownInhibition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "576-590",
          "snippet": "void\nvirNetDaemonRemoveShutdownInhibition(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n    dmn->autoShutdownInhibitions--;\n\n    VIR_DEBUG(\"dmn=%p inhibitions=%zu\", dmn, dmn->autoShutdownInhibitions);\n\n    if (dmn->autoShutdownInhibitions == 0) {\n        VIR_DEBUG(\"Closing inhibit FD %d\", dmn->autoShutdownInhibitFd);\n        VIR_FORCE_CLOSE(dmn->autoShutdownInhibitFd);\n    }\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonRemoveShutdownInhibition(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n    dmn->autoShutdownInhibitions--;\n\n    VIR_DEBUG(\"dmn=%p inhibitions=%zu\", dmn, dmn->autoShutdownInhibitions);\n\n    if (dmn->autoShutdownInhibitions == 0) {\n        VIR_DEBUG(\"Closing inhibit FD %d\", dmn->autoShutdownInhibitFd);\n        VIR_FORCE_CLOSE(dmn->autoShutdownInhibitFd);\n    }\n\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonAddShutdownInhibition",
          "args": [
            "dmn"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAddShutdownInhibition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "555-573",
          "snippet": "void\nvirNetDaemonAddShutdownInhibition(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n    dmn->autoShutdownInhibitions++;\n\n    VIR_DEBUG(\"dmn=%p inhibitions=%zu\", dmn, dmn->autoShutdownInhibitions);\n\n#if defined(WITH_DBUS) && defined(DBUS_TYPE_UNIX_FD)\n    if (dmn->autoShutdownInhibitions == 1)\n        virNetDaemonCallInhibit(dmn,\n                                \"shutdown\",\n                                _(\"Libvirt\"),\n                                _(\"Virtual machines need to be saved\"),\n                                \"delay\");\n#endif\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonAddShutdownInhibition(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n    dmn->autoShutdownInhibitions++;\n\n    VIR_DEBUG(\"dmn=%p inhibitions=%zu\", dmn, dmn->autoShutdownInhibitions);\n\n#if defined(WITH_DBUS) && defined(DBUS_TYPE_UNIX_FD)\n    if (dmn->autoShutdownInhibitions == 1)\n        virNetDaemonCallInhibit(dmn,\n                                \"shutdown\",\n                                _(\"Libvirt\"),\n                                _(\"Virtual machines need to be saved\"),\n                                \"delay\");\n#endif\n\n    virObjectUnlock(dmn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonInhibitCallback(bool inhibit, void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    if (inhibit)\n        virNetDaemonAddShutdownInhibition(dmn);\n    else\n        virNetDaemonRemoveShutdownInhibition(dmn);\n}"
  },
  {
    "function_name": "daemonSetupSignals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "723-734",
    "snippet": "static int daemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGHUP, daemonReloadHandler, NULL) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonAddSignalHandler",
          "args": [
            "dmn",
            "SIGHUP",
            "daemonReloadHandler",
            "NULL"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAddSignalHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "737-746",
          "snippet": "int\nvirNetDaemonAddSignalHandler(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                             int signum G_GNUC_UNUSED,\n                             virNetDaemonSignalFunc func G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Signal handling not available on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDaemonAddSignalHandler(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                             int signum G_GNUC_UNUSED,\n                             virNetDaemonSignalFunc func G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Signal handling not available on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, daemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGHUP, daemonReloadHandler, NULL) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "daemonReloadHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "703-721",
    "snippet": "static void daemonReloadHandler(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                                siginfo_t *sig G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED)\n{\n    virThread thr;\n\n    if (!driversInitialized) {\n        VIR_WARN(\"Drivers are not initialized, reload ignored\");\n        return;\n    }\n\n    if (virThreadCreateFull(&thr, false, daemonReloadHandlerThread,\n                            \"daemon-reload\", false, NULL) < 0) {\n        /*\n         * Not much we can do on error here except log it.\n         */\n        VIR_ERROR(_(\"Failed to create thread to handle daemon restart\"));\n    }\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "volatile bool driversInitialized = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to create thread to handle daemon restart\")"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create thread to handle daemon restart\""
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&thr",
            "false",
            "daemonReloadHandlerThread",
            "\"daemon-reload\"",
            "false",
            "NULL"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Drivers are not initialized, reload ignored\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvolatile bool driversInitialized = false;\n\nstatic void daemonReloadHandler(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                                siginfo_t *sig G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED)\n{\n    virThread thr;\n\n    if (!driversInitialized) {\n        VIR_WARN(\"Drivers are not initialized, reload ignored\");\n        return;\n    }\n\n    if (virThreadCreateFull(&thr, false, daemonReloadHandlerThread,\n                            \"daemon-reload\", false, NULL) < 0) {\n        /*\n         * Not much we can do on error here except log it.\n         */\n        VIR_ERROR(_(\"Failed to create thread to handle daemon restart\"));\n    }\n}"
  },
  {
    "function_name": "daemonReloadHandlerThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "694-701",
    "snippet": "static void daemonReloadHandlerThread(void *opague G_GNUC_UNUSED)\n{\n    VIR_INFO(\"Reloading configuration on SIGHUP\");\n    virHookCall(VIR_HOOK_DRIVER_DAEMON, \"-\",\n                VIR_HOOK_DAEMON_OP_RELOAD, SIGHUP, \"SIGHUP\", NULL, NULL);\n    if (virStateReload() < 0)\n        VIR_WARN(\"Error while reloading drivers\");\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Error while reloading drivers\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStateReload",
          "args": [],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "virStateReload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "704-716",
          "snippet": "int\nvirStateReload(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateReload &&\n            virStateDriverTab[i]->stateReload() < 0)\n            ret = -1;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirStateReload(void)\n{\n    size_t i;\n    int ret = 0;\n\n    for (i = 0; i < virStateDriverTabCount; i++) {\n        if (virStateDriverTab[i]->stateReload &&\n            virStateDriverTab[i]->stateReload() < 0)\n            ret = -1;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_DAEMON",
            "\"-\"",
            "VIR_HOOK_DAEMON_OP_RELOAD",
            "SIGHUP",
            "\"SIGHUP\"",
            "NULL",
            "NULL"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Reloading configuration on SIGHUP\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonReloadHandlerThread(void *opague G_GNUC_UNUSED)\n{\n    VIR_INFO(\"Reloading configuration on SIGHUP\");\n    virHookCall(VIR_HOOK_DRIVER_DAEMON, \"-\",\n                VIR_HOOK_DAEMON_OP_RELOAD, SIGHUP, \"SIGHUP\", NULL, NULL);\n    if (virStateReload() < 0)\n        VIR_WARN(\"Error while reloading drivers\");\n}"
  },
  {
    "function_name": "daemonShutdownHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "687-692",
    "snippet": "static void daemonShutdownHandler(virNetDaemonPtr dmn,\n                                  siginfo_t *sig G_GNUC_UNUSED,\n                                  void *opaque G_GNUC_UNUSED)\n{\n    virNetDaemonQuit(dmn);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonQuit",
          "args": [
            "dmn"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonQuit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "867-876",
          "snippet": "void\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonShutdownHandler(virNetDaemonPtr dmn,\n                                  siginfo_t *sig G_GNUC_UNUSED,\n                                  void *opaque G_GNUC_UNUSED)\n{\n    virNetDaemonQuit(dmn);\n}"
  },
  {
    "function_name": "daemonVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "680-684",
    "snippet": "static void\ndaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s (%s) %s\\n\"",
            "argv0",
            "PACKAGE_NAME",
            "PACKAGE_VERSION"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\ndaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}"
  },
  {
    "function_name": "daemonSetupAccessManager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "659-676",
    "snippet": "static int\ndaemonSetupAccessManager(struct daemonConfig *config)\n{\n    virAccessManagerPtr mgr;\n    const char *none[] = { \"none\", NULL };\n    const char **drv = (const char **)config->access_drivers;\n\n    if (!drv ||\n        !drv[0])\n        drv = none;\n\n    if (!(mgr = virAccessManagerNewStack(drv)))\n        return -1;\n\n    virAccessManagerSetDefault(mgr);\n    virObjectUnref(mgr);\n    return 0;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mgr"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAccessManagerSetDefault",
          "args": [
            "mgr"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "virAccessManagerSetDefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/access/viraccessmanager.c",
          "lines": "78-83",
          "snippet": "void virAccessManagerSetDefault(virAccessManagerPtr mgr)\n{\n    virObjectUnref(virAccessManagerDefault);\n\n    virAccessManagerDefault = virObjectRef(mgr);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "# include \"viraccessdriverpolkit.h\"",
            "#include \"viraccessdriverstack.h\"",
            "#include \"viraccessdrivernop.h\"",
            "#include \"viraccessmanager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virAccessManagerPtr virAccessManagerDefault;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n# include \"viraccessdriverpolkit.h\"\n#include \"viraccessdriverstack.h\"\n#include \"viraccessdrivernop.h\"\n#include \"viraccessmanager.h\"\n#include <config.h>\n\nstatic virAccessManagerPtr virAccessManagerDefault;\n\nvoid virAccessManagerSetDefault(virAccessManagerPtr mgr)\n{\n    virObjectUnref(virAccessManagerDefault);\n\n    virAccessManagerDefault = virObjectRef(mgr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAccessManagerNewStack",
          "args": [
            "drv"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "virAccessManagerNewStack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/access/viraccessmanager.c",
          "lines": "154-179",
          "snippet": "virAccessManagerPtr virAccessManagerNewStack(const char **names)\n{\n    virAccessManagerPtr manager = virAccessManagerNewDriver(&accessDriverStack);\n    size_t i;\n\n    if (!manager)\n        return NULL;\n\n    for (i = 0; names[i] != NULL; i++) {\n        virAccessManagerPtr child = virAccessManagerNew(names[i]);\n\n        if (!child)\n            goto error;\n\n        if (virAccessDriverStackAppend(manager, child) < 0) {\n            virObjectUnref(child);\n            goto error;\n        }\n    }\n\n    return manager;\n\n error:\n    virObjectUnref(manager);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "# include \"viraccessdriverpolkit.h\"",
            "#include \"viraccessdriverstack.h\"",
            "#include \"viraccessdrivernop.h\"",
            "#include \"viraccessmanager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n# include \"viraccessdriverpolkit.h\"\n#include \"viraccessdriverstack.h\"\n#include \"viraccessdrivernop.h\"\n#include \"viraccessmanager.h\"\n#include <config.h>\n\nvirAccessManagerPtr virAccessManagerNewStack(const char **names)\n{\n    virAccessManagerPtr manager = virAccessManagerNewDriver(&accessDriverStack);\n    size_t i;\n\n    if (!manager)\n        return NULL;\n\n    for (i = 0; names[i] != NULL; i++) {\n        virAccessManagerPtr child = virAccessManagerNew(names[i]);\n\n        if (!child)\n            goto error;\n\n        if (virAccessDriverStackAppend(manager, child) < 0) {\n            virObjectUnref(child);\n            goto error;\n        }\n    }\n\n    return manager;\n\n error:\n    virObjectUnref(manager);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonSetupAccessManager(struct daemonConfig *config)\n{\n    virAccessManagerPtr mgr;\n    const char *none[] = { \"none\", NULL };\n    const char **drv = (const char **)config->access_drivers;\n\n    if (!drv ||\n        !drv[0])\n        drv = none;\n\n    if (!(mgr = virAccessManagerNewStack(drv)))\n        return -1;\n\n    virAccessManagerSetDefault(mgr);\n    virObjectUnref(mgr);\n    return 0;\n}"
  },
  {
    "function_name": "daemonSetupLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "613-656",
    "snippet": "static int\ndaemonSetupLogging(struct daemonConfig *config,\n                   bool privileged,\n                   bool verbose,\n                   bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Logging setup order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(DAEMON_NAME, godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogSetOutputs",
          "args": [
            "virLogGetDefaultOutput()"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1747-1779",
          "snippet": "int\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *virLogDefaultOutput;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *virLogDefaultOutput;\n\nint\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultOutput",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "223-227",
          "snippet": "char *\nvirLogGetDefaultOutput(void)\n{\n    return virLogDefaultOutput;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *virLogDefaultOutput;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *virLogDefaultOutput;\n\nchar *\nvirLogGetDefaultOutput(void)\n{\n    return virLogDefaultOutput;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetNbOutputs",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetNbOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1163-1167",
          "snippet": "int\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t virLogNbOutputs;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic size_t virLogNbOutputs;\n\nint\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetDefaultOutput",
          "args": [
            "DAEMON_NAME",
            "godaemon",
            "privileged"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetDefaultOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "204-220",
          "snippet": "void\nvirLogSetDefaultOutput(const char *binary, bool godaemon, bool privileged)\n{\n    bool have_journald = access(\"/run/systemd/journal/socket\", W_OK) >= 0;\n\n    if (godaemon) {\n        if (have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToFile(binary, privileged);\n    } else {\n        if (!isatty(STDIN_FILENO) && have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToStderr();\n    }\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetDefaultOutput(const char *binary, bool godaemon, bool privileged)\n{\n    bool have_journald = access(\"/run/systemd/journal/socket\", W_OK) >= 0;\n\n    if (godaemon) {\n        if (have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToFile(binary, privileged);\n    } else {\n        if (!isatty(STDIN_FILENO) && have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToStderr();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetDefaultPriority",
          "args": [
            "VIR_LOG_INFO"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "304-318",
          "snippet": "int\nvirLogSetDefaultPriority(virLogPriority priority)\n{\n    if ((priority < VIR_LOG_DEBUG) || (priority > VIR_LOG_ERROR)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to set logging priority, argument '%u' is \"\n                         \"invalid\"), priority);\n        return -1;\n    }\n    if (virLogInitialize() < 0)\n        return -1;\n\n    virLogDefaultPriority = priority;\n    return 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nint\nvirLogSetDefaultPriority(virLogPriority priority)\n{\n    if ((priority < VIR_LOG_DEBUG) || (priority > VIR_LOG_ERROR)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to set logging priority, argument '%u' is \"\n                         \"invalid\"), priority);\n        return -1;\n    }\n    if (virLogInitialize() < 0)\n        return -1;\n\n    virLogDefaultPriority = priority;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultPriority",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1063-1067",
          "snippet": "virLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nvirLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetFromEnv",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFromEnv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1208-1225",
          "snippet": "void\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virLogSetOutputs(config->log_outputs)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virLogSetFilters(config->log_filters)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogSetFilters",
          "args": [
            "config->log_filters"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1790-1811",
          "snippet": "int\nvirLogSetFilters(const char *src)\n{\n    int ret = -1;\n    int nfilters = 0;\n    virLogFilterPtr *filters = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && (nfilters = virLogParseFilters(src, &filters)) < 0)\n        goto cleanup;\n\n    if (virLogDefineFilters(filters, nfilters) < 0)\n        goto cleanup;\n\n    filters = NULL;\n    ret = 0;\n cleanup:\n    virLogFilterListFree(filters, nfilters);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirLogSetFilters(const char *src)\n{\n    int ret = -1;\n    int nfilters = 0;\n    virLogFilterPtr *filters = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && (nfilters = virLogParseFilters(src, &filters)) < 0)\n        goto cleanup;\n\n    if (virLogDefineFilters(filters, nfilters) < 0)\n        goto cleanup;\n\n    filters = NULL;\n    ret = 0;\n cleanup:\n    virLogFilterListFree(filters, nfilters);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogReset",
          "args": [],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virLogResetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "373-379",
          "snippet": "static void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogOutputPtr *virLogOutputs;",
            "static size_t virLogNbOutputs;",
            "static void virLogResetOutputs(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogOutputPtr *virLogOutputs;\nstatic size_t virLogNbOutputs;\nstatic void virLogResetOutputs(void);\n\nstatic void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonSetupLogging(struct daemonConfig *config,\n                   bool privileged,\n                   bool verbose,\n                   bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Logging setup order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(DAEMON_NAME, godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}"
  },
  {
    "function_name": "daemonSetupNetDevOpenvswitch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "600-604",
    "snippet": "static void\ndaemonSetupNetDevOpenvswitch(struct daemonConfig *config)\n{\n    virNetDevOpenvswitchSetTimeout(config->ovs_timeout);\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevOpenvswitchSetTimeout",
          "args": [
            "config->ovs_timeout"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevOpenvswitchSetTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevopenvswitch.c",
          "lines": "48-52",
          "snippet": "void\nvirNetDevOpenvswitchSetTimeout(unsigned int timeout)\n{\n    virNetDevOpenvswitchTimeout = timeout;\n}",
          "includes": [
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int virNetDevOpenvswitchTimeout = VIR_NETDEV_OVS_DEFAULT_TIMEOUT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virmacaddr.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevopenvswitch.h\"\n#include <config.h>\n\nstatic unsigned int virNetDevOpenvswitchTimeout = VIR_NETDEV_OVS_DEFAULT_TIMEOUT;\n\nvoid\nvirNetDevOpenvswitchSetTimeout(unsigned int timeout)\n{\n    virNetDevOpenvswitchTimeout = timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\ndaemonSetupNetDevOpenvswitch(struct daemonConfig *config)\n{\n    virNetDevOpenvswitchSetTimeout(config->ovs_timeout);\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "378-422",
    "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\")"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\""
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrResolveService",
          "args": [
            "config->tcp_port"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrResolveService",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "245-285",
          "snippet": "int virSocketAddrResolveService(const char *service)\n{\n    struct addrinfo *res, *tmp;\n    struct addrinfo hints;\n    int err;\n    int port = -1;\n\n    memset(&hints, 0, sizeof(hints));\n\n    if ((err = getaddrinfo(NULL, service, &hints, &res)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot parse socket service '%s': %s\"),\n                       service, gai_strerror(err));\n        return -1;\n    }\n\n    tmp = res;\n    while (tmp) {\n        if (tmp->ai_family == AF_INET) {\n            struct sockaddr_in in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin_port);\n            goto cleanup;\n        } else if (tmp->ai_family == AF_INET6) {\n            struct sockaddr_in6 in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin6_port);\n            goto cleanup;\n        }\n        tmp++;\n    }\n\n    virReportError(VIR_ERR_SYSTEM_ERROR,\n                   _(\"No matches for socket service '%s': %s\"),\n                   service, gai_strerror(err));\n\n cleanup:\n    freeaddrinfo(res);\n\n    return port;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrResolveService(const char *service)\n{\n    struct addrinfo *res, *tmp;\n    struct addrinfo hints;\n    int err;\n    int port = -1;\n\n    memset(&hints, 0, sizeof(hints));\n\n    if ((err = getaddrinfo(NULL, service, &hints, &res)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot parse socket service '%s': %s\"),\n                       service, gai_strerror(err));\n        return -1;\n    }\n\n    tmp = res;\n    while (tmp) {\n        if (tmp->ai_family == AF_INET) {\n            struct sockaddr_in in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin_port);\n            goto cleanup;\n        } else if (tmp->ai_family == AF_INET6) {\n            struct sockaddr_in6 in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin6_port);\n            goto cleanup;\n        }\n        tmp++;\n    }\n\n    virReportError(VIR_ERR_SYSTEM_ERROR,\n                   _(\"No matches for socket service '%s': %s\"),\n                   service, gai_strerror(err));\n\n cleanup:\n    freeaddrinfo(res);\n\n    return port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
  },
  {
    "function_name": "daemonInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "304-375",
    "snippet": "static int daemonInitialize(void)\n{\n#ifndef LIBVIRTD\n# ifdef MODULE_NAME\n    /* This a dedicated per-driver daemon build */\n    if (virDriverLoadModule(MODULE_NAME, MODULE_NAME \"Register\", true) < 0)\n        return -1;\n# else\n    /* This is virtproxyd which merely proxies to the per-driver\n     * daemons for back compat, and also allows IP connectivity.\n     */\n# endif\n#else\n    /* This is the legacy monolithic libvirtd built with all drivers\n     *\n     * Note that the order is important: the first ones have a higher\n     * priority when calling virStateInitialize. We must register the\n     * network, storage and nodedev drivers before any stateful domain\n     * driver, since their resources must be auto-started before any\n     * domains can be auto-started.\n     */\n# ifdef WITH_NETWORK\n    if (virDriverLoadModule(\"network\", \"networkRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_INTERFACE\n    if (virDriverLoadModule(\"interface\", \"interfaceRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_SECRETS\n    if (virDriverLoadModule(\"secret\", \"secretRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_STORAGE\n    if (virDriverLoadModule(\"storage\", \"storageRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NODE_DEVICES\n    if (virDriverLoadModule(\"nodedev\", \"nodedevRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NWFILTER\n    if (virDriverLoadModule(\"nwfilter\", \"nwfilterRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LIBXL\n    if (virDriverLoadModule(\"libxl\", \"libxlRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_QEMU\n    if (virDriverLoadModule(\"qemu\", \"qemuRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LXC\n    if (virDriverLoadModule(\"lxc\", \"lxcRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VBOX\n    if (virDriverLoadModule(\"vbox\", \"vboxRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_BHYVE\n    if (virDriverLoadModule(\"bhyve\", \"bhyveRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VZ\n    if (virDriverLoadModule(\"vz\", \"vzRegister\", false) < 0)\n        return -1;\n# endif\n#endif\n    return 0;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDriverLoadModule",
          "args": [
            "\"vz\"",
            "\"vzRegister\"",
            "false"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virDriverLoadModule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "46-69",
          "snippet": "int\nvirDriverLoadModule(const char *name,\n                    const char *regfunc,\n                    bool required)\n{\n    char *modfile = NULL;\n    int ret;\n\n    VIR_DEBUG(\"Module load %s\", name);\n\n    if (!(modfile = virFileFindResourceFull(name,\n                                            \"libvirt_driver_\",\n                                            \".so\",\n                                            abs_top_builddir \"/src/.libs\",\n                                            DEFAULT_DRIVER_DIR,\n                                            \"LIBVIRT_DRIVER_DIR\")))\n        return -1;\n\n    ret = virModuleLoad(modfile, regfunc, required);\n\n    VIR_FREE(modfile);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEFAULT_DRIVER_DIR LIBDIR \"/libvirt/connection-driver\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define DEFAULT_DRIVER_DIR LIBDIR \"/libvirt/connection-driver\"\n\nint\nvirDriverLoadModule(const char *name,\n                    const char *regfunc,\n                    bool required)\n{\n    char *modfile = NULL;\n    int ret;\n\n    VIR_DEBUG(\"Module load %s\", name);\n\n    if (!(modfile = virFileFindResourceFull(name,\n                                            \"libvirt_driver_\",\n                                            \".so\",\n                                            abs_top_builddir \"/src/.libs\",\n                                            DEFAULT_DRIVER_DIR,\n                                            \"LIBVIRT_DRIVER_DIR\")))\n        return -1;\n\n    ret = virModuleLoad(modfile, regfunc, required);\n\n    VIR_FREE(modfile);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonInitialize(void)\n{\n#ifndef LIBVIRTD\n# ifdef MODULE_NAME\n    /* This a dedicated per-driver daemon build */\n    if (virDriverLoadModule(MODULE_NAME, MODULE_NAME \"Register\", true) < 0)\n        return -1;\n# else\n    /* This is virtproxyd which merely proxies to the per-driver\n     * daemons for back compat, and also allows IP connectivity.\n     */\n# endif\n#else\n    /* This is the legacy monolithic libvirtd built with all drivers\n     *\n     * Note that the order is important: the first ones have a higher\n     * priority when calling virStateInitialize. We must register the\n     * network, storage and nodedev drivers before any stateful domain\n     * driver, since their resources must be auto-started before any\n     * domains can be auto-started.\n     */\n# ifdef WITH_NETWORK\n    if (virDriverLoadModule(\"network\", \"networkRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_INTERFACE\n    if (virDriverLoadModule(\"interface\", \"interfaceRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_SECRETS\n    if (virDriverLoadModule(\"secret\", \"secretRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_STORAGE\n    if (virDriverLoadModule(\"storage\", \"storageRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NODE_DEVICES\n    if (virDriverLoadModule(\"nodedev\", \"nodedevRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_NWFILTER\n    if (virDriverLoadModule(\"nwfilter\", \"nwfilterRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LIBXL\n    if (virDriverLoadModule(\"libxl\", \"libxlRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_QEMU\n    if (virDriverLoadModule(\"qemu\", \"qemuRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_LXC\n    if (virDriverLoadModule(\"lxc\", \"lxcRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VBOX\n    if (virDriverLoadModule(\"vbox\", \"vboxRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_BHYVE\n    if (virDriverLoadModule(\"bhyve\", \"bhyveRegister\", false) < 0)\n        return -1;\n# endif\n# ifdef WITH_VZ\n    if (virDriverLoadModule(\"vz\", \"vzRegister\", false) < 0)\n        return -1;\n# endif\n#endif\n    return 0;\n}"
  },
  {
    "function_name": "daemonErrorLogFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "274-301",
    "snippet": "static int daemonErrorLogFilter(virErrorPtr err, int priority)\n{\n    /* These error codes don't really reflect real errors. They\n     * are expected events that occur when an app tries to check\n     * whether a particular guest already exists. This filters\n     * them to a lower log level to prevent pollution of syslog\n     */\n    switch (err->code) {\n    case VIR_ERR_NO_DOMAIN:\n    case VIR_ERR_NO_NETWORK:\n    case VIR_ERR_NO_STORAGE_POOL:\n    case VIR_ERR_NO_STORAGE_VOL:\n    case VIR_ERR_NO_NODE_DEVICE:\n    case VIR_ERR_NO_INTERFACE:\n    case VIR_ERR_NO_NWFILTER:\n    case VIR_ERR_NO_NWFILTER_BINDING:\n    case VIR_ERR_NO_SECRET:\n    case VIR_ERR_NO_DOMAIN_SNAPSHOT:\n    case VIR_ERR_OPERATION_INVALID:\n    case VIR_ERR_NO_DOMAIN_METADATA:\n    case VIR_ERR_NO_SERVER:\n    case VIR_ERR_NO_CLIENT:\n    case VIR_ERR_NO_HOSTNAME:\n        return VIR_LOG_DEBUG;\n    }\n\n    return priority;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonErrorLogFilter(virErrorPtr err, int priority)\n{\n    /* These error codes don't really reflect real errors. They\n     * are expected events that occur when an app tries to check\n     * whether a particular guest already exists. This filters\n     * them to a lower log level to prevent pollution of syslog\n     */\n    switch (err->code) {\n    case VIR_ERR_NO_DOMAIN:\n    case VIR_ERR_NO_NETWORK:\n    case VIR_ERR_NO_STORAGE_POOL:\n    case VIR_ERR_NO_STORAGE_VOL:\n    case VIR_ERR_NO_NODE_DEVICE:\n    case VIR_ERR_NO_INTERFACE:\n    case VIR_ERR_NO_NWFILTER:\n    case VIR_ERR_NO_NWFILTER_BINDING:\n    case VIR_ERR_NO_SECRET:\n    case VIR_ERR_NO_DOMAIN_SNAPSHOT:\n    case VIR_ERR_OPERATION_INVALID:\n    case VIR_ERR_NO_DOMAIN_METADATA:\n    case VIR_ERR_NO_SERVER:\n    case VIR_ERR_NO_CLIENT:\n    case VIR_ERR_NO_HOSTNAME:\n        return VIR_LOG_DEBUG;\n    }\n\n    return priority;\n}"
  },
  {
    "function_name": "daemonErrorHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "267-272",
    "snippet": "static void daemonErrorHandler(void *opaque G_GNUC_UNUSED,\n                               virErrorPtr err G_GNUC_UNUSED)\n{\n    /* Don't do anything, since logging infrastructure already\n     * took care of reporting the error */\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void daemonErrorHandler(void *opaque G_GNUC_UNUSED,\n                               virErrorPtr err G_GNUC_UNUSED)\n{\n    /* Don't do anything, since logging infrastructure already\n     * took care of reporting the error */\n}"
  },
  {
    "function_name": "daemonUnixSocketPaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "215-264",
    "snippet": "static int\ndaemonUnixSocketPaths(struct daemonConfig *config,\n                      bool privileged,\n                      char **sockfile,\n                      char **rosockfile,\n                      char **admsockfile)\n{\n    int ret = -1;\n    char *rundir = NULL;\n\n    if (config->unix_sock_dir) {\n        *sockfile = g_strdup_printf(\"%s/%s-sock\", config->unix_sock_dir,\n                                    SOCK_PREFIX);\n\n        if (privileged) {\n            *rosockfile = g_strdup_printf(\"%s/%s-sock-ro\",\n                                          config->unix_sock_dir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\",\n                                           config->unix_sock_dir, SOCK_PREFIX);\n        }\n    } else {\n        if (privileged) {\n            *sockfile = g_strdup_printf(\"%s/libvirt/%s-sock\",\n                                        RUNSTATEDIR, SOCK_PREFIX);\n            *rosockfile = g_strdup_printf(\"%s/libvirt/%s-sock-ro\",\n                                          RUNSTATEDIR, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/libvirt/%s-admin-sock\",\n                                           RUNSTATEDIR, SOCK_PREFIX);\n        } else {\n            mode_t old_umask;\n\n            rundir = virGetUserRuntimeDirectory();\n\n            old_umask = umask(077);\n            if (virFileMakePath(rundir) < 0) {\n                umask(old_umask);\n                goto cleanup;\n            }\n            umask(old_umask);\n\n            *sockfile = g_strdup_printf(\"%s/%s-sock\", rundir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\", rundir, SOCK_PREFIX);\n        }\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(rundir);\n    return ret;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rundir"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s-admin-sock\"",
            "rundir",
            "SOCK_PREFIX"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "rundir"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\ndaemonUnixSocketPaths(struct daemonConfig *config,\n                      bool privileged,\n                      char **sockfile,\n                      char **rosockfile,\n                      char **admsockfile)\n{\n    int ret = -1;\n    char *rundir = NULL;\n\n    if (config->unix_sock_dir) {\n        *sockfile = g_strdup_printf(\"%s/%s-sock\", config->unix_sock_dir,\n                                    SOCK_PREFIX);\n\n        if (privileged) {\n            *rosockfile = g_strdup_printf(\"%s/%s-sock-ro\",\n                                          config->unix_sock_dir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\",\n                                           config->unix_sock_dir, SOCK_PREFIX);\n        }\n    } else {\n        if (privileged) {\n            *sockfile = g_strdup_printf(\"%s/libvirt/%s-sock\",\n                                        RUNSTATEDIR, SOCK_PREFIX);\n            *rosockfile = g_strdup_printf(\"%s/libvirt/%s-sock-ro\",\n                                          RUNSTATEDIR, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/libvirt/%s-admin-sock\",\n                                           RUNSTATEDIR, SOCK_PREFIX);\n        } else {\n            mode_t old_umask;\n\n            rundir = virGetUserRuntimeDirectory();\n\n            old_umask = umask(077);\n            if (virFileMakePath(rundir) < 0) {\n                umask(old_umask);\n                goto cleanup;\n            }\n            umask(old_umask);\n\n            *sockfile = g_strdup_printf(\"%s/%s-sock\", rundir, SOCK_PREFIX);\n            *admsockfile = g_strdup_printf(\"%s/%s-admin-sock\", rundir, SOCK_PREFIX);\n        }\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(rundir);\n    return ret;\n}"
  },
  {
    "function_name": "daemonForkIntoBackground",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
    "lines": "113-212",
    "snippet": "static int daemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            /* intermediate child */\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0: /* grandchild */\n                return statuspipe[1];\n            case -1: /* error */\n                goto cleanup;\n            default: /* intermediate child succeeded */\n                _exit(EXIT_SUCCESS);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            VIR_FORCE_CLOSE(statuspipe[1]);\n            _exit(EXIT_FAILURE);\n\n        }\n\n    case -1: /* error in parent */\n        goto error;\n\n    default:\n        {\n            /* parent */\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if (virProcessWait(pid, NULL, false) < 0)\n                goto error;\n\n            /* If we get here, then the grandchild was spawned, so we\n             * must exit.  Block until the second child initializes\n             * successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if (ret != 1) {\n                fprintf(stderr,\n                        _(\"%s: error: unable to determine if daemon is \"\n                          \"running: %s\\n\"), argv0,\n                        g_strerror(errno));\n                exit(EXIT_FAILURE);\n            } else if (status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run \"\n                          \"without --daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n                exit(EXIT_FAILURE);\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n error:\n    VIR_FORCE_CLOSE(statuspipe[0]);\n    VIR_FORCE_CLOSE(statuspipe[1]);\n    return -1;\n}",
    "includes": [
      "#include \"virdbus.h\"",
      "#include \"configmake.h\"",
      "#include \"driver.h\"",
      "#include \"virhostuptime.h\"",
      "#include \"virsystemd.h\"",
      "#include \"util/virnetdevopenvswitch.h\"",
      "#include \"virgettext.h\"",
      "#include \"virutil.h\"",
      "#include \"viraccessmanager.h\"",
      "#include \"locking/lock_manager.h\"",
      "#include \"virstring.h\"",
      "#include \"viraudit.h\"",
      "#include \"virhook.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"virnetdaemon.h\"",
      "#include \"virnetlink.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_driver.h\"",
      "#include \"viruuid.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"remote_daemon_config.h\"",
      "#include \"remote_daemon.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"libvirt_internal.h\"",
      "#include <grp.h>",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[1]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[0]"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: error: %s. Check /var/log/messages or run \"\n                          \"without --daemon for more info.\\n\")",
            "argv0",
            "virDaemonErrTypeToString(status)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDaemonErrTypeToString",
          "args": [
            "status"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: error: %s. Check /var/log/messages or run \"\n                          \"without --daemon for more info.\\n\""
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: error: unable to determine if daemon is \"\n                          \"running: %s\\n\")",
            "argv0",
            "g_strerror(errno)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[0]"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "statuspipe[0]",
            "&status",
            "1"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "remoteDomainGetIOThreadInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_driver.c",
          "lines": "2446-2522",
          "snippet": "static int\nremoteDomainGetIOThreadInfo(virDomainPtr dom,\n                            virDomainIOThreadInfoPtr **info,\n                            unsigned int flags)\n{\n    int rv = -1;\n    size_t i;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_get_iothread_info_args args;\n    remote_domain_get_iothread_info_ret ret;\n    remote_domain_iothread_info *src;\n    virDomainIOThreadInfoPtr *info_ret = NULL;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_IOTHREAD_INFO,\n             (xdrproc_t)xdr_remote_domain_get_iothread_info_args,\n             (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_iothread_info_ret,\n             (char *)&ret) == -1)\n        goto done;\n\n    if (ret.info.info_len > REMOTE_IOTHREAD_INFO_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many IOThreads in info: %d for limit %d\"),\n                       ret.info.info_len, REMOTE_IOTHREAD_INFO_MAX);\n        goto cleanup;\n    }\n\n    if (info) {\n        if (!ret.info.info_len) {\n            *info = NULL;\n            rv = ret.ret;\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(info_ret, ret.info.info_len) < 0)\n            goto cleanup;\n\n        for (i = 0; i < ret.info.info_len; i++) {\n            src = &ret.info.info_val[i];\n\n            if (VIR_ALLOC(info_ret[i]) < 0)\n                goto cleanup;\n\n            info_ret[i]->iothread_id = src->iothread_id;\n            if (VIR_ALLOC_N(info_ret[i]->cpumap, src->cpumap.cpumap_len) < 0)\n                goto cleanup;\n            memcpy(info_ret[i]->cpumap, src->cpumap.cpumap_val,\n                   src->cpumap.cpumap_len);\n            info_ret[i]->cpumaplen = src->cpumap.cpumap_len;\n        }\n        *info = info_ret;\n        info_ret = NULL;\n    }\n\n    rv = ret.ret;\n\n cleanup:\n    if (info_ret) {\n        for (i = 0; i < ret.info.info_len; i++)\n            virDomainIOThreadInfoFree(info_ret[i]);\n        VIR_FREE(info_ret);\n    }\n    xdr_free((xdrproc_t)xdr_remote_domain_get_iothread_info_ret,\n             (char *) &ret);\n\n done:\n    remoteDriverUnlock(priv);\n    return rv;\n}",
          "includes": [
            "#include \"qemu_client_bodies.h\"",
            "#include \"lxc_client_bodies.h\"",
            "#include \"remote_client_bodies.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"virauth.h\"",
            "#include \"viruri.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_protocol.h\"",
            "#include \"lxc_protocol.h\"",
            "#include \"remote_protocol.h\"",
            "#include \"remote_driver.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"secret_event.h\"",
            "#include \"node_device_event.h\"",
            "#include \"storage_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetclientstream.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include \"virnetclient.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int call(virConnectPtr conn, struct private_data *priv,\n                unsigned int flags, int proc_nr,\n                xdrproc_t args_filter, char *args,\n                xdrproc_t ret_filter, char *ret);",
            "static int callFull(virConnectPtr conn, struct private_data *priv,\n                    unsigned int flags,\n                    int *fdin, size_t fdinlen,\n                    int **fdout, size_t *fdoutlen,\n                    int proc_nr,\n                    xdrproc_t args_filter, char *args,\n                    xdrproc_t ret_filter, char *ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_client_bodies.h\"\n#include \"lxc_client_bodies.h\"\n#include \"remote_client_bodies.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"virauth.h\"\n#include \"viruri.h\"\n#include \"virtypedparam.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"qemu_protocol.h\"\n#include \"lxc_protocol.h\"\n#include \"remote_protocol.h\"\n#include \"remote_driver.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"secret_event.h\"\n#include \"node_device_event.h\"\n#include \"storage_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virnetclientstream.h\"\n#include \"virnetclientprogram.h\"\n#include \"virnetclient.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int call(virConnectPtr conn, struct private_data *priv,\n                unsigned int flags, int proc_nr,\n                xdrproc_t args_filter, char *args,\n                xdrproc_t ret_filter, char *ret);\nstatic int callFull(virConnectPtr conn, struct private_data *priv,\n                    unsigned int flags,\n                    int *fdin, size_t fdinlen,\n                    int **fdout, size_t *fdoutlen,\n                    int proc_nr,\n                    xdrproc_t args_filter, char *args,\n                    xdrproc_t ret_filter, char *ret);\n\nstatic int\nremoteDomainGetIOThreadInfo(virDomainPtr dom,\n                            virDomainIOThreadInfoPtr **info,\n                            unsigned int flags)\n{\n    int rv = -1;\n    size_t i;\n    struct private_data *priv = dom->conn->privateData;\n    remote_domain_get_iothread_info_args args;\n    remote_domain_get_iothread_info_ret ret;\n    remote_domain_iothread_info *src;\n    virDomainIOThreadInfoPtr *info_ret = NULL;\n\n    remoteDriverLock(priv);\n\n    make_nonnull_domain(&args.dom, dom);\n\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n\n    if (call(dom->conn, priv, 0, REMOTE_PROC_DOMAIN_GET_IOTHREAD_INFO,\n             (xdrproc_t)xdr_remote_domain_get_iothread_info_args,\n             (char *)&args,\n             (xdrproc_t)xdr_remote_domain_get_iothread_info_ret,\n             (char *)&ret) == -1)\n        goto done;\n\n    if (ret.info.info_len > REMOTE_IOTHREAD_INFO_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many IOThreads in info: %d for limit %d\"),\n                       ret.info.info_len, REMOTE_IOTHREAD_INFO_MAX);\n        goto cleanup;\n    }\n\n    if (info) {\n        if (!ret.info.info_len) {\n            *info = NULL;\n            rv = ret.ret;\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(info_ret, ret.info.info_len) < 0)\n            goto cleanup;\n\n        for (i = 0; i < ret.info.info_len; i++) {\n            src = &ret.info.info_val[i];\n\n            if (VIR_ALLOC(info_ret[i]) < 0)\n                goto cleanup;\n\n            info_ret[i]->iothread_id = src->iothread_id;\n            if (VIR_ALLOC_N(info_ret[i]->cpumap, src->cpumap.cpumap_len) < 0)\n                goto cleanup;\n            memcpy(info_ret[i]->cpumap, src->cpumap.cpumap_val,\n                   src->cpumap.cpumap_len);\n            info_ret[i]->cpumaplen = src->cpumap.cpumap_len;\n        }\n        *info = info_ret;\n        info_ret = NULL;\n    }\n\n    rv = ret.ret;\n\n cleanup:\n    if (info_ret) {\n        for (i = 0; i < ret.info.info_len; i++)\n            virDomainIOThreadInfoFree(info_ret[i]);\n        VIR_FREE(info_ret);\n    }\n    xdr_free((xdrproc_t)xdr_remote_domain_get_iothread_info_ret,\n             (char *) &ret);\n\n done:\n    remoteDriverUnlock(priv);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessWait",
          "args": [
            "pid",
            "NULL",
            "false"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "296-302",
          "snippet": "int\nvirProcessWait(pid_t pid, int *exitstatus G_GNUC_UNUSED, bool raw G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"unable to wait for process %lld\"),\n                         (long long) pid);\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessWait(pid_t pid, int *exitstatus G_GNUC_UNUSED, bool raw G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"unable to wait for process %lld\"),\n                         (long long) pid);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[1]"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[1]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "stdinfd"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "stdoutfd"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "stdoutfd"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "stdinfd"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdoutfd",
            "STDERR_FILENO"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdoutfd",
            "STDOUT_FILENO"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdinfd",
            "STDIN_FILENO"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_WRONLY"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[0]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipeQuiet",
          "args": [
            "statuspipe"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1806-1810",
          "snippet": "int\nvirPipeQuiet(int fds[2])\n{\n    return virPipeImpl(fds, false, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeQuiet(int fds[2])\n{\n    return virPipeImpl(fds, false, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int daemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            /* intermediate child */\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) <= STDERR_FILENO)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0: /* grandchild */\n                return statuspipe[1];\n            case -1: /* error */\n                goto cleanup;\n            default: /* intermediate child succeeded */\n                _exit(EXIT_SUCCESS);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            VIR_FORCE_CLOSE(statuspipe[1]);\n            _exit(EXIT_FAILURE);\n\n        }\n\n    case -1: /* error in parent */\n        goto error;\n\n    default:\n        {\n            /* parent */\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if (virProcessWait(pid, NULL, false) < 0)\n                goto error;\n\n            /* If we get here, then the grandchild was spawned, so we\n             * must exit.  Block until the second child initializes\n             * successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if (ret != 1) {\n                fprintf(stderr,\n                        _(\"%s: error: unable to determine if daemon is \"\n                          \"running: %s\\n\"), argv0,\n                        g_strerror(errno));\n                exit(EXIT_FAILURE);\n            } else if (status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run \"\n                          \"without --daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n                exit(EXIT_FAILURE);\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n error:\n    VIR_FORCE_CLOSE(statuspipe[0]);\n    VIR_FORCE_CLOSE(statuspipe[1]);\n    return -1;\n}"
  }
]