[
  {
    "function_name": "daemonStreamHandleRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "823-951",
    "snippet": "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream)\n{\n    virNetMessagePtr msg = NULL;\n    virNetMessageError rerr;\n    char *buffer;\n    size_t bufferLen = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    int rv;\n    int inData = 0;\n    long long length = 0;\n\n    VIR_DEBUG(\"client=%p, stream=%p tx=%d closed=%d\",\n              client, stream, stream->tx, stream->closed);\n\n    /* We might have had an event pending before we shut\n     * down the stream, so if we're marked as closed,\n     * then do nothing\n     */\n    if (stream->closed)\n        return 0;\n\n    /* Shouldn't ever be called unless we're marked able to\n     * transmit, but doesn't hurt to check */\n    if (!stream->tx)\n        return 0;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (VIR_ALLOC_N(buffer, bufferLen) < 0)\n        return -1;\n\n    if (!(msg = virNetMessageNew(false)))\n        goto cleanup;\n\n    if (stream->allowSkip && stream->dataLen == 0) {\n        /* Handle skip. We want to send some data to the client. But we might\n         * be in a hole. Seek to next data. But if we are in data already, just\n         * carry on. */\n\n        rv = virStreamInData(stream->st, &inData, &length);\n        VIR_DEBUG(\"rv=%d inData=%d length=%lld\", rv, inData, length);\n\n        if (rv < 0) {\n            if (virNetServerProgramSendStreamError(stream->prog,\n                                                   client,\n                                                   msg,\n                                                   &rerr,\n                                                   stream->procedure,\n                                                   stream->serial) < 0)\n                goto cleanup;\n            msg = NULL;\n\n            /* We're done with this call */\n            goto done;\n        } else {\n            if (!inData && length) {\n                stream->tx = false;\n                msg->cb = daemonStreamMessageFinished;\n                msg->opaque = stream;\n                stream->refs++;\n                if (virNetServerProgramSendStreamHole(stream->prog,\n                                                      client,\n                                                      msg,\n                                                      stream->procedure,\n                                                      stream->serial,\n                                                      length,\n                                                      0) < 0)\n                    goto cleanup;\n\n                msg = NULL;\n\n                /* We have successfully sent stream skip to the other side.\n                 * To keep streams in sync seek locally too. */\n                virStreamSendHole(stream->st, length, 0);\n                /* We're done with this call */\n                goto done;\n            }\n        }\n\n        stream->dataLen = length;\n    }\n\n    if (stream->allowSkip &&\n        bufferLen > stream->dataLen)\n        bufferLen = stream->dataLen;\n\n    rv = virStreamRecv(stream->st, buffer, bufferLen);\n    if (rv == -2) {\n        /* Should never get this, since we're only called when we know\n         * we're readable, but hey things change... */\n    } else if (rv < 0) {\n        if (virNetServerProgramSendStreamError(stream->prog,\n                                               client,\n                                               msg,\n                                               &rerr,\n                                               stream->procedure,\n                                               stream->serial) < 0)\n            goto cleanup;\n        msg = NULL;\n    } else {\n        if (stream->allowSkip)\n            stream->dataLen -= rv;\n\n        stream->tx = false;\n        if (rv == 0)\n            stream->recvEOF = true;\n\n        msg->cb = daemonStreamMessageFinished;\n        msg->opaque = stream;\n        stream->refs++;\n        if (virNetServerProgramSendStreamData(stream->prog,\n                                              client,\n                                              msg,\n                                              stream->procedure,\n                                              stream->serial,\n                                              buffer, rv) < 0)\n            goto cleanup;\n        msg = NULL;\n    }\n\n done:\n    ret = 0;\n cleanup:\n    VIR_FREE(buffer);\n    virNetMessageFree(msg);\n    return ret;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamData",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "stream->procedure",
            "stream->serial",
            "buffer",
            "rv"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "495-534",
          "snippet": "int virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamError",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "&rerr",
            "stream->procedure",
            "stream->serial"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "210-225",
          "snippet": "int virNetServerProgramSendStreamError(virNetServerProgramPtr prog,\n                                       virNetServerClientPtr client,\n                                       virNetMessagePtr msg,\n                                       virNetMessageErrorPtr rerr,\n                                       int procedure,\n                                       unsigned int serial)\n{\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        procedure,\n                                        VIR_NET_STREAM,\n                                        serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamError(virNetServerProgramPtr prog,\n                                       virNetServerClientPtr client,\n                                       virNetMessagePtr msg,\n                                       virNetMessageErrorPtr rerr,\n                                       int procedure,\n                                       unsigned int serial)\n{\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        procedure,\n                                        VIR_NET_STREAM,\n                                        serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamRecv",
          "args": [
            "stream->st",
            "buffer",
            "bufferLen"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamRecvAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "845-907",
          "snippet": "int\nvirStreamRecvAll(virStreamPtr stream,\n                 virStreamSinkFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sinks cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = virStreamRecv(stream, bytes, want);\n        if (got < 0)\n            goto cleanup;\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = (handler)(stream, bytes + offset, got - offset, opaque);\n            if (done < 0) {\n                if (errno == 0)\n                    errno = EIO;\n                virReportSystemError(errno, \"%s\",\n                                     _(\"recv handler failed\"));\n                goto cleanup;\n            }\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamRecvAll(virStreamPtr stream,\n                 virStreamSinkFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sinks cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = virStreamRecv(stream, bytes, want);\n        if (got < 0)\n            goto cleanup;\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = (handler)(stream, bytes + offset, got - offset, opaque);\n            if (done < 0) {\n                if (errno == 0)\n                    errno = EIO;\n                virReportSystemError(errno, \"%s\",\n                                     _(\"recv handler failed\"));\n                goto cleanup;\n            }\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamSendHole",
          "args": [
            "stream->st",
            "length",
            "0"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamSendHole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "413-439",
          "snippet": "int\nvirStreamSendHole(virStreamPtr stream,\n                  long long length,\n                  unsigned int flags)\n{\n    VIR_DEBUG(\"stream=%p, length=%lld flags=0x%x\",\n              stream, length, flags);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamSendHole) {\n        int ret;\n        ret = (stream->driver->streamSendHole)(stream, length, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamSendHole(virStreamPtr stream,\n                  long long length,\n                  unsigned int flags)\n{\n    VIR_DEBUG(\"stream=%p, length=%lld flags=0x%x\",\n              stream, length, flags);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamSendHole) {\n        int ret;\n        ret = (stream->driver->streamSendHole)(stream, length, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamHole",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "stream->procedure",
            "stream->serial",
            "length",
            "0"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamHole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "537-569",
          "snippet": "int virNetServerProgramSendStreamHole(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      long long length,\n                                      unsigned int flags)\n{\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p msg=%p length=%lld\", client, msg, length);\n\n    memset(&data, 0, sizeof(data));\n    data.length = length;\n    data.flags = flags;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM_HOLE;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_CONTINUE;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (virNetMessageEncodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    return virNetServerClientSendMessage(client, msg);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamHole(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      long long length,\n                                      unsigned int flags)\n{\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p msg=%p length=%lld\", client, msg, length);\n\n    memset(&data, 0, sizeof(data));\n    data.length = length;\n    data.flags = flags;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM_HOLE;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_CONTINUE;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (virNetMessageEncodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    return virNetServerClientSendMessage(client, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"rv=%d inData=%d length=%lld\"",
            "rv",
            "inData",
            "length"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamInData",
          "args": [
            "stream->st",
            "&inData",
            "&length"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamInData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "512-528",
          "snippet": "int\nvirStreamInData(virStreamPtr stream,\n                int *data,\n                long long *length)\n{\n    VIR_DEBUG(\"stream=%p, data=%p, length=%p\", stream, data, length);\n\n    virResetLastError();\n    virCheckNonNullArgReturn(data, -1);\n    virCheckNonNullArgReturn(length, -1);\n\n    if (stream->driver->streamInData)\n        return (stream->driver->streamInData)(stream, data, length);\n\n    virReportUnsupportedError();\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamInData(virStreamPtr stream,\n                int *data,\n                long long *length)\n{\n    VIR_DEBUG(\"stream=%p, data=%p, length=%p\", stream, data, length);\n\n    virResetLastError();\n    virCheckNonNullArgReturn(data, -1);\n    virCheckNonNullArgReturn(length, -1);\n\n    if (stream->driver->streamInData)\n        return (stream->driver->streamInData)(stream, data, length);\n\n    virReportUnsupportedError();\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buffer",
            "bufferLen"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, stream=%p tx=%d closed=%d\"",
            "client",
            "stream",
            "stream->tx",
            "stream->closed"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream)\n{\n    virNetMessagePtr msg = NULL;\n    virNetMessageError rerr;\n    char *buffer;\n    size_t bufferLen = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    int rv;\n    int inData = 0;\n    long long length = 0;\n\n    VIR_DEBUG(\"client=%p, stream=%p tx=%d closed=%d\",\n              client, stream, stream->tx, stream->closed);\n\n    /* We might have had an event pending before we shut\n     * down the stream, so if we're marked as closed,\n     * then do nothing\n     */\n    if (stream->closed)\n        return 0;\n\n    /* Shouldn't ever be called unless we're marked able to\n     * transmit, but doesn't hurt to check */\n    if (!stream->tx)\n        return 0;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (VIR_ALLOC_N(buffer, bufferLen) < 0)\n        return -1;\n\n    if (!(msg = virNetMessageNew(false)))\n        goto cleanup;\n\n    if (stream->allowSkip && stream->dataLen == 0) {\n        /* Handle skip. We want to send some data to the client. But we might\n         * be in a hole. Seek to next data. But if we are in data already, just\n         * carry on. */\n\n        rv = virStreamInData(stream->st, &inData, &length);\n        VIR_DEBUG(\"rv=%d inData=%d length=%lld\", rv, inData, length);\n\n        if (rv < 0) {\n            if (virNetServerProgramSendStreamError(stream->prog,\n                                                   client,\n                                                   msg,\n                                                   &rerr,\n                                                   stream->procedure,\n                                                   stream->serial) < 0)\n                goto cleanup;\n            msg = NULL;\n\n            /* We're done with this call */\n            goto done;\n        } else {\n            if (!inData && length) {\n                stream->tx = false;\n                msg->cb = daemonStreamMessageFinished;\n                msg->opaque = stream;\n                stream->refs++;\n                if (virNetServerProgramSendStreamHole(stream->prog,\n                                                      client,\n                                                      msg,\n                                                      stream->procedure,\n                                                      stream->serial,\n                                                      length,\n                                                      0) < 0)\n                    goto cleanup;\n\n                msg = NULL;\n\n                /* We have successfully sent stream skip to the other side.\n                 * To keep streams in sync seek locally too. */\n                virStreamSendHole(stream->st, length, 0);\n                /* We're done with this call */\n                goto done;\n            }\n        }\n\n        stream->dataLen = length;\n    }\n\n    if (stream->allowSkip &&\n        bufferLen > stream->dataLen)\n        bufferLen = stream->dataLen;\n\n    rv = virStreamRecv(stream->st, buffer, bufferLen);\n    if (rv == -2) {\n        /* Should never get this, since we're only called when we know\n         * we're readable, but hey things change... */\n    } else if (rv < 0) {\n        if (virNetServerProgramSendStreamError(stream->prog,\n                                               client,\n                                               msg,\n                                               &rerr,\n                                               stream->procedure,\n                                               stream->serial) < 0)\n            goto cleanup;\n        msg = NULL;\n    } else {\n        if (stream->allowSkip)\n            stream->dataLen -= rv;\n\n        stream->tx = false;\n        if (rv == 0)\n            stream->recvEOF = true;\n\n        msg->cb = daemonStreamMessageFinished;\n        msg->opaque = stream;\n        stream->refs++;\n        if (virNetServerProgramSendStreamData(stream->prog,\n                                              client,\n                                              msg,\n                                              stream->procedure,\n                                              stream->serial,\n                                              buffer, rv) < 0)\n            goto cleanup;\n        msg = NULL;\n    }\n\n done:\n    ret = 0;\n cleanup:\n    VIR_FREE(buffer);\n    virNetMessageFree(msg);\n    return ret;\n}"
  },
  {
    "function_name": "daemonStreamHandleWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "744-809",
    "snippet": "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, stream=%p\", client, stream);\n\n    while (stream->rx && !stream->closed) {\n        virNetMessagePtr msg = stream->rx;\n        int ret;\n\n        if (msg->header.type == VIR_NET_STREAM_HOLE) {\n            /* Handle special case when the client sent us a hole.\n             * Otherwise just carry on with processing stream\n             * data. */\n            ret = daemonStreamHandleHole(client, stream, msg);\n        } else if (msg->header.type == VIR_NET_STREAM) {\n            switch (msg->header.status) {\n            case VIR_NET_OK:\n                ret = daemonStreamHandleFinish(client, stream, msg);\n                break;\n\n            case VIR_NET_CONTINUE:\n                ret = daemonStreamHandleWriteData(client, stream, msg);\n                break;\n\n            case VIR_NET_ERROR:\n            default:\n                ret = daemonStreamHandleAbort(client, stream, msg);\n                break;\n            }\n        } else {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Unexpected message type: %d\"),\n                           msg->header.type);\n            ret = -1;\n        }\n\n        if (ret > 0)\n            break;  /* still processing data from msg */\n\n        virNetMessageQueueServe(&stream->rx);\n        if (ret < 0) {\n            virNetMessageFree(msg);\n            virNetServerClientImmediateClose(client);\n            return -1;\n        }\n\n        /* 'CONTINUE' messages don't send a reply (unless error\n         * occurred), so to release the 'msg' object we need to\n         * send a fake zero-length reply. Nothing actually gets\n         * onto the wire, but this causes the client to reset\n         * its active request count / throttling\n         */\n        if (msg->header.status == VIR_NET_CONTINUE) {\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetMessageFree(msg);\n                virNetServerClientImmediateClose(client);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientImmediateClose",
          "args": [
            "client"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientImmediateClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1083-1088",
          "snippet": "void virNetServerClientImmediateClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    client->wantClose = true;\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid virNetServerClientImmediateClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    client->wantClose = true;\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageClear",
          "args": [
            "msg"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "69-78",
          "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueueServe",
          "args": [
            "&stream->rx"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueueServe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "109-119",
          "snippet": "virNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Unexpected message type: %d\")",
            "msg->header.type"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected message type: %d\""
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleAbort",
          "args": [
            "client",
            "stream",
            "msg"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "646-687",
          "snippet": "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg)\n{\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n    int ret;\n    bool raise_error = false;\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamAbort(stream->st);\n\n    if (msg->header.status == VIR_NET_ERROR) {\n        VIR_INFO(\"stream aborted at client request\");\n        raise_error = (ret < 0);\n    } else {\n        virReportError(VIR_ERR_RPC,\n                       _(\"stream aborted with unexpected status %d\"),\n                       msg->header.status);\n        raise_error = true;\n    }\n\n    if (raise_error) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg)\n{\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n    int ret;\n    bool raise_error = false;\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamAbort(stream->st);\n\n    if (msg->header.status == VIR_NET_ERROR) {\n        VIR_INFO(\"stream aborted at client request\");\n        raise_error = (ret < 0);\n    } else {\n        virReportError(VIR_ERR_RPC,\n                       _(\"stream aborted with unexpected status %d\"),\n                       msg->header.status);\n        raise_error = true;\n    }\n\n    if (raise_error) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleWriteData",
          "args": [
            "client",
            "stream",
            "msg"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleWriteData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "549-596",
          "snippet": "static int\ndaemonStreamHandleWriteData(virNetServerClientPtr client,\n                            daemonClientStream *stream,\n                            virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u, len=%zu, offset=%zu\",\n              client, stream, msg->header.proc, msg->header.serial,\n              msg->bufferLength, msg->bufferOffset);\n\n    ret = virStreamSend(stream->st,\n                        msg->buffer + msg->bufferOffset,\n                        msg->bufferLength - msg->bufferOffset);\n\n    if (ret > 0) {\n        msg->bufferOffset += ret;\n\n        /* Partial write, so indicate we have more todo later */\n        if (msg->bufferOffset < msg->bufferLength)\n            return 1;\n    } else if (ret == -2) {\n        /* Blocking, so indicate we have more todo later */\n        return 1;\n    } else if (ret < 0) {\n        virNetMessageError rerr;\n        virErrorPtr err;\n\n        virErrorPreserveLast(&err);\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        virErrorRestore(&err);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleWriteData(virNetServerClientPtr client,\n                            daemonClientStream *stream,\n                            virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u, len=%zu, offset=%zu\",\n              client, stream, msg->header.proc, msg->header.serial,\n              msg->bufferLength, msg->bufferOffset);\n\n    ret = virStreamSend(stream->st,\n                        msg->buffer + msg->bufferOffset,\n                        msg->bufferLength - msg->bufferOffset);\n\n    if (ret > 0) {\n        msg->bufferOffset += ret;\n\n        /* Partial write, so indicate we have more todo later */\n        if (msg->bufferOffset < msg->bufferLength)\n            return 1;\n    } else if (ret == -2) {\n        /* Blocking, so indicate we have more todo later */\n        return 1;\n    } else if (ret < 0) {\n        virNetMessageError rerr;\n        virErrorPtr err;\n\n        virErrorPreserveLast(&err);\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        virErrorRestore(&err);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleFinish",
          "args": [
            "client",
            "stream",
            "msg"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "607-638",
          "snippet": "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamFinish(stream->st);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamFinish(stream->st);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleHole",
          "args": [
            "client",
            "stream",
            "msg"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleHole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "690-734",
          "snippet": "static int\ndaemonStreamHandleHole(virNetServerClientPtr client,\n                       daemonClientStream *stream,\n                       virNetMessagePtr msg)\n{\n    int ret;\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    /* Let's check if client plays nicely and advertised usage of\n     * sparse stream upfront. */\n    if (!stream->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        return -1;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t) xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    ret = virStreamSendHole(stream->st, data.length, data.flags);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send hole failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleHole(virNetServerClientPtr client,\n                       daemonClientStream *stream,\n                       virNetMessagePtr msg)\n{\n    int ret;\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    /* Let's check if client plays nicely and advertised usage of\n     * sparse stream upfront. */\n    if (!stream->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        return -1;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t) xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    ret = virStreamSendHole(stream->st, data.length, data.flags);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send hole failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, stream=%p\"",
            "client",
            "stream"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, stream=%p\", client, stream);\n\n    while (stream->rx && !stream->closed) {\n        virNetMessagePtr msg = stream->rx;\n        int ret;\n\n        if (msg->header.type == VIR_NET_STREAM_HOLE) {\n            /* Handle special case when the client sent us a hole.\n             * Otherwise just carry on with processing stream\n             * data. */\n            ret = daemonStreamHandleHole(client, stream, msg);\n        } else if (msg->header.type == VIR_NET_STREAM) {\n            switch (msg->header.status) {\n            case VIR_NET_OK:\n                ret = daemonStreamHandleFinish(client, stream, msg);\n                break;\n\n            case VIR_NET_CONTINUE:\n                ret = daemonStreamHandleWriteData(client, stream, msg);\n                break;\n\n            case VIR_NET_ERROR:\n            default:\n                ret = daemonStreamHandleAbort(client, stream, msg);\n                break;\n            }\n        } else {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Unexpected message type: %d\"),\n                           msg->header.type);\n            ret = -1;\n        }\n\n        if (ret > 0)\n            break;  /* still processing data from msg */\n\n        virNetMessageQueueServe(&stream->rx);\n        if (ret < 0) {\n            virNetMessageFree(msg);\n            virNetServerClientImmediateClose(client);\n            return -1;\n        }\n\n        /* 'CONTINUE' messages don't send a reply (unless error\n         * occurred), so to release the 'msg' object we need to\n         * send a fake zero-length reply. Nothing actually gets\n         * onto the wire, but this causes the client to reset\n         * its active request count / throttling\n         */\n        if (msg->header.status == VIR_NET_CONTINUE) {\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetMessageFree(msg);\n                virNetServerClientImmediateClose(client);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "daemonStreamHandleHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "690-734",
    "snippet": "static int\ndaemonStreamHandleHole(virNetServerClientPtr client,\n                       daemonClientStream *stream,\n                       virNetMessagePtr msg)\n{\n    int ret;\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    /* Let's check if client plays nicely and advertised usage of\n     * sparse stream upfront. */\n    if (!stream->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        return -1;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t) xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    ret = virStreamSendHole(stream->st, data.length, data.flags);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send hole failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendReplyError",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "&rerr",
            "&msg->header"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendReplyError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "188-207",
          "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "stream->st"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Stream send hole failed\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamSendHole",
          "args": [
            "stream->st",
            "data.length",
            "data.flags"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamSendHole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "413-439",
          "snippet": "int\nvirStreamSendHole(virStreamPtr stream,\n                  long long length,\n                  unsigned int flags)\n{\n    VIR_DEBUG(\"stream=%p, length=%lld flags=0x%x\",\n              stream, length, flags);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamSendHole) {\n        int ret;\n        ret = (stream->driver->streamSendHole)(stream, length, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamSendHole(virStreamPtr stream,\n                  long long length,\n                  unsigned int flags)\n{\n    VIR_DEBUG(\"stream=%p, length=%lld flags=0x%x\",\n              stream, length, flags);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamSendHole) {\n        int ret;\n        ret = (stream->driver->streamSendHole)(stream, length, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "(xdrproc_t) xdr_virNetStreamHole",
            "&data"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unexpected stream hole\")"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected stream hole\""
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, stream=%p, proc=%d, serial=%u\"",
            "client",
            "stream",
            "msg->header.proc",
            "msg->header.serial"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleHole(virNetServerClientPtr client,\n                       daemonClientStream *stream,\n                       virNetMessagePtr msg)\n{\n    int ret;\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    /* Let's check if client plays nicely and advertised usage of\n     * sparse stream upfront. */\n    if (!stream->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        return -1;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t) xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    ret = virStreamSendHole(stream->st, data.length, data.flags);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send hole failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "daemonStreamHandleAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "646-687",
    "snippet": "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg)\n{\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n    int ret;\n    bool raise_error = false;\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamAbort(stream->st);\n\n    if (msg->header.status == VIR_NET_ERROR) {\n        VIR_INFO(\"stream aborted at client request\");\n        raise_error = (ret < 0);\n    } else {\n        virReportError(VIR_ERR_RPC,\n                       _(\"stream aborted with unexpected status %d\"),\n                       msg->header.status);\n        raise_error = true;\n    }\n\n    if (raise_error) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamData",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "stream->procedure",
            "stream->serial",
            "NULL",
            "0"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "495-534",
          "snippet": "int virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendReplyError",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "&rerr",
            "&msg->header"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendReplyError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "188-207",
          "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"stream aborted with unexpected status %d\")",
            "msg->header.status"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"stream aborted with unexpected status %d\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"stream aborted at client request\""
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "stream->st"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, stream=%p, proc=%d, serial=%u\"",
            "client",
            "stream",
            "msg->header.proc",
            "msg->header.serial"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg)\n{\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n    int ret;\n    bool raise_error = false;\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamAbort(stream->st);\n\n    if (msg->header.status == VIR_NET_ERROR) {\n        VIR_INFO(\"stream aborted at client request\");\n        raise_error = (ret < 0);\n    } else {\n        virReportError(VIR_ERR_RPC,\n                       _(\"stream aborted with unexpected status %d\"),\n                       msg->header.status);\n        raise_error = true;\n    }\n\n    if (raise_error) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}"
  },
  {
    "function_name": "daemonStreamHandleFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "607-638",
    "snippet": "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamFinish(stream->st);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamData",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "stream->procedure",
            "stream->serial",
            "NULL",
            "0"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "495-534",
          "snippet": "int virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendReplyError",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "&rerr",
            "&msg->header"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendReplyError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "188-207",
          "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamFinish",
          "args": [
            "stream->st"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1179-1202",
          "snippet": "int\nvirStreamFinish(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamFinish) {\n        int ret;\n        ret = (stream->driver->streamFinish)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamFinish(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamFinish) {\n        int ret;\n        ret = (stream->driver->streamFinish)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, stream=%p, proc=%d, serial=%u\"",
            "client",
            "stream",
            "msg->header.proc",
            "msg->header.serial"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamFinish(stream->st);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}"
  },
  {
    "function_name": "daemonStreamHandleWriteData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "549-596",
    "snippet": "static int\ndaemonStreamHandleWriteData(virNetServerClientPtr client,\n                            daemonClientStream *stream,\n                            virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u, len=%zu, offset=%zu\",\n              client, stream, msg->header.proc, msg->header.serial,\n              msg->bufferLength, msg->bufferOffset);\n\n    ret = virStreamSend(stream->st,\n                        msg->buffer + msg->bufferOffset,\n                        msg->bufferLength - msg->bufferOffset);\n\n    if (ret > 0) {\n        msg->bufferOffset += ret;\n\n        /* Partial write, so indicate we have more todo later */\n        if (msg->bufferOffset < msg->bufferLength)\n            return 1;\n    } else if (ret == -2) {\n        /* Blocking, so indicate we have more todo later */\n        return 1;\n    } else if (ret < 0) {\n        virNetMessageError rerr;\n        virErrorPtr err;\n\n        virErrorPreserveLast(&err);\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        virErrorRestore(&err);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendReplyError",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "&rerr",
            "&msg->header"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendReplyError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "188-207",
          "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "stream->st"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Stream send failed\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamSend",
          "args": [
            "stream->st",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamSendAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "571-631",
          "snippet": "int\nvirStreamSendAll(virStreamPtr stream,\n                 virStreamSourceFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sources cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = (handler)(stream, bytes, want, opaque);\n        if (got < 0) {\n            if (errno == 0)\n                errno = EIO;\n            virReportSystemError(errno, \"%s\", _(\"send handler failed\"));\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = virStreamSend(stream, bytes + offset, got - offset);\n            if (done < 0)\n                goto cleanup;\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamSendAll(virStreamPtr stream,\n                 virStreamSourceFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sources cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = (handler)(stream, bytes, want, opaque);\n        if (got < 0) {\n            if (errno == 0)\n                errno = EIO;\n            virReportSystemError(errno, \"%s\", _(\"send handler failed\"));\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = virStreamSend(stream, bytes + offset, got - offset);\n            if (done < 0)\n                goto cleanup;\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, stream=%p, proc=%d, serial=%u, len=%zu, offset=%zu\"",
            "client",
            "stream",
            "msg->header.proc",
            "msg->header.serial",
            "msg->bufferLength",
            "msg->bufferOffset"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleWriteData(virNetServerClientPtr client,\n                            daemonClientStream *stream,\n                            virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u, len=%zu, offset=%zu\",\n              client, stream, msg->header.proc, msg->header.serial,\n              msg->bufferLength, msg->bufferOffset);\n\n    ret = virStreamSend(stream->st,\n                        msg->buffer + msg->bufferOffset,\n                        msg->bufferLength - msg->bufferOffset);\n\n    if (ret > 0) {\n        msg->bufferOffset += ret;\n\n        /* Partial write, so indicate we have more todo later */\n        if (msg->bufferOffset < msg->bufferLength)\n            return 1;\n    } else if (ret == -2) {\n        /* Blocking, so indicate we have more todo later */\n        return 1;\n    } else if (ret < 0) {\n        virNetMessageError rerr;\n        virErrorPtr err;\n\n        virErrorPreserveLast(&err);\n\n        memset(&rerr, 0, sizeof(rerr));\n\n        VIR_INFO(\"Stream send failed\");\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n\n        virErrorRestore(&err);\n\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "daemonRemoveAllClientStreams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "520-541",
    "snippet": "void\ndaemonRemoveAllClientStreams(daemonClientStream *stream)\n{\n    daemonClientStream *tmp;\n\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    while (stream) {\n        tmp = stream->next;\n\n        if (!stream->closed) {\n            stream->closed = true;\n            virStreamEventRemoveCallback(stream->st);\n            virStreamAbort(stream->st);\n        }\n\n        daemonFreeClientStream(NULL, stream);\n\n        VIR_DEBUG(\"next stream=%p\", tmp);\n        stream = tmp;\n    }\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"next stream=%p\"",
            "tmp"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemonFreeClientStream",
          "args": [
            "NULL",
            "stream"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "daemonFreeClientStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "386-426",
          "snippet": "int daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nint daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "stream->st"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"stream=%p\"",
            "stream"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nvoid\ndaemonRemoveAllClientStreams(daemonClientStream *stream)\n{\n    daemonClientStream *tmp;\n\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    while (stream) {\n        tmp = stream->next;\n\n        if (!stream->closed) {\n            stream->closed = true;\n            virStreamEventRemoveCallback(stream->st);\n            virStreamAbort(stream->st);\n        }\n\n        daemonFreeClientStream(NULL, stream);\n\n        VIR_DEBUG(\"next stream=%p\", tmp);\n        stream = tmp;\n    }\n}"
  },
  {
    "function_name": "daemonRemoveClientStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "483-517",
    "snippet": "int\ndaemonRemoveClientStream(virNetServerClientPtr client,\n                         daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p\",\n              client, stream->procedure, stream->serial, stream->st);\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n    daemonClientStream *curr = priv->streams;\n    daemonClientStream *prev = NULL;\n\n    if (stream->filterID != -1) {\n        virNetServerClientRemoveFilter(client,\n                                       stream->filterID);\n        stream->filterID = -1;\n    }\n\n    if (!stream->closed) {\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n    }\n\n    while (curr) {\n        if (curr == stream) {\n            if (prev)\n                prev->next = curr->next;\n            else\n                priv->streams = curr->next;\n            return daemonFreeClientStream(client, stream);\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "daemonFreeClientStream",
          "args": [
            "client",
            "stream"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "daemonFreeClientStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "386-426",
          "snippet": "int daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nint daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "stream->st"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientRemoveFilter",
          "args": [
            "client",
            "stream->filterID"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientRemoveFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "264-288",
          "snippet": "void virNetServerClientRemoveFilter(virNetServerClientPtr client,\n                                    int filterID)\n{\n    virNetServerClientFilterPtr tmp, prev;\n\n    virObjectLock(client);\n\n    prev = NULL;\n    tmp = client->filters;\n    while (tmp) {\n        if (tmp->id == filterID) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                client->filters = tmp->next;\n\n            VIR_FREE(tmp);\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid virNetServerClientRemoveFilter(virNetServerClientPtr client,\n                                    int filterID)\n{\n    virNetServerClientFilterPtr tmp, prev;\n\n    virObjectLock(client);\n\n    prev = NULL;\n    tmp = client->filters;\n    while (tmp) {\n        if (tmp->id == filterID) {\n            if (prev)\n                prev->next = tmp->next;\n            else\n                client->filters = tmp->next;\n\n            VIR_FREE(tmp);\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, proc=%d, serial=%u, st=%p\"",
            "client",
            "stream->procedure",
            "stream->serial",
            "stream->st"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nint\ndaemonRemoveClientStream(virNetServerClientPtr client,\n                         daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p\",\n              client, stream->procedure, stream->serial, stream->st);\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n    daemonClientStream *curr = priv->streams;\n    daemonClientStream *prev = NULL;\n\n    if (stream->filterID != -1) {\n        virNetServerClientRemoveFilter(client,\n                                       stream->filterID);\n        stream->filterID = -1;\n    }\n\n    if (!stream->closed) {\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n    }\n\n    while (curr) {\n        if (curr == stream) {\n            if (prev)\n                prev->next = curr->next;\n            else\n                priv->streams = curr->next;\n            return daemonFreeClientStream(client, stream);\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "daemonAddClientStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "433-472",
    "snippet": "int daemonAddClientStream(virNetServerClientPtr client,\n                          daemonClientStream *stream,\n                          bool transmit)\n{\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p, transmit=%d\",\n              client, stream->procedure, stream->serial, stream->st, transmit);\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n\n    if (stream->filterID != -1) {\n        VIR_WARN(\"Filter already added to client %p\", client);\n        return -1;\n    }\n\n    if (virStreamEventAddCallback(stream->st, 0,\n                                  daemonStreamEvent, client,\n                                  virObjectFreeCallback) < 0)\n        return -1;\n\n    virObjectRef(client);\n\n    if ((stream->filterID = virNetServerClientAddFilter(client,\n                                                        daemonStreamFilter,\n                                                        stream)) < 0) {\n        virStreamEventRemoveCallback(stream->st);\n        return -1;\n    }\n\n    if (transmit)\n        stream->tx = true;\n\n    virMutexLock(&priv->lock);\n    stream->next = priv->streams;\n    priv->streams = stream;\n\n    daemonStreamUpdateEvents(stream);\n\n    virMutexUnlock(&priv->lock);\n\n    return 0;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamUpdateEvents",
          "args": [
            "stream"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamUpdateEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "77-89",
          "snippet": "static void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nstatic void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientAddFilter",
          "args": [
            "client",
            "daemonStreamFilter",
            "stream"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientAddFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "235-262",
          "snippet": "int virNetServerClientAddFilter(virNetServerClientPtr client,\n                                virNetServerClientFilterFunc func,\n                                void *opaque)\n{\n    virNetServerClientFilterPtr filter;\n    virNetServerClientFilterPtr *place;\n    int ret;\n\n    if (VIR_ALLOC(filter) < 0)\n        return -1;\n\n    virObjectLock(client);\n\n    filter->id = client->nextFilterID++;\n    filter->func = func;\n    filter->opaque = opaque;\n\n    place = &client->filters;\n    while (*place)\n        place = &(*place)->next;\n    *place = filter;\n\n    ret = filter->id;\n\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientDispatchEvent(virNetSocketPtr sock, int events, void *opaque);",
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientDispatchEvent(virNetSocketPtr sock, int events, void *opaque);\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint virNetServerClientAddFilter(virNetServerClientPtr client,\n                                virNetServerClientFilterFunc func,\n                                void *opaque)\n{\n    virNetServerClientFilterPtr filter;\n    virNetServerClientFilterPtr *place;\n    int ret;\n\n    if (VIR_ALLOC(filter) < 0)\n        return -1;\n\n    virObjectLock(client);\n\n    filter->id = client->nextFilterID++;\n    filter->func = func;\n    filter->opaque = opaque;\n\n    place = &client->filters;\n    while (*place)\n        place = &(*place)->next;\n    *place = filter;\n\n    ret = filter->id;\n\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "client"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventAddCallback",
          "args": [
            "stream->st",
            "0",
            "daemonStreamEvent",
            "client",
            "virObjectFreeCallback"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventAddCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1057-1085",
          "snippet": "int\nvirStreamEventAddCallback(virStreamPtr stream,\n                          int events,\n                          virStreamEventCallback cb,\n                          void *opaque,\n                          virFreeCallback ff)\n{\n    VIR_DEBUG(\"stream=%p, events=%d, cb=%p, opaque=%p, ff=%p\",\n              stream, events, cb, opaque, ff);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventAddCallback) {\n        int ret;\n        ret = (stream->driver->streamEventAddCallback)(stream, events, cb, opaque, ff);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventAddCallback(virStreamPtr stream,\n                          int events,\n                          virStreamEventCallback cb,\n                          void *opaque,\n                          virFreeCallback ff)\n{\n    VIR_DEBUG(\"stream=%p, events=%d, cb=%p, opaque=%p, ff=%p\",\n              stream, events, cb, opaque, ff);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventAddCallback) {\n        int ret;\n        ret = (stream->driver->streamEventAddCallback)(stream, events, cb, opaque, ff);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Filter already added to client %p\"",
            "client"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, proc=%d, serial=%u, st=%p, transmit=%d\"",
            "client",
            "stream->procedure",
            "stream->serial",
            "stream->st",
            "transmit"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nint daemonAddClientStream(virNetServerClientPtr client,\n                          daemonClientStream *stream,\n                          bool transmit)\n{\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p, transmit=%d\",\n              client, stream->procedure, stream->serial, stream->st, transmit);\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n\n    if (stream->filterID != -1) {\n        VIR_WARN(\"Filter already added to client %p\", client);\n        return -1;\n    }\n\n    if (virStreamEventAddCallback(stream->st, 0,\n                                  daemonStreamEvent, client,\n                                  virObjectFreeCallback) < 0)\n        return -1;\n\n    virObjectRef(client);\n\n    if ((stream->filterID = virNetServerClientAddFilter(client,\n                                                        daemonStreamFilter,\n                                                        stream)) < 0) {\n        virStreamEventRemoveCallback(stream->st);\n        return -1;\n    }\n\n    if (transmit)\n        stream->tx = true;\n\n    virMutexLock(&priv->lock);\n    stream->next = priv->streams;\n    priv->streams = stream;\n\n    daemonStreamUpdateEvents(stream);\n\n    virMutexUnlock(&priv->lock);\n\n    return 0;\n}"
  },
  {
    "function_name": "daemonFreeClientStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "386-426",
    "snippet": "int daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stream"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "stream->st"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientImmediateClose",
          "args": [
            "client"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientImmediateClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1083-1088",
          "snippet": "void virNetServerClientImmediateClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    client->wantClose = true;\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid virNetServerClientImmediateClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    client->wantClose = true;\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageClear",
          "args": [
            "msg"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "69-78",
          "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, proc=%d, serial=%u\"",
            "client",
            "stream->procedure",
            "stream->serial"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nint daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}"
  },
  {
    "function_name": "daemonCreateClientStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "352-378",
    "snippet": "daemonClientStream *\ndaemonCreateClientStream(virNetServerClientPtr client,\n                         virStreamPtr st,\n                         virNetServerProgramPtr prog,\n                         virNetMessageHeaderPtr header,\n                         bool allowSkip)\n{\n    daemonClientStream *stream;\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p\",\n              client, header->proc, header->serial, st);\n\n    if (VIR_ALLOC(stream) < 0)\n        return NULL;\n\n    stream->refs = 1;\n    stream->priv = priv;\n    stream->prog = virObjectRef(prog);\n    stream->procedure = header->proc;\n    stream->serial = header->serial;\n    stream->filterID = -1;\n    stream->st = st;\n    stream->allowSkip = allowSkip;\n\n    return stream;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "prog"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "stream"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p, proc=%d, serial=%u, st=%p\"",
            "client",
            "header->proc",
            "header->serial",
            "st"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\ndaemonClientStream *\ndaemonCreateClientStream(virNetServerClientPtr client,\n                         virStreamPtr st,\n                         virNetServerProgramPtr prog,\n                         virNetMessageHeaderPtr header,\n                         bool allowSkip)\n{\n    daemonClientStream *stream;\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p\",\n              client, header->proc, header->serial, st);\n\n    if (VIR_ALLOC(stream) < 0)\n        return NULL;\n\n    stream->refs = 1;\n    stream->priv = priv;\n    stream->prog = virObjectRef(prog);\n    stream->procedure = header->proc;\n    stream->serial = header->serial;\n    stream->filterID = -1;\n    stream->st = st;\n    stream->allowSkip = allowSkip;\n\n    return stream;\n}"
  },
  {
    "function_name": "daemonStreamFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "288-341",
    "snippet": "static int\ndaemonStreamFilter(virNetServerClientPtr client,\n                   virNetMessagePtr msg,\n                   void *opaque)\n{\n    daemonClientStream *stream = opaque;\n    int ret = 0;\n\n    /* We must honour lock ordering here. Client private data lock must\n     * be acquired before client lock. Bu we are already called with\n     * client locked. To avoid stream disappearing while we unlock\n     * everything, let's increase its refcounter. This has some\n     * implications though. */\n    stream->refs++;\n    virObjectUnlock(client);\n    virMutexLock(&stream->priv->lock);\n    virObjectLock(client);\n\n    if (stream->refs == 1) {\n        /* So we are the only ones holding the reference to the stream.\n         * Return 1 to signal to the caller that we've processed the\n         * message. And to \"process\" means free. */\n        virNetMessageFree(msg);\n        ret = 1;\n        goto cleanup;\n    }\n\n    if (msg->header.type != VIR_NET_STREAM &&\n        msg->header.type != VIR_NET_STREAM_HOLE)\n        goto cleanup;\n\n    if (!virNetServerProgramMatches(stream->prog, msg))\n        goto cleanup;\n\n    if (msg->header.proc != stream->procedure ||\n        msg->header.serial != stream->serial)\n        goto cleanup;\n\n    VIR_DEBUG(\"Incoming client=%p, rx=%p, serial=%u, proc=%d, status=%d\",\n              client, stream->rx, msg->header.proc,\n              msg->header.serial, msg->header.status);\n\n    virNetMessageQueuePush(&stream->rx, msg);\n    daemonStreamUpdateEvents(stream);\n    ret = 1;\n\n cleanup:\n    virMutexUnlock(&stream->priv->lock);\n    /* Don't pass client here, because client is locked here and this\n     * function might try to lock it again which would result in a\n     * deadlock. */\n    daemonFreeClientStream(NULL, stream);\n    return ret;\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "daemonFreeClientStream",
          "args": [
            "NULL",
            "stream"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "daemonFreeClientStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "386-426",
          "snippet": "int daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nint daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&stream->priv->lock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamUpdateEvents",
          "args": [
            "stream"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamUpdateEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "77-89",
          "snippet": "static void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nstatic void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueuePush",
          "args": [
            "&stream->rx",
            "msg"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueuePush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "95-106",
          "snippet": "void virNetMessageQueuePush(virNetMessagePtr *queue, virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        while (tmp->next)\n            tmp = tmp->next;\n        tmp->next = msg;\n    } else {\n        *queue = msg;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageQueuePush(virNetMessagePtr *queue, virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        while (tmp->next)\n            tmp = tmp->next;\n        tmp->next = msg;\n    } else {\n        *queue = msg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Incoming client=%p, rx=%p, serial=%u, proc=%d, status=%d\"",
            "client",
            "stream->rx",
            "msg->header.proc",
            "msg->header.serial",
            "msg->header.status"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerProgramMatches",
          "args": [
            "stream->prog",
            "msg"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramMatches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "97-104",
          "snippet": "int virNetServerProgramMatches(virNetServerProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramMatches(virNetServerProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&stream->priv->lock"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "client"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamFilter(virNetServerClientPtr client,\n                   virNetMessagePtr msg,\n                   void *opaque)\n{\n    daemonClientStream *stream = opaque;\n    int ret = 0;\n\n    /* We must honour lock ordering here. Client private data lock must\n     * be acquired before client lock. Bu we are already called with\n     * client locked. To avoid stream disappearing while we unlock\n     * everything, let's increase its refcounter. This has some\n     * implications though. */\n    stream->refs++;\n    virObjectUnlock(client);\n    virMutexLock(&stream->priv->lock);\n    virObjectLock(client);\n\n    if (stream->refs == 1) {\n        /* So we are the only ones holding the reference to the stream.\n         * Return 1 to signal to the caller that we've processed the\n         * message. And to \"process\" means free. */\n        virNetMessageFree(msg);\n        ret = 1;\n        goto cleanup;\n    }\n\n    if (msg->header.type != VIR_NET_STREAM &&\n        msg->header.type != VIR_NET_STREAM_HOLE)\n        goto cleanup;\n\n    if (!virNetServerProgramMatches(stream->prog, msg))\n        goto cleanup;\n\n    if (msg->header.proc != stream->procedure ||\n        msg->header.serial != stream->serial)\n        goto cleanup;\n\n    VIR_DEBUG(\"Incoming client=%p, rx=%p, serial=%u, proc=%d, status=%d\",\n              client, stream->rx, msg->header.proc,\n              msg->header.serial, msg->header.status);\n\n    virNetMessageQueuePush(&stream->rx, msg);\n    daemonStreamUpdateEvents(stream);\n    ret = 1;\n\n cleanup:\n    virMutexUnlock(&stream->priv->lock);\n    /* Don't pass client here, because client is locked here and this\n     * function might try to lock it again which would result in a\n     * deadlock. */\n    daemonFreeClientStream(NULL, stream);\n    return ret;\n}"
  },
  {
    "function_name": "daemonStreamEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "116-277",
    "snippet": "static void\ndaemonStreamEvent(virStreamPtr st, int events, void *opaque)\n{\n    virNetServerClientPtr client = opaque;\n    daemonClientStream *stream;\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n\n    virMutexLock(&priv->lock);\n\n    stream = priv->streams;\n    while (stream) {\n        if (stream->st == st)\n            break;\n        stream = stream->next;\n    }\n\n    if (!stream) {\n        VIR_WARN(\"event for client=%p stream st=%p, but missing stream state\", client, st);\n        virStreamEventRemoveCallback(st);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"st=%p events=%d EOF=%d closed=%d\", st, events, stream->recvEOF, stream->closed);\n\n    if (!stream->closed &&\n        (events & VIR_STREAM_EVENT_WRITABLE)) {\n        if (daemonStreamHandleWrite(client, stream) < 0) {\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n    }\n\n    if (!stream->closed && !stream->recvEOF &&\n        (events & (VIR_STREAM_EVENT_READABLE))) {\n        events = events & ~(VIR_STREAM_EVENT_READABLE);\n        if (daemonStreamHandleRead(client, stream) < 0) {\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n        /* If we detected EOF during read processing,\n         * then clear hangup/error conditions, since\n         * we want the client to see the EOF message\n         * we just sent them\n         */\n        if (stream->recvEOF)\n            events = events & ~(VIR_STREAM_EVENT_HANGUP |\n                                VIR_STREAM_EVENT_ERROR);\n    }\n\n    /* If we have a completion/abort message, always process it */\n    if (stream->rx) {\n        virNetMessagePtr msg = stream->rx;\n        switch (msg->header.status) {\n        case VIR_NET_CONTINUE:\n            /* nada */\n            break;\n        case VIR_NET_OK:\n            virNetMessageQueueServe(&stream->rx);\n            if (daemonStreamHandleFinish(client, stream, msg) < 0) {\n                virNetMessageFree(msg);\n                daemonRemoveClientStream(client, stream);\n                virNetServerClientClose(client);\n                goto cleanup;\n            }\n            break;\n        case VIR_NET_ERROR:\n        default:\n            virNetMessageQueueServe(&stream->rx);\n            if (daemonStreamHandleAbort(client, stream, msg) < 0) {\n                virNetMessageFree(msg);\n                daemonRemoveClientStream(client, stream);\n                virNetServerClientClose(client);\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n\n    /* If we got HANGUP, we need to only send an empty\n     * packet so the client sees an EOF and cleans up\n     */\n    if (!stream->closed && !stream->recvEOF &&\n        (events & VIR_STREAM_EVENT_HANGUP)) {\n        virNetMessagePtr msg;\n        events &= ~(VIR_STREAM_EVENT_HANGUP);\n        stream->tx = false;\n        stream->recvEOF = true;\n        if (!(msg = virNetMessageNew(false))) {\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n        msg->cb = daemonStreamMessageFinished;\n        msg->opaque = stream;\n        stream->refs++;\n        if (virNetServerProgramSendStreamData(stream->prog,\n                                              client,\n                                              msg,\n                                              stream->procedure,\n                                              stream->serial,\n                                              \"\", 0) < 0) {\n            virNetMessageFree(msg);\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n    }\n\n    if (!stream->closed &&\n        (events & (VIR_STREAM_EVENT_ERROR | VIR_STREAM_EVENT_HANGUP))) {\n        int ret;\n        virNetMessagePtr msg;\n        virNetMessageError rerr;\n        virErrorPtr origErr;\n\n        virErrorPreserveLast(&origErr);\n\n        memset(&rerr, 0, sizeof(rerr));\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n        if (origErr && origErr->code != VIR_ERR_OK) {\n            virErrorRestore(&origErr);\n        } else {\n            virFreeError(origErr);\n            if (events & VIR_STREAM_EVENT_HANGUP)\n                virReportError(VIR_ERR_RPC,\n                               \"%s\", _(\"stream had unexpected termination\"));\n            else\n                virReportError(VIR_ERR_RPC,\n                               \"%s\", _(\"stream had I/O failure\"));\n        }\n\n        msg = virNetMessageNew(false);\n        if (!msg) {\n            ret = -1;\n        } else {\n            ret = virNetServerProgramSendStreamError(stream->prog,\n                                                     client,\n                                                     msg,\n                                                     &rerr,\n                                                     stream->procedure,\n                                                     stream->serial);\n        }\n        daemonRemoveClientStream(client, stream);\n        if (ret < 0)\n            virNetServerClientClose(client);\n        goto cleanup;\n    }\n\n    if (stream->closed) {\n        daemonRemoveClientStream(client, stream);\n    } else {\n        daemonStreamUpdateEvents(stream);\n    }\n\n cleanup:\n    virMutexUnlock(&priv->lock);\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&priv->lock"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamUpdateEvents",
          "args": [
            "stream"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamUpdateEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "77-89",
          "snippet": "static void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nstatic void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonRemoveClientStream",
          "args": [
            "client",
            "stream"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "daemonRemoveClientStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "483-517",
          "snippet": "int\ndaemonRemoveClientStream(virNetServerClientPtr client,\n                         daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p\",\n              client, stream->procedure, stream->serial, stream->st);\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n    daemonClientStream *curr = priv->streams;\n    daemonClientStream *prev = NULL;\n\n    if (stream->filterID != -1) {\n        virNetServerClientRemoveFilter(client,\n                                       stream->filterID);\n        stream->filterID = -1;\n    }\n\n    if (!stream->closed) {\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n    }\n\n    while (curr) {\n        if (curr == stream) {\n            if (prev)\n                prev->next = curr->next;\n            else\n                priv->streams = curr->next;\n            return daemonFreeClientStream(client, stream);\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nint\ndaemonRemoveClientStream(virNetServerClientPtr client,\n                         daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u, st=%p\",\n              client, stream->procedure, stream->serial, stream->st);\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n    daemonClientStream *curr = priv->streams;\n    daemonClientStream *prev = NULL;\n\n    if (stream->filterID != -1) {\n        virNetServerClientRemoveFilter(client,\n                                       stream->filterID);\n        stream->filterID = -1;\n    }\n\n    if (!stream->closed) {\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n    }\n\n    while (curr) {\n        if (curr == stream) {\n            if (prev)\n                prev->next = curr->next;\n            else\n                priv->streams = curr->next;\n            return daemonFreeClientStream(client, stream);\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientClose",
          "args": [
            "client"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1060-1066",
          "snippet": "void\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamError",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "&rerr",
            "stream->procedure",
            "stream->serial"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "210-225",
          "snippet": "int virNetServerProgramSendStreamError(virNetServerProgramPtr prog,\n                                       virNetServerClientPtr client,\n                                       virNetMessagePtr msg,\n                                       virNetMessageErrorPtr rerr,\n                                       int procedure,\n                                       unsigned int serial)\n{\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        procedure,\n                                        VIR_NET_STREAM,\n                                        serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamError(virNetServerProgramPtr prog,\n                                       virNetServerClientPtr client,\n                                       virNetMessagePtr msg,\n                                       virNetMessageErrorPtr rerr,\n                                       int procedure,\n                                       unsigned int serial)\n{\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        procedure,\n                                        VIR_NET_STREAM,\n                                        serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"stream had I/O failure\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"stream had I/O failure\""
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon.c",
          "lines": "378-422",
          "snippet": "static int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }",
          "includes": [
            "#include \"virdbus.h\"",
            "#include \"configmake.h\"",
            "#include \"driver.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"virsystemd.h\"",
            "#include \"util/virnetdevopenvswitch.h\"",
            "#include \"virgettext.h\"",
            "#include \"virutil.h\"",
            "#include \"viraccessmanager.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virstring.h\"",
            "#include \"viraudit.h\"",
            "#include \"virhook.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"virnetdaemon.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_driver.h\"",
            "#include \"viruuid.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"remote_daemon_config.h\"",
            "#include \"remote_daemon.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"libvirt_internal.h\"",
            "#include <grp.h>",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdbus.h\"\n#include \"configmake.h\"\n#include \"driver.h\"\n#include \"virhostuptime.h\"\n#include \"virsystemd.h\"\n#include \"util/virnetdevopenvswitch.h\"\n#include \"virgettext.h\"\n#include \"virutil.h\"\n#include \"viraccessmanager.h\"\n#include \"locking/lock_manager.h\"\n#include \"virstring.h\"\n#include \"viraudit.h\"\n#include \"virhook.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"virnetdaemon.h\"\n#include \"virnetlink.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"remote_driver.h\"\n#include \"viruuid.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"remote_daemon_config.h\"\n#include \"remote_daemon.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"libvirt_internal.h\"\n#include <grp.h>\n#include <getopt.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int ATTRIBUTE_NONNULL(3)\ndaemonSetupNetworking(virNetServerPtr srv,\n                      virNetServerPtr srvAdm,\n                      struct daemonConfig *config,\n#ifdef WITH_IP\n                      bool ipsock,\n                      bool privileged,\n#endif /* ! WITH_IP */\n                      const char *sock_path,\n                      const char *sock_path_ro,\n                      const char *sock_path_adm)\n{\n    gid_t unix_sock_gid = 0;\n    int unix_sock_ro_mask = 0;\n    int unix_sock_rw_mask = 0;\n    int unix_sock_adm_mask = 0;\n    g_autoptr(virSystemdActivation) act = NULL;\n    virSystemdActivationMap actmap[] = {\n        { .name = DAEMON_NAME \".socket\", .family = AF_UNIX, .path = sock_path },\n        { .name = DAEMON_NAME \"-ro.socket\", .family = AF_UNIX, .path = sock_path_ro },\n        { .name = DAEMON_NAME \"-admin.socket\", .family = AF_UNIX, .path = sock_path_adm },\n#ifdef WITH_IP\n        { .name = DAEMON_NAME \"-tcp.socket\", .family = AF_INET },\n        { .name = DAEMON_NAME \"-tls.socket\", .family = AF_INET },\n#endif /* ! WITH_IP */\n    };\n\n#ifdef WITH_IP\n    if ((actmap[3].port = virSocketAddrResolveService(config->tcp_port)) < 0)\n        return -1;\n\n    if ((actmap[4].port = virSocketAddrResolveService(config->tls_port)) < 0)\n        return -1;\n#endif /* ! WITH_IP */\n\n    if (virSystemdGetActivation(actmap, G_N_ELEMENTS(actmap), &act) < 0)\n        return -1;\n\n#ifdef WITH_IP\n# ifdef LIBVIRTD\n    if (act && ipsock) {\n        VIR_ERROR(_(\"--listen parameter not permitted with systemd activation \"\n                    \"sockets, see 'man libvirtd' for further guidance\"));\n        return -1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"stream had unexpected termination\")"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "origErr"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&origErr"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "stream->st"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamEventRemoveCallback",
          "args": [
            "stream->st"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventRemoveCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1135-1158",
          "snippet": "int\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventRemoveCallback(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventRemoveCallback) {\n        int ret;\n        ret = (stream->driver->streamEventRemoveCallback)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&origErr"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendStreamData",
          "args": [
            "stream->prog",
            "client",
            "msg",
            "stream->procedure",
            "stream->serial",
            "\"\"",
            "0"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendStreamData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "495-534",
          "snippet": "int virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleAbort",
          "args": [
            "client",
            "stream",
            "msg"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "646-687",
          "snippet": "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg)\n{\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n    int ret;\n    bool raise_error = false;\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamAbort(stream->st);\n\n    if (msg->header.status == VIR_NET_ERROR) {\n        VIR_INFO(\"stream aborted at client request\");\n        raise_error = (ret < 0);\n    } else {\n        virReportError(VIR_ERR_RPC,\n                       _(\"stream aborted with unexpected status %d\"),\n                       msg->header.status);\n        raise_error = true;\n    }\n\n    if (raise_error) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg)\n{\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n    int ret;\n    bool raise_error = false;\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamAbort(stream->st);\n\n    if (msg->header.status == VIR_NET_ERROR) {\n        VIR_INFO(\"stream aborted at client request\");\n        raise_error = (ret < 0);\n    } else {\n        virReportError(VIR_ERR_RPC,\n                       _(\"stream aborted with unexpected status %d\"),\n                       msg->header.status);\n        raise_error = true;\n    }\n\n    if (raise_error) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueueServe",
          "args": [
            "&stream->rx"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueueServe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "109-119",
          "snippet": "virNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleFinish",
          "args": [
            "client",
            "stream",
            "msg"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "607-638",
          "snippet": "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamFinish(stream->st);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg)\n{\n    int ret;\n\n    VIR_DEBUG(\"client=%p, stream=%p, proc=%d, serial=%u\",\n              client, stream, msg->header.proc, msg->header.serial);\n\n    stream->closed = true;\n    virStreamEventRemoveCallback(stream->st);\n    ret = virStreamFinish(stream->st);\n\n    if (ret < 0) {\n        virNetMessageError rerr;\n        memset(&rerr, 0, sizeof(rerr));\n        return virNetServerProgramSendReplyError(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 &rerr,\n                                                 &msg->header);\n    } else {\n        /* Send zero-length confirm */\n        return virNetServerProgramSendStreamData(stream->prog,\n                                                 client,\n                                                 msg,\n                                                 stream->procedure,\n                                                 stream->serial,\n                                                 NULL, 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleRead",
          "args": [
            "client",
            "stream"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "823-951",
          "snippet": "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream)\n{\n    virNetMessagePtr msg = NULL;\n    virNetMessageError rerr;\n    char *buffer;\n    size_t bufferLen = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    int rv;\n    int inData = 0;\n    long long length = 0;\n\n    VIR_DEBUG(\"client=%p, stream=%p tx=%d closed=%d\",\n              client, stream, stream->tx, stream->closed);\n\n    /* We might have had an event pending before we shut\n     * down the stream, so if we're marked as closed,\n     * then do nothing\n     */\n    if (stream->closed)\n        return 0;\n\n    /* Shouldn't ever be called unless we're marked able to\n     * transmit, but doesn't hurt to check */\n    if (!stream->tx)\n        return 0;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (VIR_ALLOC_N(buffer, bufferLen) < 0)\n        return -1;\n\n    if (!(msg = virNetMessageNew(false)))\n        goto cleanup;\n\n    if (stream->allowSkip && stream->dataLen == 0) {\n        /* Handle skip. We want to send some data to the client. But we might\n         * be in a hole. Seek to next data. But if we are in data already, just\n         * carry on. */\n\n        rv = virStreamInData(stream->st, &inData, &length);\n        VIR_DEBUG(\"rv=%d inData=%d length=%lld\", rv, inData, length);\n\n        if (rv < 0) {\n            if (virNetServerProgramSendStreamError(stream->prog,\n                                                   client,\n                                                   msg,\n                                                   &rerr,\n                                                   stream->procedure,\n                                                   stream->serial) < 0)\n                goto cleanup;\n            msg = NULL;\n\n            /* We're done with this call */\n            goto done;\n        } else {\n            if (!inData && length) {\n                stream->tx = false;\n                msg->cb = daemonStreamMessageFinished;\n                msg->opaque = stream;\n                stream->refs++;\n                if (virNetServerProgramSendStreamHole(stream->prog,\n                                                      client,\n                                                      msg,\n                                                      stream->procedure,\n                                                      stream->serial,\n                                                      length,\n                                                      0) < 0)\n                    goto cleanup;\n\n                msg = NULL;\n\n                /* We have successfully sent stream skip to the other side.\n                 * To keep streams in sync seek locally too. */\n                virStreamSendHole(stream->st, length, 0);\n                /* We're done with this call */\n                goto done;\n            }\n        }\n\n        stream->dataLen = length;\n    }\n\n    if (stream->allowSkip &&\n        bufferLen > stream->dataLen)\n        bufferLen = stream->dataLen;\n\n    rv = virStreamRecv(stream->st, buffer, bufferLen);\n    if (rv == -2) {\n        /* Should never get this, since we're only called when we know\n         * we're readable, but hey things change... */\n    } else if (rv < 0) {\n        if (virNetServerProgramSendStreamError(stream->prog,\n                                               client,\n                                               msg,\n                                               &rerr,\n                                               stream->procedure,\n                                               stream->serial) < 0)\n            goto cleanup;\n        msg = NULL;\n    } else {\n        if (stream->allowSkip)\n            stream->dataLen -= rv;\n\n        stream->tx = false;\n        if (rv == 0)\n            stream->recvEOF = true;\n\n        msg->cb = daemonStreamMessageFinished;\n        msg->opaque = stream;\n        stream->refs++;\n        if (virNetServerProgramSendStreamData(stream->prog,\n                                              client,\n                                              msg,\n                                              stream->procedure,\n                                              stream->serial,\n                                              buffer, rv) < 0)\n            goto cleanup;\n        msg = NULL;\n    }\n\n done:\n    ret = 0;\n cleanup:\n    VIR_FREE(buffer);\n    virNetMessageFree(msg);\n    return ret;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream)\n{\n    virNetMessagePtr msg = NULL;\n    virNetMessageError rerr;\n    char *buffer;\n    size_t bufferLen = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    int rv;\n    int inData = 0;\n    long long length = 0;\n\n    VIR_DEBUG(\"client=%p, stream=%p tx=%d closed=%d\",\n              client, stream, stream->tx, stream->closed);\n\n    /* We might have had an event pending before we shut\n     * down the stream, so if we're marked as closed,\n     * then do nothing\n     */\n    if (stream->closed)\n        return 0;\n\n    /* Shouldn't ever be called unless we're marked able to\n     * transmit, but doesn't hurt to check */\n    if (!stream->tx)\n        return 0;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (VIR_ALLOC_N(buffer, bufferLen) < 0)\n        return -1;\n\n    if (!(msg = virNetMessageNew(false)))\n        goto cleanup;\n\n    if (stream->allowSkip && stream->dataLen == 0) {\n        /* Handle skip. We want to send some data to the client. But we might\n         * be in a hole. Seek to next data. But if we are in data already, just\n         * carry on. */\n\n        rv = virStreamInData(stream->st, &inData, &length);\n        VIR_DEBUG(\"rv=%d inData=%d length=%lld\", rv, inData, length);\n\n        if (rv < 0) {\n            if (virNetServerProgramSendStreamError(stream->prog,\n                                                   client,\n                                                   msg,\n                                                   &rerr,\n                                                   stream->procedure,\n                                                   stream->serial) < 0)\n                goto cleanup;\n            msg = NULL;\n\n            /* We're done with this call */\n            goto done;\n        } else {\n            if (!inData && length) {\n                stream->tx = false;\n                msg->cb = daemonStreamMessageFinished;\n                msg->opaque = stream;\n                stream->refs++;\n                if (virNetServerProgramSendStreamHole(stream->prog,\n                                                      client,\n                                                      msg,\n                                                      stream->procedure,\n                                                      stream->serial,\n                                                      length,\n                                                      0) < 0)\n                    goto cleanup;\n\n                msg = NULL;\n\n                /* We have successfully sent stream skip to the other side.\n                 * To keep streams in sync seek locally too. */\n                virStreamSendHole(stream->st, length, 0);\n                /* We're done with this call */\n                goto done;\n            }\n        }\n\n        stream->dataLen = length;\n    }\n\n    if (stream->allowSkip &&\n        bufferLen > stream->dataLen)\n        bufferLen = stream->dataLen;\n\n    rv = virStreamRecv(stream->st, buffer, bufferLen);\n    if (rv == -2) {\n        /* Should never get this, since we're only called when we know\n         * we're readable, but hey things change... */\n    } else if (rv < 0) {\n        if (virNetServerProgramSendStreamError(stream->prog,\n                                               client,\n                                               msg,\n                                               &rerr,\n                                               stream->procedure,\n                                               stream->serial) < 0)\n            goto cleanup;\n        msg = NULL;\n    } else {\n        if (stream->allowSkip)\n            stream->dataLen -= rv;\n\n        stream->tx = false;\n        if (rv == 0)\n            stream->recvEOF = true;\n\n        msg->cb = daemonStreamMessageFinished;\n        msg->opaque = stream;\n        stream->refs++;\n        if (virNetServerProgramSendStreamData(stream->prog,\n                                              client,\n                                              msg,\n                                              stream->procedure,\n                                              stream->serial,\n                                              buffer, rv) < 0)\n            goto cleanup;\n        msg = NULL;\n    }\n\n done:\n    ret = 0;\n cleanup:\n    VIR_FREE(buffer);\n    virNetMessageFree(msg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamHandleWrite",
          "args": [
            "client",
            "stream"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamHandleWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "744-809",
          "snippet": "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, stream=%p\", client, stream);\n\n    while (stream->rx && !stream->closed) {\n        virNetMessagePtr msg = stream->rx;\n        int ret;\n\n        if (msg->header.type == VIR_NET_STREAM_HOLE) {\n            /* Handle special case when the client sent us a hole.\n             * Otherwise just carry on with processing stream\n             * data. */\n            ret = daemonStreamHandleHole(client, stream, msg);\n        } else if (msg->header.type == VIR_NET_STREAM) {\n            switch (msg->header.status) {\n            case VIR_NET_OK:\n                ret = daemonStreamHandleFinish(client, stream, msg);\n                break;\n\n            case VIR_NET_CONTINUE:\n                ret = daemonStreamHandleWriteData(client, stream, msg);\n                break;\n\n            case VIR_NET_ERROR:\n            default:\n                ret = daemonStreamHandleAbort(client, stream, msg);\n                break;\n            }\n        } else {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Unexpected message type: %d\"),\n                           msg->header.type);\n            ret = -1;\n        }\n\n        if (ret > 0)\n            break;  /* still processing data from msg */\n\n        virNetMessageQueueServe(&stream->rx);\n        if (ret < 0) {\n            virNetMessageFree(msg);\n            virNetServerClientImmediateClose(client);\n            return -1;\n        }\n\n        /* 'CONTINUE' messages don't send a reply (unless error\n         * occurred), so to release the 'msg' object we need to\n         * send a fake zero-length reply. Nothing actually gets\n         * onto the wire, but this causes the client to reset\n         * its active request count / throttling\n         */\n        if (msg->header.status == VIR_NET_CONTINUE) {\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetMessageFree(msg);\n                virNetServerClientImmediateClose(client);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream)\n{\n    VIR_DEBUG(\"client=%p, stream=%p\", client, stream);\n\n    while (stream->rx && !stream->closed) {\n        virNetMessagePtr msg = stream->rx;\n        int ret;\n\n        if (msg->header.type == VIR_NET_STREAM_HOLE) {\n            /* Handle special case when the client sent us a hole.\n             * Otherwise just carry on with processing stream\n             * data. */\n            ret = daemonStreamHandleHole(client, stream, msg);\n        } else if (msg->header.type == VIR_NET_STREAM) {\n            switch (msg->header.status) {\n            case VIR_NET_OK:\n                ret = daemonStreamHandleFinish(client, stream, msg);\n                break;\n\n            case VIR_NET_CONTINUE:\n                ret = daemonStreamHandleWriteData(client, stream, msg);\n                break;\n\n            case VIR_NET_ERROR:\n            default:\n                ret = daemonStreamHandleAbort(client, stream, msg);\n                break;\n            }\n        } else {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Unexpected message type: %d\"),\n                           msg->header.type);\n            ret = -1;\n        }\n\n        if (ret > 0)\n            break;  /* still processing data from msg */\n\n        virNetMessageQueueServe(&stream->rx);\n        if (ret < 0) {\n            virNetMessageFree(msg);\n            virNetServerClientImmediateClose(client);\n            return -1;\n        }\n\n        /* 'CONTINUE' messages don't send a reply (unless error\n         * occurred), so to release the 'msg' object we need to\n         * send a fake zero-length reply. Nothing actually gets\n         * onto the wire, but this causes the client to reset\n         * its active request count / throttling\n         */\n        if (msg->header.status == VIR_NET_CONTINUE) {\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetMessageFree(msg);\n                virNetServerClientImmediateClose(client);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p events=%d EOF=%d closed=%d\"",
            "st",
            "events",
            "stream->recvEOF",
            "stream->closed"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"event for client=%p stream st=%p, but missing stream state\"",
            "client",
            "st"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&priv->lock"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetPrivateData",
          "args": [
            "client"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "912-919",
          "snippet": "void *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid *virNetServerClientGetPrivateData(virNetServerClientPtr client)\n{\n    void *data;\n    virObjectLock(client);\n    data = client->privateData;\n    virObjectUnlock(client);\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic void\ndaemonStreamEvent(virStreamPtr st, int events, void *opaque)\n{\n    virNetServerClientPtr client = opaque;\n    daemonClientStream *stream;\n    daemonClientPrivatePtr priv = virNetServerClientGetPrivateData(client);\n\n    virMutexLock(&priv->lock);\n\n    stream = priv->streams;\n    while (stream) {\n        if (stream->st == st)\n            break;\n        stream = stream->next;\n    }\n\n    if (!stream) {\n        VIR_WARN(\"event for client=%p stream st=%p, but missing stream state\", client, st);\n        virStreamEventRemoveCallback(st);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"st=%p events=%d EOF=%d closed=%d\", st, events, stream->recvEOF, stream->closed);\n\n    if (!stream->closed &&\n        (events & VIR_STREAM_EVENT_WRITABLE)) {\n        if (daemonStreamHandleWrite(client, stream) < 0) {\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n    }\n\n    if (!stream->closed && !stream->recvEOF &&\n        (events & (VIR_STREAM_EVENT_READABLE))) {\n        events = events & ~(VIR_STREAM_EVENT_READABLE);\n        if (daemonStreamHandleRead(client, stream) < 0) {\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n        /* If we detected EOF during read processing,\n         * then clear hangup/error conditions, since\n         * we want the client to see the EOF message\n         * we just sent them\n         */\n        if (stream->recvEOF)\n            events = events & ~(VIR_STREAM_EVENT_HANGUP |\n                                VIR_STREAM_EVENT_ERROR);\n    }\n\n    /* If we have a completion/abort message, always process it */\n    if (stream->rx) {\n        virNetMessagePtr msg = stream->rx;\n        switch (msg->header.status) {\n        case VIR_NET_CONTINUE:\n            /* nada */\n            break;\n        case VIR_NET_OK:\n            virNetMessageQueueServe(&stream->rx);\n            if (daemonStreamHandleFinish(client, stream, msg) < 0) {\n                virNetMessageFree(msg);\n                daemonRemoveClientStream(client, stream);\n                virNetServerClientClose(client);\n                goto cleanup;\n            }\n            break;\n        case VIR_NET_ERROR:\n        default:\n            virNetMessageQueueServe(&stream->rx);\n            if (daemonStreamHandleAbort(client, stream, msg) < 0) {\n                virNetMessageFree(msg);\n                daemonRemoveClientStream(client, stream);\n                virNetServerClientClose(client);\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n\n    /* If we got HANGUP, we need to only send an empty\n     * packet so the client sees an EOF and cleans up\n     */\n    if (!stream->closed && !stream->recvEOF &&\n        (events & VIR_STREAM_EVENT_HANGUP)) {\n        virNetMessagePtr msg;\n        events &= ~(VIR_STREAM_EVENT_HANGUP);\n        stream->tx = false;\n        stream->recvEOF = true;\n        if (!(msg = virNetMessageNew(false))) {\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n        msg->cb = daemonStreamMessageFinished;\n        msg->opaque = stream;\n        stream->refs++;\n        if (virNetServerProgramSendStreamData(stream->prog,\n                                              client,\n                                              msg,\n                                              stream->procedure,\n                                              stream->serial,\n                                              \"\", 0) < 0) {\n            virNetMessageFree(msg);\n            daemonRemoveClientStream(client, stream);\n            virNetServerClientClose(client);\n            goto cleanup;\n        }\n    }\n\n    if (!stream->closed &&\n        (events & (VIR_STREAM_EVENT_ERROR | VIR_STREAM_EVENT_HANGUP))) {\n        int ret;\n        virNetMessagePtr msg;\n        virNetMessageError rerr;\n        virErrorPtr origErr;\n\n        virErrorPreserveLast(&origErr);\n\n        memset(&rerr, 0, sizeof(rerr));\n        stream->closed = true;\n        virStreamEventRemoveCallback(stream->st);\n        virStreamAbort(stream->st);\n        if (origErr && origErr->code != VIR_ERR_OK) {\n            virErrorRestore(&origErr);\n        } else {\n            virFreeError(origErr);\n            if (events & VIR_STREAM_EVENT_HANGUP)\n                virReportError(VIR_ERR_RPC,\n                               \"%s\", _(\"stream had unexpected termination\"));\n            else\n                virReportError(VIR_ERR_RPC,\n                               \"%s\", _(\"stream had I/O failure\"));\n        }\n\n        msg = virNetMessageNew(false);\n        if (!msg) {\n            ret = -1;\n        } else {\n            ret = virNetServerProgramSendStreamError(stream->prog,\n                                                     client,\n                                                     msg,\n                                                     &rerr,\n                                                     stream->procedure,\n                                                     stream->serial);\n        }\n        daemonRemoveClientStream(client, stream);\n        if (ret < 0)\n            virNetServerClientClose(client);\n        goto cleanup;\n    }\n\n    if (stream->closed) {\n        daemonRemoveClientStream(client, stream);\n    } else {\n        daemonStreamUpdateEvents(stream);\n    }\n\n cleanup:\n    virMutexUnlock(&priv->lock);\n}"
  },
  {
    "function_name": "daemonStreamMessageFinished",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "98-110",
    "snippet": "static void\ndaemonStreamMessageFinished(virNetMessagePtr msg,\n                            void *opaque)\n{\n    daemonClientStream *stream = opaque;\n    VIR_DEBUG(\"stream=%p proc=%d serial=%u\",\n              stream, msg->header.proc, msg->header.serial);\n\n    stream->tx = true;\n    daemonStreamUpdateEvents(stream);\n\n    daemonFreeClientStream(NULL, stream);\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
      "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
      "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "daemonFreeClientStream",
          "args": [
            "NULL",
            "stream"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "daemonFreeClientStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "386-426",
          "snippet": "int daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);",
            "static int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);",
            "static int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nint daemonFreeClientStream(virNetServerClientPtr client,\n                           daemonClientStream *stream)\n{\n    virNetMessagePtr msg;\n    int ret = 0;\n\n    if (!stream)\n        return 0;\n\n    stream->refs--;\n    if (stream->refs)\n        return 0;\n\n    VIR_DEBUG(\"client=%p, proc=%d, serial=%u\",\n              client, stream->procedure, stream->serial);\n\n    virObjectUnref(stream->prog);\n\n    msg = stream->rx;\n    while (msg) {\n        virNetMessagePtr tmp = msg->next;\n        if (client) {\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0) {\n                virNetServerClientImmediateClose(client);\n                virNetMessageFree(msg);\n                ret = -1;\n            }\n        } else {\n            virNetMessageFree(msg);\n        }\n        msg = tmp;\n    }\n\n    virObjectUnref(stream->st);\n    VIR_FREE(stream);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "daemonStreamUpdateEvents",
          "args": [
            "stream"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "daemonStreamUpdateEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
          "lines": "77-89",
          "snippet": "static void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}",
          "includes": [
            "#include \"libvirt_internal.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"remote_daemon_dispatch.h\"",
            "#include \"remote_daemon_stream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
            "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nstatic void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"stream=%p proc=%d serial=%u\"",
            "stream",
            "msg->header.proc",
            "msg->header.serial"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\nstatic int\ndaemonStreamHandleFinish(virNetServerClientPtr client,\n                         daemonClientStream *stream,\n                         virNetMessagePtr msg);\nstatic int\ndaemonStreamHandleAbort(virNetServerClientPtr client,\n                        daemonClientStream *stream,\n                        virNetMessagePtr msg);\n\nstatic void\ndaemonStreamMessageFinished(virNetMessagePtr msg,\n                            void *opaque)\n{\n    daemonClientStream *stream = opaque;\n    VIR_DEBUG(\"stream=%p proc=%d serial=%u\",\n              stream, msg->header.proc, msg->header.serial);\n\n    stream->tx = true;\n    daemonStreamUpdateEvents(stream);\n\n    daemonFreeClientStream(NULL, stream);\n}"
  },
  {
    "function_name": "daemonStreamUpdateEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/remote/remote_daemon_stream.c",
    "lines": "77-89",
    "snippet": "static void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}",
    "includes": [
      "#include \"libvirt_internal.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"remote_daemon_dispatch.h\"",
      "#include \"remote_daemon_stream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);",
      "static int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStreamEventUpdateCallback",
          "args": [
            "stream->st",
            "newEvents"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamEventUpdateCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1100-1124",
          "snippet": "int\nvirStreamEventUpdateCallback(virStreamPtr stream,\n                             int events)\n{\n    VIR_DEBUG(\"stream=%p, events=%d\", stream, events);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventUpdateCallback) {\n        int ret;\n        ret = (stream->driver->streamEventUpdateCallback)(stream, events);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamEventUpdateCallback(virStreamPtr stream,\n                             int events)\n{\n    VIR_DEBUG(\"stream=%p, events=%d\", stream, events);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamEventUpdateCallback) {\n        int ret;\n        ret = (stream->driver->streamEventUpdateCallback)(stream, events);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libvirt_internal.h\"\n#include \"virerror.h\"\n#include \"virnetserverclient.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"remote_daemon_dispatch.h\"\n#include \"remote_daemon_stream.h\"\n#include <config.h>\n\nstatic int\ndaemonStreamHandleWrite(virNetServerClientPtr client,\n                        daemonClientStream *stream);\nstatic int\ndaemonStreamHandleRead(virNetServerClientPtr client,\n                       daemonClientStream *stream);\n\nstatic void\ndaemonStreamUpdateEvents(daemonClientStream *stream)\n{\n    int newEvents = 0;\n    if (stream->closed)\n        return;\n    if (stream->rx)\n        newEvents |= VIR_STREAM_EVENT_WRITABLE;\n    if (stream->tx && !stream->recvEOF)\n        newEvents |= VIR_STREAM_EVENT_READABLE;\n\n    virStreamEventUpdateCallback(stream->st, newEvents);\n}"
  }
]