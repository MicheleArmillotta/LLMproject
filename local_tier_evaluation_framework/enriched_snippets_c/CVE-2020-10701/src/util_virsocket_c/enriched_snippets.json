[
  {
    "function_name": "virSocketRecvFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "496-501",
    "snippet": "int\nvirSocketRecvFD(int sock G_GNUC_UNUSED, int fdflags G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvirSocketRecvFD(int sock G_GNUC_UNUSED, int fdflags G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
  },
  {
    "function_name": "virSocketSendFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "489-494",
    "snippet": "int\nvirSocketSendFD(int sock G_GNUC_UNUSED, int fd G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvirSocketSendFD(int sock G_GNUC_UNUSED, int fd G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
  },
  {
    "function_name": "virSocketRecvFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "425-487",
    "snippet": "int\nvirSocketRecvFD(int sock, int fdflags)\n{\n    char byte = 0;\n    struct iovec iov;\n    struct msghdr msg;\n    int fd = -1;\n    ssize_t len;\n    struct cmsghdr *cmsg;\n    char buf[CMSG_SPACE(sizeof(fd))];\n    int fdflags_recvmsg = fdflags & O_CLOEXEC ? MSG_CMSG_CLOEXEC : 0;\n\n    if ((fdflags & ~O_CLOEXEC) != 0) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    /* send at least one char */\n    memset(&msg, 0, sizeof(msg));\n    iov.iov_base = &byte;\n    iov.iov_len = 1;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n\n    msg.msg_control = buf;\n    msg.msg_controllen = sizeof(buf);\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    /* Initialize the payload: */\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    len = recvmsg(sock, &msg, fdflags_recvmsg);\n    if (len < 0)\n        return -1;\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    /* be paranoiac */\n    if (len == 0 || cmsg == NULL || cmsg->cmsg_len != CMSG_LEN(sizeof(fd))\n        || cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n        /* fake errno: at end the file is not available */\n        errno = len ? EACCES : ENOTCONN;\n        return -1;\n    }\n\n    memcpy(&fd, CMSG_DATA(cmsg), sizeof(fd));\n\n    /* set close-on-exec flag */\n    if (!MSG_CMSG_CLOEXEC && (fdflags & O_CLOEXEC)) {\n        if (virSetCloseExec(fd) < 0) {\n            int saved_errno = errno;\n            VIR_FORCE_CLOSE(fd);\n            errno = saved_errno;\n            return -1;\n        }\n    }\n\n    return fd;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "fd"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fd",
            "CMSG_DATA(cmsg)",
            "sizeof(fd)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(fd)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "sock",
            "&msg",
            "fdflags_recvmsg"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CMSG_DATA(cmsg)",
            "&fd",
            "sizeof(fd)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(fd)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(fd)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvirSocketRecvFD(int sock, int fdflags)\n{\n    char byte = 0;\n    struct iovec iov;\n    struct msghdr msg;\n    int fd = -1;\n    ssize_t len;\n    struct cmsghdr *cmsg;\n    char buf[CMSG_SPACE(sizeof(fd))];\n    int fdflags_recvmsg = fdflags & O_CLOEXEC ? MSG_CMSG_CLOEXEC : 0;\n\n    if ((fdflags & ~O_CLOEXEC) != 0) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    /* send at least one char */\n    memset(&msg, 0, sizeof(msg));\n    iov.iov_base = &byte;\n    iov.iov_len = 1;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n\n    msg.msg_control = buf;\n    msg.msg_controllen = sizeof(buf);\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    /* Initialize the payload: */\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    len = recvmsg(sock, &msg, fdflags_recvmsg);\n    if (len < 0)\n        return -1;\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    /* be paranoiac */\n    if (len == 0 || cmsg == NULL || cmsg->cmsg_len != CMSG_LEN(sizeof(fd))\n        || cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n        /* fake errno: at end the file is not available */\n        errno = len ? EACCES : ENOTCONN;\n        return -1;\n    }\n\n    memcpy(&fd, CMSG_DATA(cmsg), sizeof(fd));\n\n    /* set close-on-exec flag */\n    if (!MSG_CMSG_CLOEXEC && (fdflags & O_CLOEXEC)) {\n        if (virSetCloseExec(fd) < 0) {\n            int saved_errno = errno;\n            VIR_FORCE_CLOSE(fd);\n            errno = saved_errno;\n            return -1;\n        }\n    }\n\n    return fd;\n}"
  },
  {
    "function_name": "virSocketSendFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "386-417",
    "snippet": "int\nvirSocketSendFD(int sock, int fd)\n{\n    char byte = 0;\n    struct iovec iov;\n    struct msghdr msg;\n    struct cmsghdr *cmsg;\n    char buf[CMSG_SPACE(sizeof(fd))];\n\n    /* send at least one char */\n    memset(&msg, 0, sizeof(msg));\n    iov.iov_base = &byte;\n    iov.iov_len = 1;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n\n    msg.msg_control = buf;\n    msg.msg_controllen = sizeof(buf);\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    /* Initialize the payload: */\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    if (sendmsg(sock, &msg, 0) != iov.iov_len)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "sock",
            "&msg",
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CMSG_DATA(cmsg)",
            "&fd",
            "sizeof(fd)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(fd)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(fd)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvirSocketSendFD(int sock, int fd)\n{\n    char byte = 0;\n    struct iovec iov;\n    struct msghdr msg;\n    struct cmsghdr *cmsg;\n    char buf[CMSG_SPACE(sizeof(fd))];\n\n    /* send at least one char */\n    memset(&msg, 0, sizeof(msg));\n    iov.iov_base = &byte;\n    iov.iov_len = 1;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_name = NULL;\n    msg.msg_namelen = 0;\n\n    msg.msg_control = buf;\n    msg.msg_controllen = sizeof(buf);\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    /* Initialize the payload: */\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    if (sendmsg(sock, &msg, 0) != iov.iov_len)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "vir_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "351-367",
    "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK2FD",
          "args": [
            "sk"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSASocket",
          "args": [
            "domain",
            "type",
            "protocol",
            "NULL",
            "0",
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
  },
  {
    "function_name": "vir_setsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "331-348",
    "snippet": "int\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sk",
            "level",
            "optname",
            "optval",
            "optlen"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "vir_setsockopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "331-348",
          "snippet": "int\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_getsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "311-328",
    "snippet": "int\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "sk",
            "level",
            "optname",
            "optval",
            "optlen"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "311-328",
          "snippet": "int\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_ioctlsocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "292-308",
    "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctlsocket",
          "args": [
            "sk",
            "cmd",
            "arg"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "vir_ioctlsocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "292-308",
          "snippet": "int\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_ioctlsocket(int fd, int cmd, void *arg)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (ioctlsocket(sk, cmd, arg) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "273-289",
    "snippet": "int\nvir_listen(int fd, int backlog)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (listen(sk, backlog) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sk",
            "backlog"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "vir_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "273-289",
          "snippet": "int\nvir_listen(int fd, int backlog)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (listen(sk, backlog) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_listen(int fd, int backlog)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (listen(sk, backlog) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_getsockname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "254-270",
    "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sk",
            "addr",
            "addrlen"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_getpeername",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "235-251",
    "snippet": "int\nvir_getpeername(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getpeername(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sk",
            "addr",
            "addrlen"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getpeername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "235-251",
          "snippet": "int\nvir_getpeername(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getpeername(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getpeername(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getpeername(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "216-232",
    "snippet": "int\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sk",
            "addr",
            "addrlen"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "vir_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "216-232",
          "snippet": "int\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_closesocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "197-213",
    "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sk"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "178-194",
    "snippet": "int\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sk",
            "addr",
            "addrlen"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "vir_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "178-194",
          "snippet": "int\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vir_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "156-175",
    "snippet": "int\nvir_accept(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n    SOCKET csk;\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    csk = accept(sk, addr, addrlen);\n\n    if (csk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(csk);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK2FD",
          "args": [
            "csk"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_errno",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "52-153",
          "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "sk",
            "addr",
            "addrlen"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "vir_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "156-175",
          "snippet": "int\nvir_accept(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n    SOCKET csk;\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    csk = accept(sk, addr, addrlen);\n\n    if (csk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(csk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "FD2SK",
          "args": [
            "fd"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_accept(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n    SOCKET csk;\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    csk = accept(sk, addr, addrlen);\n\n    if (csk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(csk);\n}"
  },
  {
    "function_name": "set_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
    "lines": "52-153",
    "snippet": "static void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nstatic void\nset_errno(void)\n{\n    int err = WSAGetLastError();\n\n    /* Map some WSAE* errors to the runtime library's error codes.  */\n    switch (err) {\n    case WSA_INVALID_HANDLE:\n        errno = EBADF;\n        break;\n    case WSA_NOT_ENOUGH_MEMORY:\n        errno = ENOMEM;\n        break;\n    case WSA_INVALID_PARAMETER:\n        errno = EINVAL;\n        break;\n    case WSAENAMETOOLONG:\n        errno = ENAMETOOLONG;\n        break;\n    case WSAENOTEMPTY:\n        errno = ENOTEMPTY;\n        break;\n    case WSAEWOULDBLOCK:\n        errno = EWOULDBLOCK;\n        break;\n    case WSAEINPROGRESS:\n        errno = EINPROGRESS;\n        break;\n    case WSAEALREADY:\n        errno = EALREADY;\n        break;\n    case WSAENOTSOCK:\n        errno = ENOTSOCK;\n        break;\n    case WSAEDESTADDRREQ:\n        errno = EDESTADDRREQ;\n        break;\n    case WSAEMSGSIZE:\n        errno = EMSGSIZE;\n        break;\n    case WSAEPROTOTYPE:\n        errno = EPROTOTYPE;\n        break;\n    case WSAENOPROTOOPT:\n        errno = ENOPROTOOPT;\n        break;\n    case WSAEPROTONOSUPPORT:\n        errno = EPROTONOSUPPORT;\n        break;\n    case WSAEOPNOTSUPP:\n        errno = EOPNOTSUPP;\n        break;\n    case WSAEAFNOSUPPORT:\n        errno = EAFNOSUPPORT;\n        break;\n    case WSAEADDRINUSE:\n        errno = EADDRINUSE;\n        break;\n    case WSAEADDRNOTAVAIL:\n        errno = EADDRNOTAVAIL;\n        break;\n    case WSAENETDOWN:\n        errno = ENETDOWN;\n        break;\n    case WSAENETUNREACH:\n        errno = ENETUNREACH;\n        break;\n    case WSAENETRESET:\n        errno = ENETRESET;\n        break;\n    case WSAECONNABORTED:\n        errno = ECONNABORTED;\n        break;\n    case WSAECONNRESET:\n        errno = ECONNRESET;\n        break;\n    case WSAENOBUFS:\n        errno = ENOBUFS;\n        break;\n    case WSAEISCONN:\n        errno = EISCONN;\n        break;\n    case WSAENOTCONN:\n        errno = ENOTCONN;\n        break;\n    case WSAETIMEDOUT:\n        errno = ETIMEDOUT;\n        break;\n    case WSAECONNREFUSED:\n        errno = ECONNREFUSED;\n        break;\n    case WSAELOOP:\n        errno = ELOOP;\n        break;\n    case WSAEHOSTUNREACH:\n        errno = EHOSTUNREACH;\n        break;\n    default:\n        errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n        break;\n    }\n}"
  }
]