[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "1059-1411",
    "snippet": "int main(int argc, char **argv) {\n    virNetServerPtr lockSrv = NULL;\n    virNetServerPtr adminSrv = NULL;\n    virNetServerProgramPtr lockProgram = NULL;\n    virNetServerProgramPtr adminProgram = NULL;\n    char *remote_config_file = NULL;\n    int statuswrite = -1;\n    int ret = 1;\n    int verbose = 0;\n    int godaemon = 0;\n    char *run_dir = NULL;\n    char *pid_file = NULL;\n    int pid_file_fd = -1;\n    char *sock_file = NULL;\n    char *admin_sock_file = NULL;\n    int timeout = -1;        /* -t: Shutdown timeout */\n    char *state_file = NULL;\n    bool implicit_conf = false;\n    mode_t old_umask;\n    bool privileged = false;\n    virLockDaemonConfigPtr config = NULL;\n    int rv;\n\n    struct option opts[] = {\n        { \"verbose\", no_argument, &verbose, 'v'},\n        { \"daemon\", no_argument, &godaemon, 'd'},\n        { \"config\", required_argument, NULL, 'f'},\n        { \"timeout\", required_argument, NULL, 't'},\n        { \"pid-file\", required_argument, NULL, 'p'},\n        { \"version\", no_argument, NULL, 'V' },\n        { \"help\", no_argument, NULL, 'h' },\n        {0, 0, 0, 0}\n    };\n\n    privileged = geteuid() == 0;\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        int optidx = 0;\n        int c;\n        char *tmp;\n\n        c = getopt_long(argc, argv, \"df:p:t:vVh\", opts, &optidx);\n\n        if (c == -1)\n            break;\n\n        switch (c) {\n        case 0:\n            /* Got one of the flags */\n            break;\n        case 'v':\n            verbose = 1;\n            break;\n        case 'd':\n            godaemon = 1;\n            break;\n\n        case 't':\n            if (virStrToLong_i(optarg, &tmp, 10, &timeout) != 0\n                || timeout <= 0\n                /* Ensure that we can multiply by 1000 without overflowing.  */\n                || timeout > INT_MAX / 1000) {\n                VIR_ERROR(_(\"Invalid value for timeout\"));\n                exit(EXIT_FAILURE);\n            }\n            break;\n\n        case 'p':\n            VIR_FREE(pid_file);\n            pid_file = g_strdup(optarg);\n            break;\n\n        case 'f':\n            VIR_FREE(remote_config_file);\n            remote_config_file = g_strdup(optarg);\n            break;\n\n        case 'V':\n            virLockDaemonVersion(argv[0]);\n            exit(EXIT_SUCCESS);\n\n        case 'h':\n            virLockDaemonUsage(argv[0], privileged);\n            exit(EXIT_SUCCESS);\n\n        case '?':\n        default:\n            virLockDaemonUsage(argv[0], privileged);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    if (!(config = virLockDaemonConfigNew(privileged))) {\n        VIR_ERROR(_(\"Can't create initial configuration\"));\n        exit(EXIT_FAILURE);\n    }\n\n    /* No explicit config, so try and find a default one */\n    if (remote_config_file == NULL) {\n        implicit_conf = true;\n        if (virLockDaemonConfigFilePath(privileged,\n                                        &remote_config_file) < 0) {\n            VIR_ERROR(_(\"Can't determine config path\"));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* Read the config file if it exists */\n    if (remote_config_file &&\n        virLockDaemonConfigLoadFile(config, remote_config_file, implicit_conf) < 0) {\n        VIR_ERROR(_(\"Can't load config file: %s: %s\"),\n                  virGetLastErrorMessage(), remote_config_file);\n        exit(EXIT_FAILURE);\n    }\n    VIR_FREE(remote_config_file);\n\n    if (virLockDaemonSetupLogging(config, privileged, verbose, godaemon) < 0) {\n        VIR_ERROR(_(\"Can't initialize logging\"));\n        exit(EXIT_FAILURE);\n    }\n\n    if (!pid_file &&\n        virPidFileConstructPath(privileged,\n                                RUNSTATEDIR,\n                                \"virtlockd\",\n                                &pid_file) < 0) {\n        VIR_ERROR(_(\"Can't determine pid file path.\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on pid file path '%s'\", NULLSTR(pid_file));\n\n    if (virLockDaemonUnixSocketPaths(privileged,\n                                     &sock_file,\n                                     &admin_sock_file) < 0) {\n        VIR_ERROR(_(\"Can't determine socket paths\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on socket paths '%s' and '%s'\",\n              sock_file, admin_sock_file);\n\n    if (virLockDaemonExecRestartStatePath(privileged,\n                                          &state_file) < 0) {\n        VIR_ERROR(_(\"Can't determine restart state file path\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on restart state file path '%s'\",\n              state_file);\n\n    /* Ensure the rundir exists (on tmpfs on some systems) */\n    if (privileged) {\n        run_dir = g_strdup(RUNSTATEDIR \"/libvirt\");\n    } else {\n        run_dir = virGetUserRuntimeDirectory();\n    }\n\n    if (privileged)\n        old_umask = umask(022);\n    else\n        old_umask = umask(077);\n    VIR_DEBUG(\"Ensuring run dir '%s' exists\", run_dir);\n    if (virFileMakePath(run_dir) < 0) {\n        VIR_ERROR(_(\"unable to create rundir %s: %s\"), run_dir,\n                  g_strerror(errno));\n        ret = VIR_LOCK_DAEMON_ERR_RUNDIR;\n        umask(old_umask);\n        goto cleanup;\n    }\n    umask(old_umask);\n\n    if ((rv = virLockDaemonPostExecRestart(state_file,\n                                           pid_file,\n                                           &pid_file_fd,\n                                           privileged)) < 0) {\n        ret = VIR_LOCK_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    /* rv == 1 means we successfully restored from the saved internal state\n     * (but still need to add @lockProgram into @srv). rv == 0 means that no\n     * saved state is present, therefore initialize from scratch here. */\n    if (rv == 0) {\n        g_autoptr(virSystemdActivation) act = NULL;\n        virSystemdActivationMap actmap[] = {\n            { .name = \"virtlockd.socket\", .family = AF_UNIX, .path = sock_file },\n            { .name = \"virtlockd-admin.socket\", .family = AF_UNIX, .path = admin_sock_file },\n        };\n\n        if (godaemon) {\n            if (chdir(\"/\") < 0) {\n                VIR_ERROR(_(\"cannot change to root directory: %s\"),\n                          g_strerror(errno));\n                goto cleanup;\n            }\n\n            if ((statuswrite = virLockDaemonForkIntoBackground(argv[0])) < 0) {\n                VIR_ERROR(_(\"Failed to fork as daemon: %s\"),\n                          g_strerror(errno));\n                goto cleanup;\n            }\n        }\n\n        /* If we have a pidfile set, claim it now, exiting if already taken */\n        if ((pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_PIDFILE;\n            goto cleanup;\n        }\n\n        if (!(lockDaemon = virLockDaemonNew(config, privileged))) {\n            ret = VIR_LOCK_DAEMON_ERR_INIT;\n            goto cleanup;\n        }\n\n        if (virSystemdGetActivation(actmap,\n                                    G_N_ELEMENTS(actmap),\n                                    &act) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n\n        lockSrv = virNetDaemonGetServer(lockDaemon->dmn, \"virtlockd\");\n        adminSrv = virNetDaemonGetServer(lockDaemon->dmn, \"admin\");\n\n        if (virNetServerAddServiceUNIX(lockSrv,\n                                       act, \"virtlockd.socket\",\n                                       sock_file, 0700, 0, 0,\n                                       NULL,\n                                       false, 0, 1) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n        if (virNetServerAddServiceUNIX(adminSrv,\n                                       act, \"virtlockd-admin.socket\",\n                                       admin_sock_file, 0700, 0, 0,\n                                       NULL,\n                                       false, 0, 1) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n\n        if (act &&\n            virSystemdActivationComplete(act) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n    } else {\n        lockSrv = virNetDaemonGetServer(lockDaemon->dmn, \"virtlockd\");\n        /* If exec-restarting from old virtlockd, we won't have an\n         * admin server present */\n        if (virNetDaemonHasServer(lockDaemon->dmn, \"admin\"))\n            adminSrv = virNetDaemonGetServer(lockDaemon->dmn, \"admin\");\n    }\n\n    if (timeout != -1) {\n        VIR_DEBUG(\"Registering shutdown timeout %d\", timeout);\n        virNetDaemonAutoShutdown(lockDaemon->dmn,\n                                 timeout);\n    }\n\n    if ((virLockDaemonSetupSignals(lockDaemon->dmn)) < 0) {\n        ret = VIR_LOCK_DAEMON_ERR_SIGNAL;\n        goto cleanup;\n    }\n\n    if (!(lockProgram = virNetServerProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                               VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                               virLockSpaceProtocolProcs,\n                                               virLockSpaceProtocolNProcs))) {\n        ret = VIR_LOCK_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (virNetServerAddProgram(lockSrv, lockProgram) < 0) {\n        ret = VIR_LOCK_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (adminSrv != NULL) {\n        if (!(adminProgram = virNetServerProgramNew(ADMIN_PROGRAM,\n                                                    ADMIN_PROTOCOL_VERSION,\n                                                    adminProcs,\n                                                    adminNProcs))) {\n            ret = VIR_LOCK_DAEMON_ERR_INIT;\n            goto cleanup;\n        }\n        if (virNetServerAddProgram(adminSrv, adminProgram) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_INIT;\n            goto cleanup;\n        }\n    }\n\n    /* Disable error func, now logging is setup */\n    virSetErrorFunc(NULL, virLockDaemonErrorHandler);\n\n\n    /* Tell parent of daemon that basic initialization is complete\n     * In particular we're ready to accept net connections & have\n     * written the pidfile\n     */\n    if (statuswrite != -1) {\n        char status = 0;\n        while (write(statuswrite, &status, 1) == -1 &&\n               errno == EINTR)\n            ;\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n\n    /* Start accepting new clients from network */\n\n    virNetDaemonUpdateServices(lockDaemon->dmn, true);\n    virNetDaemonRun(lockDaemon->dmn);\n\n    if (execRestart &&\n        virLockDaemonPreExecRestart(state_file,\n                                    lockDaemon->dmn,\n                                    argv) < 0)\n        ret = VIR_LOCK_DAEMON_ERR_REEXEC;\n    else\n        ret = 0;\n\n cleanup:\n    virObjectUnref(lockProgram);\n    virObjectUnref(adminProgram);\n    virObjectUnref(lockSrv);\n    virObjectUnref(adminSrv);\n    virLockDaemonFree(lockDaemon);\n    if (statuswrite != -1) {\n        if (ret != 0) {\n            /* Tell parent of daemon what failed */\n            char status = ret;\n            while (write(statuswrite, &status, 1) == -1 &&\n                   errno == EINTR)\n                ;\n        }\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n    if (pid_file_fd != -1)\n        virPidFileReleasePath(pid_file, pid_file_fd);\n    VIR_FREE(pid_file);\n    VIR_FREE(sock_file);\n    VIR_FREE(admin_sock_file);\n    VIR_FREE(state_file);\n    VIR_FREE(run_dir);\n    virLockDaemonConfigFree(config);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virLockDaemonPtr lockDaemon = NULL;",
      "static bool execRestart;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockDaemonConfigFree",
          "args": [
            "config"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonConfigFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_config.c",
          "lines": "69-79",
          "snippet": "void\nvirLockDaemonConfigFree(virLockDaemonConfigPtr data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->log_filters);\n    VIR_FREE(data->log_outputs);\n\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_daemon_config.h\"\n#include <config.h>\n\nvoid\nvirLockDaemonConfigFree(virLockDaemonConfigPtr data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->log_filters);\n    VIR_FREE(data->log_outputs);\n\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "run_dir"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state_file"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "admin_sock_file"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock_file"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pid_file"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReleasePath",
          "args": [
            "pid_file",
            "pid_file_fd"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReleasePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "430-450",
          "snippet": "int virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuswrite"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "statuswrite",
            "&status",
            "1"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonFree",
          "args": [
            "lockDaemon"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "116-128",
          "snippet": "static void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "adminSrv"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonPreExecRestart",
          "args": [
            "state_file",
            "lockDaemon->dmn",
            "argv"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonPreExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "915-1003",
          "snippet": "static int\nvirLockDaemonPreExecRestart(const char *state_file,\n                            virNetDaemonPtr dmn,\n                            char **argv)\n{\n    virJSONValuePtr child;\n    char *state = NULL;\n    int ret = -1;\n    virJSONValuePtr object = virJSONValueNewObject();\n    char *magic;\n    virHashKeyValuePairPtr pairs = NULL, tmp;\n    virJSONValuePtr lockspaces;\n\n    VIR_DEBUG(\"Running pre-restart exec\");\n\n    if (!(child = virNetDaemonPreExecRestart(dmn)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"daemon\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    if (!(child = virLockSpacePreExecRestart(lockDaemon->defaultLockspace)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"defaultLockspace\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    lockspaces = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"lockspaces\", lockspaces) < 0) {\n        virJSONValueFree(lockspaces);\n        goto cleanup;\n    }\n\n\n    tmp = pairs = virHashGetItems(lockDaemon->lockspaces, NULL);\n    while (tmp && tmp->key) {\n        virLockSpacePtr lockspace = (virLockSpacePtr)tmp->value;\n\n        if (!(child = virLockSpacePreExecRestart(lockspace)))\n            goto cleanup;\n\n        if (virJSONValueArrayAppend(lockspaces, child) < 0) {\n            virJSONValueFree(child);\n            goto cleanup;\n        }\n\n        tmp++;\n    }\n\n    if (!(magic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (virJSONValueObjectAppendString(object, \"magic\", magic) < 0) {\n        VIR_FREE(magic);\n        goto cleanup;\n    }\n\n    if (!(state = virJSONValueToString(object, true)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Saving state %s\", state);\n\n    if (virFileWriteStr(state_file,\n                        state, 0700) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to save state file %s\"),\n                             state_file);\n        goto cleanup;\n    }\n\n    if (execvp(argv[0], argv) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to restart self\"));\n        goto cleanup;\n    }\n\n    abort(); /* This should be impossible to reach */\n\n cleanup:\n    VIR_FREE(pairs);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virLockDaemonPtr lockDaemon = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\n\nstatic int\nvirLockDaemonPreExecRestart(const char *state_file,\n                            virNetDaemonPtr dmn,\n                            char **argv)\n{\n    virJSONValuePtr child;\n    char *state = NULL;\n    int ret = -1;\n    virJSONValuePtr object = virJSONValueNewObject();\n    char *magic;\n    virHashKeyValuePairPtr pairs = NULL, tmp;\n    virJSONValuePtr lockspaces;\n\n    VIR_DEBUG(\"Running pre-restart exec\");\n\n    if (!(child = virNetDaemonPreExecRestart(dmn)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"daemon\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    if (!(child = virLockSpacePreExecRestart(lockDaemon->defaultLockspace)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"defaultLockspace\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    lockspaces = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"lockspaces\", lockspaces) < 0) {\n        virJSONValueFree(lockspaces);\n        goto cleanup;\n    }\n\n\n    tmp = pairs = virHashGetItems(lockDaemon->lockspaces, NULL);\n    while (tmp && tmp->key) {\n        virLockSpacePtr lockspace = (virLockSpacePtr)tmp->value;\n\n        if (!(child = virLockSpacePreExecRestart(lockspace)))\n            goto cleanup;\n\n        if (virJSONValueArrayAppend(lockspaces, child) < 0) {\n            virJSONValueFree(child);\n            goto cleanup;\n        }\n\n        tmp++;\n    }\n\n    if (!(magic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (virJSONValueObjectAppendString(object, \"magic\", magic) < 0) {\n        VIR_FREE(magic);\n        goto cleanup;\n    }\n\n    if (!(state = virJSONValueToString(object, true)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Saving state %s\", state);\n\n    if (virFileWriteStr(state_file,\n                        state, 0700) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to save state file %s\"),\n                             state_file);\n        goto cleanup;\n    }\n\n    if (execvp(argv[0], argv) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to restart self\"));\n        goto cleanup;\n    }\n\n    abort(); /* This should be impossible to reach */\n\n cleanup:\n    VIR_FREE(pairs);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonRun",
          "args": [
            "lockDaemon->dmn"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "799-864",
          "snippet": "void\nvirNetDaemonRun(virNetDaemonPtr dmn)\n{\n    int timerid = -1;\n    bool timerActive = false;\n\n    virObjectLock(dmn);\n\n    if (dmn->srvObject) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Not all servers restored, cannot run server\"));\n        goto cleanup;\n    }\n\n    dmn->quit = false;\n\n    if (dmn->autoShutdownTimeout &&\n        (timerid = virEventAddTimeout(-1,\n                                      virNetDaemonAutoShutdownTimer,\n                                      dmn, NULL)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register shutdown timeout\"));\n        goto cleanup;\n    }\n\n    /* We are accepting connections now. Notify systemd\n     * so it can start dependent services. */\n    virSystemdNotifyStartup();\n\n    VIR_DEBUG(\"dmn=%p quit=%d\", dmn, dmn->quit);\n    while (!dmn->quit) {\n        /* A shutdown timeout is specified, so check\n         * if any drivers have active state, if not\n         * shutdown after timeout seconds\n         */\n        if (dmn->autoShutdownTimeout) {\n            if (timerActive) {\n                if (virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Deactivating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid, -1);\n                    timerActive = false;\n                }\n            } else {\n                if (!virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Activating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid,\n                                          dmn->autoShutdownTimeout * 1000);\n                    timerActive = true;\n                }\n            }\n        }\n\n        virObjectUnlock(dmn);\n        if (virEventRunDefaultImpl() < 0) {\n            virObjectLock(dmn);\n            VIR_DEBUG(\"Loop iteration error, exiting\");\n            break;\n        }\n        virObjectLock(dmn);\n\n        virHashForEach(dmn->servers, daemonServerProcessClients, NULL);\n    }\n\n cleanup:\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonRun(virNetDaemonPtr dmn)\n{\n    int timerid = -1;\n    bool timerActive = false;\n\n    virObjectLock(dmn);\n\n    if (dmn->srvObject) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Not all servers restored, cannot run server\"));\n        goto cleanup;\n    }\n\n    dmn->quit = false;\n\n    if (dmn->autoShutdownTimeout &&\n        (timerid = virEventAddTimeout(-1,\n                                      virNetDaemonAutoShutdownTimer,\n                                      dmn, NULL)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register shutdown timeout\"));\n        goto cleanup;\n    }\n\n    /* We are accepting connections now. Notify systemd\n     * so it can start dependent services. */\n    virSystemdNotifyStartup();\n\n    VIR_DEBUG(\"dmn=%p quit=%d\", dmn, dmn->quit);\n    while (!dmn->quit) {\n        /* A shutdown timeout is specified, so check\n         * if any drivers have active state, if not\n         * shutdown after timeout seconds\n         */\n        if (dmn->autoShutdownTimeout) {\n            if (timerActive) {\n                if (virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Deactivating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid, -1);\n                    timerActive = false;\n                }\n            } else {\n                if (!virNetDaemonHasClients(dmn)) {\n                    VIR_DEBUG(\"Activating shutdown timer %d\", timerid);\n                    virEventUpdateTimeout(timerid,\n                                          dmn->autoShutdownTimeout * 1000);\n                    timerActive = true;\n                }\n            }\n        }\n\n        virObjectUnlock(dmn);\n        if (virEventRunDefaultImpl() < 0) {\n            virObjectLock(dmn);\n            VIR_DEBUG(\"Loop iteration error, exiting\");\n            break;\n        }\n        virObjectLock(dmn);\n\n        virHashForEach(dmn->servers, daemonServerProcessClients, NULL);\n    }\n\n cleanup:\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonUpdateServices",
          "args": [
            "lockDaemon->dmn",
            "true"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonUpdateServices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "779-786",
          "snippet": "void\nvirNetDaemonUpdateServices(virNetDaemonPtr dmn,\n                           bool enabled)\n{\n    virObjectLock(dmn);\n    virHashForEach(dmn->servers, daemonServerUpdateServices, &enabled);\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonUpdateServices(virNetDaemonPtr dmn,\n                           bool enabled)\n{\n    virObjectLock(dmn);\n    virHashForEach(dmn->servers, daemonServerUpdateServices, &enabled);\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuswrite"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetErrorFunc",
          "args": [
            "NULL",
            "virLockDaemonErrorHandler"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "609-614",
          "snippet": "void\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddProgram",
          "args": [
            "adminSrv",
            "adminProgram"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "820-836",
          "snippet": "int virNetServerAddProgram(virNetServerPtr srv,\n                           virNetServerProgramPtr prog)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->programs, srv->nprograms, 1) < 0)\n        goto error;\n\n    srv->programs[srv->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddProgram(virNetServerPtr srv,\n                           virNetServerProgramPtr prog)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->programs, srv->nprograms, 1) < 0)\n        goto error;\n\n    srv->programs[srv->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramNew",
          "args": [
            "ADMIN_PROGRAM",
            "ADMIN_PROTOCOL_VERSION",
            "adminProcs",
            "adminNProcs"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "61-82",
          "snippet": "virNetServerProgramPtr virNetServerProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetServerProgramProcPtr procs,\n                                              size_t nprocs)\n{\n    virNetServerProgramPtr prog;\n\n    if (virNetServerProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetServerProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->procs = procs;\n    prog->nprocs = nprocs;\n\n    VIR_DEBUG(\"prog=%p\", prog);\n\n    return prog;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerProgramClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerProgramClass;\n\nvirNetServerProgramPtr virNetServerProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetServerProgramProcPtr procs,\n                                              size_t nprocs)\n{\n    virNetServerProgramPtr prog;\n\n    if (virNetServerProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetServerProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->procs = procs;\n    prog->nprocs = nprocs;\n\n    VIR_DEBUG(\"prog=%p\", prog);\n\n    return prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonSetupSignals",
          "args": [
            "lockDaemon->dmn"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonSetupSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "557-569",
          "snippet": "static int\nvirLockDaemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGUSR1, virLockDaemonExecRestartHandler, NULL) < 0)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGUSR1, virLockDaemonExecRestartHandler, NULL) < 0)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonAutoShutdown",
          "args": [
            "lockDaemon->dmn",
            "timeout"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAutoShutdownTimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "751-765",
          "snippet": "static void\nvirNetDaemonAutoShutdownTimer(int timerid G_GNUC_UNUSED,\n                              void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    virObjectLock(dmn);\n\n    if (!dmn->autoShutdownInhibitions) {\n        VIR_DEBUG(\"Automatic shutdown triggered\");\n        dmn->quit = true;\n    }\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetDaemonAutoShutdownTimer(int timerid G_GNUC_UNUSED,\n                              void *opaque)\n{\n    virNetDaemonPtr dmn = opaque;\n\n    virObjectLock(dmn);\n\n    if (!dmn->autoShutdownInhibitions) {\n        VIR_DEBUG(\"Automatic shutdown triggered\");\n        dmn->quit = true;\n    }\n\n    virObjectUnlock(dmn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Registering shutdown timeout %d\"",
            "timeout"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDaemonGetServer",
          "args": [
            "lockDaemon->dmn",
            "\"admin\""
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonGetServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "240-264",
          "snippet": "ssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t\nvirNetDaemonGetServers(virNetDaemonPtr dmn,\n                       virNetServerPtr **servers)\n{\n    struct collectData data = { servers, 0 };\n    ssize_t ret = -1;\n\n    *servers = NULL;\n\n    virObjectLock(dmn);\n\n    if (virHashForEach(dmn->servers, collectServers, &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot get all servers from daemon\"));\n        goto cleanup;\n    }\n\n    ret = data.nservers;\n\n cleanup:\n    if (ret < 0)\n        virObjectListFreeCount(*servers, data.nservers);\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonHasServer",
          "args": [
            "lockDaemon->dmn",
            "\"admin\""
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonHasServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "200-211",
          "snippet": "bool\nvirNetDaemonHasServer(virNetDaemonPtr dmn,\n                      const char *serverName)\n{\n    void *ent;\n\n    virObjectLock(dmn);\n    ent = virHashLookup(dmn->servers, serverName);\n    virObjectUnlock(dmn);\n\n    return ent != NULL;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirNetDaemonHasServer(virNetDaemonPtr dmn,\n                      const char *serverName)\n{\n    void *ent;\n\n    virObjectLock(dmn);\n    ent = virHashLookup(dmn->servers, serverName);\n    virObjectUnlock(dmn);\n\n    return ent != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSystemdActivationComplete",
          "args": [
            "act"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "virSystemdActivationComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsystemd.c",
          "lines": "976-986",
          "snippet": "int\nvirSystemdActivationComplete(virSystemdActivationPtr act)\n{\n    if (virHashSize(act->fds) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Some activation file descriptors are unclaimed\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virsystemdpriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virbuffer.h\"\n#include \"virsystemd.h\"\n#include \"virsystemdpriv.h\"\n#include <config.h>\n\nint\nvirSystemdActivationComplete(virSystemdActivationPtr act)\n{\n    if (virHashSize(act->fds) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Some activation file descriptors are unclaimed\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddServiceUNIX",
          "args": [
            "adminSrv",
            "act",
            "\"virtlockd-admin.socket\"",
            "admin_sock_file",
            "0700",
            "0",
            "0",
            "NULL",
            "false",
            "0",
            "1"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddServiceUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "772-817",
          "snippet": "int virNetServerAddServiceUNIX(virNetServerPtr srv,\n                               virSystemdActivationPtr act,\n                               const char *actname,\n                               const char *path,\n                               mode_t mask,\n                               gid_t grp,\n                               int auth,\n                               virNetTLSContextPtr tls,\n                               bool readonly,\n                               size_t max_queued_clients,\n                               size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    int ret;\n\n    ret = virNetServerAddServiceActivation(srv, act, actname,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max);\n    if (ret < 0)\n        return -1;\n\n    if (ret == 1)\n        return 0;\n\n    if (!(svc = virNetServerServiceNewUNIX(path,\n                                           mask,\n                                           grp,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max)))\n        return -1;\n\n    if (virNetServerAddService(srv, svc) < 0) {\n        virObjectUnref(svc);\n        return -1;\n    }\n\n    virObjectUnref(svc);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddServiceUNIX(virNetServerPtr srv,\n                               virSystemdActivationPtr act,\n                               const char *actname,\n                               const char *path,\n                               mode_t mask,\n                               gid_t grp,\n                               int auth,\n                               virNetTLSContextPtr tls,\n                               bool readonly,\n                               size_t max_queued_clients,\n                               size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    int ret;\n\n    ret = virNetServerAddServiceActivation(srv, act, actname,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max);\n    if (ret < 0)\n        return -1;\n\n    if (ret == 1)\n        return 0;\n\n    if (!(svc = virNetServerServiceNewUNIX(path,\n                                           mask,\n                                           grp,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max)))\n        return -1;\n\n    if (virNetServerAddService(srv, svc) < 0) {\n        virObjectUnref(svc);\n        return -1;\n    }\n\n    virObjectUnref(svc);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSystemdGetActivation",
          "args": [
            "actmap",
            "G_N_ELEMENTS(actmap)",
            "&act"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "virSystemdGetActivation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsystemd.c",
          "lines": "926-944",
          "snippet": "int\nvirSystemdGetActivation(virSystemdActivationMap *map,\n                        size_t nmap,\n                        virSystemdActivationPtr *act)\n{\n    int nfds = 0;\n\n    if ((nfds = virSystemdGetListenFDs()) < 0)\n        return -1;\n\n    if (nfds == 0) {\n        VIR_DEBUG(\"No activation FDs present\");\n        *act = NULL;\n        return 0;\n    }\n\n    *act = virSystemdActivationNew(map, nmap, nfds);\n    return 0;\n}",
          "includes": [
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virsystemdpriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virbuffer.h\"\n#include \"virsystemd.h\"\n#include \"virsystemdpriv.h\"\n#include <config.h>\n\nint\nvirSystemdGetActivation(virSystemdActivationMap *map,\n                        size_t nmap,\n                        virSystemdActivationPtr *act)\n{\n    int nfds = 0;\n\n    if ((nfds = virSystemdGetListenFDs()) < 0)\n        return -1;\n\n    if (nfds == 0) {\n        VIR_DEBUG(\"No activation FDs present\");\n        *act = NULL;\n        return 0;\n    }\n\n    *act = virSystemdActivationNew(map, nmap, nfds);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "actmap"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonNew",
          "args": [
            "config",
            "privileged"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "241-327",
          "snippet": "static virLockDaemonPtr\nvirLockDaemonNewPostExecRestart(virJSONValuePtr object, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virJSONValuePtr child;\n    virJSONValuePtr lockspaces;\n    size_t i;\n    const char *serverNames[] = { \"virtlockd\" };\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(child = virJSONValueObjectGet(object, \"defaultLockspace\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing defaultLockspace data from JSON file\"));\n        goto error;\n    }\n\n    if (!(lockd->defaultLockspace =\n          virLockSpaceNewPostExecRestart(child)))\n        goto error;\n\n    if (!(lockspaces = virJSONValueObjectGet(object, \"lockspaces\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing lockspaces data from JSON file\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(lockspaces)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed lockspaces array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(lockspaces); i++) {\n        virLockSpacePtr lockspace;\n\n        child = virJSONValueArrayGet(lockspaces, i);\n\n        if (!(lockspace = virLockSpaceNewPostExecRestart(child)))\n            goto error;\n\n        if (virHashAddEntry(lockd->lockspaces,\n                            virLockSpaceGetDirectory(lockspace),\n                            lockspace) < 0) {\n            virLockSpaceFree(lockspace);\n        }\n    }\n\n    if (virJSONValueObjectHasKey(object, \"daemon\")) {\n        if (!(child = virJSONValueObjectGet(object, \"daemon\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed daemon data from JSON file\"));\n            goto error;\n        }\n    } else {\n        if (!(child = virJSONValueObjectGet(object, \"server\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing server data from JSON file\"));\n            goto error;\n        }\n    }\n\n    if (!(lockd->dmn = virNetDaemonNewPostExecRestart(child,\n                                                      G_N_ELEMENTS(serverNames),\n                                                      serverNames,\n                                                      virLockDaemonNewServerPostExecRestart,\n                                                      (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    return lockd;\n\n error:\n    virLockDaemonFree(lockd);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3\n\nstatic virLockDaemonPtr\nvirLockDaemonNewPostExecRestart(virJSONValuePtr object, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virJSONValuePtr child;\n    virJSONValuePtr lockspaces;\n    size_t i;\n    const char *serverNames[] = { \"virtlockd\" };\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(child = virJSONValueObjectGet(object, \"defaultLockspace\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing defaultLockspace data from JSON file\"));\n        goto error;\n    }\n\n    if (!(lockd->defaultLockspace =\n          virLockSpaceNewPostExecRestart(child)))\n        goto error;\n\n    if (!(lockspaces = virJSONValueObjectGet(object, \"lockspaces\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing lockspaces data from JSON file\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(lockspaces)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed lockspaces array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(lockspaces); i++) {\n        virLockSpacePtr lockspace;\n\n        child = virJSONValueArrayGet(lockspaces, i);\n\n        if (!(lockspace = virLockSpaceNewPostExecRestart(child)))\n            goto error;\n\n        if (virHashAddEntry(lockd->lockspaces,\n                            virLockSpaceGetDirectory(lockspace),\n                            lockspace) < 0) {\n            virLockSpaceFree(lockspace);\n        }\n    }\n\n    if (virJSONValueObjectHasKey(object, \"daemon\")) {\n        if (!(child = virJSONValueObjectGet(object, \"daemon\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed daemon data from JSON file\"));\n            goto error;\n        }\n    } else {\n        if (!(child = virJSONValueObjectGet(object, \"server\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing server data from JSON file\"));\n            goto error;\n        }\n    }\n\n    if (!(lockd->dmn = virNetDaemonNewPostExecRestart(child,\n                                                      G_N_ELEMENTS(serverNames),\n                                                      serverNames,\n                                                      virLockDaemonNewServerPostExecRestart,\n                                                      (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    return lockd;\n\n error:\n    virLockDaemonFree(lockd);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquirePath",
          "args": [
            "pid_file",
            "false",
            "getpid()"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquirePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "330-410",
          "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to fork as daemon: %s\")",
            "g_strerror(errno)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to fork as daemon: %s\""
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonForkIntoBackground",
          "args": [
            "argv[0]"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonForkIntoBackground",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "355-440",
          "snippet": "static int\nvirLockDaemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) < 0)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) < 0)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0:\n                return statuspipe[1];\n            case -1:\n                return -1;\n            default:\n                _exit(0);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            return -1;\n\n        }\n\n    case -1:\n        return -1;\n\n    default:\n        {\n            int got, exitstatus = 0;\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if ((got = waitpid(pid, &exitstatus, 0)) < 0 ||\n                got != pid ||\n                exitstatus != 0) {\n                return -1;\n            }\n\n            /* Now block until the second child initializes successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            if (ret == 1 && status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run without \"\n                          \"--daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n            }\n            _exit(ret == 1 && status == 0 ? 0 : 1);\n        }\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) < 0)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) < 0)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0:\n                return statuspipe[1];\n            case -1:\n                return -1;\n            default:\n                _exit(0);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            return -1;\n\n        }\n\n    case -1:\n        return -1;\n\n    default:\n        {\n            int got, exitstatus = 0;\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if ((got = waitpid(pid, &exitstatus, 0)) < 0 ||\n                got != pid ||\n                exitstatus != 0) {\n                return -1;\n            }\n\n            /* Now block until the second child initializes successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            if (ret == 1 && status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run without \"\n                          \"--daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n            }\n            _exit(ret == 1 && status == 0 ? 0 : 1);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"cannot change to root directory: %s\")",
            "g_strerror(errno)"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonPostExecRestart",
          "args": [
            "state_file",
            "pid_file",
            "&pid_file_fd",
            "privileged"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "848-912",
          "snippet": "static int\nvirLockDaemonPostExecRestart(const char *state_file,\n                             const char *pid_file,\n                             int *pid_file_fd,\n                             bool privileged)\n{\n    const char *gotmagic;\n    char *wantmagic = NULL;\n    int ret = -1;\n    char *state = NULL;\n    virJSONValuePtr object = NULL;\n\n    VIR_DEBUG(\"Running post-restart exec\");\n\n    if (!virFileExists(state_file)) {\n        VIR_DEBUG(\"No restart state file %s present\",\n                  state_file);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileReadAll(state_file,\n                       1024 * 1024 * 10, /* 10 MB */\n                       &state) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Loading state %s\", state);\n\n    if (!(object = virJSONValueFromString(state)))\n        goto cleanup;\n\n    gotmagic = virJSONValueObjectGetString(object, \"magic\");\n    if (!gotmagic) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing magic data in JSON document\"));\n        goto cleanup;\n    }\n\n    if (!(wantmagic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (STRNEQ(gotmagic, wantmagic)) {\n        VIR_WARN(\"Found restart exec file with old magic %s vs wanted %s\",\n                 gotmagic, wantmagic);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Re-claim PID file now as we will not be daemonizing */\n    if (pid_file &&\n        (*pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0)\n        goto cleanup;\n\n    if (!(lockDaemon = virLockDaemonNewPostExecRestart(object, privileged)))\n        goto cleanup;\n\n    ret = 1;\n\n cleanup:\n    unlink(state_file);\n    VIR_FREE(wantmagic);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virLockDaemonPtr lockDaemon = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\n\nstatic int\nvirLockDaemonPostExecRestart(const char *state_file,\n                             const char *pid_file,\n                             int *pid_file_fd,\n                             bool privileged)\n{\n    const char *gotmagic;\n    char *wantmagic = NULL;\n    int ret = -1;\n    char *state = NULL;\n    virJSONValuePtr object = NULL;\n\n    VIR_DEBUG(\"Running post-restart exec\");\n\n    if (!virFileExists(state_file)) {\n        VIR_DEBUG(\"No restart state file %s present\",\n                  state_file);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileReadAll(state_file,\n                       1024 * 1024 * 10, /* 10 MB */\n                       &state) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Loading state %s\", state);\n\n    if (!(object = virJSONValueFromString(state)))\n        goto cleanup;\n\n    gotmagic = virJSONValueObjectGetString(object, \"magic\");\n    if (!gotmagic) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing magic data in JSON document\"));\n        goto cleanup;\n    }\n\n    if (!(wantmagic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (STRNEQ(gotmagic, wantmagic)) {\n        VIR_WARN(\"Found restart exec file with old magic %s vs wanted %s\",\n                 gotmagic, wantmagic);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Re-claim PID file now as we will not be daemonizing */\n    if (pid_file &&\n        (*pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0)\n        goto cleanup;\n\n    if (!(lockDaemon = virLockDaemonNewPostExecRestart(object, privileged)))\n        goto cleanup;\n\n    ret = 1;\n\n cleanup:\n    unlink(state_file);\n    VIR_FREE(wantmagic);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"unable to create rundir %s: %s\")",
            "run_dir",
            "g_strerror(errno)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "run_dir"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ensuring run dir '%s' exists\"",
            "run_dir"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "022"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "RUNSTATEDIR \"/libvirt\""
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Decided on restart state file path '%s'\"",
            "state_file"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine restart state file path\")"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonExecRestartStatePath",
          "args": [
            "privileged",
            "&state_file"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonExecRestartStatePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "812-835",
          "snippet": "static int\nvirLockDaemonExecRestartStatePath(bool privileged,\n                                  char **state_file)\n{\n    if (privileged) {\n        *state_file = g_strdup(RUNSTATEDIR \"/virtlockd-restart-exec.json\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *state_file = g_strdup_printf(\"%s/virtlockd-restart-exec.json\", rundir);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonExecRestartStatePath(bool privileged,\n                                  char **state_file)\n{\n    if (privileged) {\n        *state_file = g_strdup(RUNSTATEDIR \"/virtlockd-restart-exec.json\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *state_file = g_strdup_printf(\"%s/virtlockd-restart-exec.json\", rundir);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Decided on socket paths '%s' and '%s'\"",
            "sock_file",
            "admin_sock_file"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine socket paths\")"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonUnixSocketPaths",
          "args": [
            "privileged",
            "&sock_file",
            "&admin_sock_file"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonUnixSocketPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "443-468",
          "snippet": "static int\nvirLockDaemonUnixSocketPaths(bool privileged,\n                             char **sockfile,\n                             char **adminSockfile)\n{\n    if (privileged) {\n        *sockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n        *adminSockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-admin-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *sockfile = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n        *adminSockfile = g_strdup_printf(\"%s/virtlockd-admin-sock\", rundir);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonUnixSocketPaths(bool privileged,\n                             char **sockfile,\n                             char **adminSockfile)\n{\n    if (privileged) {\n        *sockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n        *adminSockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-admin-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *sockfile = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n        *adminSockfile = g_strdup_printf(\"%s/virtlockd-admin-sock\", rundir);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Decided on pid file path '%s'\"",
            "NULLSTR(pid_file)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "pid_file"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine pid file path.\")"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileConstructPath",
          "args": [
            "privileged",
            "RUNSTATEDIR",
            "\"virtlockd\"",
            "&pid_file"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileConstructPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "469-502",
          "snippet": "int\nvirPidFileConstructPath(bool privileged,\n                        const char *runstatedir,\n                        const char *progname,\n                        char **pidfile)\n{\n    g_autofree char *rundir = NULL;\n\n    if (privileged) {\n        /*\n         * This is here just to allow calling this function with\n         * statedir == NULL; of course only when !privileged.\n         */\n        if (!runstatedir) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"No runstatedir specified\"));\n            return -1;\n        }\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", runstatedir, progname);\n    } else {\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            return -1;\n        }\n\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", rundir, progname);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirPidFileConstructPath(bool privileged,\n                        const char *runstatedir,\n                        const char *progname,\n                        char **pidfile)\n{\n    g_autofree char *rundir = NULL;\n\n    if (privileged) {\n        /*\n         * This is here just to allow calling this function with\n         * statedir == NULL; of course only when !privileged.\n         */\n        if (!runstatedir) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"No runstatedir specified\"));\n            return -1;\n        }\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", runstatedir, progname);\n    } else {\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            return -1;\n        }\n\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", rundir, progname);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't initialize logging\")"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonSetupLogging",
          "args": [
            "config",
            "privileged",
            "verbose",
            "godaemon"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonSetupLogging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "486-529",
          "snippet": "static int\nvirLockDaemonSetupLogging(virLockDaemonConfigPtr config,\n                          bool privileged,\n                          bool verbose,\n                          bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Libvirtd's order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(\"virtlockd\", godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonSetupLogging(virLockDaemonConfigPtr config,\n                          bool privileged,\n                          bool verbose,\n                          bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Libvirtd's order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(\"virtlockd\", godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "remote_config_file"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't load config file: %s: %s\")",
            "virGetLastErrorMessage()",
            "remote_config_file"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonConfigLoadFile",
          "args": [
            "config",
            "remote_config_file",
            "implicit_conf"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonConfigLoadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_config.c",
          "lines": "103-120",
          "snippet": "int\nvirLockDaemonConfigLoadFile(virLockDaemonConfigPtr data,\n                            const char *filename,\n                            bool allow_missing)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (allow_missing &&\n        access(filename, R_OK) == -1 &&\n        errno == ENOENT)\n        return 0;\n\n    conf = virConfReadFile(filename, 0);\n    if (!conf)\n        return -1;\n\n    return virLockDaemonConfigLoadOptions(data, conf);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_daemon_config.h\"\n#include <config.h>\n\nint\nvirLockDaemonConfigLoadFile(virLockDaemonConfigPtr data,\n                            const char *filename,\n                            bool allow_missing)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (allow_missing &&\n        access(filename, R_OK) == -1 &&\n        errno == ENOENT)\n        return 0;\n\n    conf = virConfReadFile(filename, 0);\n    if (!conf)\n        return -1;\n\n    return virLockDaemonConfigLoadOptions(data, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't determine config path\")"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonConfigFilePath",
          "args": [
            "privileged",
            "&remote_config_file"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonConfigFilePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_config.c",
          "lines": "38-52",
          "snippet": "int\nvirLockDaemonConfigFilePath(bool privileged, char **configfile)\n{\n    if (privileged) {\n        *configfile = g_strdup(SYSCONFDIR \"/libvirt/virtlockd.conf\");\n    } else {\n        g_autofree char *configdir = NULL;\n\n        configdir = virGetUserConfigDirectory();\n\n        *configfile = g_strdup_printf(\"%s/virtlockd.conf\", configdir);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_daemon_config.h\"\n#include <config.h>\n\nint\nvirLockDaemonConfigFilePath(bool privileged, char **configfile)\n{\n    if (privileged) {\n        *configfile = g_strdup(SYSCONFDIR \"/libvirt/virtlockd.conf\");\n    } else {\n        g_autofree char *configdir = NULL;\n\n        configdir = virGetUserConfigDirectory();\n\n        *configfile = g_strdup_printf(\"%s/virtlockd.conf\", configdir);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Can't create initial configuration\")"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonConfigNew",
          "args": [
            "privileged"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonConfigNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon_config.c",
          "lines": "55-67",
          "snippet": "virLockDaemonConfigPtr\nvirLockDaemonConfigNew(bool privileged G_GNUC_UNUSED)\n{\n    virLockDaemonConfigPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->max_clients = 1024;\n    data->admin_max_clients = 5000;\n\n    return data;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"lock_daemon_config.h\"\n#include <config.h>\n\nvirLockDaemonConfigPtr\nvirLockDaemonConfigNew(bool privileged G_GNUC_UNUSED)\n{\n    virLockDaemonConfigPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->max_clients = 1024;\n    data->admin_max_clients = 5000;\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileActivateDirOverrideForProg",
          "args": [
            "argv[0]"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "virFileActivateDirOverrideForProg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1788-1800",
          "snippet": "void\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nvoid\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonUsage",
          "args": [
            "argv[0]",
            "privileged"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "1006-1057",
          "snippet": "static void\nvirLockDaemonUsage(const char *argv0, bool privileged)\n{\n    fprintf(stderr,\n            _(\"\\n\"\n              \"Usage:\\n\"\n              \"  %s [options]\\n\"\n              \"\\n\"\n              \"Options:\\n\"\n              \"  -h | --help            Display program help:\\n\"\n              \"  -v | --verbose         Verbose messages.\\n\"\n              \"  -d | --daemon          Run as a daemon & write PID file.\\n\"\n              \"  -t | --timeout <secs>  Exit after timeout period.\\n\"\n              \"  -f | --config <file>   Configuration file.\\n\"\n              \"  -V | --version         Display version information.\\n\"\n              \"  -p | --pid-file <file> Change name of PID file.\\n\"\n              \"\\n\"\n              \"libvirt lock management daemon:\\n\"), argv0);\n\n    if (privileged) {\n        fprintf(stderr,\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      %s/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      %s/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file (unless overridden by -p):\\n\"\n                  \"      %s/virtlockd.pid\\n\"\n                  \"\\n\"),\n                SYSCONFDIR,\n                RUNSTATEDIR,\n                RUNSTATEDIR);\n    } else {\n        fprintf(stderr, \"%s\",\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      $XDG_CONFIG_HOME/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd.pid\\n\"\n                  \"\\n\"));\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonUsage(const char *argv0, bool privileged)\n{\n    fprintf(stderr,\n            _(\"\\n\"\n              \"Usage:\\n\"\n              \"  %s [options]\\n\"\n              \"\\n\"\n              \"Options:\\n\"\n              \"  -h | --help            Display program help:\\n\"\n              \"  -v | --verbose         Verbose messages.\\n\"\n              \"  -d | --daemon          Run as a daemon & write PID file.\\n\"\n              \"  -t | --timeout <secs>  Exit after timeout period.\\n\"\n              \"  -f | --config <file>   Configuration file.\\n\"\n              \"  -V | --version         Display version information.\\n\"\n              \"  -p | --pid-file <file> Change name of PID file.\\n\"\n              \"\\n\"\n              \"libvirt lock management daemon:\\n\"), argv0);\n\n    if (privileged) {\n        fprintf(stderr,\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      %s/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      %s/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file (unless overridden by -p):\\n\"\n                  \"      %s/virtlockd.pid\\n\"\n                  \"\\n\"),\n                SYSCONFDIR,\n                RUNSTATEDIR,\n                RUNSTATEDIR);\n    } else {\n        fprintf(stderr, \"%s\",\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      $XDG_CONFIG_HOME/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd.pid\\n\"\n                  \"\\n\"));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonVersion",
          "args": [
            "argv[0]"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "534-538",
          "snippet": "static void\nvirLockDaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "remote_config_file"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pid_file"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Invalid value for timeout\")"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "optarg",
            "&tmp",
            "10",
            "&timeout"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"df:p:t:vVh\"",
            "opts",
            "&optidx"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: initialization failed\\n\")",
            "argv[0]"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorInitialize",
          "args": [],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "172-176",
          "snippet": "int\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal virLastErr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirThreadLocal virLastErr;\n\nint\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\nstatic bool execRestart;\n\nint main(int argc, char **argv) {\n    virNetServerPtr lockSrv = NULL;\n    virNetServerPtr adminSrv = NULL;\n    virNetServerProgramPtr lockProgram = NULL;\n    virNetServerProgramPtr adminProgram = NULL;\n    char *remote_config_file = NULL;\n    int statuswrite = -1;\n    int ret = 1;\n    int verbose = 0;\n    int godaemon = 0;\n    char *run_dir = NULL;\n    char *pid_file = NULL;\n    int pid_file_fd = -1;\n    char *sock_file = NULL;\n    char *admin_sock_file = NULL;\n    int timeout = -1;        /* -t: Shutdown timeout */\n    char *state_file = NULL;\n    bool implicit_conf = false;\n    mode_t old_umask;\n    bool privileged = false;\n    virLockDaemonConfigPtr config = NULL;\n    int rv;\n\n    struct option opts[] = {\n        { \"verbose\", no_argument, &verbose, 'v'},\n        { \"daemon\", no_argument, &godaemon, 'd'},\n        { \"config\", required_argument, NULL, 'f'},\n        { \"timeout\", required_argument, NULL, 't'},\n        { \"pid-file\", required_argument, NULL, 'p'},\n        { \"version\", no_argument, NULL, 'V' },\n        { \"help\", no_argument, NULL, 'h' },\n        {0, 0, 0, 0}\n    };\n\n    privileged = geteuid() == 0;\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        int optidx = 0;\n        int c;\n        char *tmp;\n\n        c = getopt_long(argc, argv, \"df:p:t:vVh\", opts, &optidx);\n\n        if (c == -1)\n            break;\n\n        switch (c) {\n        case 0:\n            /* Got one of the flags */\n            break;\n        case 'v':\n            verbose = 1;\n            break;\n        case 'd':\n            godaemon = 1;\n            break;\n\n        case 't':\n            if (virStrToLong_i(optarg, &tmp, 10, &timeout) != 0\n                || timeout <= 0\n                /* Ensure that we can multiply by 1000 without overflowing.  */\n                || timeout > INT_MAX / 1000) {\n                VIR_ERROR(_(\"Invalid value for timeout\"));\n                exit(EXIT_FAILURE);\n            }\n            break;\n\n        case 'p':\n            VIR_FREE(pid_file);\n            pid_file = g_strdup(optarg);\n            break;\n\n        case 'f':\n            VIR_FREE(remote_config_file);\n            remote_config_file = g_strdup(optarg);\n            break;\n\n        case 'V':\n            virLockDaemonVersion(argv[0]);\n            exit(EXIT_SUCCESS);\n\n        case 'h':\n            virLockDaemonUsage(argv[0], privileged);\n            exit(EXIT_SUCCESS);\n\n        case '?':\n        default:\n            virLockDaemonUsage(argv[0], privileged);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    if (!(config = virLockDaemonConfigNew(privileged))) {\n        VIR_ERROR(_(\"Can't create initial configuration\"));\n        exit(EXIT_FAILURE);\n    }\n\n    /* No explicit config, so try and find a default one */\n    if (remote_config_file == NULL) {\n        implicit_conf = true;\n        if (virLockDaemonConfigFilePath(privileged,\n                                        &remote_config_file) < 0) {\n            VIR_ERROR(_(\"Can't determine config path\"));\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* Read the config file if it exists */\n    if (remote_config_file &&\n        virLockDaemonConfigLoadFile(config, remote_config_file, implicit_conf) < 0) {\n        VIR_ERROR(_(\"Can't load config file: %s: %s\"),\n                  virGetLastErrorMessage(), remote_config_file);\n        exit(EXIT_FAILURE);\n    }\n    VIR_FREE(remote_config_file);\n\n    if (virLockDaemonSetupLogging(config, privileged, verbose, godaemon) < 0) {\n        VIR_ERROR(_(\"Can't initialize logging\"));\n        exit(EXIT_FAILURE);\n    }\n\n    if (!pid_file &&\n        virPidFileConstructPath(privileged,\n                                RUNSTATEDIR,\n                                \"virtlockd\",\n                                &pid_file) < 0) {\n        VIR_ERROR(_(\"Can't determine pid file path.\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on pid file path '%s'\", NULLSTR(pid_file));\n\n    if (virLockDaemonUnixSocketPaths(privileged,\n                                     &sock_file,\n                                     &admin_sock_file) < 0) {\n        VIR_ERROR(_(\"Can't determine socket paths\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on socket paths '%s' and '%s'\",\n              sock_file, admin_sock_file);\n\n    if (virLockDaemonExecRestartStatePath(privileged,\n                                          &state_file) < 0) {\n        VIR_ERROR(_(\"Can't determine restart state file path\"));\n        exit(EXIT_FAILURE);\n    }\n    VIR_DEBUG(\"Decided on restart state file path '%s'\",\n              state_file);\n\n    /* Ensure the rundir exists (on tmpfs on some systems) */\n    if (privileged) {\n        run_dir = g_strdup(RUNSTATEDIR \"/libvirt\");\n    } else {\n        run_dir = virGetUserRuntimeDirectory();\n    }\n\n    if (privileged)\n        old_umask = umask(022);\n    else\n        old_umask = umask(077);\n    VIR_DEBUG(\"Ensuring run dir '%s' exists\", run_dir);\n    if (virFileMakePath(run_dir) < 0) {\n        VIR_ERROR(_(\"unable to create rundir %s: %s\"), run_dir,\n                  g_strerror(errno));\n        ret = VIR_LOCK_DAEMON_ERR_RUNDIR;\n        umask(old_umask);\n        goto cleanup;\n    }\n    umask(old_umask);\n\n    if ((rv = virLockDaemonPostExecRestart(state_file,\n                                           pid_file,\n                                           &pid_file_fd,\n                                           privileged)) < 0) {\n        ret = VIR_LOCK_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    /* rv == 1 means we successfully restored from the saved internal state\n     * (but still need to add @lockProgram into @srv). rv == 0 means that no\n     * saved state is present, therefore initialize from scratch here. */\n    if (rv == 0) {\n        g_autoptr(virSystemdActivation) act = NULL;\n        virSystemdActivationMap actmap[] = {\n            { .name = \"virtlockd.socket\", .family = AF_UNIX, .path = sock_file },\n            { .name = \"virtlockd-admin.socket\", .family = AF_UNIX, .path = admin_sock_file },\n        };\n\n        if (godaemon) {\n            if (chdir(\"/\") < 0) {\n                VIR_ERROR(_(\"cannot change to root directory: %s\"),\n                          g_strerror(errno));\n                goto cleanup;\n            }\n\n            if ((statuswrite = virLockDaemonForkIntoBackground(argv[0])) < 0) {\n                VIR_ERROR(_(\"Failed to fork as daemon: %s\"),\n                          g_strerror(errno));\n                goto cleanup;\n            }\n        }\n\n        /* If we have a pidfile set, claim it now, exiting if already taken */\n        if ((pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_PIDFILE;\n            goto cleanup;\n        }\n\n        if (!(lockDaemon = virLockDaemonNew(config, privileged))) {\n            ret = VIR_LOCK_DAEMON_ERR_INIT;\n            goto cleanup;\n        }\n\n        if (virSystemdGetActivation(actmap,\n                                    G_N_ELEMENTS(actmap),\n                                    &act) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n\n        lockSrv = virNetDaemonGetServer(lockDaemon->dmn, \"virtlockd\");\n        adminSrv = virNetDaemonGetServer(lockDaemon->dmn, \"admin\");\n\n        if (virNetServerAddServiceUNIX(lockSrv,\n                                       act, \"virtlockd.socket\",\n                                       sock_file, 0700, 0, 0,\n                                       NULL,\n                                       false, 0, 1) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n        if (virNetServerAddServiceUNIX(adminSrv,\n                                       act, \"virtlockd-admin.socket\",\n                                       admin_sock_file, 0700, 0, 0,\n                                       NULL,\n                                       false, 0, 1) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n\n        if (act &&\n            virSystemdActivationComplete(act) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_NETWORK;\n            goto cleanup;\n        }\n    } else {\n        lockSrv = virNetDaemonGetServer(lockDaemon->dmn, \"virtlockd\");\n        /* If exec-restarting from old virtlockd, we won't have an\n         * admin server present */\n        if (virNetDaemonHasServer(lockDaemon->dmn, \"admin\"))\n            adminSrv = virNetDaemonGetServer(lockDaemon->dmn, \"admin\");\n    }\n\n    if (timeout != -1) {\n        VIR_DEBUG(\"Registering shutdown timeout %d\", timeout);\n        virNetDaemonAutoShutdown(lockDaemon->dmn,\n                                 timeout);\n    }\n\n    if ((virLockDaemonSetupSignals(lockDaemon->dmn)) < 0) {\n        ret = VIR_LOCK_DAEMON_ERR_SIGNAL;\n        goto cleanup;\n    }\n\n    if (!(lockProgram = virNetServerProgramNew(VIR_LOCK_SPACE_PROTOCOL_PROGRAM,\n                                               VIR_LOCK_SPACE_PROTOCOL_PROGRAM_VERSION,\n                                               virLockSpaceProtocolProcs,\n                                               virLockSpaceProtocolNProcs))) {\n        ret = VIR_LOCK_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (virNetServerAddProgram(lockSrv, lockProgram) < 0) {\n        ret = VIR_LOCK_DAEMON_ERR_INIT;\n        goto cleanup;\n    }\n\n    if (adminSrv != NULL) {\n        if (!(adminProgram = virNetServerProgramNew(ADMIN_PROGRAM,\n                                                    ADMIN_PROTOCOL_VERSION,\n                                                    adminProcs,\n                                                    adminNProcs))) {\n            ret = VIR_LOCK_DAEMON_ERR_INIT;\n            goto cleanup;\n        }\n        if (virNetServerAddProgram(adminSrv, adminProgram) < 0) {\n            ret = VIR_LOCK_DAEMON_ERR_INIT;\n            goto cleanup;\n        }\n    }\n\n    /* Disable error func, now logging is setup */\n    virSetErrorFunc(NULL, virLockDaemonErrorHandler);\n\n\n    /* Tell parent of daemon that basic initialization is complete\n     * In particular we're ready to accept net connections & have\n     * written the pidfile\n     */\n    if (statuswrite != -1) {\n        char status = 0;\n        while (write(statuswrite, &status, 1) == -1 &&\n               errno == EINTR)\n            ;\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n\n    /* Start accepting new clients from network */\n\n    virNetDaemonUpdateServices(lockDaemon->dmn, true);\n    virNetDaemonRun(lockDaemon->dmn);\n\n    if (execRestart &&\n        virLockDaemonPreExecRestart(state_file,\n                                    lockDaemon->dmn,\n                                    argv) < 0)\n        ret = VIR_LOCK_DAEMON_ERR_REEXEC;\n    else\n        ret = 0;\n\n cleanup:\n    virObjectUnref(lockProgram);\n    virObjectUnref(adminProgram);\n    virObjectUnref(lockSrv);\n    virObjectUnref(adminSrv);\n    virLockDaemonFree(lockDaemon);\n    if (statuswrite != -1) {\n        if (ret != 0) {\n            /* Tell parent of daemon what failed */\n            char status = ret;\n            while (write(statuswrite, &status, 1) == -1 &&\n                   errno == EINTR)\n                ;\n        }\n        VIR_FORCE_CLOSE(statuswrite);\n    }\n    if (pid_file_fd != -1)\n        virPidFileReleasePath(pid_file, pid_file_fd);\n    VIR_FREE(pid_file);\n    VIR_FREE(sock_file);\n    VIR_FREE(admin_sock_file);\n    VIR_FREE(state_file);\n    VIR_FREE(run_dir);\n    virLockDaemonConfigFree(config);\n    return ret;\n}"
  },
  {
    "function_name": "virLockDaemonUsage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "1006-1057",
    "snippet": "static void\nvirLockDaemonUsage(const char *argv0, bool privileged)\n{\n    fprintf(stderr,\n            _(\"\\n\"\n              \"Usage:\\n\"\n              \"  %s [options]\\n\"\n              \"\\n\"\n              \"Options:\\n\"\n              \"  -h | --help            Display program help:\\n\"\n              \"  -v | --verbose         Verbose messages.\\n\"\n              \"  -d | --daemon          Run as a daemon & write PID file.\\n\"\n              \"  -t | --timeout <secs>  Exit after timeout period.\\n\"\n              \"  -f | --config <file>   Configuration file.\\n\"\n              \"  -V | --version         Display version information.\\n\"\n              \"  -p | --pid-file <file> Change name of PID file.\\n\"\n              \"\\n\"\n              \"libvirt lock management daemon:\\n\"), argv0);\n\n    if (privileged) {\n        fprintf(stderr,\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      %s/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      %s/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file (unless overridden by -p):\\n\"\n                  \"      %s/virtlockd.pid\\n\"\n                  \"\\n\"),\n                SYSCONFDIR,\n                RUNSTATEDIR,\n                RUNSTATEDIR);\n    } else {\n        fprintf(stderr, \"%s\",\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      $XDG_CONFIG_HOME/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd.pid\\n\"\n                  \"\\n\"));\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "_(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      $XDG_CONFIG_HOME/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd.pid\\n\"\n                  \"\\n\")"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      $XDG_CONFIG_HOME/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd.pid\\n\"\n                  \"\\n\""
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      %s/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      %s/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file (unless overridden by -p):\\n\"\n                  \"      %s/virtlockd.pid\\n\"\n                  \"\\n\")",
            "SYSCONFDIR",
            "RUNSTATEDIR",
            "RUNSTATEDIR"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"\\n\"\n              \"Usage:\\n\"\n              \"  %s [options]\\n\"\n              \"\\n\"\n              \"Options:\\n\"\n              \"  -h | --help            Display program help:\\n\"\n              \"  -v | --verbose         Verbose messages.\\n\"\n              \"  -d | --daemon          Run as a daemon & write PID file.\\n\"\n              \"  -t | --timeout <secs>  Exit after timeout period.\\n\"\n              \"  -f | --config <file>   Configuration file.\\n\"\n              \"  -V | --version         Display version information.\\n\"\n              \"  -p | --pid-file <file> Change name of PID file.\\n\"\n              \"\\n\"\n              \"libvirt lock management daemon:\\n\")",
            "argv0"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonUsage(const char *argv0, bool privileged)\n{\n    fprintf(stderr,\n            _(\"\\n\"\n              \"Usage:\\n\"\n              \"  %s [options]\\n\"\n              \"\\n\"\n              \"Options:\\n\"\n              \"  -h | --help            Display program help:\\n\"\n              \"  -v | --verbose         Verbose messages.\\n\"\n              \"  -d | --daemon          Run as a daemon & write PID file.\\n\"\n              \"  -t | --timeout <secs>  Exit after timeout period.\\n\"\n              \"  -f | --config <file>   Configuration file.\\n\"\n              \"  -V | --version         Display version information.\\n\"\n              \"  -p | --pid-file <file> Change name of PID file.\\n\"\n              \"\\n\"\n              \"libvirt lock management daemon:\\n\"), argv0);\n\n    if (privileged) {\n        fprintf(stderr,\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      %s/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      %s/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file (unless overridden by -p):\\n\"\n                  \"      %s/virtlockd.pid\\n\"\n                  \"\\n\"),\n                SYSCONFDIR,\n                RUNSTATEDIR,\n                RUNSTATEDIR);\n    } else {\n        fprintf(stderr, \"%s\",\n                _(\"\\n\"\n                  \"  Default paths:\\n\"\n                  \"\\n\"\n                  \"    Configuration file (unless overridden by -f):\\n\"\n                  \"      $XDG_CONFIG_HOME/libvirt/virtlockd.conf\\n\"\n                  \"\\n\"\n                  \"    Sockets:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd-sock\\n\"\n                  \"\\n\"\n                  \"    PID file:\\n\"\n                  \"      $XDG_RUNTIME_DIR/libvirt/virtlockd.pid\\n\"\n                  \"\\n\"));\n    }\n}"
  },
  {
    "function_name": "virLockDaemonPreExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "915-1003",
    "snippet": "static int\nvirLockDaemonPreExecRestart(const char *state_file,\n                            virNetDaemonPtr dmn,\n                            char **argv)\n{\n    virJSONValuePtr child;\n    char *state = NULL;\n    int ret = -1;\n    virJSONValuePtr object = virJSONValueNewObject();\n    char *magic;\n    virHashKeyValuePairPtr pairs = NULL, tmp;\n    virJSONValuePtr lockspaces;\n\n    VIR_DEBUG(\"Running pre-restart exec\");\n\n    if (!(child = virNetDaemonPreExecRestart(dmn)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"daemon\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    if (!(child = virLockSpacePreExecRestart(lockDaemon->defaultLockspace)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"defaultLockspace\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    lockspaces = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"lockspaces\", lockspaces) < 0) {\n        virJSONValueFree(lockspaces);\n        goto cleanup;\n    }\n\n\n    tmp = pairs = virHashGetItems(lockDaemon->lockspaces, NULL);\n    while (tmp && tmp->key) {\n        virLockSpacePtr lockspace = (virLockSpacePtr)tmp->value;\n\n        if (!(child = virLockSpacePreExecRestart(lockspace)))\n            goto cleanup;\n\n        if (virJSONValueArrayAppend(lockspaces, child) < 0) {\n            virJSONValueFree(child);\n            goto cleanup;\n        }\n\n        tmp++;\n    }\n\n    if (!(magic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (virJSONValueObjectAppendString(object, \"magic\", magic) < 0) {\n        VIR_FREE(magic);\n        goto cleanup;\n    }\n\n    if (!(state = virJSONValueToString(object, true)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Saving state %s\", state);\n\n    if (virFileWriteStr(state_file,\n                        state, 0700) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to save state file %s\"),\n                             state_file);\n        goto cleanup;\n    }\n\n    if (execvp(argv[0], argv) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to restart self\"));\n        goto cleanup;\n    }\n\n    abort(); /* This should be impossible to reach */\n\n cleanup:\n    VIR_FREE(pairs);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virLockDaemonPtr lockDaemon = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "object"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pairs"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to restart self\")"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to restart self\""
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to save state file %s\")",
            "state_file"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "state_file",
            "state",
            "0700"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Saving state %s\"",
            "state"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueToString",
          "args": [
            "object",
            "true"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "2014-2024",
          "snippet": "char *\nvirJSONValueToString(virJSONValuePtr object,\n                     bool pretty)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n\n    if (virJSONValueToBuffer(object, &buf, pretty) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nchar *\nvirJSONValueToString(virJSONValuePtr object,\n                     bool pretty)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n\n    if (virJSONValueToBuffer(object, &buf, pretty) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "magic"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "object",
            "\"magic\"",
            "magic"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonGetExecRestartMagic",
          "args": [],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonGetExecRestartMagic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "838-845",
          "snippet": "static char *\nvirLockDaemonGetExecRestartMagic(void)\n{\n    char *ret;\n\n    ret = g_strdup_printf(\"%lld\", (long long int)getpid());\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvirLockDaemonGetExecRestartMagic(void)\n{\n    char *ret;\n\n    ret = g_strdup_printf(\"%lld\", (long long int)getpid());\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppend",
          "args": [
            "lockspaces",
            "child"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpacePreExecRestart",
          "args": [
            "lockspace"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpacePreExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "428-502",
          "snippet": "virJSONValuePtr virLockSpacePreExecRestart(virLockSpacePtr lockspace)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr resources;\n    virHashKeyValuePairPtr pairs = NULL, tmp;\n\n    virMutexLock(&lockspace->lock);\n\n    if (lockspace->dir &&\n        virJSONValueObjectAppendString(object, \"directory\", lockspace->dir) < 0)\n        goto error;\n\n    resources = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"resources\", resources) < 0) {\n        virJSONValueFree(resources);\n        goto error;\n    }\n\n    tmp = pairs = virHashGetItems(lockspace->resources, NULL);\n    while (tmp && tmp->value) {\n        virLockSpaceResourcePtr res = (virLockSpaceResourcePtr)tmp->value;\n        virJSONValuePtr child = virJSONValueNewObject();\n        virJSONValuePtr owners = NULL;\n        size_t i;\n\n        if (virJSONValueArrayAppend(resources, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n\n        if (virJSONValueObjectAppendString(child, \"name\", res->name) < 0 ||\n            virJSONValueObjectAppendString(child, \"path\", res->path) < 0 ||\n            virJSONValueObjectAppendNumberInt(child, \"fd\", res->fd) < 0 ||\n            virJSONValueObjectAppendBoolean(child, \"lockHeld\", res->lockHeld) < 0 ||\n            virJSONValueObjectAppendNumberUint(child, \"flags\", res->flags) < 0)\n            goto error;\n\n        if (virSetInherit(res->fd, true) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot disable close-on-exec flag\"));\n            goto error;\n        }\n\n        owners = virJSONValueNewArray();\n\n        if (virJSONValueObjectAppend(child, \"owners\", owners) < 0) {\n            virJSONValueFree(owners);\n            goto error;\n        }\n\n        for (i = 0; i < res->nOwners; i++) {\n            virJSONValuePtr owner = virJSONValueNewNumberUlong(res->owners[i]);\n            if (!owner)\n                goto error;\n\n            if (virJSONValueArrayAppend(owners, owner) < 0) {\n                virJSONValueFree(owner);\n                goto error;\n            }\n        }\n\n        tmp++;\n    }\n    VIR_FREE(pairs);\n\n    virMutexUnlock(&lockspace->lock);\n    return object;\n\n error:\n    VIR_FREE(pairs);\n    virJSONValueFree(object);\n    virMutexUnlock(&lockspace->lock);\n    return NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nvirJSONValuePtr virLockSpacePreExecRestart(virLockSpacePtr lockspace)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr resources;\n    virHashKeyValuePairPtr pairs = NULL, tmp;\n\n    virMutexLock(&lockspace->lock);\n\n    if (lockspace->dir &&\n        virJSONValueObjectAppendString(object, \"directory\", lockspace->dir) < 0)\n        goto error;\n\n    resources = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"resources\", resources) < 0) {\n        virJSONValueFree(resources);\n        goto error;\n    }\n\n    tmp = pairs = virHashGetItems(lockspace->resources, NULL);\n    while (tmp && tmp->value) {\n        virLockSpaceResourcePtr res = (virLockSpaceResourcePtr)tmp->value;\n        virJSONValuePtr child = virJSONValueNewObject();\n        virJSONValuePtr owners = NULL;\n        size_t i;\n\n        if (virJSONValueArrayAppend(resources, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n\n        if (virJSONValueObjectAppendString(child, \"name\", res->name) < 0 ||\n            virJSONValueObjectAppendString(child, \"path\", res->path) < 0 ||\n            virJSONValueObjectAppendNumberInt(child, \"fd\", res->fd) < 0 ||\n            virJSONValueObjectAppendBoolean(child, \"lockHeld\", res->lockHeld) < 0 ||\n            virJSONValueObjectAppendNumberUint(child, \"flags\", res->flags) < 0)\n            goto error;\n\n        if (virSetInherit(res->fd, true) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot disable close-on-exec flag\"));\n            goto error;\n        }\n\n        owners = virJSONValueNewArray();\n\n        if (virJSONValueObjectAppend(child, \"owners\", owners) < 0) {\n            virJSONValueFree(owners);\n            goto error;\n        }\n\n        for (i = 0; i < res->nOwners; i++) {\n            virJSONValuePtr owner = virJSONValueNewNumberUlong(res->owners[i]);\n            if (!owner)\n                goto error;\n\n            if (virJSONValueArrayAppend(owners, owner) < 0) {\n                virJSONValueFree(owner);\n                goto error;\n            }\n        }\n\n        tmp++;\n    }\n    VIR_FREE(pairs);\n\n    virMutexUnlock(&lockspace->lock);\n    return object;\n\n error:\n    VIR_FREE(pairs);\n    virJSONValueFree(object);\n    virMutexUnlock(&lockspace->lock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashGetItems",
          "args": [
            "lockDaemon->lockspaces",
            "NULL"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "virHashGetItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "783-805",
          "snippet": "virHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "object",
            "\"lockspaces\"",
            "lockspaces"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonPreExecRestart",
          "args": [
            "dmn"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonPreExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "381-426",
          "snippet": "virJSONValuePtr\nvirNetDaemonPreExecRestart(virNetDaemonPtr dmn)\n{\n    size_t i = 0;\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr srvObj = virJSONValueNewObject();\n    virHashKeyValuePairPtr srvArray = NULL;\n\n    virObjectLock(dmn);\n\n    if (virJSONValueObjectAppend(object, \"servers\", srvObj) < 0) {\n        virJSONValueFree(srvObj);\n        goto error;\n    }\n\n    if (!(srvArray = virHashGetItems(dmn->servers, daemonServerCompare)))\n        goto error;\n\n    for (i = 0; srvArray[i].key; i++) {\n        virNetServerPtr server = virHashLookup(dmn->servers, srvArray[i].key);\n        virJSONValuePtr srvJSON;\n\n        if (!server)\n            goto error;\n\n        srvJSON = virNetServerPreExecRestart(server);\n        if (!srvJSON)\n            goto error;\n\n        if (virJSONValueObjectAppend(srvObj, srvArray[i].key, srvJSON) < 0) {\n            virJSONValueFree(srvJSON);\n            goto error;\n        }\n    }\n\n    VIR_FREE(srvArray);\n    virObjectUnlock(dmn);\n\n    return object;\n\n error:\n    VIR_FREE(srvArray);\n    virJSONValueFree(object);\n    virObjectUnlock(dmn);\n    return NULL;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirJSONValuePtr\nvirNetDaemonPreExecRestart(virNetDaemonPtr dmn)\n{\n    size_t i = 0;\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr srvObj = virJSONValueNewObject();\n    virHashKeyValuePairPtr srvArray = NULL;\n\n    virObjectLock(dmn);\n\n    if (virJSONValueObjectAppend(object, \"servers\", srvObj) < 0) {\n        virJSONValueFree(srvObj);\n        goto error;\n    }\n\n    if (!(srvArray = virHashGetItems(dmn->servers, daemonServerCompare)))\n        goto error;\n\n    for (i = 0; srvArray[i].key; i++) {\n        virNetServerPtr server = virHashLookup(dmn->servers, srvArray[i].key);\n        virJSONValuePtr srvJSON;\n\n        if (!server)\n            goto error;\n\n        srvJSON = virNetServerPreExecRestart(server);\n        if (!srvJSON)\n            goto error;\n\n        if (virJSONValueObjectAppend(srvObj, srvArray[i].key, srvJSON) < 0) {\n            virJSONValueFree(srvJSON);\n            goto error;\n        }\n    }\n\n    VIR_FREE(srvArray);\n    virObjectUnlock(dmn);\n\n    return object;\n\n error:\n    VIR_FREE(srvArray);\n    virJSONValueFree(object);\n    virObjectUnlock(dmn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Running pre-restart exec\""
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\n\nstatic int\nvirLockDaemonPreExecRestart(const char *state_file,\n                            virNetDaemonPtr dmn,\n                            char **argv)\n{\n    virJSONValuePtr child;\n    char *state = NULL;\n    int ret = -1;\n    virJSONValuePtr object = virJSONValueNewObject();\n    char *magic;\n    virHashKeyValuePairPtr pairs = NULL, tmp;\n    virJSONValuePtr lockspaces;\n\n    VIR_DEBUG(\"Running pre-restart exec\");\n\n    if (!(child = virNetDaemonPreExecRestart(dmn)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"daemon\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    if (!(child = virLockSpacePreExecRestart(lockDaemon->defaultLockspace)))\n        goto cleanup;\n\n    if (virJSONValueObjectAppend(object, \"defaultLockspace\", child) < 0) {\n        virJSONValueFree(child);\n        goto cleanup;\n    }\n\n    lockspaces = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"lockspaces\", lockspaces) < 0) {\n        virJSONValueFree(lockspaces);\n        goto cleanup;\n    }\n\n\n    tmp = pairs = virHashGetItems(lockDaemon->lockspaces, NULL);\n    while (tmp && tmp->key) {\n        virLockSpacePtr lockspace = (virLockSpacePtr)tmp->value;\n\n        if (!(child = virLockSpacePreExecRestart(lockspace)))\n            goto cleanup;\n\n        if (virJSONValueArrayAppend(lockspaces, child) < 0) {\n            virJSONValueFree(child);\n            goto cleanup;\n        }\n\n        tmp++;\n    }\n\n    if (!(magic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (virJSONValueObjectAppendString(object, \"magic\", magic) < 0) {\n        VIR_FREE(magic);\n        goto cleanup;\n    }\n\n    if (!(state = virJSONValueToString(object, true)))\n        goto cleanup;\n\n    VIR_DEBUG(\"Saving state %s\", state);\n\n    if (virFileWriteStr(state_file,\n                        state, 0700) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to save state file %s\"),\n                             state_file);\n        goto cleanup;\n    }\n\n    if (execvp(argv[0], argv) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to restart self\"));\n        goto cleanup;\n    }\n\n    abort(); /* This should be impossible to reach */\n\n cleanup:\n    VIR_FREE(pairs);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}"
  },
  {
    "function_name": "virLockDaemonPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "848-912",
    "snippet": "static int\nvirLockDaemonPostExecRestart(const char *state_file,\n                             const char *pid_file,\n                             int *pid_file_fd,\n                             bool privileged)\n{\n    const char *gotmagic;\n    char *wantmagic = NULL;\n    int ret = -1;\n    char *state = NULL;\n    virJSONValuePtr object = NULL;\n\n    VIR_DEBUG(\"Running post-restart exec\");\n\n    if (!virFileExists(state_file)) {\n        VIR_DEBUG(\"No restart state file %s present\",\n                  state_file);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileReadAll(state_file,\n                       1024 * 1024 * 10, /* 10 MB */\n                       &state) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Loading state %s\", state);\n\n    if (!(object = virJSONValueFromString(state)))\n        goto cleanup;\n\n    gotmagic = virJSONValueObjectGetString(object, \"magic\");\n    if (!gotmagic) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing magic data in JSON document\"));\n        goto cleanup;\n    }\n\n    if (!(wantmagic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (STRNEQ(gotmagic, wantmagic)) {\n        VIR_WARN(\"Found restart exec file with old magic %s vs wanted %s\",\n                 gotmagic, wantmagic);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Re-claim PID file now as we will not be daemonizing */\n    if (pid_file &&\n        (*pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0)\n        goto cleanup;\n\n    if (!(lockDaemon = virLockDaemonNewPostExecRestart(object, privileged)))\n        goto cleanup;\n\n    ret = 1;\n\n cleanup:\n    unlink(state_file);\n    VIR_FREE(wantmagic);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virLockDaemonPtr lockDaemon = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "object"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "wantmagic"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "state_file"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonNewPostExecRestart",
          "args": [
            "object",
            "privileged"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "241-327",
          "snippet": "static virLockDaemonPtr\nvirLockDaemonNewPostExecRestart(virJSONValuePtr object, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virJSONValuePtr child;\n    virJSONValuePtr lockspaces;\n    size_t i;\n    const char *serverNames[] = { \"virtlockd\" };\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(child = virJSONValueObjectGet(object, \"defaultLockspace\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing defaultLockspace data from JSON file\"));\n        goto error;\n    }\n\n    if (!(lockd->defaultLockspace =\n          virLockSpaceNewPostExecRestart(child)))\n        goto error;\n\n    if (!(lockspaces = virJSONValueObjectGet(object, \"lockspaces\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing lockspaces data from JSON file\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(lockspaces)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed lockspaces array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(lockspaces); i++) {\n        virLockSpacePtr lockspace;\n\n        child = virJSONValueArrayGet(lockspaces, i);\n\n        if (!(lockspace = virLockSpaceNewPostExecRestart(child)))\n            goto error;\n\n        if (virHashAddEntry(lockd->lockspaces,\n                            virLockSpaceGetDirectory(lockspace),\n                            lockspace) < 0) {\n            virLockSpaceFree(lockspace);\n        }\n    }\n\n    if (virJSONValueObjectHasKey(object, \"daemon\")) {\n        if (!(child = virJSONValueObjectGet(object, \"daemon\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed daemon data from JSON file\"));\n            goto error;\n        }\n    } else {\n        if (!(child = virJSONValueObjectGet(object, \"server\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing server data from JSON file\"));\n            goto error;\n        }\n    }\n\n    if (!(lockd->dmn = virNetDaemonNewPostExecRestart(child,\n                                                      G_N_ELEMENTS(serverNames),\n                                                      serverNames,\n                                                      virLockDaemonNewServerPostExecRestart,\n                                                      (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    return lockd;\n\n error:\n    virLockDaemonFree(lockd);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3\n\nstatic virLockDaemonPtr\nvirLockDaemonNewPostExecRestart(virJSONValuePtr object, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virJSONValuePtr child;\n    virJSONValuePtr lockspaces;\n    size_t i;\n    const char *serverNames[] = { \"virtlockd\" };\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(child = virJSONValueObjectGet(object, \"defaultLockspace\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing defaultLockspace data from JSON file\"));\n        goto error;\n    }\n\n    if (!(lockd->defaultLockspace =\n          virLockSpaceNewPostExecRestart(child)))\n        goto error;\n\n    if (!(lockspaces = virJSONValueObjectGet(object, \"lockspaces\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing lockspaces data from JSON file\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(lockspaces)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed lockspaces array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(lockspaces); i++) {\n        virLockSpacePtr lockspace;\n\n        child = virJSONValueArrayGet(lockspaces, i);\n\n        if (!(lockspace = virLockSpaceNewPostExecRestart(child)))\n            goto error;\n\n        if (virHashAddEntry(lockd->lockspaces,\n                            virLockSpaceGetDirectory(lockspace),\n                            lockspace) < 0) {\n            virLockSpaceFree(lockspace);\n        }\n    }\n\n    if (virJSONValueObjectHasKey(object, \"daemon\")) {\n        if (!(child = virJSONValueObjectGet(object, \"daemon\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed daemon data from JSON file\"));\n            goto error;\n        }\n    } else {\n        if (!(child = virJSONValueObjectGet(object, \"server\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing server data from JSON file\"));\n            goto error;\n        }\n    }\n\n    if (!(lockd->dmn = virNetDaemonNewPostExecRestart(child,\n                                                      G_N_ELEMENTS(serverNames),\n                                                      serverNames,\n                                                      virLockDaemonNewServerPostExecRestart,\n                                                      (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    return lockd;\n\n error:\n    virLockDaemonFree(lockd);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquirePath",
          "args": [
            "pid_file",
            "false",
            "getpid()"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquirePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "330-410",
          "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Found restart exec file with old magic %s vs wanted %s\"",
            "gotmagic",
            "wantmagic"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "gotmagic",
            "wantmagic"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonGetExecRestartMagic",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonGetExecRestartMagic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "838-845",
          "snippet": "static char *\nvirLockDaemonGetExecRestartMagic(void)\n{\n    char *ret;\n\n    ret = g_strdup_printf(\"%lld\", (long long int)getpid());\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvirLockDaemonGetExecRestartMagic(void)\n{\n    char *ret;\n\n    ret = g_strdup_printf(\"%lld\", (long long int)getpid());\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing magic data in JSON document\")"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing magic data in JSON document\""
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "object",
            "\"magic\""
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFromString",
          "args": [
            "state"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1993-1999",
          "snippet": "virJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Loading state %s\"",
            "state"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "state_file",
            "1024 * 1024 * 10",
            "/* 10 MB */&state"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No restart state file %s present\"",
            "state_file"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "state_file"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Running post-restart exec\""
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\n\nstatic int\nvirLockDaemonPostExecRestart(const char *state_file,\n                             const char *pid_file,\n                             int *pid_file_fd,\n                             bool privileged)\n{\n    const char *gotmagic;\n    char *wantmagic = NULL;\n    int ret = -1;\n    char *state = NULL;\n    virJSONValuePtr object = NULL;\n\n    VIR_DEBUG(\"Running post-restart exec\");\n\n    if (!virFileExists(state_file)) {\n        VIR_DEBUG(\"No restart state file %s present\",\n                  state_file);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileReadAll(state_file,\n                       1024 * 1024 * 10, /* 10 MB */\n                       &state) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Loading state %s\", state);\n\n    if (!(object = virJSONValueFromString(state)))\n        goto cleanup;\n\n    gotmagic = virJSONValueObjectGetString(object, \"magic\");\n    if (!gotmagic) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing magic data in JSON document\"));\n        goto cleanup;\n    }\n\n    if (!(wantmagic = virLockDaemonGetExecRestartMagic()))\n        goto cleanup;\n\n    if (STRNEQ(gotmagic, wantmagic)) {\n        VIR_WARN(\"Found restart exec file with old magic %s vs wanted %s\",\n                 gotmagic, wantmagic);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Re-claim PID file now as we will not be daemonizing */\n    if (pid_file &&\n        (*pid_file_fd = virPidFileAcquirePath(pid_file, false, getpid())) < 0)\n        goto cleanup;\n\n    if (!(lockDaemon = virLockDaemonNewPostExecRestart(object, privileged)))\n        goto cleanup;\n\n    ret = 1;\n\n cleanup:\n    unlink(state_file);\n    VIR_FREE(wantmagic);\n    VIR_FREE(state);\n    virJSONValueFree(object);\n    return ret;\n}"
  },
  {
    "function_name": "virLockDaemonGetExecRestartMagic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "838-845",
    "snippet": "static char *\nvirLockDaemonGetExecRestartMagic(void)\n{\n    char *ret;\n\n    ret = g_strdup_printf(\"%lld\", (long long int)getpid());\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%lld\"",
            "(long long int)getpid()"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvirLockDaemonGetExecRestartMagic(void)\n{\n    char *ret;\n\n    ret = g_strdup_printf(\"%lld\", (long long int)getpid());\n    return ret;\n}"
  },
  {
    "function_name": "virLockDaemonExecRestartStatePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "812-835",
    "snippet": "static int\nvirLockDaemonExecRestartStatePath(bool privileged,\n                                  char **state_file)\n{\n    if (privileged) {\n        *state_file = g_strdup(RUNSTATEDIR \"/virtlockd-restart-exec.json\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *state_file = g_strdup_printf(\"%s/virtlockd-restart-exec.json\", rundir);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/virtlockd-restart-exec.json\"",
            "rundir"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "rundir"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonExecRestartStatePath(bool privileged,\n                                  char **state_file)\n{\n    if (privileged) {\n        *state_file = g_strdup(RUNSTATEDIR \"/virtlockd-restart-exec.json\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *state_file = g_strdup_printf(\"%s/virtlockd-restart-exec.json\", rundir);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockDaemonClientPreExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "769-809",
    "snippet": "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client G_GNUC_UNUSED,\n                                  void *opaque)\n{\n    virLockDaemonClientPtr priv = opaque;\n    virJSONValuePtr object = virJSONValueNewObject();\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virJSONValueObjectAppendBoolean(object, \"restricted\", priv->restricted) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set restricted data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"ownerPid\", priv->ownerPid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerPid data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"ownerId\", priv->ownerId) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerId data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendString(object, \"ownerName\", priv->ownerName) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerName data in JSON document\"));\n        goto error;\n    }\n    virUUIDFormat(priv->ownerUUID, uuidstr);\n    if (virJSONValueObjectAppendString(object, \"ownerUUID\", uuidstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerUUID data in JSON document\"));\n        goto error;\n    }\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "object"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set ownerUUID data in JSON document\")"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot set ownerUUID data in JSON document\""
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendString",
          "args": [
            "object",
            "\"ownerUUID\"",
            "uuidstr"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "643-649",
          "snippet": "int\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendString(virJSONValuePtr object,\n                               const char *key,\n                               const char *value)\n{\n    return virJSONValueObjectInsertString(object, key, value, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "priv->ownerUUID",
            "uuidstr"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set ownerName data in JSON document\")"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set ownerId data in JSON document\")"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendNumberUint",
          "args": [
            "object",
            "\"ownerId\"",
            "priv->ownerId"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendNumberUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "677-690",
          "snippet": "int\nvirJSONValueObjectAppendNumberUint(virJSONValuePtr object,\n                                   const char *key,\n                                   unsigned int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUint(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendNumberUint(virJSONValuePtr object,\n                                   const char *key,\n                                   unsigned int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUint(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set ownerPid data in JSON document\")"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set restricted data in JSON document\")"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendBoolean",
          "args": [
            "object",
            "\"restricted\"",
            "priv->restricted"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client G_GNUC_UNUSED,\n                                  void *opaque)\n{\n    virLockDaemonClientPtr priv = opaque;\n    virJSONValuePtr object = virJSONValueNewObject();\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virJSONValueObjectAppendBoolean(object, \"restricted\", priv->restricted) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set restricted data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"ownerPid\", priv->ownerPid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerPid data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"ownerId\", priv->ownerId) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerId data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendString(object, \"ownerName\", priv->ownerName) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerName data in JSON document\"));\n        goto error;\n    }\n    virUUIDFormat(priv->ownerUUID, uuidstr);\n    if (virJSONValueObjectAppendString(object, \"ownerUUID\", uuidstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set ownerUUID data in JSON document\"));\n        goto error;\n    }\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockDaemonClientNewPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "716-766",
    "snippet": "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque)\n{\n    virLockDaemonClientPtr priv = virLockDaemonClientNew(client, opaque);\n    unsigned int ownerPid;\n    const char *ownerUUID;\n    const char *ownerName;\n\n    if (!priv)\n        return NULL;\n\n    if (virJSONValueObjectGetBoolean(object, \"restricted\", &priv->restricted) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing restricted data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"ownerPid\", &ownerPid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerPid data in JSON document\"));\n        goto error;\n    }\n    priv->ownerPid = (pid_t)ownerPid;\n    if (virJSONValueObjectGetNumberUint(object, \"ownerId\", &priv->ownerId) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerId data in JSON document\"));\n        goto error;\n    }\n    if (!(ownerName = virJSONValueObjectGetString(object, \"ownerName\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerName data in JSON document\"));\n        goto error;\n    }\n    priv->ownerName = g_strdup(ownerName);\n    if (!(ownerUUID = virJSONValueObjectGetString(object, \"ownerUUID\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerUUID data in JSON document\"));\n        goto error;\n    }\n    if (virUUIDParse(ownerUUID, priv->ownerUUID) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerUUID data in JSON document\"));\n        goto error;\n    }\n    return priv;\n\n error:\n    virLockDaemonClientFree(priv);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockDaemonClientFree",
          "args": [
            "priv"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonClientFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "597-655",
          "snippet": "static void\nvirLockDaemonClientFree(void *opaque)\n{\n    virLockDaemonClientPtr priv = opaque;\n\n    if (!priv)\n        return;\n\n    VIR_DEBUG(\"priv=%p client=%lld owner=%lld\",\n              priv,\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)priv->ownerPid);\n\n    /* If client & owner match, this is the lock holder */\n    if (priv->clientPid == priv->ownerPid) {\n        size_t i;\n        struct virLockDaemonClientReleaseData data = {\n            .client = priv, .hadSomeLeases = false, .gotError = false\n        };\n\n        /* Release all locks associated with this\n         * owner in all lockspaces */\n        virLockDaemonLock(lockDaemon);\n        virHashForEach(lockDaemon->lockspaces,\n                       virLockDaemonClientReleaseLockspace,\n                       &data);\n        virLockDaemonClientReleaseLockspace(lockDaemon->defaultLockspace,\n                                            \"\",\n                                            &data);\n        virLockDaemonUnlock(lockDaemon);\n\n        /* If the client had some active leases when it\n         * closed the connection, we must kill it off\n         * to make sure it doesn't do nasty stuff */\n        if (data.gotError || data.hadSomeLeases) {\n            for (i = 0; i < 15; i++) {\n                int signum;\n                if (i == 0)\n                    signum = SIGTERM;\n                else if (i == 8)\n                    signum = SIGKILL;\n                else\n                    signum = 0;\n                if (priv->clientPid != 0 && virProcessKill(priv->clientPid, signum) < 0) {\n                    if (errno == ESRCH)\n                        break;\n\n                    VIR_WARN(\"Failed to kill off pid %lld\",\n                             (unsigned long long)priv->clientPid);\n                }\n                g_usleep(200 * 1000);\n            }\n        }\n    }\n\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv->ownerName);\n    VIR_FREE(priv);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virLockDaemonPtr lockDaemon = NULL;",
            "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
            "static void\nvirLockDaemonClientFree(void *opaque);",
            "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
            "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void\nvirLockDaemonClientFree(void *opaque)\n{\n    virLockDaemonClientPtr priv = opaque;\n\n    if (!priv)\n        return;\n\n    VIR_DEBUG(\"priv=%p client=%lld owner=%lld\",\n              priv,\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)priv->ownerPid);\n\n    /* If client & owner match, this is the lock holder */\n    if (priv->clientPid == priv->ownerPid) {\n        size_t i;\n        struct virLockDaemonClientReleaseData data = {\n            .client = priv, .hadSomeLeases = false, .gotError = false\n        };\n\n        /* Release all locks associated with this\n         * owner in all lockspaces */\n        virLockDaemonLock(lockDaemon);\n        virHashForEach(lockDaemon->lockspaces,\n                       virLockDaemonClientReleaseLockspace,\n                       &data);\n        virLockDaemonClientReleaseLockspace(lockDaemon->defaultLockspace,\n                                            \"\",\n                                            &data);\n        virLockDaemonUnlock(lockDaemon);\n\n        /* If the client had some active leases when it\n         * closed the connection, we must kill it off\n         * to make sure it doesn't do nasty stuff */\n        if (data.gotError || data.hadSomeLeases) {\n            for (i = 0; i < 15; i++) {\n                int signum;\n                if (i == 0)\n                    signum = SIGTERM;\n                else if (i == 8)\n                    signum = SIGKILL;\n                else\n                    signum = 0;\n                if (priv->clientPid != 0 && virProcessKill(priv->clientPid, signum) < 0) {\n                    if (errno == ESRCH)\n                        break;\n\n                    VIR_WARN(\"Failed to kill off pid %lld\",\n                             (unsigned long long)priv->clientPid);\n                }\n                g_usleep(200 * 1000);\n            }\n        }\n    }\n\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv->ownerName);\n    VIR_FREE(priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing ownerUUID data in JSON document\")"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing ownerUUID data in JSON document\""
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "ownerUUID",
            "priv->ownerUUID"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing ownerUUID data in JSON document\")"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "object",
            "\"ownerUUID\""
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "ownerName"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing ownerName data in JSON document\")"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing ownerId data in JSON document\")"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberUint",
          "args": [
            "object",
            "\"ownerId\"",
            "&priv->ownerId"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1345-1356",
          "snippet": "int\nvirJSONValueObjectGetNumberUint(virJSONValuePtr object,\n                                const char *key,\n                                unsigned int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUint(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberUint(virJSONValuePtr object,\n                                const char *key,\n                                unsigned int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUint(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing ownerPid data in JSON document\")"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing restricted data in JSON document\")"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetBoolean",
          "args": [
            "object",
            "\"restricted\"",
            "&priv->restricted"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1401-1412",
          "snippet": "int\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonClientNew",
          "args": [
            "client",
            "opaque"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "658-713",
          "snippet": "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque)\n{\n    virLockDaemonClientPtr priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    unsigned long long timestamp;\n    bool privileged = opaque != NULL;\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &priv->clientPid,\n                                          &timestamp) < 0)\n        goto error;\n\n    VIR_DEBUG(\"New client pid %llu uid %llu\",\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)clientuid);\n\n    if (!privileged) {\n        if (geteuid() != clientuid) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    } else {\n        if (clientuid != 0) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    }\n\n    /* there's no closing handshake in the locking protocol */\n    virNetServerClientSetQuietEOF(client);\n\n    return priv;\n\n error:\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
            "static void\nvirLockDaemonClientFree(void *opaque);",
            "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
            "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque)\n{\n    virLockDaemonClientPtr priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    unsigned long long timestamp;\n    bool privileged = opaque != NULL;\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &priv->clientPid,\n                                          &timestamp) < 0)\n        goto error;\n\n    VIR_DEBUG(\"New client pid %llu uid %llu\",\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)clientuid);\n\n    if (!privileged) {\n        if (geteuid() != clientuid) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    } else {\n        if (clientuid != 0) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    }\n\n    /* there's no closing handshake in the locking protocol */\n    virNetServerClientSetQuietEOF(client);\n\n    return priv;\n\n error:\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque)\n{\n    virLockDaemonClientPtr priv = virLockDaemonClientNew(client, opaque);\n    unsigned int ownerPid;\n    const char *ownerUUID;\n    const char *ownerName;\n\n    if (!priv)\n        return NULL;\n\n    if (virJSONValueObjectGetBoolean(object, \"restricted\", &priv->restricted) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing restricted data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"ownerPid\", &ownerPid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerPid data in JSON document\"));\n        goto error;\n    }\n    priv->ownerPid = (pid_t)ownerPid;\n    if (virJSONValueObjectGetNumberUint(object, \"ownerId\", &priv->ownerId) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerId data in JSON document\"));\n        goto error;\n    }\n    if (!(ownerName = virJSONValueObjectGetString(object, \"ownerName\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerName data in JSON document\"));\n        goto error;\n    }\n    priv->ownerName = g_strdup(ownerName);\n    if (!(ownerUUID = virJSONValueObjectGetString(object, \"ownerUUID\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerUUID data in JSON document\"));\n        goto error;\n    }\n    if (virUUIDParse(ownerUUID, priv->ownerUUID) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing ownerUUID data in JSON document\"));\n        goto error;\n    }\n    return priv;\n\n error:\n    virLockDaemonClientFree(priv);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockDaemonClientNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "658-713",
    "snippet": "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque)\n{\n    virLockDaemonClientPtr priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    unsigned long long timestamp;\n    bool privileged = opaque != NULL;\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &priv->clientPid,\n                                          &timestamp) < 0)\n        goto error;\n\n    VIR_DEBUG(\"New client pid %llu uid %llu\",\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)clientuid);\n\n    if (!privileged) {\n        if (geteuid() != clientuid) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    } else {\n        if (clientuid != 0) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    }\n\n    /* there's no closing handshake in the locking protocol */\n    virNetServerClientSetQuietEOF(client);\n\n    return priv;\n\n error:\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&priv->lock"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSetQuietEOF",
          "args": [
            "client"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSetQuietEOF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1692-1696",
          "snippet": "void\nvirNetServerClientSetQuietEOF(virNetServerClientPtr client)\n{\n    virNetSocketSetQuietEOF(client->sock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientSetQuietEOF(virNetServerClientPtr client)\n{\n    virNetSocketSetQuietEOF(client->sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportRestrictedError",
          "args": [
            "_(\"Disallowing client %llu with uid %llu\")",
            "(unsigned long long)priv->clientPid",
            "(unsigned long long)clientuid"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Disallowing client %llu with uid %llu\""
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virReportRestrictedError",
          "args": [
            "_(\"Disallowing client %llu with uid %llu\")",
            "(unsigned long long)priv->clientPid",
            "(unsigned long long)clientuid"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"New client pid %llu uid %llu\"",
            "(unsigned long long)priv->clientPid",
            "(unsigned long long)clientuid"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetUNIXIdentity",
          "args": [
            "client",
            "&clientuid",
            "&clientgid",
            "&priv->clientPid",
            "&timestamp"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetUNIXIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "741-753",
          "snippet": "int virNetServerClientGetUNIXIdentity(virNetServerClientPtr client,\n                                      uid_t *uid, gid_t *gid, pid_t *pid,\n                                      unsigned long long *timestamp)\n{\n    int ret = -1;\n    virObjectLock(client);\n    if (client->sock)\n        ret = virNetSocketGetUNIXIdentity(client->sock,\n                                          uid, gid, pid,\n                                          timestamp);\n    virObjectUnlock(client);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint virNetServerClientGetUNIXIdentity(virNetServerClientPtr client,\n                                      uid_t *uid, gid_t *gid, pid_t *pid,\n                                      unsigned long long *timestamp)\n{\n    int ret = -1;\n    virObjectLock(client);\n    if (client->sock)\n        ret = virNetSocketGetUNIXIdentity(client->sock,\n                                          uid, gid, pid,\n                                          timestamp);\n    virObjectUnlock(client);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to init mutex\")"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&priv->lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque)\n{\n    virLockDaemonClientPtr priv;\n    uid_t clientuid;\n    gid_t clientgid;\n    unsigned long long timestamp;\n    bool privileged = opaque != NULL;\n\n    if (VIR_ALLOC(priv) < 0)\n        return NULL;\n\n    if (virMutexInit(&priv->lock) < 0) {\n        VIR_FREE(priv);\n        virReportSystemError(errno, \"%s\", _(\"unable to init mutex\"));\n        return NULL;\n    }\n\n    if (virNetServerClientGetUNIXIdentity(client,\n                                          &clientuid,\n                                          &clientgid,\n                                          &priv->clientPid,\n                                          &timestamp) < 0)\n        goto error;\n\n    VIR_DEBUG(\"New client pid %llu uid %llu\",\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)clientuid);\n\n    if (!privileged) {\n        if (geteuid() != clientuid) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    } else {\n        if (clientuid != 0) {\n            virReportRestrictedError(_(\"Disallowing client %llu with uid %llu\"),\n                                     (unsigned long long)priv->clientPid,\n                                     (unsigned long long)clientuid);\n            goto error;\n        }\n    }\n\n    /* there's no closing handshake in the locking protocol */\n    virNetServerClientSetQuietEOF(client);\n\n    return priv;\n\n error:\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockDaemonClientFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "597-655",
    "snippet": "static void\nvirLockDaemonClientFree(void *opaque)\n{\n    virLockDaemonClientPtr priv = opaque;\n\n    if (!priv)\n        return;\n\n    VIR_DEBUG(\"priv=%p client=%lld owner=%lld\",\n              priv,\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)priv->ownerPid);\n\n    /* If client & owner match, this is the lock holder */\n    if (priv->clientPid == priv->ownerPid) {\n        size_t i;\n        struct virLockDaemonClientReleaseData data = {\n            .client = priv, .hadSomeLeases = false, .gotError = false\n        };\n\n        /* Release all locks associated with this\n         * owner in all lockspaces */\n        virLockDaemonLock(lockDaemon);\n        virHashForEach(lockDaemon->lockspaces,\n                       virLockDaemonClientReleaseLockspace,\n                       &data);\n        virLockDaemonClientReleaseLockspace(lockDaemon->defaultLockspace,\n                                            \"\",\n                                            &data);\n        virLockDaemonUnlock(lockDaemon);\n\n        /* If the client had some active leases when it\n         * closed the connection, we must kill it off\n         * to make sure it doesn't do nasty stuff */\n        if (data.gotError || data.hadSomeLeases) {\n            for (i = 0; i < 15; i++) {\n                int signum;\n                if (i == 0)\n                    signum = SIGTERM;\n                else if (i == 8)\n                    signum = SIGKILL;\n                else\n                    signum = 0;\n                if (priv->clientPid != 0 && virProcessKill(priv->clientPid, signum) < 0) {\n                    if (errno == ESRCH)\n                        break;\n\n                    VIR_WARN(\"Failed to kill off pid %lld\",\n                             (unsigned long long)priv->clientPid);\n                }\n                g_usleep(200 * 1000);\n            }\n        }\n    }\n\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv->ownerName);\n    VIR_FREE(priv);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virLockDaemonPtr lockDaemon = NULL;",
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->ownerName"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&priv->lock"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "200 * 1000"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to kill off pid %lld\"",
            "(unsigned long long)priv->clientPid"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKill",
          "args": [
            "priv->clientPid",
            "signum"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonUnlock",
          "args": [
            "lockDaemon"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "136-140",
          "snippet": "static inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonClientReleaseLockspace",
          "args": [
            "lockDaemon->defaultLockspace",
            "\"\"",
            "&data"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonClientReleaseLockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "578-594",
          "snippet": "static int\nvirLockDaemonClientReleaseLockspace(void *payload,\n                                    const void *name G_GNUC_UNUSED,\n                                    void *opaque)\n{\n    virLockSpacePtr lockspace = payload;\n    struct virLockDaemonClientReleaseData *data = opaque;\n    int rc;\n\n    rc = virLockSpaceReleaseResourcesForOwner(lockspace,\n                                              data->client->clientPid);\n    if (rc > 0)\n        data->hadSomeLeases = true;\n    else if (rc < 0)\n        data->gotError = true;\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
            "static void\nvirLockDaemonClientFree(void *opaque);",
            "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
            "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic int\nvirLockDaemonClientReleaseLockspace(void *payload,\n                                    const void *name G_GNUC_UNUSED,\n                                    void *opaque)\n{\n    virLockSpacePtr lockspace = payload;\n    struct virLockDaemonClientReleaseData *data = opaque;\n    int rc;\n\n    rc = virLockSpaceReleaseResourcesForOwner(lockspace,\n                                              data->client->clientPid);\n    if (rc > 0)\n        data->hadSomeLeases = true;\n    else if (rc < 0)\n        data->gotError = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashForEach",
          "args": [
            "lockDaemon->lockspaces",
            "virLockDaemonClientReleaseLockspace",
            "&data"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "virHashForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "626-649",
          "snippet": "int\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashForEach(virHashTablePtr table, virHashIterator iter, void *data)\n{\n    size_t i;\n    int ret = -1;\n\n    if (table == NULL || iter == NULL)\n        return -1;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry = table->table[i];\n        while (entry) {\n            virHashEntryPtr next = entry->next;\n            ret = iter(entry->payload, entry->name, data);\n\n            if (ret < 0)\n                return ret;\n\n            entry = next;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonLock",
          "args": [
            "lockDaemon"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonLockSpaceDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "142-145",
          "snippet": "static void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"priv=%p client=%lld owner=%lld\"",
            "priv",
            "(unsigned long long)priv->clientPid",
            "(unsigned long long)priv->ownerPid"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockDaemonPtr lockDaemon = NULL;\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void\nvirLockDaemonClientFree(void *opaque)\n{\n    virLockDaemonClientPtr priv = opaque;\n\n    if (!priv)\n        return;\n\n    VIR_DEBUG(\"priv=%p client=%lld owner=%lld\",\n              priv,\n              (unsigned long long)priv->clientPid,\n              (unsigned long long)priv->ownerPid);\n\n    /* If client & owner match, this is the lock holder */\n    if (priv->clientPid == priv->ownerPid) {\n        size_t i;\n        struct virLockDaemonClientReleaseData data = {\n            .client = priv, .hadSomeLeases = false, .gotError = false\n        };\n\n        /* Release all locks associated with this\n         * owner in all lockspaces */\n        virLockDaemonLock(lockDaemon);\n        virHashForEach(lockDaemon->lockspaces,\n                       virLockDaemonClientReleaseLockspace,\n                       &data);\n        virLockDaemonClientReleaseLockspace(lockDaemon->defaultLockspace,\n                                            \"\",\n                                            &data);\n        virLockDaemonUnlock(lockDaemon);\n\n        /* If the client had some active leases when it\n         * closed the connection, we must kill it off\n         * to make sure it doesn't do nasty stuff */\n        if (data.gotError || data.hadSomeLeases) {\n            for (i = 0; i < 15; i++) {\n                int signum;\n                if (i == 0)\n                    signum = SIGTERM;\n                else if (i == 8)\n                    signum = SIGKILL;\n                else\n                    signum = 0;\n                if (priv->clientPid != 0 && virProcessKill(priv->clientPid, signum) < 0) {\n                    if (errno == ESRCH)\n                        break;\n\n                    VIR_WARN(\"Failed to kill off pid %lld\",\n                             (unsigned long long)priv->clientPid);\n                }\n                g_usleep(200 * 1000);\n            }\n        }\n    }\n\n    virMutexDestroy(&priv->lock);\n    VIR_FREE(priv->ownerName);\n    VIR_FREE(priv);\n}"
  },
  {
    "function_name": "virLockDaemonClientReleaseLockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "578-594",
    "snippet": "static int\nvirLockDaemonClientReleaseLockspace(void *payload,\n                                    const void *name G_GNUC_UNUSED,\n                                    void *opaque)\n{\n    virLockSpacePtr lockspace = payload;\n    struct virLockDaemonClientReleaseData *data = opaque;\n    int rc;\n\n    rc = virLockSpaceReleaseResourcesForOwner(lockspace,\n                                              data->client->clientPid);\n    if (rc > 0)\n        data->hadSomeLeases = true;\n    else if (rc < 0)\n        data->gotError = true;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockSpaceReleaseResourcesForOwner",
          "args": [
            "lockspace",
            "data->client->clientPid"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceReleaseResourcesForOwner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "726-751",
          "snippet": "int virLockSpaceReleaseResourcesForOwner(virLockSpacePtr lockspace,\n                                         pid_t owner)\n{\n    int ret = 0;\n    struct virLockSpaceRemoveData data = {\n        owner, 0\n    };\n\n    VIR_DEBUG(\"lockspace=%p owner=%lld\", lockspace, (unsigned long long)owner);\n\n    virMutexLock(&lockspace->lock);\n\n    if (virHashRemoveSet(lockspace->resources,\n                         virLockSpaceRemoveResourcesForOwner,\n                         &data) < 0)\n        goto error;\n\n    ret = data.count;\n\n    virMutexUnlock(&lockspace->lock);\n    return ret;\n\n error:\n    virMutexUnlock(&lockspace->lock);\n    return -1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nint virLockSpaceReleaseResourcesForOwner(virLockSpacePtr lockspace,\n                                         pid_t owner)\n{\n    int ret = 0;\n    struct virLockSpaceRemoveData data = {\n        owner, 0\n    };\n\n    VIR_DEBUG(\"lockspace=%p owner=%lld\", lockspace, (unsigned long long)owner);\n\n    virMutexLock(&lockspace->lock);\n\n    if (virHashRemoveSet(lockspace->resources,\n                         virLockSpaceRemoveResourcesForOwner,\n                         &data) < 0)\n        goto error;\n\n    ret = data.count;\n\n    virMutexUnlock(&lockspace->lock);\n    return ret;\n\n error:\n    virMutexUnlock(&lockspace->lock);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic int\nvirLockDaemonClientReleaseLockspace(void *payload,\n                                    const void *name G_GNUC_UNUSED,\n                                    void *opaque)\n{\n    virLockSpacePtr lockspace = payload;\n    struct virLockDaemonClientReleaseData *data = opaque;\n    int rc;\n\n    rc = virLockSpaceReleaseResourcesForOwner(lockspace,\n                                              data->client->clientPid);\n    if (rc > 0)\n        data->hadSomeLeases = true;\n    else if (rc < 0)\n        data->gotError = true;\n    return 0;\n}"
  },
  {
    "function_name": "virLockDaemonSetupSignals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "557-569",
    "snippet": "static int\nvirLockDaemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGUSR1, virLockDaemonExecRestartHandler, NULL) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonAddSignalHandler",
          "args": [
            "dmn",
            "SIGUSR1",
            "virLockDaemonExecRestartHandler",
            "NULL"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAddSignalHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "737-746",
          "snippet": "int\nvirNetDaemonAddSignalHandler(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                             int signum G_GNUC_UNUSED,\n                             virNetDaemonSignalFunc func G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Signal handling not available on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDaemonAddSignalHandler(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                             int signum G_GNUC_UNUSED,\n                             virNetDaemonSignalFunc func G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Signal handling not available on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonSetupSignals(virNetDaemonPtr dmn)\n{\n    if (virNetDaemonAddSignalHandler(dmn, SIGINT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGQUIT, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGTERM, virLockDaemonShutdownHandler, NULL) < 0)\n        return -1;\n    if (virNetDaemonAddSignalHandler(dmn, SIGUSR1, virLockDaemonExecRestartHandler, NULL) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "virLockDaemonExecRestartHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "548-555",
    "snippet": "static void\nvirLockDaemonExecRestartHandler(virNetDaemonPtr dmn,\n                                siginfo_t *sig G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED)\n{\n    execRestart = true;\n    virNetDaemonQuit(dmn);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool execRestart;",
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonQuit",
          "args": [
            "dmn"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonQuit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "867-876",
          "snippet": "void\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool execRestart;\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void\nvirLockDaemonExecRestartHandler(virNetDaemonPtr dmn,\n                                siginfo_t *sig G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED)\n{\n    execRestart = true;\n    virNetDaemonQuit(dmn);\n}"
  },
  {
    "function_name": "virLockDaemonShutdownHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "540-546",
    "snippet": "static void\nvirLockDaemonShutdownHandler(virNetDaemonPtr dmn,\n                             siginfo_t *sig G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED)\n{\n    virNetDaemonQuit(dmn);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDaemonQuit",
          "args": [
            "dmn"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonQuit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "867-876",
          "snippet": "void\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDaemonQuit(virNetDaemonPtr dmn)\n{\n    virObjectLock(dmn);\n\n    VIR_DEBUG(\"Quit requested %p\", dmn);\n    dmn->quit = true;\n\n    virObjectUnlock(dmn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void\nvirLockDaemonShutdownHandler(virNetDaemonPtr dmn,\n                             siginfo_t *sig G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED)\n{\n    virNetDaemonQuit(dmn);\n}"
  },
  {
    "function_name": "virLockDaemonVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "534-538",
    "snippet": "static void\nvirLockDaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s (%s) %s\\n\"",
            "argv0",
            "PACKAGE_NAME",
            "PACKAGE_VERSION"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonVersion(const char *argv0)\n{\n    printf(\"%s (%s) %s\\n\", argv0, PACKAGE_NAME, PACKAGE_VERSION);\n}"
  },
  {
    "function_name": "virLockDaemonSetupLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "486-529",
    "snippet": "static int\nvirLockDaemonSetupLogging(virLockDaemonConfigPtr config,\n                          bool privileged,\n                          bool verbose,\n                          bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Libvirtd's order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(\"virtlockd\", godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogSetOutputs",
          "args": [
            "virLogGetDefaultOutput()"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1747-1779",
          "snippet": "int\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *virLogDefaultOutput;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *virLogDefaultOutput;\n\nint\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultOutput",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "223-227",
          "snippet": "char *\nvirLogGetDefaultOutput(void)\n{\n    return virLogDefaultOutput;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *virLogDefaultOutput;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *virLogDefaultOutput;\n\nchar *\nvirLogGetDefaultOutput(void)\n{\n    return virLogDefaultOutput;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetNbOutputs",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetNbOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1163-1167",
          "snippet": "int\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t virLogNbOutputs;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic size_t virLogNbOutputs;\n\nint\nvirLogGetNbOutputs(void)\n{\n    return virLogNbOutputs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetDefaultOutput",
          "args": [
            "\"virtlockd\"",
            "godaemon",
            "privileged"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetDefaultOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "204-220",
          "snippet": "void\nvirLogSetDefaultOutput(const char *binary, bool godaemon, bool privileged)\n{\n    bool have_journald = access(\"/run/systemd/journal/socket\", W_OK) >= 0;\n\n    if (godaemon) {\n        if (have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToFile(binary, privileged);\n    } else {\n        if (!isatty(STDIN_FILENO) && have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToStderr();\n    }\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetDefaultOutput(const char *binary, bool godaemon, bool privileged)\n{\n    bool have_journald = access(\"/run/systemd/journal/socket\", W_OK) >= 0;\n\n    if (godaemon) {\n        if (have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToFile(binary, privileged);\n    } else {\n        if (!isatty(STDIN_FILENO) && have_journald)\n            virLogSetDefaultOutputToJournald();\n        else\n            virLogSetDefaultOutputToStderr();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetDefaultPriority",
          "args": [
            "VIR_LOG_INFO"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "304-318",
          "snippet": "int\nvirLogSetDefaultPriority(virLogPriority priority)\n{\n    if ((priority < VIR_LOG_DEBUG) || (priority > VIR_LOG_ERROR)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to set logging priority, argument '%u' is \"\n                         \"invalid\"), priority);\n        return -1;\n    }\n    if (virLogInitialize() < 0)\n        return -1;\n\n    virLogDefaultPriority = priority;\n    return 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nint\nvirLogSetDefaultPriority(virLogPriority priority)\n{\n    if ((priority < VIR_LOG_DEBUG) || (priority > VIR_LOG_ERROR)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to set logging priority, argument '%u' is \"\n                         \"invalid\"), priority);\n        return -1;\n    }\n    if (virLogInitialize() < 0)\n        return -1;\n\n    virLogDefaultPriority = priority;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultPriority",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1063-1067",
          "snippet": "virLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nvirLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogSetFromEnv",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFromEnv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1208-1225",
          "snippet": "void\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virLogSetOutputs(config->log_outputs)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virLogSetFilters(config->log_filters)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogSetFilters",
          "args": [
            "config->log_filters"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFilters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1790-1811",
          "snippet": "int\nvirLogSetFilters(const char *src)\n{\n    int ret = -1;\n    int nfilters = 0;\n    virLogFilterPtr *filters = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && (nfilters = virLogParseFilters(src, &filters)) < 0)\n        goto cleanup;\n\n    if (virLogDefineFilters(filters, nfilters) < 0)\n        goto cleanup;\n\n    filters = NULL;\n    ret = 0;\n cleanup:\n    virLogFilterListFree(filters, nfilters);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirLogSetFilters(const char *src)\n{\n    int ret = -1;\n    int nfilters = 0;\n    virLogFilterPtr *filters = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && (nfilters = virLogParseFilters(src, &filters)) < 0)\n        goto cleanup;\n\n    if (virLogDefineFilters(filters, nfilters) < 0)\n        goto cleanup;\n\n    filters = NULL;\n    ret = 0;\n cleanup:\n    virLogFilterListFree(filters, nfilters);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogReset",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "virLogResetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "373-379",
          "snippet": "static void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogOutputPtr *virLogOutputs;",
            "static size_t virLogNbOutputs;",
            "static void virLogResetOutputs(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogOutputPtr *virLogOutputs;\nstatic size_t virLogNbOutputs;\nstatic void virLogResetOutputs(void);\n\nstatic void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonSetupLogging(virLockDaemonConfigPtr config,\n                          bool privileged,\n                          bool verbose,\n                          bool godaemon)\n{\n    virLogReset();\n\n    /*\n     * Libvirtd's order of precedence is:\n     * cmdline > environment > config\n     *\n     * Given the precedence, we must process the variables in the opposite\n     * order, each one overriding the previous.\n     */\n    if (config->log_level != 0)\n        virLogSetDefaultPriority(config->log_level);\n\n    /* In case the config is empty, both filters and outputs will become empty,\n     * however we can't start with empty outputs, thus we'll need to define and\n     * setup a default one.\n     */\n    ignore_value(virLogSetFilters(config->log_filters));\n    ignore_value(virLogSetOutputs(config->log_outputs));\n\n    /* If there are some environment variables defined, use those instead */\n    virLogSetFromEnv();\n\n    /*\n     * Command line override for --verbose\n     */\n    if ((verbose) && (virLogGetDefaultPriority() > VIR_LOG_INFO))\n        virLogSetDefaultPriority(VIR_LOG_INFO);\n\n    /* Define the default output. This is only applied if there was no setting\n     * from either the config or the environment.\n     */\n    virLogSetDefaultOutput(\"virtlockd\", godaemon, privileged);\n\n    if (virLogGetNbOutputs() == 0)\n        virLogSetOutputs(virLogGetDefaultOutput());\n\n    return 0;\n}"
  },
  {
    "function_name": "virLockDaemonErrorHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "471-477",
    "snippet": "static void\nvirLockDaemonErrorHandler(void *opaque G_GNUC_UNUSED,\n                          virErrorPtr err G_GNUC_UNUSED)\n{\n    /* Don't do anything, since logging infrastructure already\n     * took care of reporting the error */\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic void\nvirLockDaemonErrorHandler(void *opaque G_GNUC_UNUSED,\n                          virErrorPtr err G_GNUC_UNUSED)\n{\n    /* Don't do anything, since logging infrastructure already\n     * took care of reporting the error */\n}"
  },
  {
    "function_name": "virLockDaemonUnixSocketPaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "443-468",
    "snippet": "static int\nvirLockDaemonUnixSocketPaths(bool privileged,\n                             char **sockfile,\n                             char **adminSockfile)\n{\n    if (privileged) {\n        *sockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n        *adminSockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-admin-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *sockfile = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n        *adminSockfile = g_strdup_printf(\"%s/virtlockd-admin-sock\", rundir);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/virtlockd-admin-sock\"",
            "rundir"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "rundir"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonUnixSocketPaths(bool privileged,\n                             char **sockfile,\n                             char **adminSockfile)\n{\n    if (privileged) {\n        *sockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-sock\");\n        *adminSockfile = g_strdup(RUNSTATEDIR \"/libvirt/virtlockd-admin-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        old_umask = umask(077);\n        if (virFileMakePath(rundir) < 0) {\n            umask(old_umask);\n            return -1;\n        }\n        umask(old_umask);\n\n        *sockfile = g_strdup_printf(\"%s/virtlockd-sock\", rundir);\n        *adminSockfile = g_strdup_printf(\"%s/virtlockd-admin-sock\", rundir);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virLockDaemonForkIntoBackground",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "355-440",
    "snippet": "static int\nvirLockDaemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) < 0)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) < 0)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0:\n                return statuspipe[1];\n            case -1:\n                return -1;\n            default:\n                _exit(0);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            return -1;\n\n        }\n\n    case -1:\n        return -1;\n\n    default:\n        {\n            int got, exitstatus = 0;\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if ((got = waitpid(pid, &exitstatus, 0)) < 0 ||\n                got != pid ||\n                exitstatus != 0) {\n                return -1;\n            }\n\n            /* Now block until the second child initializes successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            if (ret == 1 && status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run without \"\n                          \"--daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n            }\n            _exit(ret == 1 && status == 0 ? 0 : 1);\n        }\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ret == 1 && status == 0 ? 0 : 1"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: error: %s. Check /var/log/messages or run without \"\n                          \"--daemon for more info.\\n\")",
            "argv0",
            "virDaemonErrTypeToString(status)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDaemonErrTypeToString",
          "args": [
            "status"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: error: %s. Check /var/log/messages or run without \"\n                          \"--daemon for more info.\\n\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "statuspipe[0]",
            "&status",
            "1"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDelIOThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "7811-7841",
          "snippet": "int\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&exitstatus",
            "0"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[1]"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "stdinfd"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "stdoutfd"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "stdoutfd"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "stdinfd"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdoutfd",
            "STDERR_FILENO"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdoutfd",
            "STDOUT_FILENO"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stdinfd",
            "STDIN_FILENO"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_WRONLY"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "statuspipe[0]"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipeQuiet",
          "args": [
            "statuspipe"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1806-1810",
          "snippet": "int\nvirPipeQuiet(int fds[2])\n{\n    return virPipeImpl(fds, false, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeQuiet(int fds[2])\n{\n    return virPipeImpl(fds, false, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirLockDaemonForkIntoBackground(const char *argv0)\n{\n    int statuspipe[2];\n    if (virPipeQuiet(statuspipe) < 0)\n        return -1;\n\n    pid_t pid = fork();\n    switch (pid) {\n    case 0:\n        {\n            int stdinfd = -1;\n            int stdoutfd = -1;\n            int nextpid;\n\n            VIR_FORCE_CLOSE(statuspipe[0]);\n\n            if ((stdinfd = open(\"/dev/null\", O_RDONLY)) < 0)\n                goto cleanup;\n            if ((stdoutfd = open(\"/dev/null\", O_WRONLY)) < 0)\n                goto cleanup;\n            if (dup2(stdinfd, STDIN_FILENO) != STDIN_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDOUT_FILENO) != STDOUT_FILENO)\n                goto cleanup;\n            if (dup2(stdoutfd, STDERR_FILENO) != STDERR_FILENO)\n                goto cleanup;\n            if (VIR_CLOSE(stdinfd) < 0)\n                goto cleanup;\n            if (VIR_CLOSE(stdoutfd) < 0)\n                goto cleanup;\n\n            if (setsid() < 0)\n                goto cleanup;\n\n            nextpid = fork();\n            switch (nextpid) {\n            case 0:\n                return statuspipe[1];\n            case -1:\n                return -1;\n            default:\n                _exit(0);\n            }\n\n        cleanup:\n            VIR_FORCE_CLOSE(stdoutfd);\n            VIR_FORCE_CLOSE(stdinfd);\n            return -1;\n\n        }\n\n    case -1:\n        return -1;\n\n    default:\n        {\n            int got, exitstatus = 0;\n            int ret;\n            char status;\n\n            VIR_FORCE_CLOSE(statuspipe[1]);\n\n            /* We wait to make sure the first child forked successfully */\n            if ((got = waitpid(pid, &exitstatus, 0)) < 0 ||\n                got != pid ||\n                exitstatus != 0) {\n                return -1;\n            }\n\n            /* Now block until the second child initializes successfully */\n        again:\n            ret = read(statuspipe[0], &status, 1);\n            if (ret == -1 && errno == EINTR)\n                goto again;\n\n            if (ret == 1 && status != 0) {\n                fprintf(stderr,\n                        _(\"%s: error: %s. Check /var/log/messages or run without \"\n                          \"--daemon for more info.\\n\"), argv0,\n                        virDaemonErrTypeToString(status));\n            }\n            _exit(ret == 1 && status == 0 ? 0 : 1);\n        }\n    }\n}"
  },
  {
    "function_name": "virLockDaemonFindLockSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "341-352",
    "snippet": "virLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockDaemonUnlock",
          "args": [
            "lockd"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "136-140",
          "snippet": "static inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "lockd->lockspaces",
            "path"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "path",
            "\"\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockDaemonLock",
          "args": [
            "lockd"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonLockSpaceDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "142-145",
          "snippet": "static void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirLockSpacePtr virLockDaemonFindLockSpace(virLockDaemonPtr lockd,\n                                           const char *path)\n{\n    virLockSpacePtr lockspace;\n    virLockDaemonLock(lockd);\n    if (path && STRNEQ(path, \"\"))\n        lockspace = virHashLookup(lockd->lockspaces, path);\n    else\n        lockspace = lockd->defaultLockspace;\n    virLockDaemonUnlock(lockd);\n    return lockspace;\n}"
  },
  {
    "function_name": "virLockDaemonAddLockSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "330-339",
    "snippet": "int virLockDaemonAddLockSpace(virLockDaemonPtr lockd,\n                              const char *path,\n                              virLockSpacePtr lockspace)\n{\n    int ret;\n    virLockDaemonLock(lockd);\n    ret = virHashAddEntry(lockd->lockspaces, path, lockspace);\n    virLockDaemonUnlock(lockd);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockDaemonUnlock",
          "args": [
            "lockd"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "136-140",
          "snippet": "static inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "lockd->lockspaces",
            "path",
            "lockspace"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockDaemonLock",
          "args": [
            "lockd"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonLockSpaceDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "142-145",
          "snippet": "static void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virLockDaemonAddLockSpace(virLockDaemonPtr lockd,\n                              const char *path,\n                              virLockSpacePtr lockspace)\n{\n    int ret;\n    virLockDaemonLock(lockd);\n    ret = virHashAddEntry(lockd->lockspaces, path, lockspace);\n    virLockDaemonUnlock(lockd);\n    return ret;\n}"
  },
  {
    "function_name": "virLockDaemonNewPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "241-327",
    "snippet": "static virLockDaemonPtr\nvirLockDaemonNewPostExecRestart(virJSONValuePtr object, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virJSONValuePtr child;\n    virJSONValuePtr lockspaces;\n    size_t i;\n    const char *serverNames[] = { \"virtlockd\" };\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(child = virJSONValueObjectGet(object, \"defaultLockspace\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing defaultLockspace data from JSON file\"));\n        goto error;\n    }\n\n    if (!(lockd->defaultLockspace =\n          virLockSpaceNewPostExecRestart(child)))\n        goto error;\n\n    if (!(lockspaces = virJSONValueObjectGet(object, \"lockspaces\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing lockspaces data from JSON file\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(lockspaces)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed lockspaces array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(lockspaces); i++) {\n        virLockSpacePtr lockspace;\n\n        child = virJSONValueArrayGet(lockspaces, i);\n\n        if (!(lockspace = virLockSpaceNewPostExecRestart(child)))\n            goto error;\n\n        if (virHashAddEntry(lockd->lockspaces,\n                            virLockSpaceGetDirectory(lockspace),\n                            lockspace) < 0) {\n            virLockSpaceFree(lockspace);\n        }\n    }\n\n    if (virJSONValueObjectHasKey(object, \"daemon\")) {\n        if (!(child = virJSONValueObjectGet(object, \"daemon\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed daemon data from JSON file\"));\n            goto error;\n        }\n    } else {\n        if (!(child = virJSONValueObjectGet(object, \"server\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing server data from JSON file\"));\n            goto error;\n        }\n    }\n\n    if (!(lockd->dmn = virNetDaemonNewPostExecRestart(child,\n                                                      G_N_ELEMENTS(serverNames),\n                                                      serverNames,\n                                                      virLockDaemonNewServerPostExecRestart,\n                                                      (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    return lockd;\n\n error:\n    virLockDaemonFree(lockd);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockDaemonFree",
          "args": [
            "lockd"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "116-128",
          "snippet": "static void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonNewPostExecRestart",
          "args": [
            "child",
            "G_N_ELEMENTS(serverNames)",
            "serverNames",
            "virLockDaemonNewServerPostExecRestart",
            "(void*)(intptr_t)(privileged ? 0x1 : 0x0)"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "293-369",
          "snippet": "virNetDaemonPtr\nvirNetDaemonNewPostExecRestart(virJSONValuePtr object,\n                               size_t nDefServerNames,\n                               const char **defServerNames,\n                               virNetDaemonNewServerPostExecRestart cb,\n                               void *opaque)\n{\n    virNetDaemonPtr dmn = NULL;\n    virJSONValuePtr servers = virJSONValueObjectGet(object, \"servers\");\n    bool new_version = virJSONValueObjectHasKey(object, \"servers\");\n\n    if (!(dmn = virNetDaemonNew()))\n        goto error;\n\n    if (new_version && !servers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed servers data in JSON document\"));\n        goto error;\n    }\n\n    if (!new_version) {\n        virNetServerPtr srv;\n\n        if (nDefServerNames < 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No default server names provided\"));\n            goto error;\n        }\n\n        VIR_DEBUG(\"No 'servers' data, creating default '%s' name\", defServerNames[0]);\n\n        srv = cb(dmn, defServerNames[0], object, opaque);\n\n        if (virHashAddEntry(dmn->servers, defServerNames[0], srv) < 0)\n            goto error;\n    } else if (virJSONValueIsArray(servers)) {\n        size_t i;\n        size_t n = virJSONValueArraySize(servers);\n        if (n > nDefServerNames) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Server count %zd greater than default name count %zu\"),\n                           n, nDefServerNames);\n            goto error;\n        }\n\n        for (i = 0; i < n; i++) {\n            virNetServerPtr srv;\n            virJSONValuePtr value = virJSONValueArrayGet(servers, i);\n\n            VIR_DEBUG(\"Creating server '%s'\", defServerNames[i]);\n            srv = cb(dmn, defServerNames[i], value, opaque);\n            if (!srv)\n                goto error;\n\n            if (virHashAddEntry(dmn->servers, defServerNames[i], srv) < 0) {\n                virObjectUnref(srv);\n                goto error;\n            }\n        }\n    } else {\n        struct virNetDaemonServerData data = {\n            dmn,\n            cb,\n            opaque,\n        };\n        if (virJSONValueObjectForeachKeyValue(servers,\n                                              virNetDaemonServerIterator,\n                                              &data) < 0)\n            goto error;\n    }\n\n    return dmn;\n\n error:\n    virObjectUnref(dmn);\n    return NULL;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetDaemonPtr\nvirNetDaemonNewPostExecRestart(virJSONValuePtr object,\n                               size_t nDefServerNames,\n                               const char **defServerNames,\n                               virNetDaemonNewServerPostExecRestart cb,\n                               void *opaque)\n{\n    virNetDaemonPtr dmn = NULL;\n    virJSONValuePtr servers = virJSONValueObjectGet(object, \"servers\");\n    bool new_version = virJSONValueObjectHasKey(object, \"servers\");\n\n    if (!(dmn = virNetDaemonNew()))\n        goto error;\n\n    if (new_version && !servers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed servers data in JSON document\"));\n        goto error;\n    }\n\n    if (!new_version) {\n        virNetServerPtr srv;\n\n        if (nDefServerNames < 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No default server names provided\"));\n            goto error;\n        }\n\n        VIR_DEBUG(\"No 'servers' data, creating default '%s' name\", defServerNames[0]);\n\n        srv = cb(dmn, defServerNames[0], object, opaque);\n\n        if (virHashAddEntry(dmn->servers, defServerNames[0], srv) < 0)\n            goto error;\n    } else if (virJSONValueIsArray(servers)) {\n        size_t i;\n        size_t n = virJSONValueArraySize(servers);\n        if (n > nDefServerNames) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Server count %zd greater than default name count %zu\"),\n                           n, nDefServerNames);\n            goto error;\n        }\n\n        for (i = 0; i < n; i++) {\n            virNetServerPtr srv;\n            virJSONValuePtr value = virJSONValueArrayGet(servers, i);\n\n            VIR_DEBUG(\"Creating server '%s'\", defServerNames[i]);\n            srv = cb(dmn, defServerNames[i], value, opaque);\n            if (!srv)\n                goto error;\n\n            if (virHashAddEntry(dmn->servers, defServerNames[i], srv) < 0) {\n                virObjectUnref(srv);\n                goto error;\n            }\n        }\n    } else {\n        struct virNetDaemonServerData data = {\n            dmn,\n            cb,\n            opaque,\n        };\n        if (virJSONValueObjectForeachKeyValue(servers,\n                                              virNetDaemonServerIterator,\n                                              &data) < 0)\n            goto error;\n    }\n\n    return dmn;\n\n error:\n    virObjectUnref(dmn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "serverNames"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing server data from JSON file\")"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing server data from JSON file\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGet",
          "args": [
            "object",
            "\"server\""
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed daemon data from JSON file\")"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectHasKey",
          "args": [
            "object",
            "\"daemon\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectHasKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "838-853",
          "snippet": "int\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceFree",
          "args": [
            "lockspace"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "505-514",
          "snippet": "void virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nvoid virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "lockd->lockspaces",
            "virLockSpaceGetDirectory(lockspace)",
            "lockspace"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceGetDirectory",
          "args": [
            "lockspace"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceGetDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "517-520",
          "snippet": "const char *virLockSpaceGetDirectory(virLockSpacePtr lockspace)\n{\n    return lockspace->dir;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nconst char *virLockSpaceGetDirectory(virLockSpacePtr lockspace)\n{\n    return lockspace->dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceNewPostExecRestart",
          "args": [
            "child"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "287-425",
          "snippet": "virLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCKSPACE_TABLE_SIZE 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\n#define VIR_LOCKSPACE_TABLE_SIZE 10\n\nvirLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "lockspaces",
            "i"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "lockspaces"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed lockspaces array\")"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueIsArray",
          "args": [
            "lockspaces"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueIsArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1010-1014",
          "snippet": "bool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nbool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing lockspaces data from JSON file\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing defaultLockspace data from JSON file\")"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "VIR_LOCK_DAEMON_NUM_LOCKSPACES",
            "virLockDaemonLockSpaceDataFree"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lockd"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to initialize mutex\")"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&lockd->lock"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "lockd"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3\n\nstatic virLockDaemonPtr\nvirLockDaemonNewPostExecRestart(virJSONValuePtr object, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virJSONValuePtr child;\n    virJSONValuePtr lockspaces;\n    size_t i;\n    const char *serverNames[] = { \"virtlockd\" };\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(child = virJSONValueObjectGet(object, \"defaultLockspace\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing defaultLockspace data from JSON file\"));\n        goto error;\n    }\n\n    if (!(lockd->defaultLockspace =\n          virLockSpaceNewPostExecRestart(child)))\n        goto error;\n\n    if (!(lockspaces = virJSONValueObjectGet(object, \"lockspaces\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing lockspaces data from JSON file\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(lockspaces)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed lockspaces array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(lockspaces); i++) {\n        virLockSpacePtr lockspace;\n\n        child = virJSONValueArrayGet(lockspaces, i);\n\n        if (!(lockspace = virLockSpaceNewPostExecRestart(child)))\n            goto error;\n\n        if (virHashAddEntry(lockd->lockspaces,\n                            virLockSpaceGetDirectory(lockspace),\n                            lockspace) < 0) {\n            virLockSpaceFree(lockspace);\n        }\n    }\n\n    if (virJSONValueObjectHasKey(object, \"daemon\")) {\n        if (!(child = virJSONValueObjectGet(object, \"daemon\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed daemon data from JSON file\"));\n            goto error;\n        }\n    } else {\n        if (!(child = virJSONValueObjectGet(object, \"server\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing server data from JSON file\"));\n            goto error;\n        }\n    }\n\n    if (!(lockd->dmn = virNetDaemonNewPostExecRestart(child,\n                                                      G_N_ELEMENTS(serverNames),\n                                                      serverNames,\n                                                      virLockDaemonNewServerPostExecRestart,\n                                                      (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    return lockd;\n\n error:\n    virLockDaemonFree(lockd);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockDaemonNewServerPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "210-238",
    "snippet": "static virNetServerPtr\nvirLockDaemonNewServerPostExecRestart(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                                      const char *name,\n                                      virJSONValuePtr object,\n                                      void *opaque)\n{\n    if (STREQ(name, \"virtlockd\")) {\n        return virNetServerNewPostExecRestart(object,\n                                              name,\n                                              virLockDaemonClientNew,\n                                              virLockDaemonClientNewPostExecRestart,\n                                              virLockDaemonClientPreExecRestart,\n                                              virLockDaemonClientFree,\n                                              opaque);\n    } else if (STREQ(name, \"admin\")) {\n        return virNetServerNewPostExecRestart(object,\n                                              name,\n                                              remoteAdmClientNew,\n                                              remoteAdmClientNewPostExecRestart,\n                                              remoteAdmClientPreExecRestart,\n                                              remoteAdmClientFree,\n                                              dmn);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected server name '%s' during restart\"),\n                       name);\n        return NULL;\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);",
      "static void\nvirLockDaemonClientFree(void *opaque);",
      "static void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);",
      "static virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected server name '%s' during restart\")",
            "name"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected server name '%s' during restart\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerNewPostExecRestart",
          "args": [
            "object",
            "name",
            "remoteAdmClientNew",
            "remoteAdmClientNewPostExecRestart",
            "remoteAdmClientPreExecRestart",
            "remoteAdmClientFree",
            "dmn"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "397-546",
          "snippet": "virNetServerPtr virNetServerNewPostExecRestart(virJSONValuePtr object,\n                                               const char *name,\n                                               virNetServerClientPrivNew clientPrivNew,\n                                               virNetServerClientPrivNewPostExecRestart clientPrivNewPostExecRestart,\n                                               virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                               virFreeCallback clientPrivFree,\n                                               void *clientPrivOpaque)\n{\n    virNetServerPtr srv = NULL;\n    virJSONValuePtr clients;\n    virJSONValuePtr services;\n    size_t i;\n    unsigned int min_workers;\n    unsigned int max_workers;\n    unsigned int priority_workers;\n    unsigned int max_clients;\n    unsigned int max_anonymous_clients;\n    unsigned int keepaliveInterval;\n    unsigned int keepaliveCount;\n    unsigned long long next_client_id;\n\n    if (virJSONValueObjectGetNumberUint(object, \"min_workers\", &min_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing min_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_workers\", &max_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"priority_workers\", &priority_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing priority_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_clients\", &max_clients) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectHasKey(object, \"max_anonymous_clients\")) {\n        if (virJSONValueObjectGetNumberUint(object, \"max_anonymous_clients\",\n                                            &max_anonymous_clients) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed max_anonymous_clients data in JSON document\"));\n            goto error;\n        }\n    } else {\n        max_anonymous_clients = max_clients;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveInterval\", &keepaliveInterval) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveInterval data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveCount\", &keepaliveCount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveCount data in JSON document\"));\n        goto error;\n    }\n\n    if (virJSONValueObjectGetNumberUlong(object, \"next_client_id\",\n                                         &next_client_id) < 0) {\n        VIR_WARN(\"Missing next_client_id data in JSON document\");\n        next_client_id = 1;\n    }\n\n    if (!(srv = virNetServerNew(name, next_client_id,\n                                min_workers, max_workers,\n                                priority_workers, max_clients,\n                                max_anonymous_clients,\n                                keepaliveInterval, keepaliveCount,\n                                clientPrivNew, clientPrivPreExecRestart,\n                                clientPrivFree, clientPrivOpaque)))\n        goto error;\n\n    if (!(services = virJSONValueObjectGet(object, \"services\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing services data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(services)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed services array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(services); i++) {\n        virNetServerServicePtr service;\n        virJSONValuePtr child = virJSONValueArrayGet(services, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing service data in JSON document\"));\n            goto error;\n        }\n\n        if (!(service = virNetServerServiceNewPostExecRestart(child)))\n            goto error;\n\n        if (virNetServerAddService(srv, service) < 0) {\n            virObjectUnref(service);\n            goto error;\n        }\n    }\n\n\n    if (!(clients = virJSONValueObjectGet(object, \"clients\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing clients data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(clients)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed clients array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(clients); i++) {\n        virNetServerClientPtr client;\n        virJSONValuePtr child = virJSONValueArrayGet(clients, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing client data in JSON document\"));\n            goto error;\n        }\n\n        if (!(client = virNetServerClientNewPostExecRestart(srv,\n                                                            child,\n                                                            clientPrivNewPostExecRestart,\n                                                            clientPrivPreExecRestart,\n                                                            clientPrivFree,\n                                                            clientPrivOpaque)))\n            goto error;\n\n        if (virNetServerAddClient(srv, client) < 0) {\n            virObjectUnref(client);\n            goto error;\n        }\n        virObjectUnref(client);\n    }\n\n    return srv;\n\n error:\n    virObjectUnref(srv);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerPtr virNetServerNewPostExecRestart(virJSONValuePtr object,\n                                               const char *name,\n                                               virNetServerClientPrivNew clientPrivNew,\n                                               virNetServerClientPrivNewPostExecRestart clientPrivNewPostExecRestart,\n                                               virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                               virFreeCallback clientPrivFree,\n                                               void *clientPrivOpaque)\n{\n    virNetServerPtr srv = NULL;\n    virJSONValuePtr clients;\n    virJSONValuePtr services;\n    size_t i;\n    unsigned int min_workers;\n    unsigned int max_workers;\n    unsigned int priority_workers;\n    unsigned int max_clients;\n    unsigned int max_anonymous_clients;\n    unsigned int keepaliveInterval;\n    unsigned int keepaliveCount;\n    unsigned long long next_client_id;\n\n    if (virJSONValueObjectGetNumberUint(object, \"min_workers\", &min_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing min_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_workers\", &max_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"priority_workers\", &priority_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing priority_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_clients\", &max_clients) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectHasKey(object, \"max_anonymous_clients\")) {\n        if (virJSONValueObjectGetNumberUint(object, \"max_anonymous_clients\",\n                                            &max_anonymous_clients) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed max_anonymous_clients data in JSON document\"));\n            goto error;\n        }\n    } else {\n        max_anonymous_clients = max_clients;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveInterval\", &keepaliveInterval) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveInterval data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveCount\", &keepaliveCount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveCount data in JSON document\"));\n        goto error;\n    }\n\n    if (virJSONValueObjectGetNumberUlong(object, \"next_client_id\",\n                                         &next_client_id) < 0) {\n        VIR_WARN(\"Missing next_client_id data in JSON document\");\n        next_client_id = 1;\n    }\n\n    if (!(srv = virNetServerNew(name, next_client_id,\n                                min_workers, max_workers,\n                                priority_workers, max_clients,\n                                max_anonymous_clients,\n                                keepaliveInterval, keepaliveCount,\n                                clientPrivNew, clientPrivPreExecRestart,\n                                clientPrivFree, clientPrivOpaque)))\n        goto error;\n\n    if (!(services = virJSONValueObjectGet(object, \"services\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing services data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(services)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed services array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(services); i++) {\n        virNetServerServicePtr service;\n        virJSONValuePtr child = virJSONValueArrayGet(services, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing service data in JSON document\"));\n            goto error;\n        }\n\n        if (!(service = virNetServerServiceNewPostExecRestart(child)))\n            goto error;\n\n        if (virNetServerAddService(srv, service) < 0) {\n            virObjectUnref(service);\n            goto error;\n        }\n    }\n\n\n    if (!(clients = virJSONValueObjectGet(object, \"clients\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing clients data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(clients)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed clients array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(clients); i++) {\n        virNetServerClientPtr client;\n        virJSONValuePtr child = virJSONValueArrayGet(clients, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing client data in JSON document\"));\n            goto error;\n        }\n\n        if (!(client = virNetServerClientNewPostExecRestart(srv,\n                                                            child,\n                                                            clientPrivNewPostExecRestart,\n                                                            clientPrivPreExecRestart,\n                                                            clientPrivFree,\n                                                            clientPrivOpaque)))\n            goto error;\n\n        if (virNetServerAddClient(srv, client) < 0) {\n            virObjectUnref(client);\n            goto error;\n        }\n        virObjectUnref(client);\n    }\n\n    return srv;\n\n error:\n    virObjectUnref(srv);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"admin\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"virtlockd\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void *\nvirLockDaemonClientNew(virNetServerClientPtr client,\n                       void *opaque);\nstatic void\nvirLockDaemonClientFree(void *opaque);\nstatic void *\nvirLockDaemonClientNewPostExecRestart(virNetServerClientPtr client,\n                                      virJSONValuePtr object,\n                                      void *opaque);\nstatic virJSONValuePtr\nvirLockDaemonClientPreExecRestart(virNetServerClientPtr client,\n                                  void *opaque);\n\nstatic virNetServerPtr\nvirLockDaemonNewServerPostExecRestart(virNetDaemonPtr dmn G_GNUC_UNUSED,\n                                      const char *name,\n                                      virJSONValuePtr object,\n                                      void *opaque)\n{\n    if (STREQ(name, \"virtlockd\")) {\n        return virNetServerNewPostExecRestart(object,\n                                              name,\n                                              virLockDaemonClientNew,\n                                              virLockDaemonClientNewPostExecRestart,\n                                              virLockDaemonClientPreExecRestart,\n                                              virLockDaemonClientFree,\n                                              opaque);\n    } else if (STREQ(name, \"admin\")) {\n        return virNetServerNewPostExecRestart(object,\n                                              name,\n                                              remoteAdmClientNew,\n                                              remoteAdmClientNewPostExecRestart,\n                                              remoteAdmClientPreExecRestart,\n                                              remoteAdmClientFree,\n                                              dmn);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected server name '%s' during restart\"),\n                       name);\n        return NULL;\n    }\n}"
  },
  {
    "function_name": "virLockDaemonNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "147-207",
    "snippet": "static virLockDaemonPtr\nvirLockDaemonNew(virLockDaemonConfigPtr config, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virNetServerPtr srv = NULL;\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->dmn = virNetDaemonNew()))\n        goto error;\n\n    if (!(srv = virNetServerNew(\"virtlockd\", 1,\n                                0, 0, 0, config->max_clients,\n                                config->max_clients, -1, 0,\n                                virLockDaemonClientNew,\n                                virLockDaemonClientPreExecRestart,\n                                virLockDaemonClientFree,\n                                (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    if (virNetDaemonAddServer(lockd->dmn, srv) < 0)\n        goto error;\n    virObjectUnref(srv);\n    srv = NULL;\n\n    if (!(srv = virNetServerNew(\"admin\", 1,\n                                0, 0, 0, config->admin_max_clients,\n                                config->admin_max_clients, -1, 0,\n                                remoteAdmClientNew,\n                                remoteAdmClientPreExecRestart,\n                                remoteAdmClientFree,\n                                lockd->dmn)))\n        goto error;\n\n    if (virNetDaemonAddServer(lockd->dmn, srv) < 0)\n         goto error;\n    virObjectUnref(srv);\n    srv = NULL;\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(lockd->defaultLockspace = virLockSpaceNew(NULL)))\n        goto error;\n\n    return lockd;\n\n error:\n    virObjectUnref(srv);\n    virLockDaemonFree(lockd);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockDaemonFree",
          "args": [
            "lockd"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virLockDaemonFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
          "lines": "116-128",
          "snippet": "static void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"locking/lock_protocol.h\"",
            "#include \"locking/lock_daemon_dispatch.h\"",
            "#include \"virenum.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"virhash.h\"",
            "#include \"virrandom.h\"",
            "#include \"rpc/virnetserver.h\"",
            "#include \"rpc/virnetdaemon.h\"",
            "#include \"virconf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"admin/admin_server_dispatch.h\"",
            "#include \"lock_daemon_config.h\"",
            "#include \"lock_daemon.h\"",
            "#include <getopt.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockSpaceNew",
          "args": [
            "NULL"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "287-425",
          "snippet": "virLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_LOCKSPACE_TABLE_SIZE 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\n#define VIR_LOCKSPACE_TABLE_SIZE 10\n\nvirLockSpacePtr virLockSpaceNewPostExecRestart(virJSONValuePtr object)\n{\n    virLockSpacePtr lockspace;\n    virJSONValuePtr resources;\n    size_t i;\n\n    VIR_DEBUG(\"object=%p\", object);\n\n    if (VIR_ALLOC(lockspace) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockspace->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize lockspace mutex\"));\n        VIR_FREE(lockspace);\n        return NULL;\n    }\n\n    if (!(lockspace->resources = virHashCreate(VIR_LOCKSPACE_TABLE_SIZE,\n                                               virLockSpaceResourceDataFree)))\n        goto error;\n\n    if (virJSONValueObjectHasKey(object, \"directory\")) {\n        const char *dir = virJSONValueObjectGetString(object, \"directory\");\n        lockspace->dir = g_strdup(dir);\n    }\n\n    if (!(resources = virJSONValueObjectGet(object, \"resources\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing resources value in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(resources)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed resources array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(resources); i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(resources, i);\n        virLockSpaceResourcePtr res;\n        const char *tmp;\n        virJSONValuePtr owners;\n        size_t j;\n        size_t m;\n\n        if (VIR_ALLOC(res) < 0)\n            goto error;\n        res->fd = -1;\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource name in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->name = g_strdup(tmp);\n\n        if (!(tmp = virJSONValueObjectGetString(child, \"path\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource path in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->path = g_strdup(tmp);\n        if (virJSONValueObjectGetNumberInt(child, \"fd\", &res->fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource fd in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virSetInherit(res->fd, false) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot enable close-on-exec flag\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        if (virJSONValueObjectGetBoolean(child, \"lockHeld\", &res->lockHeld) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource lockHeld in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (virJSONValueObjectGetNumberUint(child, \"flags\", &res->flags) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource flags in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!(owners = virJSONValueObjectGet(child, \"owners\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing resource owners in JSON document\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(owners)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed owners array\"));\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n\n        m = virJSONValueArraySize(owners);\n        if (VIR_ALLOC_N(res->owners, res->nOwners) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n        res->nOwners = m;\n\n        for (j = 0; j < res->nOwners; j++) {\n            unsigned long long int owner;\n            virJSONValuePtr ownerval = virJSONValueArrayGet(owners, j);\n\n            if (virJSONValueGetNumberUlong(ownerval, &owner) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Malformed owner value in JSON document\"));\n                virLockSpaceResourceFree(res);\n                goto error;\n            }\n\n            res->owners[j] = (pid_t)owner;\n        }\n\n        if (virHashAddEntry(lockspace->resources, res->name, res) < 0) {\n            virLockSpaceResourceFree(res);\n            goto error;\n        }\n    }\n\n    return lockspace;\n\n error:\n    virLockSpaceFree(lockspace);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "VIR_LOCK_DAEMON_NUM_LOCKSPACES",
            "virLockDaemonLockSpaceDataFree"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonAddServer",
          "args": [
            "lockd->dmn",
            "srv"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonAddServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "161-179",
          "snippet": "int\nvirNetDaemonAddServer(virNetDaemonPtr dmn,\n                      virNetServerPtr srv)\n{\n    int ret = -1;\n    const char *serverName = virNetServerGetName(srv);\n\n    virObjectLock(dmn);\n\n    if (virHashAddEntry(dmn->servers, serverName, srv) < 0)\n        goto cleanup;\n\n    virObjectRef(srv);\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(dmn);\n    return ret;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDaemonAddServer(virNetDaemonPtr dmn,\n                      virNetServerPtr srv)\n{\n    int ret = -1;\n    const char *serverName = virNetServerGetName(srv);\n\n    virObjectLock(dmn);\n\n    if (virHashAddEntry(dmn->servers, serverName, srv) < 0)\n        goto cleanup;\n\n    virObjectRef(srv);\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(dmn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerNew",
          "args": [
            "\"admin\"",
            "1",
            "0",
            "0",
            "0",
            "config->admin_max_clients",
            "config->admin_max_clients",
            "-1",
            "0",
            "remoteAdmClientNew",
            "remoteAdmClientPreExecRestart",
            "remoteAdmClientFree",
            "lockd->dmn"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "349-394",
          "snippet": "virNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerClass;",
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerClass;\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDaemonNew",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDaemonNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetdaemon.c",
          "lines": "120-158",
          "snippet": "virNetDaemonPtr\nvirNetDaemonNew(void)\n{\n    virNetDaemonPtr dmn;\n#ifndef WIN32\n    struct sigaction sig_action;\n#endif /* !WIN32 */\n\n    if (virNetDaemonInitialize() < 0)\n        return NULL;\n\n    if (!(dmn = virObjectLockableNew(virNetDaemonClass)))\n        return NULL;\n\n    if (!(dmn->servers = virHashCreate(5, virObjectFreeHashData)))\n        goto error;\n\n#ifndef WIN32\n    dmn->sigwrite = dmn->sigread = -1;\n#endif /* !WIN32 */\n\n    dmn->privileged = geteuid() == 0;\n    dmn->autoShutdownInhibitFd = -1;\n\n    if (virEventRegisterDefaultImpl() < 0)\n        goto error;\n\n#ifndef WIN32\n    memset(&sig_action, 0, sizeof(sig_action));\n    sig_action.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &sig_action, NULL);\n#endif /* !WIN32 */\n\n    return dmn;\n\n error:\n    virObjectUnref(dmn);\n    return NULL;\n}",
          "includes": [
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virdbus.h\"",
            "#include \"virnetserver.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdaemon.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetDaemonClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virdbus.h\"\n#include \"virnetserver.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetdaemon.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetDaemonClass;\n\nvirNetDaemonPtr\nvirNetDaemonNew(void)\n{\n    virNetDaemonPtr dmn;\n#ifndef WIN32\n    struct sigaction sig_action;\n#endif /* !WIN32 */\n\n    if (virNetDaemonInitialize() < 0)\n        return NULL;\n\n    if (!(dmn = virObjectLockableNew(virNetDaemonClass)))\n        return NULL;\n\n    if (!(dmn->servers = virHashCreate(5, virObjectFreeHashData)))\n        goto error;\n\n#ifndef WIN32\n    dmn->sigwrite = dmn->sigread = -1;\n#endif /* !WIN32 */\n\n    dmn->privileged = geteuid() == 0;\n    dmn->autoShutdownInhibitFd = -1;\n\n    if (virEventRegisterDefaultImpl() < 0)\n        goto error;\n\n#ifndef WIN32\n    memset(&sig_action, 0, sizeof(sig_action));\n    sig_action.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &sig_action, NULL);\n#endif /* !WIN32 */\n\n    return dmn;\n\n error:\n    virObjectUnref(dmn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lockd"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to initialize mutex\")"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to initialize mutex\""
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_driver_sanlock.c",
          "lines": "97-111",
          "snippet": "static bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"lock_driver.h\"",
            "#include <sanlock_admin.h>",
            "#include <sanlock_resource.h>",
            "#include <sanlock.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdint.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"lock_driver.h\"\n#include <sanlock_admin.h>\n#include <sanlock_resource.h>\n#include <sanlock.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <config.h>\n\nstatic bool\nATTRIBUTE_NONNULL(2)\nvirLockManagerSanlockError(int err,\n                           char **message)\n{\n    if (err <= -200) {\n#if HAVE_SANLOCK_STRERROR\n        *message = g_strdup(sanlock_strerror(err));\n#else\n        *message = g_strdup_printf(_(\"sanlock error %d\"), err);\n#endif\n        return true;\n    } else {\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&lockd->lock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "lockd"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_LOCK_DAEMON_NUM_LOCKSPACES 3\n\nstatic virLockDaemonPtr\nvirLockDaemonNew(virLockDaemonConfigPtr config, bool privileged)\n{\n    virLockDaemonPtr lockd;\n    virNetServerPtr srv = NULL;\n\n    if (VIR_ALLOC(lockd) < 0)\n        return NULL;\n\n    if (virMutexInit(&lockd->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        VIR_FREE(lockd);\n        return NULL;\n    }\n\n    if (!(lockd->dmn = virNetDaemonNew()))\n        goto error;\n\n    if (!(srv = virNetServerNew(\"virtlockd\", 1,\n                                0, 0, 0, config->max_clients,\n                                config->max_clients, -1, 0,\n                                virLockDaemonClientNew,\n                                virLockDaemonClientPreExecRestart,\n                                virLockDaemonClientFree,\n                                (void*)(intptr_t)(privileged ? 0x1 : 0x0))))\n        goto error;\n\n    if (virNetDaemonAddServer(lockd->dmn, srv) < 0)\n        goto error;\n    virObjectUnref(srv);\n    srv = NULL;\n\n    if (!(srv = virNetServerNew(\"admin\", 1,\n                                0, 0, 0, config->admin_max_clients,\n                                config->admin_max_clients, -1, 0,\n                                remoteAdmClientNew,\n                                remoteAdmClientPreExecRestart,\n                                remoteAdmClientFree,\n                                lockd->dmn)))\n        goto error;\n\n    if (virNetDaemonAddServer(lockd->dmn, srv) < 0)\n         goto error;\n    virObjectUnref(srv);\n    srv = NULL;\n\n    if (!(lockd->lockspaces = virHashCreate(VIR_LOCK_DAEMON_NUM_LOCKSPACES,\n                                            virLockDaemonLockSpaceDataFree)))\n        goto error;\n\n    if (!(lockd->defaultLockspace = virLockSpaceNew(NULL)))\n        goto error;\n\n    return lockd;\n\n error:\n    virObjectUnref(srv);\n    virLockDaemonFree(lockd);\n    return NULL;\n}"
  },
  {
    "function_name": "virLockDaemonLockSpaceDataFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "142-145",
    "snippet": "static void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLockSpaceFree",
          "args": [
            "data"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "505-514",
          "snippet": "void virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nvoid virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virLockDaemonLockSpaceDataFree(void *data)\n{\n    virLockSpaceFree(data);\n}"
  },
  {
    "function_name": "virLockDaemonUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "136-140",
    "snippet": "static inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&lockd->lock"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic inline void\nvirLockDaemonUnlock(virLockDaemonPtr lockd)\n{\n    virMutexUnlock(&lockd->lock);\n}"
  },
  {
    "function_name": "virLockDaemonLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "130-134",
    "snippet": "static inline void\nvirLockDaemonLock(virLockDaemonPtr lockd)\n{\n    virMutexLock(&lockd->lock);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&lockd->lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic inline void\nvirLockDaemonLock(virLockDaemonPtr lockd)\n{\n    virMutexLock(&lockd->lock);\n}"
  },
  {
    "function_name": "virLockDaemonFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_daemon.c",
    "lines": "116-128",
    "snippet": "static void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"locking/lock_protocol.h\"",
      "#include \"locking/lock_daemon_dispatch.h\"",
      "#include \"virenum.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"viruuid.h\"",
      "#include \"virhash.h\"",
      "#include \"virrandom.h\"",
      "#include \"rpc/virnetserver.h\"",
      "#include \"rpc/virnetdaemon.h\"",
      "#include \"virconf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"admin/admin_server_dispatch.h\"",
      "#include \"lock_daemon_config.h\"",
      "#include \"lock_daemon.h\"",
      "#include <getopt.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lockd"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockSpaceFree",
          "args": [
            "lockd->defaultLockspace"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virLockSpaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlockspace.c",
          "lines": "505-514",
          "snippet": "void virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virlockspace.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virlockspace.h\"\n#include <config.h>\n\nvoid virLockSpaceFree(virLockSpacePtr lockspace)\n{\n    if (!lockspace)\n        return;\n\n    virHashFree(lockspace->resources);\n    VIR_FREE(lockspace->dir);\n    virMutexDestroy(&lockspace->lock);\n    VIR_FREE(lockspace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "lockd->lockspaces"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "lockd->dmn"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&lockd->lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"locking/lock_protocol.h\"\n#include \"locking/lock_daemon_dispatch.h\"\n#include \"virenum.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"virhash.h\"\n#include \"virrandom.h\"\n#include \"rpc/virnetserver.h\"\n#include \"rpc/virnetdaemon.h\"\n#include \"virconf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"admin/admin_server_dispatch.h\"\n#include \"lock_daemon_config.h\"\n#include \"lock_daemon.h\"\n#include <getopt.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirLockDaemonFree(virLockDaemonPtr lockd)\n{\n    if (!lockd)\n        return;\n\n    virMutexDestroy(&lockd->lock);\n    virObjectUnref(lockd->dmn);\n    virHashFree(lockd->lockspaces);\n    virLockSpaceFree(lockd->defaultLockspace);\n\n    VIR_FREE(lockd);\n}"
  }
]