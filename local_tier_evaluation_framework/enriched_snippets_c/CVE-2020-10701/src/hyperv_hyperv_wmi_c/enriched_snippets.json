[
  {
    "function_name": "hypervGetMsvmMemorySettingDataFromVSSD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1613-1631",
    "snippet": "int\nhypervGetMsvmMemorySettingDataFromVSSD(hypervPrivate *priv,\n        const char *vssd_instanceid, Msvm_MemorySettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n            \"ResultClass = Msvm_MemorySettingData\",\n            vssd_instanceid);\n\n    if (hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_MemorySettingData_WmiInfo",
            "&query",
            "(hypervObject **)list"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&query",
            "\"associators of \"\n            \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n            \"ResultClass = Msvm_MemorySettingData\"",
            "vssd_instanceid"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmMemorySettingDataFromVSSD(hypervPrivate *priv,\n        const char *vssd_instanceid, Msvm_MemorySettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_VirtualSystemSettingData.InstanceID=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_VirtualSystemSettingDataComponent \"\n            \"ResultClass = Msvm_MemorySettingData\",\n            vssd_instanceid);\n\n    if (hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervGetMsvmVirtualSystemSettingDataFromUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1587-1606",
    "snippet": "int\nhypervGetMsvmVirtualSystemSettingDataFromUUID(hypervPrivate *priv,\n        const char *uuid_string, Msvm_VirtualSystemSettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_SettingsDefineState \"\n            \"ResultClass = Msvm_VirtualSystemSettingData\",\n            uuid_string);\n\n    if (hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_VirtualSystemSettingData_WmiInfo",
            "&query",
            "(hypervObject **)list"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&query",
            "\"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_SettingsDefineState \"\n            \"ResultClass = Msvm_VirtualSystemSettingData\"",
            "uuid_string"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmVirtualSystemSettingDataFromUUID(hypervPrivate *priv,\n        const char *uuid_string, Msvm_VirtualSystemSettingData **list)\n{\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&query,\n            \"associators of \"\n            \"{Msvm_ComputerSystem.CreationClassName=\\\"Msvm_ComputerSystem\\\",\"\n            \"Name=\\\"%s\\\"} \"\n            \"where AssocClass = Msvm_SettingsDefineState \"\n            \"ResultClass = Msvm_VirtualSystemSettingData\",\n            uuid_string);\n\n    if (hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, &query,\n                (hypervObject **)list) < 0 || *list == NULL)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervMsvmComputerSystemFromDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1550-1580",
    "snippet": "int\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"No domain with UUID %s\")",
            "uuid_string"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No domain with UUID %s\""
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmComputerSystemList",
          "args": [
            "priv",
            "&query",
            "computerSystem"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmComputerSystemList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1232-1238",
          "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&query",
            "\"and Name = \\\"%s\\\"\"",
            "uuid_string"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_VIRTUAL"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "\"where \""
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_COMPUTERSYSTEM_WQL_SELECT"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemFromDomain(virDomainPtr domain,\n                                   Msvm_ComputerSystem **computerSystem)\n{\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n\n    if (computerSystem == NULL || *computerSystem != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_SELECT);\n    virBufferAddLit(&query, \"where \");\n    virBufferAddLit(&query, MSVM_COMPUTERSYSTEM_WQL_VIRTUAL);\n    virBufferAsprintf(&query, \"and Name = \\\"%s\\\"\", uuid_string);\n\n    if (hypervGetMsvmComputerSystemList(priv, &query, computerSystem) < 0)\n        return -1;\n\n    if (*computerSystem == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"No domain with UUID %s\"), uuid_string);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervMsvmComputerSystemToDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1522-1548",
    "snippet": "int\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "computerSystem->data.common->ElementName",
            "uuid",
            "id"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervIsMsvmComputerSystemActive",
          "args": [
            "computerSystem",
            "NULL"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "hypervIsMsvmComputerSystemActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1483-1520",
          "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse UUID from string '%s'\")",
            "computerSystem->data.common->Name"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from string '%s'\""
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "computerSystem->data.common->Name",
            "uuid"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemToDomain(virConnectPtr conn,\n                                 Msvm_ComputerSystem *computerSystem,\n                                 virDomainPtr *domain)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int id = -1;\n\n    if (domain == NULL || *domain != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virUUIDParse(computerSystem->data.common->Name, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       computerSystem->data.common->Name);\n        return -1;\n    }\n\n    if (hypervIsMsvmComputerSystemActive(computerSystem, NULL))\n        id = computerSystem->data.common->ProcessID;\n\n    *domain = virGetDomain(conn, computerSystem->data.common->ElementName, uuid, id);\n\n    return *domain ? 0 : -1;\n}"
  },
  {
    "function_name": "hypervIsMsvmComputerSystemActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1483-1520",
    "snippet": "bool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nbool\nhypervIsMsvmComputerSystemActive(Msvm_ComputerSystem *computerSystem,\n                                 bool *in_transition)\n{\n    if (in_transition != NULL)\n        *in_transition = false;\n\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return true;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return false;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        if (in_transition != NULL)\n            *in_transition = true;\n\n        return true;\n\n      default:\n        return false;\n    }\n}"
  },
  {
    "function_name": "hypervMsvmComputerSystemEnabledStateToDomainState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1446-1481",
    "snippet": "int\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervMsvmComputerSystemEnabledStateToDomainState\n  (Msvm_ComputerSystem *computerSystem)\n{\n    switch (computerSystem->data.common->EnabledState) {\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_UNKNOWN:\n        return VIR_DOMAIN_NOSTATE;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_ENABLED:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_DISABLED:\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSED:\n        return VIR_DOMAIN_PAUSED;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SUSPENDED: /* managed save */\n        return VIR_DOMAIN_SHUTOFF;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STARTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SNAPSHOTTING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_SAVING:\n        return VIR_DOMAIN_RUNNING;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_STOPPING:\n        return VIR_DOMAIN_SHUTDOWN;\n\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_PAUSING:\n      case MSVM_COMPUTERSYSTEM_ENABLEDSTATE_RESUMING:\n        return VIR_DOMAIN_RUNNING;\n\n      default:\n        return VIR_DOMAIN_NOSTATE;\n    }\n}"
  },
  {
    "function_name": "hypervInvokeMsvmComputerSystemRequestStateChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1303-1444",
    "snippet": "int\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)concreteJob"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "instanceID"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "returnValue"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "properties"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "selector"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "response"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_destroy",
          "args": [
            "options"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invocation of %s returned an error: %s (%d)\")",
            "\"RequestStateChange\"",
            "hypervReturnCodeToString(returnCode)",
            "returnCode"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervReturnCodeToString",
          "args": [
            "returnCode"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "hypervReturnCodeToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1151-1224",
          "snippet": "const char *\nhypervReturnCodeToString(int returnCode)\n{\n    switch (returnCode) {\n      case CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR:\n        return _(\"Completed with no error\");\n\n      case CIM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case CIM_RETURNCODE_UNKNOWN_ERROR:\n        return _(\"Unknown error\");\n\n      case CIM_RETURNCODE_CANNOT_COMPLETE_WITHIN_TIMEOUT_PERIOD:\n        return _(\"Cannot complete within timeout period\");\n\n      case CIM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case CIM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case CIM_RETURNCODE_IN_USE:\n        return _(\"In use\");\n\n      case CIM_RETURNCODE_TRANSITION_STARTED:\n        return _(\"Transition started\");\n\n      case CIM_RETURNCODE_INVALID_STATE_TRANSITION:\n        return _(\"Invalid state transition\");\n\n      case CIM_RETURNCODE_TIMEOUT_PARAMETER_NOT_SUPPORTED:\n        return _(\"Timeout parameter not supported\");\n\n      case CIM_RETURNCODE_BUSY:\n        return _(\"Busy\");\n\n      case MSVM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case MSVM_RETURNCODE_ACCESS_DENIED:\n        return _(\"Access denied\");\n\n      case MSVM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case MSVM_RETURNCODE_STATUS_IS_UNKNOWN:\n        return _(\"Status is unknown\");\n\n      case MSVM_RETURNCODE_TIMEOUT:\n        return _(\"Timeout\");\n\n      case MSVM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_IN_USE:\n        return _(\"System is in use\");\n\n      case MSVM_RETURNCODE_INVALID_STATE_FOR_THIS_OPERATION:\n        return _(\"Invalid state for this operation\");\n\n      case MSVM_RETURNCODE_INCORRECT_DATA_TYPE:\n        return _(\"Incorrect data type\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_NOT_AVAILABLE:\n        return _(\"System is not available\");\n\n      case MSVM_RETURNCODE_OUT_OF_MEMORY:\n        return _(\"Out of memory\");\n\n      default:\n        return _(\"Unknown return code\");\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nconst char *\nhypervReturnCodeToString(int returnCode)\n{\n    switch (returnCode) {\n      case CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR:\n        return _(\"Completed with no error\");\n\n      case CIM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case CIM_RETURNCODE_UNKNOWN_ERROR:\n        return _(\"Unknown error\");\n\n      case CIM_RETURNCODE_CANNOT_COMPLETE_WITHIN_TIMEOUT_PERIOD:\n        return _(\"Cannot complete within timeout period\");\n\n      case CIM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case CIM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case CIM_RETURNCODE_IN_USE:\n        return _(\"In use\");\n\n      case CIM_RETURNCODE_TRANSITION_STARTED:\n        return _(\"Transition started\");\n\n      case CIM_RETURNCODE_INVALID_STATE_TRANSITION:\n        return _(\"Invalid state transition\");\n\n      case CIM_RETURNCODE_TIMEOUT_PARAMETER_NOT_SUPPORTED:\n        return _(\"Timeout parameter not supported\");\n\n      case CIM_RETURNCODE_BUSY:\n        return _(\"Busy\");\n\n      case MSVM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case MSVM_RETURNCODE_ACCESS_DENIED:\n        return _(\"Access denied\");\n\n      case MSVM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case MSVM_RETURNCODE_STATUS_IS_UNKNOWN:\n        return _(\"Status is unknown\");\n\n      case MSVM_RETURNCODE_TIMEOUT:\n        return _(\"Timeout\");\n\n      case MSVM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_IN_USE:\n        return _(\"System is in use\");\n\n      case MSVM_RETURNCODE_INVALID_STATE_FOR_THIS_OPERATION:\n        return _(\"Invalid state for this operation\");\n\n      case MSVM_RETURNCODE_INCORRECT_DATA_TYPE:\n        return _(\"Incorrect data type\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_NOT_AVAILABLE:\n        return _(\"System is not available\");\n\n      case MSVM_RETURNCODE_OUT_OF_MEMORY:\n        return _(\"Out of memory\");\n\n      default:\n        return _(\"Unknown return code\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invocation of %s returned an error: %s (%d)\""
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Concrete job for %s invocation is in unknown state\")",
            "\"RequestStateChange\""
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Concrete job for %s invocation is in error state\")",
            "\"RequestStateChange\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for %s invocation\")",
            "\"Msvm_ConcreteJob\"",
            "\"RequestStateChange\""
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmConcreteJobList",
          "args": [
            "priv",
            "&query",
            "&concreteJob"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmConcreteJobList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1240-1246",
          "snippet": "int\nhypervGetMsvmConcreteJobList(hypervPrivate *priv, virBufferPtr query,\n                             Msvm_ConcreteJob **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ConcreteJob_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmConcreteJobList(hypervPrivate *priv, virBufferPtr query,\n                             Msvm_ConcreteJob **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ConcreteJob_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&query",
            "\"where InstanceID = \\\"%s\\\"\"",
            "instanceID"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_CONCRETEJOB_WQL_SELECT"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for %s invocation\")",
            "\"InstanceID\"",
            "\"RequestStateChange\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_xpath_value",
          "args": [
            "response",
            "(char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse return code from '%s'\")",
            "returnValue"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "returnValue",
            "NULL",
            "10",
            "&returnCode"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup %s for %s invocation\")",
            "\"ReturnValue\"",
            "\"RequestStateChange\""
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_xpath_value",
          "args": [
            "response",
            "(char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervVerifyResponse",
          "args": [
            "priv->client",
            "response",
            "\"invocation\""
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "hypervVerifyResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "97-149",
          "snippet": "int\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_action_invoke",
          "args": [
            "priv->client",
            "resourceUri",
            "options",
            "\"RequestStateChange\"",
            "NULL"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_add_prop_from_str",
          "args": [
            "options",
            "properties"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_add_selectors_from_str",
          "args": [
            "options",
            "selector"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize options\")"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_init",
          "args": [],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervInvokeMsvmComputerSystemRequestStateChange(virDomainPtr domain,\n                                                 int requestedState)\n{\n    int result = -1;\n    hypervPrivate *priv = domain->conn->privateData;\n    char uuid_string[VIR_UUID_STRING_BUFLEN];\n    WsXmlDocH response = NULL;\n    client_opt_t *options = NULL;\n    char *selector = NULL;\n    char *properties = NULL;\n    char *returnValue = NULL;\n    int returnCode;\n    char *instanceID = NULL;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *concreteJob = NULL;\n    bool completed = false;\n    const char *resourceUri = MSVM_COMPUTERSYSTEM_V2_RESOURCE_URI;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    selector = g_strdup_printf(\"Name=%s&CreationClassName=Msvm_ComputerSystem\", uuid_string);\n    properties = g_strdup_printf(\"RequestedState=%d\", requestedState);\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        resourceUri = MSVM_COMPUTERSYSTEM_V1_RESOURCE_URI;\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    wsmc_add_selectors_from_str(options, selector);\n    wsmc_add_prop_from_str(options, properties);\n\n    /* Invoke method */\n    response = wsmc_action_invoke(priv->client, resourceUri,\n                                  options, \"RequestStateChange\", NULL);\n\n    if (hypervVerifyResponse(priv->client, response, \"invocation\") < 0)\n        goto cleanup;\n\n    /* Check return value */\n    returnValue = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:ReturnValue\");\n\n    if (returnValue == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup %s for %s invocation\"),\n                       \"ReturnValue\", \"RequestStateChange\");\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse return code from '%s'\"), returnValue);\n        goto cleanup;\n    }\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        /* Get concrete job object */\n        instanceID = ws_xml_get_xpath_value(response, (char *)\"/s:Envelope/s:Body/p:RequestStateChange_OUTPUT/p:Job/a:ReferenceParameters/w:SelectorSet/w:Selector[@Name='InstanceID']\");\n\n        if (instanceID == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup %s for %s invocation\"),\n                           \"InstanceID\", \"RequestStateChange\");\n            goto cleanup;\n        }\n\n        /* FIXME: Poll every 100ms until the job completes or fails. There\n         *        seems to be no other way than polling. */\n        while (!completed) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferAsprintf(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &concreteJob) < 0)\n                goto cleanup;\n\n            if (concreteJob == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not lookup %s for %s invocation\"),\n                               \"Msvm_ConcreteJob\", \"RequestStateChange\");\n                goto cleanup;\n            }\n\n            switch (concreteJob->data.common->JobState) {\n              case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n              case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n              case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n              case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                hypervFreeObject(priv, (hypervObject *)concreteJob);\n                concreteJob = NULL;\n\n                g_usleep(100 * 1000);\n                continue;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                completed = true;\n                break;\n\n              case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n              case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n              case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n              case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in error state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n\n              default:\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Concrete job for %s invocation is in unknown state\"),\n                               \"RequestStateChange\");\n                goto cleanup;\n            }\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invocation of %s returned an error: %s (%d)\"),\n                       \"RequestStateChange\", hypervReturnCodeToString(returnCode),\n                       returnCode);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    ws_xml_destroy_doc(response);\n    VIR_FREE(selector);\n    VIR_FREE(properties);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    hypervFreeObject(priv, (hypervObject *)concreteJob);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervGetMsvmKeyboardList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1290-1295",
    "snippet": "int hypervGetMsvmKeyboardList(hypervPrivate *priv, virBufferPtr query,\n                              Msvm_Keyboard **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_Keyboard_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_Keyboard_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint hypervGetMsvmKeyboardList(hypervPrivate *priv, virBufferPtr query,\n                              Msvm_Keyboard **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_Keyboard_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetMsvmMemorySettingDataList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1282-1288",
    "snippet": "int\nhypervGetMsvmMemorySettingDataList(hypervPrivate *priv, virBufferPtr query,\n                                   Msvm_MemorySettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_MemorySettingData_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmMemorySettingDataList(hypervPrivate *priv, virBufferPtr query,\n                                   Msvm_MemorySettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_MemorySettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetMsvmProcessorSettingDataList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1273-1280",
    "snippet": "int\nhypervGetMsvmProcessorSettingDataList(hypervPrivate *priv,\n                                      virBufferPtr query,\n                                      Msvm_ProcessorSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ProcessorSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_ProcessorSettingData_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmProcessorSettingDataList(hypervPrivate *priv,\n                                      virBufferPtr query,\n                                      Msvm_ProcessorSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ProcessorSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetMsvmVirtualSystemSettingDataList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1264-1271",
    "snippet": "int\nhypervGetMsvmVirtualSystemSettingDataList(hypervPrivate *priv,\n                                          virBufferPtr query,\n                                          Msvm_VirtualSystemSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_VirtualSystemSettingData_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmVirtualSystemSettingDataList(hypervPrivate *priv,\n                                          virBufferPtr query,\n                                          Msvm_VirtualSystemSettingData **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_VirtualSystemSettingData_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetWin32ProcessorList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1256-1262",
    "snippet": "int\nhypervGetWin32ProcessorList(hypervPrivate *priv, virBufferPtr query,\n                            Win32_Processor **list)\n{\n    return hypervGetWmiClassList(priv, Win32_Processor_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Win32_Processor_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetWin32ProcessorList(hypervPrivate *priv, virBufferPtr query,\n                            Win32_Processor **list)\n{\n    return hypervGetWmiClassList(priv, Win32_Processor_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetWin32ComputerSystemList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1248-1254",
    "snippet": "int\nhypervGetWin32ComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                 Win32_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Win32_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Win32_ComputerSystem_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetWin32ComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                 Win32_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Win32_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetMsvmConcreteJobList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1240-1246",
    "snippet": "int\nhypervGetMsvmConcreteJobList(hypervPrivate *priv, virBufferPtr query,\n                             Msvm_ConcreteJob **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ConcreteJob_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_ConcreteJob_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmConcreteJobList(hypervPrivate *priv, virBufferPtr query,\n                             Msvm_ConcreteJob **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ConcreteJob_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervGetMsvmComputerSystemList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1232-1238",
    "snippet": "int\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassList",
          "args": [
            "priv",
            "Msvm_ComputerSystem_WmiInfo",
            "query",
            "(hypervObject **)list"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "85-95",
          "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmComputerSystemList(hypervPrivate *priv, virBufferPtr query,\n                                Msvm_ComputerSystem **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ComputerSystem_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
  },
  {
    "function_name": "hypervReturnCodeToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1151-1224",
    "snippet": "const char *\nhypervReturnCodeToString(int returnCode)\n{\n    switch (returnCode) {\n      case CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR:\n        return _(\"Completed with no error\");\n\n      case CIM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case CIM_RETURNCODE_UNKNOWN_ERROR:\n        return _(\"Unknown error\");\n\n      case CIM_RETURNCODE_CANNOT_COMPLETE_WITHIN_TIMEOUT_PERIOD:\n        return _(\"Cannot complete within timeout period\");\n\n      case CIM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case CIM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case CIM_RETURNCODE_IN_USE:\n        return _(\"In use\");\n\n      case CIM_RETURNCODE_TRANSITION_STARTED:\n        return _(\"Transition started\");\n\n      case CIM_RETURNCODE_INVALID_STATE_TRANSITION:\n        return _(\"Invalid state transition\");\n\n      case CIM_RETURNCODE_TIMEOUT_PARAMETER_NOT_SUPPORTED:\n        return _(\"Timeout parameter not supported\");\n\n      case CIM_RETURNCODE_BUSY:\n        return _(\"Busy\");\n\n      case MSVM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case MSVM_RETURNCODE_ACCESS_DENIED:\n        return _(\"Access denied\");\n\n      case MSVM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case MSVM_RETURNCODE_STATUS_IS_UNKNOWN:\n        return _(\"Status is unknown\");\n\n      case MSVM_RETURNCODE_TIMEOUT:\n        return _(\"Timeout\");\n\n      case MSVM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_IN_USE:\n        return _(\"System is in use\");\n\n      case MSVM_RETURNCODE_INVALID_STATE_FOR_THIS_OPERATION:\n        return _(\"Invalid state for this operation\");\n\n      case MSVM_RETURNCODE_INCORRECT_DATA_TYPE:\n        return _(\"Incorrect data type\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_NOT_AVAILABLE:\n        return _(\"System is not available\");\n\n      case MSVM_RETURNCODE_OUT_OF_MEMORY:\n        return _(\"Out of memory\");\n\n      default:\n        return _(\"Unknown return code\");\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown return code\""
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nconst char *\nhypervReturnCodeToString(int returnCode)\n{\n    switch (returnCode) {\n      case CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR:\n        return _(\"Completed with no error\");\n\n      case CIM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case CIM_RETURNCODE_UNKNOWN_ERROR:\n        return _(\"Unknown error\");\n\n      case CIM_RETURNCODE_CANNOT_COMPLETE_WITHIN_TIMEOUT_PERIOD:\n        return _(\"Cannot complete within timeout period\");\n\n      case CIM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case CIM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case CIM_RETURNCODE_IN_USE:\n        return _(\"In use\");\n\n      case CIM_RETURNCODE_TRANSITION_STARTED:\n        return _(\"Transition started\");\n\n      case CIM_RETURNCODE_INVALID_STATE_TRANSITION:\n        return _(\"Invalid state transition\");\n\n      case CIM_RETURNCODE_TIMEOUT_PARAMETER_NOT_SUPPORTED:\n        return _(\"Timeout parameter not supported\");\n\n      case CIM_RETURNCODE_BUSY:\n        return _(\"Busy\");\n\n      case MSVM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case MSVM_RETURNCODE_ACCESS_DENIED:\n        return _(\"Access denied\");\n\n      case MSVM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case MSVM_RETURNCODE_STATUS_IS_UNKNOWN:\n        return _(\"Status is unknown\");\n\n      case MSVM_RETURNCODE_TIMEOUT:\n        return _(\"Timeout\");\n\n      case MSVM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_IN_USE:\n        return _(\"System is in use\");\n\n      case MSVM_RETURNCODE_INVALID_STATE_FOR_THIS_OPERATION:\n        return _(\"Invalid state for this operation\");\n\n      case MSVM_RETURNCODE_INCORRECT_DATA_TYPE:\n        return _(\"Incorrect data type\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_NOT_AVAILABLE:\n        return _(\"System is not available\");\n\n      case MSVM_RETURNCODE_OUT_OF_MEMORY:\n        return _(\"Out of memory\");\n\n      default:\n        return _(\"Unknown return code\");\n    }\n}"
  },
  {
    "function_name": "hypervFreeObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "1109-1144",
    "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "object"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Could not free deserialized data\")"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not free deserialized data\""
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ws_serializer_free_mem",
          "args": [
            "serializerContext",
            "object->data.common",
            "object->info->serializerInfo"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_serialization_context",
          "args": [
            "priv->client"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
  },
  {
    "function_name": "hypervEnumAndPull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "953-1107",
    "snippet": "int\nhypervEnumAndPull(hypervPrivate *priv, hypervWqlQueryPtr wqlQuery,\n                  hypervObject **list)\n{\n    int result = -1;\n    WsSerializerContextH serializerContext;\n    client_opt_t *options = NULL;\n    char *query_string = NULL;\n    hypervWmiClassInfoPtr wmiInfo = NULL;\n    filter_t *filter = NULL;\n    WsXmlDocH response = NULL;\n    char *enumContext = NULL;\n    hypervObject *head = NULL;\n    hypervObject *tail = NULL;\n    WsXmlNodeH node = NULL;\n    XML_TYPE_PTR data = NULL;\n    hypervObject *object;\n\n    query_string = virBufferContentAndReset(wqlQuery->query);\n\n    if (list == NULL || *list != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        VIR_FREE(query_string);\n        return -1;\n    }\n\n    if (hypervGetWmiClassInfo(priv, wqlQuery->info, &wmiInfo) < 0)\n        goto cleanup;\n\n    serializerContext = wsmc_get_serialization_context(priv->client);\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n\n    if (filter == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create filter\"));\n        goto cleanup;\n    }\n\n    response = wsmc_action_enumerate(priv->client, wmiInfo->rootUri, options,\n                                     filter);\n\n    if (hypervVerifyResponse(priv->client, response, \"enumeration\") < 0)\n        goto cleanup;\n\n    enumContext = wsmc_get_enum_context(response);\n\n    ws_xml_destroy_doc(response);\n    response = NULL;\n\n    while (enumContext != NULL && *enumContext != '\\0') {\n        response = wsmc_action_pull(priv->client, wmiInfo->resourceUri, options,\n                                    filter, enumContext);\n\n        if (hypervVerifyResponse(priv->client, response, \"pull\") < 0)\n            goto cleanup;\n\n        node = ws_xml_get_soap_body(response);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup SOAP body\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ITEMS);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response items\"));\n            goto cleanup;\n        }\n\n        if (ws_xml_get_child(node, 0, wmiInfo->resourceUri,\n                             wmiInfo->name) == NULL)\n            break;\n\n        data = ws_deserialize(serializerContext, node, wmiInfo->serializerInfo,\n                              wmiInfo->name, wmiInfo->resourceUri, NULL, 0, 0);\n\n        if (data == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not deserialize pull response item\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(object) < 0)\n            goto cleanup;\n\n        object->info = wmiInfo;\n        object->data.common = data;\n\n        data = NULL;\n\n        if (head == NULL) {\n            head = object;\n        } else {\n            tail->next = object;\n        }\n\n        tail = object;\n\n        VIR_FREE(enumContext);\n        enumContext = wsmc_get_enum_context(response);\n\n        ws_xml_destroy_doc(response);\n        response = NULL;\n    }\n\n    *list = head;\n    head = NULL;\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    if (filter != NULL)\n        filter_destroy(filter);\n\n    if (data != NULL) {\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        see hypervFreeObject for a detailed explanation. */\n        if (ws_serializer_free_mem(serializerContext, data,\n                                   wmiInfo->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n    }\n\n    VIR_FREE(query_string);\n    ws_xml_destroy_doc(response);\n    VIR_FREE(enumContext);\n    hypervFreeObject(priv, head);\n\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "head"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "enumContext"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "response"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "query_string"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Could not free deserialized data\")"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not free deserialized data\""
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ws_serializer_free_mem",
          "args": [
            "serializerContext",
            "data",
            "wmiInfo->serializerInfo"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_destroy",
          "args": [
            "filter"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_destroy",
          "args": [
            "options"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "response"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_enum_context",
          "args": [
            "response"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "enumContext"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "object"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not deserialize pull response item\")"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_deserialize",
          "args": [
            "serializerContext",
            "node",
            "wmiInfo->serializerInfo",
            "wmiInfo->name",
            "wmiInfo->resourceUri",
            "NULL",
            "0",
            "0"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "node",
            "0",
            "wmiInfo->resourceUri",
            "wmiInfo->name"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not lookup pull response items\")"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "node",
            "0",
            "XML_NS_ENUMERATION",
            "WSENUM_ITEMS"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not lookup pull response\")"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "node",
            "0",
            "XML_NS_ENUMERATION",
            "WSENUM_PULL_RESP"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not lookup SOAP body\")"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_soap_body",
          "args": [
            "response"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervVerifyResponse",
          "args": [
            "priv->client",
            "response",
            "\"pull\""
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "hypervVerifyResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "97-149",
          "snippet": "int\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_action_pull",
          "args": [
            "priv->client",
            "wmiInfo->resourceUri",
            "options",
            "filter",
            "enumContext"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "response"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_enum_context",
          "args": [
            "response"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_action_enumerate",
          "args": [
            "priv->client",
            "wmiInfo->rootUri",
            "options",
            "filter"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create filter\")"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_create_simple",
          "args": [
            "WSM_WQL_FILTER_DIALECT",
            "query_string"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize options\")"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_init",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_serialization_context",
          "args": [
            "priv->client"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetWmiClassInfo",
          "args": [
            "priv",
            "wqlQuery->info",
            "&wmiInfo"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "49-83",
          "snippet": "static int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "query_string"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "wqlQuery->query"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nint\nhypervEnumAndPull(hypervPrivate *priv, hypervWqlQueryPtr wqlQuery,\n                  hypervObject **list)\n{\n    int result = -1;\n    WsSerializerContextH serializerContext;\n    client_opt_t *options = NULL;\n    char *query_string = NULL;\n    hypervWmiClassInfoPtr wmiInfo = NULL;\n    filter_t *filter = NULL;\n    WsXmlDocH response = NULL;\n    char *enumContext = NULL;\n    hypervObject *head = NULL;\n    hypervObject *tail = NULL;\n    WsXmlNodeH node = NULL;\n    XML_TYPE_PTR data = NULL;\n    hypervObject *object;\n\n    query_string = virBufferContentAndReset(wqlQuery->query);\n\n    if (list == NULL || *list != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        VIR_FREE(query_string);\n        return -1;\n    }\n\n    if (hypervGetWmiClassInfo(priv, wqlQuery->info, &wmiInfo) < 0)\n        goto cleanup;\n\n    serializerContext = wsmc_get_serialization_context(priv->client);\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n\n    if (filter == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create filter\"));\n        goto cleanup;\n    }\n\n    response = wsmc_action_enumerate(priv->client, wmiInfo->rootUri, options,\n                                     filter);\n\n    if (hypervVerifyResponse(priv->client, response, \"enumeration\") < 0)\n        goto cleanup;\n\n    enumContext = wsmc_get_enum_context(response);\n\n    ws_xml_destroy_doc(response);\n    response = NULL;\n\n    while (enumContext != NULL && *enumContext != '\\0') {\n        response = wsmc_action_pull(priv->client, wmiInfo->resourceUri, options,\n                                    filter, enumContext);\n\n        if (hypervVerifyResponse(priv->client, response, \"pull\") < 0)\n            goto cleanup;\n\n        node = ws_xml_get_soap_body(response);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup SOAP body\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ITEMS);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response items\"));\n            goto cleanup;\n        }\n\n        if (ws_xml_get_child(node, 0, wmiInfo->resourceUri,\n                             wmiInfo->name) == NULL)\n            break;\n\n        data = ws_deserialize(serializerContext, node, wmiInfo->serializerInfo,\n                              wmiInfo->name, wmiInfo->resourceUri, NULL, 0, 0);\n\n        if (data == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not deserialize pull response item\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(object) < 0)\n            goto cleanup;\n\n        object->info = wmiInfo;\n        object->data.common = data;\n\n        data = NULL;\n\n        if (head == NULL) {\n            head = object;\n        } else {\n            tail->next = object;\n        }\n\n        tail = object;\n\n        VIR_FREE(enumContext);\n        enumContext = wsmc_get_enum_context(response);\n\n        ws_xml_destroy_doc(response);\n        response = NULL;\n    }\n\n    *list = head;\n    head = NULL;\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    if (filter != NULL)\n        filter_destroy(filter);\n\n    if (data != NULL) {\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        see hypervFreeObject for a detailed explanation. */\n        if (ws_serializer_free_mem(serializerContext, data,\n                                   wmiInfo->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n    }\n\n    VIR_FREE(query_string);\n    ws_xml_destroy_doc(response);\n    VIR_FREE(enumContext);\n    hypervFreeObject(priv, head);\n\n    return result;\n}"
  },
  {
    "function_name": "hypervInvokeMethod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "765-946",
    "snippet": "int\nhypervInvokeMethod(hypervPrivate *priv, hypervInvokeParamsListPtr params,\n        WsXmlDocH *res)\n{\n    int result = -1;\n    size_t i = 0;\n    int returnCode;\n    WsXmlDocH paramsDocRoot = NULL;\n    client_opt_t *options = NULL;\n    WsXmlDocH response = NULL;\n    WsXmlNodeH methodNode = NULL;\n    char *returnValue_xpath = NULL;\n    char *jobcode_instance_xpath = NULL;\n    char *returnValue = NULL;\n    char *instanceID = NULL;\n    bool completed = false;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *job = NULL;\n    int jobState = -1;\n    hypervParamPtr p = NULL;\n    int timeout = HYPERV_JOB_TIMEOUT_MS;\n\n    if (hypervCreateInvokeXmlDoc(params, &paramsDocRoot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create XML document\"));\n        goto cleanup;\n    }\n\n    methodNode = xml_parser_get_root(paramsDocRoot);\n    if (!methodNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root of XML document\"));\n        goto cleanup;\n    }\n\n    /* Serialize parameters */\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                if (hypervSerializeSimpleParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EPR_PARAM:\n                if (hypervSerializeEprParam(p, priv, params->resourceUri,\n                                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                if (hypervSerializeEmbeddedParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Unknown parameter type\"));\n                goto cleanup;\n        }\n    }\n\n    /* Invoke the method and get the response */\n\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_add_selectors_from_str(options, params->selector);\n\n    /* do the invoke */\n    response = wsmc_action_invoke(priv->client, params->resourceUri, options,\n            params->method, paramsDocRoot);\n\n    /* check return code of invocation */\n    returnValue_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:ReturnValue\",\n                                        params->method);\n\n    returnValue = ws_xml_get_xpath_value(response, returnValue_xpath);\n    if (!returnValue) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get return value for %s invocation\"),\n                       params->method);\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0)\n        goto cleanup;\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        jobcode_instance_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:Job/a:ReferenceParameters/\"\n                                                 \"w:SelectorSet/w:Selector[@Name='InstanceID']\",\n                                                 params->method);\n\n        instanceID = ws_xml_get_xpath_value(response, jobcode_instance_xpath);\n        if (!instanceID) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get instance ID for %s invocation\"),\n                           params->method);\n            goto cleanup;\n        }\n\n        /*\n         * Poll Hyper-V about the job until either the job completes or fails,\n         * or 5 minutes have elapsed.\n         *\n         * Windows has its own timeout on running WMI method calls (it calls\n         * these \"jobs\"), by default set to 1 minute. The administrator can\n         * change this to whatever they want, however, so we can't rely on it.\n         *\n         * Therefore, to avoid waiting in this loop for a very long-running job\n         * to complete, we instead bail after 5 minutes no matter what. NOTE that\n         * this does not mean that the remote job has terminated on the Windows\n         * side! That is up to Windows to control, we don't do anything about it.\n         */\n        while (!completed && timeout >= 0) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferEscapeSQL(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &job) < 0\n                    || job == NULL)\n                goto cleanup;\n\n            jobState = job->data.common->JobState;\n            switch (jobState) {\n                case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n                case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n                case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n                case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                    hypervFreeObject(priv, (hypervObject *)job);\n                    job = NULL;\n                    g_usleep(100 * 1000); /* sleep 100 ms */\n                    timeout -= 100;\n                    continue;\n                case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                    completed = true;\n                    break;\n                case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n                case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n                case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n                case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                    goto cleanup;\n                default:\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unknown invocation state\"));\n                    goto cleanup;\n            }\n        }\n        if (!completed && timeout < 0) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                    _(\"Timeout waiting for %s invocation\"), params->method);\n            goto cleanup;\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invocation of %s returned an error: %s (%d)\"),\n                    params->method, hypervReturnCodeToString(returnCode),\n                    returnCode);\n        goto cleanup;\n    }\n\n    if (res)\n        *res = response;\n\n    result = 0;\n\n cleanup:\n    if (options)\n        wsmc_options_destroy(options);\n    if (response && (!res))\n        ws_xml_destroy_doc(response);\n    if (paramsDocRoot)\n        ws_xml_destroy_doc(paramsDocRoot);\n    VIR_FREE(returnValue_xpath);\n    VIR_FREE(jobcode_instance_xpath);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    virBufferFreeAndReset(&query);\n    hypervFreeObject(priv, (hypervObject *)job);\n    hypervFreeInvokeParams(params);\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HYPERV_JOB_TIMEOUT_MS 300000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervFreeInvokeParams",
          "args": [
            "params"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeInvokeParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "202-231",
          "snippet": "void\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervFreeObject",
          "args": [
            "priv",
            "(hypervObject *)job"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1109-1144",
          "snippet": "void\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nvoid\nhypervFreeObject(hypervPrivate *priv G_GNUC_UNUSED, hypervObject *object)\n{\n    hypervObject *next;\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    WsSerializerContextH serializerContext;\n#endif\n\n    if (object == NULL)\n        return;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n    serializerContext = wsmc_get_serialization_context(priv->client);\n#endif\n\n    while (object != NULL) {\n        next = object->next;\n\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        but this is not that critical, because openwsman keeps\n         *        track of all allocations of the deserializer and frees\n         *        them in wsmc_release. So this doesn't result in a real\n         *        memory leak, but just in piling up unused memory until\n         *        the connection is closed. */\n        if (ws_serializer_free_mem(serializerContext, object->data.common,\n                                   object->info->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n\n        VIR_FREE(object);\n\n        object = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&query"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "instanceID"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "returnValue"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "jobcode_instance_xpath"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "returnValue_xpath"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "paramsDocRoot"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "response"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_destroy",
          "args": [
            "options"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invocation of %s returned an error: %s (%d)\")",
            "params->method",
            "hypervReturnCodeToString(returnCode)",
            "returnCode"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervReturnCodeToString",
          "args": [
            "returnCode"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "hypervReturnCodeToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1151-1224",
          "snippet": "const char *\nhypervReturnCodeToString(int returnCode)\n{\n    switch (returnCode) {\n      case CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR:\n        return _(\"Completed with no error\");\n\n      case CIM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case CIM_RETURNCODE_UNKNOWN_ERROR:\n        return _(\"Unknown error\");\n\n      case CIM_RETURNCODE_CANNOT_COMPLETE_WITHIN_TIMEOUT_PERIOD:\n        return _(\"Cannot complete within timeout period\");\n\n      case CIM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case CIM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case CIM_RETURNCODE_IN_USE:\n        return _(\"In use\");\n\n      case CIM_RETURNCODE_TRANSITION_STARTED:\n        return _(\"Transition started\");\n\n      case CIM_RETURNCODE_INVALID_STATE_TRANSITION:\n        return _(\"Invalid state transition\");\n\n      case CIM_RETURNCODE_TIMEOUT_PARAMETER_NOT_SUPPORTED:\n        return _(\"Timeout parameter not supported\");\n\n      case CIM_RETURNCODE_BUSY:\n        return _(\"Busy\");\n\n      case MSVM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case MSVM_RETURNCODE_ACCESS_DENIED:\n        return _(\"Access denied\");\n\n      case MSVM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case MSVM_RETURNCODE_STATUS_IS_UNKNOWN:\n        return _(\"Status is unknown\");\n\n      case MSVM_RETURNCODE_TIMEOUT:\n        return _(\"Timeout\");\n\n      case MSVM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_IN_USE:\n        return _(\"System is in use\");\n\n      case MSVM_RETURNCODE_INVALID_STATE_FOR_THIS_OPERATION:\n        return _(\"Invalid state for this operation\");\n\n      case MSVM_RETURNCODE_INCORRECT_DATA_TYPE:\n        return _(\"Incorrect data type\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_NOT_AVAILABLE:\n        return _(\"System is not available\");\n\n      case MSVM_RETURNCODE_OUT_OF_MEMORY:\n        return _(\"Out of memory\");\n\n      default:\n        return _(\"Unknown return code\");\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nconst char *\nhypervReturnCodeToString(int returnCode)\n{\n    switch (returnCode) {\n      case CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR:\n        return _(\"Completed with no error\");\n\n      case CIM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case CIM_RETURNCODE_UNKNOWN_ERROR:\n        return _(\"Unknown error\");\n\n      case CIM_RETURNCODE_CANNOT_COMPLETE_WITHIN_TIMEOUT_PERIOD:\n        return _(\"Cannot complete within timeout period\");\n\n      case CIM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case CIM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case CIM_RETURNCODE_IN_USE:\n        return _(\"In use\");\n\n      case CIM_RETURNCODE_TRANSITION_STARTED:\n        return _(\"Transition started\");\n\n      case CIM_RETURNCODE_INVALID_STATE_TRANSITION:\n        return _(\"Invalid state transition\");\n\n      case CIM_RETURNCODE_TIMEOUT_PARAMETER_NOT_SUPPORTED:\n        return _(\"Timeout parameter not supported\");\n\n      case CIM_RETURNCODE_BUSY:\n        return _(\"Busy\");\n\n      case MSVM_RETURNCODE_FAILED:\n        return _(\"Failed\");\n\n      case MSVM_RETURNCODE_ACCESS_DENIED:\n        return _(\"Access denied\");\n\n      case MSVM_RETURNCODE_NOT_SUPPORTED:\n        return _(\"Not supported\");\n\n      case MSVM_RETURNCODE_STATUS_IS_UNKNOWN:\n        return _(\"Status is unknown\");\n\n      case MSVM_RETURNCODE_TIMEOUT:\n        return _(\"Timeout\");\n\n      case MSVM_RETURNCODE_INVALID_PARAMETER:\n        return _(\"Invalid parameter\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_IN_USE:\n        return _(\"System is in use\");\n\n      case MSVM_RETURNCODE_INVALID_STATE_FOR_THIS_OPERATION:\n        return _(\"Invalid state for this operation\");\n\n      case MSVM_RETURNCODE_INCORRECT_DATA_TYPE:\n        return _(\"Incorrect data type\");\n\n      case MSVM_RETURNCODE_SYSTEM_IS_NOT_AVAILABLE:\n        return _(\"System is not available\");\n\n      case MSVM_RETURNCODE_OUT_OF_MEMORY:\n        return _(\"Out of memory\");\n\n      default:\n        return _(\"Unknown return code\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invocation of %s returned an error: %s (%d)\""
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_TIMEOUT",
            "_(\"Timeout waiting for %s invocation\")",
            "params->method"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unknown invocation state\")"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetMsvmConcreteJobList",
          "args": [
            "priv",
            "&query",
            "&job"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetMsvmConcreteJobList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "1240-1246",
          "snippet": "int\nhypervGetMsvmConcreteJobList(hypervPrivate *priv, virBufferPtr query,\n                             Msvm_ConcreteJob **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ConcreteJob_WmiInfo, query,\n                                 (hypervObject **)list);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervGetMsvmConcreteJobList(hypervPrivate *priv, virBufferPtr query,\n                             Msvm_ConcreteJob **list)\n{\n    return hypervGetWmiClassList(priv, Msvm_ConcreteJob_WmiInfo, query,\n                                 (hypervObject **)list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSQL",
          "args": [
            "&query",
            "\"where InstanceID = \\\"%s\\\"\"",
            "instanceID"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSQL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "469-475",
          "snippet": "void\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSQL(virBufferPtr buf,\n                   const char *format,\n                   const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"'\\\"\\\\\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&query",
            "MSVM_CONCRETEJOB_WQL_SELECT"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get instance ID for %s invocation\")",
            "params->method"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_xpath_value",
          "args": [
            "response",
            "jobcode_instance_xpath"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "returnValue",
            "NULL",
            "10",
            "&returnCode"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get return value for %s invocation\")",
            "params->method"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_xpath_value",
          "args": [
            "response",
            "returnValue_xpath"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_action_invoke",
          "args": [
            "priv->client",
            "params->resourceUri",
            "options",
            "params->method",
            "paramsDocRoot"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_add_selectors_from_str",
          "args": [
            "options",
            "params->selector"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not init options\")"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_init",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unknown parameter type\")"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervSerializeEmbeddedParam",
          "args": [
            "p",
            "params->resourceUri",
            "&methodNode"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "hypervSerializeEmbeddedParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "607-752",
          "snippet": "static int\nhypervSerializeEmbeddedParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeInstance = NULL,\n               xmlNodeProperty = NULL,\n               xmlNodeParam = NULL,\n               xmlNodeArray = NULL;\n    WsXmlDocH xmlDocTemp = NULL,\n              xmlDocCdata = NULL;\n    char *cdataContent = NULL;\n    xmlNodePtr xmlNodeCdata = NULL;\n    hypervWmiClassInfoPtr classInfo = p->embedded.info;\n    virHashKeyValuePairPtr items = NULL;\n    hypervCimTypePtr property = NULL;\n    ssize_t numKeys = -1;\n    int len = 0, i = 0;\n\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri, p->embedded.name,\n                    NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not add child node %s\"),\n                p->embedded.name);\n        goto cleanup;\n    }\n\n    /* create the temp xml doc */\n\n    /* start with the INSTANCE node */\n    if (!(xmlDocTemp = ws_xml_create_doc(NULL, \"INSTANCE\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create temporary xml doc\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeInstance = xml_parser_get_root(xmlDocTemp))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get temp xml doc root\"));\n        goto cleanup;\n    }\n\n    /* add CLASSNAME node to INSTANCE node */\n    if (!(ws_xml_add_node_attr(xmlNodeInstance, NULL, \"CLASSNAME\",\n                classInfo->name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add attribute to node\"));\n        goto cleanup;\n    }\n\n    /* retrieve parameters out of hash table */\n    numKeys = virHashSize(p->embedded.table);\n    items = virHashGetItems(p->embedded.table, NULL);\n    if (!items) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not read embedded param hash table\"));\n        goto cleanup;\n    }\n\n    /* Add the parameters */\n    for (i = 0; i < numKeys; i++) {\n        const char *name = items[i].key;\n        const char *value = items[i].value;\n\n        if (value != NULL) {\n            if (hypervGetCimTypeInfo(classInfo->propertyInfo, name,\n                        &property) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not read type information\"));\n                goto cleanup;\n            }\n\n            if (!(xmlNodeProperty = ws_xml_add_child(xmlNodeInstance, NULL,\n                            property->isArray ? \"PROPERTY.ARRAY\" : \"PROPERTY\",\n                            NULL))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"NAME\", name))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"TYPE\", property->type))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            /* If this attribute is an array, add VALUE.ARRAY node */\n            if (property->isArray) {\n                if (!(xmlNodeArray = ws_xml_add_child(xmlNodeProperty, NULL,\n                                \"VALUE.ARRAY\", NULL))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                            _(\"Could not add child to XML node\"));\n                    goto cleanup;\n                }\n            }\n\n            /* add the child */\n            if (!(ws_xml_add_child(property->isArray ? xmlNodeArray : xmlNodeProperty,\n                        NULL, \"VALUE\", value))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            xmlNodeArray = NULL;\n            xmlNodeProperty = NULL;\n        }\n    }\n\n    /* create CDATA node */\n    ws_xml_dump_memory_node_tree(xmlNodeInstance, &cdataContent, &len);\n\n    if (!(xmlNodeCdata = xmlNewCDataBlock((xmlDocPtr) xmlDocCdata,\n                    (xmlChar *)cdataContent, len))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create CDATA element\"));\n        goto cleanup;\n    }\n\n    /*\n     * Add CDATA node to the doc root\n     *\n     * FIXME: there is no openwsman wrapper for xmlNewCDataBlock, so instead\n     * silence clang alignment warnings by casting to a void pointer first\n     */\n    if (!(xmlAddChild((xmlNodePtr)(void *)xmlNodeParam, xmlNodeCdata))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add CDATA to doc root\"));\n        goto cleanup;\n    }\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    VIR_FREE(items);\n    ws_xml_destroy_doc(xmlDocCdata);\n    ws_xml_destroy_doc(xmlDocTemp);\n    ws_xml_free_memory(cdataContent);\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervSerializeEmbeddedParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeInstance = NULL,\n               xmlNodeProperty = NULL,\n               xmlNodeParam = NULL,\n               xmlNodeArray = NULL;\n    WsXmlDocH xmlDocTemp = NULL,\n              xmlDocCdata = NULL;\n    char *cdataContent = NULL;\n    xmlNodePtr xmlNodeCdata = NULL;\n    hypervWmiClassInfoPtr classInfo = p->embedded.info;\n    virHashKeyValuePairPtr items = NULL;\n    hypervCimTypePtr property = NULL;\n    ssize_t numKeys = -1;\n    int len = 0, i = 0;\n\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri, p->embedded.name,\n                    NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not add child node %s\"),\n                p->embedded.name);\n        goto cleanup;\n    }\n\n    /* create the temp xml doc */\n\n    /* start with the INSTANCE node */\n    if (!(xmlDocTemp = ws_xml_create_doc(NULL, \"INSTANCE\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create temporary xml doc\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeInstance = xml_parser_get_root(xmlDocTemp))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get temp xml doc root\"));\n        goto cleanup;\n    }\n\n    /* add CLASSNAME node to INSTANCE node */\n    if (!(ws_xml_add_node_attr(xmlNodeInstance, NULL, \"CLASSNAME\",\n                classInfo->name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add attribute to node\"));\n        goto cleanup;\n    }\n\n    /* retrieve parameters out of hash table */\n    numKeys = virHashSize(p->embedded.table);\n    items = virHashGetItems(p->embedded.table, NULL);\n    if (!items) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not read embedded param hash table\"));\n        goto cleanup;\n    }\n\n    /* Add the parameters */\n    for (i = 0; i < numKeys; i++) {\n        const char *name = items[i].key;\n        const char *value = items[i].value;\n\n        if (value != NULL) {\n            if (hypervGetCimTypeInfo(classInfo->propertyInfo, name,\n                        &property) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not read type information\"));\n                goto cleanup;\n            }\n\n            if (!(xmlNodeProperty = ws_xml_add_child(xmlNodeInstance, NULL,\n                            property->isArray ? \"PROPERTY.ARRAY\" : \"PROPERTY\",\n                            NULL))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"NAME\", name))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"TYPE\", property->type))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            /* If this attribute is an array, add VALUE.ARRAY node */\n            if (property->isArray) {\n                if (!(xmlNodeArray = ws_xml_add_child(xmlNodeProperty, NULL,\n                                \"VALUE.ARRAY\", NULL))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                            _(\"Could not add child to XML node\"));\n                    goto cleanup;\n                }\n            }\n\n            /* add the child */\n            if (!(ws_xml_add_child(property->isArray ? xmlNodeArray : xmlNodeProperty,\n                        NULL, \"VALUE\", value))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            xmlNodeArray = NULL;\n            xmlNodeProperty = NULL;\n        }\n    }\n\n    /* create CDATA node */\n    ws_xml_dump_memory_node_tree(xmlNodeInstance, &cdataContent, &len);\n\n    if (!(xmlNodeCdata = xmlNewCDataBlock((xmlDocPtr) xmlDocCdata,\n                    (xmlChar *)cdataContent, len))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create CDATA element\"));\n        goto cleanup;\n    }\n\n    /*\n     * Add CDATA node to the doc root\n     *\n     * FIXME: there is no openwsman wrapper for xmlNewCDataBlock, so instead\n     * silence clang alignment warnings by casting to a void pointer first\n     */\n    if (!(xmlAddChild((xmlNodePtr)(void *)xmlNodeParam, xmlNodeCdata))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add CDATA to doc root\"));\n        goto cleanup;\n    }\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    VIR_FREE(items);\n    ws_xml_destroy_doc(xmlDocCdata);\n    ws_xml_destroy_doc(xmlDocTemp);\n    ws_xml_free_memory(cdataContent);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervSerializeEprParam",
          "args": [
            "p",
            "priv",
            "params->resourceUri",
            "&methodNode"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "hypervSerializeEprParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "484-605",
          "snippet": "static int\nhypervSerializeEprParam(hypervParamPtr p, hypervPrivate *priv,\n        const char *resourceUri, WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeParam = NULL,\n               xmlNodeTemp = NULL,\n               xmlNodeAddr = NULL,\n               xmlNodeRef = NULL;\n    WsXmlDocH xmlDocResponse = NULL;\n    WsXmlNsH ns = NULL;\n    client_opt_t *options = NULL;\n    filter_t *filter = NULL;\n    char *enumContext = NULL;\n    char *query_string = NULL;\n\n    /* init and set up options */\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_set_action_option(options, FLAG_ENUMERATION_ENUM_EPR);\n\n    query_string = virBufferContentAndReset(p->epr.query);\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n    if (!filter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create WQL filter\"));\n        goto cleanup;\n    }\n\n    /* enumerate based on the filter from this query */\n    xmlDocResponse = wsmc_action_enumerate(priv->client, p->epr.info->rootUri,\n            options, filter);\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"enumeration\") < 0)\n        goto cleanup;\n\n    /* Get context */\n    enumContext = wsmc_get_enum_context(xmlDocResponse);\n    ws_xml_destroy_doc(xmlDocResponse);\n\n    /* Pull using filter and enum context */\n    xmlDocResponse = wsmc_action_pull(priv->client, resourceUri, options,\n            filter, enumContext);\n\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"pull\") < 0)\n        goto cleanup;\n\n    /* drill down and extract EPR node children */\n    if (!(xmlNodeTemp = ws_xml_get_soap_body(xmlDocResponse))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get SOAP body\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION,\n            WSENUM_PULL_RESP))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION, WSENUM_ITEMS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING, WSA_EPR))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeAddr = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n                    WSA_ADDRESS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR address\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeRef = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n            WSA_REFERENCE_PARAMETERS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not lookup EPR item reference parameters\"));\n        goto cleanup;\n    }\n\n    /* now build a new xml doc with the EPR node children */\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n                    p->epr.name, NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add child node to methodNode\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.xmlsoap.org/ws/2004/08/addressing\", \"a\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\", \"w\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set wsman namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeAddr);\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeRef);\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n    if (filter != NULL)\n        filter_destroy(filter);\n    ws_xml_destroy_doc(xmlDocResponse);\n    VIR_FREE(enumContext);\n    VIR_FREE(query_string);\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervSerializeEprParam(hypervParamPtr p, hypervPrivate *priv,\n        const char *resourceUri, WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeParam = NULL,\n               xmlNodeTemp = NULL,\n               xmlNodeAddr = NULL,\n               xmlNodeRef = NULL;\n    WsXmlDocH xmlDocResponse = NULL;\n    WsXmlNsH ns = NULL;\n    client_opt_t *options = NULL;\n    filter_t *filter = NULL;\n    char *enumContext = NULL;\n    char *query_string = NULL;\n\n    /* init and set up options */\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_set_action_option(options, FLAG_ENUMERATION_ENUM_EPR);\n\n    query_string = virBufferContentAndReset(p->epr.query);\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n    if (!filter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create WQL filter\"));\n        goto cleanup;\n    }\n\n    /* enumerate based on the filter from this query */\n    xmlDocResponse = wsmc_action_enumerate(priv->client, p->epr.info->rootUri,\n            options, filter);\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"enumeration\") < 0)\n        goto cleanup;\n\n    /* Get context */\n    enumContext = wsmc_get_enum_context(xmlDocResponse);\n    ws_xml_destroy_doc(xmlDocResponse);\n\n    /* Pull using filter and enum context */\n    xmlDocResponse = wsmc_action_pull(priv->client, resourceUri, options,\n            filter, enumContext);\n\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"pull\") < 0)\n        goto cleanup;\n\n    /* drill down and extract EPR node children */\n    if (!(xmlNodeTemp = ws_xml_get_soap_body(xmlDocResponse))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get SOAP body\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION,\n            WSENUM_PULL_RESP))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION, WSENUM_ITEMS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING, WSA_EPR))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeAddr = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n                    WSA_ADDRESS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR address\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeRef = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n            WSA_REFERENCE_PARAMETERS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not lookup EPR item reference parameters\"));\n        goto cleanup;\n    }\n\n    /* now build a new xml doc with the EPR node children */\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n                    p->epr.name, NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add child node to methodNode\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.xmlsoap.org/ws/2004/08/addressing\", \"a\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\", \"w\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set wsman namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeAddr);\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeRef);\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n    if (filter != NULL)\n        filter_destroy(filter);\n    ws_xml_destroy_doc(xmlDocResponse);\n    VIR_FREE(enumContext);\n    VIR_FREE(query_string);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervSerializeSimpleParam",
          "args": [
            "p",
            "params->resourceUri",
            "&methodNode"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "hypervSerializeSimpleParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "467-482",
          "snippet": "static int\nhypervSerializeSimpleParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    WsXmlNodeH xmlNodeParam = NULL;\n\n    xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n            p->simple.name, p->simple.value);\n    if (xmlNodeParam == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create simple param\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervSerializeSimpleParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    WsXmlNodeH xmlNodeParam = NULL;\n\n    xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n            p->simple.name, p->simple.value);\n    if (xmlNodeParam == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create simple param\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get root of XML document\")"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parser_get_root",
          "args": [
            "paramsDocRoot"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create XML document\")"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervCreateInvokeXmlDoc",
          "args": [
            "params",
            "&paramsDocRoot"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCreateInvokeXmlDoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "430-465",
          "snippet": "static int\nhypervCreateInvokeXmlDoc(hypervInvokeParamsListPtr params, WsXmlDocH *docRoot)\n{\n    int result = -1;\n    char *method = NULL;\n    WsXmlNodeH xmlNodeMethod = NULL;\n\n    method = g_strdup_printf(\"%s_INPUT\", params->method);\n\n    *docRoot = ws_xml_create_doc(NULL, method);\n    if (*docRoot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not instantiate XML document\"));\n        goto cleanup;\n    }\n\n    xmlNodeMethod = xml_parser_get_root(*docRoot);\n    if (xmlNodeMethod == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root node of XML document\"));\n        goto cleanup;\n    }\n\n    /* add resource URI as namespace */\n    ws_xml_set_ns(xmlNodeMethod, params->resourceUri, \"p\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0 && *docRoot != NULL) {\n        ws_xml_destroy_doc(*docRoot);\n        *docRoot = NULL;\n    }\n    VIR_FREE(method);\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervCreateInvokeXmlDoc(hypervInvokeParamsListPtr params, WsXmlDocH *docRoot)\n{\n    int result = -1;\n    char *method = NULL;\n    WsXmlNodeH xmlNodeMethod = NULL;\n\n    method = g_strdup_printf(\"%s_INPUT\", params->method);\n\n    *docRoot = ws_xml_create_doc(NULL, method);\n    if (*docRoot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not instantiate XML document\"));\n        goto cleanup;\n    }\n\n    xmlNodeMethod = xml_parser_get_root(*docRoot);\n    if (xmlNodeMethod == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root node of XML document\"));\n        goto cleanup;\n    }\n\n    /* add resource URI as namespace */\n    ws_xml_set_ns(xmlNodeMethod, params->resourceUri, \"p\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0 && *docRoot != NULL) {\n        ws_xml_destroy_doc(*docRoot);\n        *docRoot = NULL;\n    }\n    VIR_FREE(method);\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define HYPERV_JOB_TIMEOUT_MS 300000\n\nint\nhypervInvokeMethod(hypervPrivate *priv, hypervInvokeParamsListPtr params,\n        WsXmlDocH *res)\n{\n    int result = -1;\n    size_t i = 0;\n    int returnCode;\n    WsXmlDocH paramsDocRoot = NULL;\n    client_opt_t *options = NULL;\n    WsXmlDocH response = NULL;\n    WsXmlNodeH methodNode = NULL;\n    char *returnValue_xpath = NULL;\n    char *jobcode_instance_xpath = NULL;\n    char *returnValue = NULL;\n    char *instanceID = NULL;\n    bool completed = false;\n    virBuffer query = VIR_BUFFER_INITIALIZER;\n    Msvm_ConcreteJob *job = NULL;\n    int jobState = -1;\n    hypervParamPtr p = NULL;\n    int timeout = HYPERV_JOB_TIMEOUT_MS;\n\n    if (hypervCreateInvokeXmlDoc(params, &paramsDocRoot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create XML document\"));\n        goto cleanup;\n    }\n\n    methodNode = xml_parser_get_root(paramsDocRoot);\n    if (!methodNode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root of XML document\"));\n        goto cleanup;\n    }\n\n    /* Serialize parameters */\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                if (hypervSerializeSimpleParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EPR_PARAM:\n                if (hypervSerializeEprParam(p, priv, params->resourceUri,\n                                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                if (hypervSerializeEmbeddedParam(p, params->resourceUri,\n                            &methodNode) < 0)\n                    goto cleanup;\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Unknown parameter type\"));\n                goto cleanup;\n        }\n    }\n\n    /* Invoke the method and get the response */\n\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_add_selectors_from_str(options, params->selector);\n\n    /* do the invoke */\n    response = wsmc_action_invoke(priv->client, params->resourceUri, options,\n            params->method, paramsDocRoot);\n\n    /* check return code of invocation */\n    returnValue_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:ReturnValue\",\n                                        params->method);\n\n    returnValue = ws_xml_get_xpath_value(response, returnValue_xpath);\n    if (!returnValue) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get return value for %s invocation\"),\n                       params->method);\n        goto cleanup;\n    }\n\n    if (virStrToLong_i(returnValue, NULL, 10, &returnCode) < 0)\n        goto cleanup;\n\n    if (returnCode == CIM_RETURNCODE_TRANSITION_STARTED) {\n        jobcode_instance_xpath = g_strdup_printf(\"/s:Envelope/s:Body/p:%s_OUTPUT/p:Job/a:ReferenceParameters/\"\n                                                 \"w:SelectorSet/w:Selector[@Name='InstanceID']\",\n                                                 params->method);\n\n        instanceID = ws_xml_get_xpath_value(response, jobcode_instance_xpath);\n        if (!instanceID) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get instance ID for %s invocation\"),\n                           params->method);\n            goto cleanup;\n        }\n\n        /*\n         * Poll Hyper-V about the job until either the job completes or fails,\n         * or 5 minutes have elapsed.\n         *\n         * Windows has its own timeout on running WMI method calls (it calls\n         * these \"jobs\"), by default set to 1 minute. The administrator can\n         * change this to whatever they want, however, so we can't rely on it.\n         *\n         * Therefore, to avoid waiting in this loop for a very long-running job\n         * to complete, we instead bail after 5 minutes no matter what. NOTE that\n         * this does not mean that the remote job has terminated on the Windows\n         * side! That is up to Windows to control, we don't do anything about it.\n         */\n        while (!completed && timeout >= 0) {\n            virBufferAddLit(&query, MSVM_CONCRETEJOB_WQL_SELECT);\n            virBufferEscapeSQL(&query, \"where InstanceID = \\\"%s\\\"\", instanceID);\n\n            if (hypervGetMsvmConcreteJobList(priv, &query, &job) < 0\n                    || job == NULL)\n                goto cleanup;\n\n            jobState = job->data.common->JobState;\n            switch (jobState) {\n                case MSVM_CONCRETEJOB_JOBSTATE_NEW:\n                case MSVM_CONCRETEJOB_JOBSTATE_STARTING:\n                case MSVM_CONCRETEJOB_JOBSTATE_RUNNING:\n                case MSVM_CONCRETEJOB_JOBSTATE_SHUTTING_DOWN:\n                    hypervFreeObject(priv, (hypervObject *)job);\n                    job = NULL;\n                    g_usleep(100 * 1000); /* sleep 100 ms */\n                    timeout -= 100;\n                    continue;\n                case MSVM_CONCRETEJOB_JOBSTATE_COMPLETED:\n                    completed = true;\n                    break;\n                case MSVM_CONCRETEJOB_JOBSTATE_TERMINATED:\n                case MSVM_CONCRETEJOB_JOBSTATE_KILLED:\n                case MSVM_CONCRETEJOB_JOBSTATE_EXCEPTION:\n                case MSVM_CONCRETEJOB_JOBSTATE_SERVICE:\n                    goto cleanup;\n                default:\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unknown invocation state\"));\n                    goto cleanup;\n            }\n        }\n        if (!completed && timeout < 0) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                    _(\"Timeout waiting for %s invocation\"), params->method);\n            goto cleanup;\n        }\n    } else if (returnCode != CIM_RETURNCODE_COMPLETED_WITH_NO_ERROR) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invocation of %s returned an error: %s (%d)\"),\n                    params->method, hypervReturnCodeToString(returnCode),\n                    returnCode);\n        goto cleanup;\n    }\n\n    if (res)\n        *res = response;\n\n    result = 0;\n\n cleanup:\n    if (options)\n        wsmc_options_destroy(options);\n    if (response && (!res))\n        ws_xml_destroy_doc(response);\n    if (paramsDocRoot)\n        ws_xml_destroy_doc(paramsDocRoot);\n    VIR_FREE(returnValue_xpath);\n    VIR_FREE(jobcode_instance_xpath);\n    VIR_FREE(returnValue);\n    VIR_FREE(instanceID);\n    virBufferFreeAndReset(&query);\n    hypervFreeObject(priv, (hypervObject *)job);\n    hypervFreeInvokeParams(params);\n    return result;\n}"
  },
  {
    "function_name": "hypervSerializeEmbeddedParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "607-752",
    "snippet": "static int\nhypervSerializeEmbeddedParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeInstance = NULL,\n               xmlNodeProperty = NULL,\n               xmlNodeParam = NULL,\n               xmlNodeArray = NULL;\n    WsXmlDocH xmlDocTemp = NULL,\n              xmlDocCdata = NULL;\n    char *cdataContent = NULL;\n    xmlNodePtr xmlNodeCdata = NULL;\n    hypervWmiClassInfoPtr classInfo = p->embedded.info;\n    virHashKeyValuePairPtr items = NULL;\n    hypervCimTypePtr property = NULL;\n    ssize_t numKeys = -1;\n    int len = 0, i = 0;\n\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri, p->embedded.name,\n                    NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not add child node %s\"),\n                p->embedded.name);\n        goto cleanup;\n    }\n\n    /* create the temp xml doc */\n\n    /* start with the INSTANCE node */\n    if (!(xmlDocTemp = ws_xml_create_doc(NULL, \"INSTANCE\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create temporary xml doc\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeInstance = xml_parser_get_root(xmlDocTemp))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get temp xml doc root\"));\n        goto cleanup;\n    }\n\n    /* add CLASSNAME node to INSTANCE node */\n    if (!(ws_xml_add_node_attr(xmlNodeInstance, NULL, \"CLASSNAME\",\n                classInfo->name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add attribute to node\"));\n        goto cleanup;\n    }\n\n    /* retrieve parameters out of hash table */\n    numKeys = virHashSize(p->embedded.table);\n    items = virHashGetItems(p->embedded.table, NULL);\n    if (!items) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not read embedded param hash table\"));\n        goto cleanup;\n    }\n\n    /* Add the parameters */\n    for (i = 0; i < numKeys; i++) {\n        const char *name = items[i].key;\n        const char *value = items[i].value;\n\n        if (value != NULL) {\n            if (hypervGetCimTypeInfo(classInfo->propertyInfo, name,\n                        &property) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not read type information\"));\n                goto cleanup;\n            }\n\n            if (!(xmlNodeProperty = ws_xml_add_child(xmlNodeInstance, NULL,\n                            property->isArray ? \"PROPERTY.ARRAY\" : \"PROPERTY\",\n                            NULL))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"NAME\", name))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"TYPE\", property->type))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            /* If this attribute is an array, add VALUE.ARRAY node */\n            if (property->isArray) {\n                if (!(xmlNodeArray = ws_xml_add_child(xmlNodeProperty, NULL,\n                                \"VALUE.ARRAY\", NULL))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                            _(\"Could not add child to XML node\"));\n                    goto cleanup;\n                }\n            }\n\n            /* add the child */\n            if (!(ws_xml_add_child(property->isArray ? xmlNodeArray : xmlNodeProperty,\n                        NULL, \"VALUE\", value))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            xmlNodeArray = NULL;\n            xmlNodeProperty = NULL;\n        }\n    }\n\n    /* create CDATA node */\n    ws_xml_dump_memory_node_tree(xmlNodeInstance, &cdataContent, &len);\n\n    if (!(xmlNodeCdata = xmlNewCDataBlock((xmlDocPtr) xmlDocCdata,\n                    (xmlChar *)cdataContent, len))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create CDATA element\"));\n        goto cleanup;\n    }\n\n    /*\n     * Add CDATA node to the doc root\n     *\n     * FIXME: there is no openwsman wrapper for xmlNewCDataBlock, so instead\n     * silence clang alignment warnings by casting to a void pointer first\n     */\n    if (!(xmlAddChild((xmlNodePtr)(void *)xmlNodeParam, xmlNodeCdata))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add CDATA to doc root\"));\n        goto cleanup;\n    }\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    VIR_FREE(items);\n    ws_xml_destroy_doc(xmlDocCdata);\n    ws_xml_destroy_doc(xmlDocTemp);\n    ws_xml_free_memory(cdataContent);\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ws_xml_free_memory",
          "args": [
            "cdataContent"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "xmlDocTemp"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "xmlDocCdata"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "items"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add CDATA to doc root\")"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not add CDATA to doc root\""
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlAddChild",
          "args": [
            "(xmlNodePtr)(void *)xmlNodeParam",
            "xmlNodeCdata"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create CDATA element\")"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewCDataBlock",
          "args": [
            "(xmlDocPtr) xmlDocCdata",
            "(xmlChar *)cdataContent",
            "len"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_dump_memory_node_tree",
          "args": [
            "xmlNodeInstance",
            "&cdataContent",
            "&len"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add child to XML node\")"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_child",
          "args": [
            "property->isArray ? xmlNodeArray : xmlNodeProperty",
            "NULL",
            "\"VALUE\"",
            "value"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add child to XML node\")"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_child",
          "args": [
            "xmlNodeProperty",
            "NULL",
            "\"VALUE.ARRAY\"",
            "NULL"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add attribute to XML node\")"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_node_attr",
          "args": [
            "xmlNodeProperty",
            "NULL",
            "\"TYPE\"",
            "property->type"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add attribute to XML node\")"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_node_attr",
          "args": [
            "xmlNodeProperty",
            "NULL",
            "\"NAME\"",
            "name"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add child to XML node\")"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_child",
          "args": [
            "xmlNodeInstance",
            "NULL",
            "property->isArray ? \"PROPERTY.ARRAY\" : \"PROPERTY\"",
            "NULL"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not read type information\")"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetCimTypeInfo",
          "args": [
            "classInfo->propertyInfo",
            "name",
            "&property"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetCimTypeInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "413-427",
          "snippet": "static int\nhypervGetCimTypeInfo(hypervCimTypePtr typemap, const char *name,\n        hypervCimTypePtr *property)\n{\n    size_t i = 0;\n    while (typemap[i].name[0] != '\\0') {\n        if (STREQ(typemap[i].name, name)) {\n            *property = &typemap[i];\n            return 0;\n        }\n        i++;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetCimTypeInfo(hypervCimTypePtr typemap, const char *name,\n        hypervCimTypePtr *property)\n{\n    size_t i = 0;\n    while (typemap[i].name[0] != '\\0') {\n        if (STREQ(typemap[i].name, name)) {\n            *property = &typemap[i];\n            return 0;\n        }\n        i++;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not read embedded param hash table\")"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashGetItems",
          "args": [
            "p->embedded.table",
            "NULL"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "virHashGetItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "783-805",
          "snippet": "virHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSize",
          "args": [
            "p->embedded.table"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "547-553",
          "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add attribute to node\")"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_node_attr",
          "args": [
            "xmlNodeInstance",
            "NULL",
            "\"CLASSNAME\"",
            "classInfo->name"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get temp xml doc root\")"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parser_get_root",
          "args": [
            "xmlDocTemp"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create temporary xml doc\")"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_create_doc",
          "args": [
            "NULL",
            "\"INSTANCE\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not add child node %s\")",
            "p->embedded.name"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_child",
          "args": [
            "*methodNode",
            "resourceUri",
            "p->embedded.name",
            "NULL"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervSerializeEmbeddedParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeInstance = NULL,\n               xmlNodeProperty = NULL,\n               xmlNodeParam = NULL,\n               xmlNodeArray = NULL;\n    WsXmlDocH xmlDocTemp = NULL,\n              xmlDocCdata = NULL;\n    char *cdataContent = NULL;\n    xmlNodePtr xmlNodeCdata = NULL;\n    hypervWmiClassInfoPtr classInfo = p->embedded.info;\n    virHashKeyValuePairPtr items = NULL;\n    hypervCimTypePtr property = NULL;\n    ssize_t numKeys = -1;\n    int len = 0, i = 0;\n\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri, p->embedded.name,\n                    NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not add child node %s\"),\n                p->embedded.name);\n        goto cleanup;\n    }\n\n    /* create the temp xml doc */\n\n    /* start with the INSTANCE node */\n    if (!(xmlDocTemp = ws_xml_create_doc(NULL, \"INSTANCE\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create temporary xml doc\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeInstance = xml_parser_get_root(xmlDocTemp))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get temp xml doc root\"));\n        goto cleanup;\n    }\n\n    /* add CLASSNAME node to INSTANCE node */\n    if (!(ws_xml_add_node_attr(xmlNodeInstance, NULL, \"CLASSNAME\",\n                classInfo->name))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add attribute to node\"));\n        goto cleanup;\n    }\n\n    /* retrieve parameters out of hash table */\n    numKeys = virHashSize(p->embedded.table);\n    items = virHashGetItems(p->embedded.table, NULL);\n    if (!items) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not read embedded param hash table\"));\n        goto cleanup;\n    }\n\n    /* Add the parameters */\n    for (i = 0; i < numKeys; i++) {\n        const char *name = items[i].key;\n        const char *value = items[i].value;\n\n        if (value != NULL) {\n            if (hypervGetCimTypeInfo(classInfo->propertyInfo, name,\n                        &property) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not read type information\"));\n                goto cleanup;\n            }\n\n            if (!(xmlNodeProperty = ws_xml_add_child(xmlNodeInstance, NULL,\n                            property->isArray ? \"PROPERTY.ARRAY\" : \"PROPERTY\",\n                            NULL))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"NAME\", name))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            if (!(ws_xml_add_node_attr(xmlNodeProperty, NULL, \"TYPE\", property->type))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add attribute to XML node\"));\n                goto cleanup;\n            }\n\n            /* If this attribute is an array, add VALUE.ARRAY node */\n            if (property->isArray) {\n                if (!(xmlNodeArray = ws_xml_add_child(xmlNodeProperty, NULL,\n                                \"VALUE.ARRAY\", NULL))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                            _(\"Could not add child to XML node\"));\n                    goto cleanup;\n                }\n            }\n\n            /* add the child */\n            if (!(ws_xml_add_child(property->isArray ? xmlNodeArray : xmlNodeProperty,\n                        NULL, \"VALUE\", value))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Could not add child to XML node\"));\n                goto cleanup;\n            }\n\n            xmlNodeArray = NULL;\n            xmlNodeProperty = NULL;\n        }\n    }\n\n    /* create CDATA node */\n    ws_xml_dump_memory_node_tree(xmlNodeInstance, &cdataContent, &len);\n\n    if (!(xmlNodeCdata = xmlNewCDataBlock((xmlDocPtr) xmlDocCdata,\n                    (xmlChar *)cdataContent, len))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create CDATA element\"));\n        goto cleanup;\n    }\n\n    /*\n     * Add CDATA node to the doc root\n     *\n     * FIXME: there is no openwsman wrapper for xmlNewCDataBlock, so instead\n     * silence clang alignment warnings by casting to a void pointer first\n     */\n    if (!(xmlAddChild((xmlNodePtr)(void *)xmlNodeParam, xmlNodeCdata))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add CDATA to doc root\"));\n        goto cleanup;\n    }\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    VIR_FREE(items);\n    ws_xml_destroy_doc(xmlDocCdata);\n    ws_xml_destroy_doc(xmlDocTemp);\n    ws_xml_free_memory(cdataContent);\n    return result;\n}"
  },
  {
    "function_name": "hypervSerializeEprParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "484-605",
    "snippet": "static int\nhypervSerializeEprParam(hypervParamPtr p, hypervPrivate *priv,\n        const char *resourceUri, WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeParam = NULL,\n               xmlNodeTemp = NULL,\n               xmlNodeAddr = NULL,\n               xmlNodeRef = NULL;\n    WsXmlDocH xmlDocResponse = NULL;\n    WsXmlNsH ns = NULL;\n    client_opt_t *options = NULL;\n    filter_t *filter = NULL;\n    char *enumContext = NULL;\n    char *query_string = NULL;\n\n    /* init and set up options */\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_set_action_option(options, FLAG_ENUMERATION_ENUM_EPR);\n\n    query_string = virBufferContentAndReset(p->epr.query);\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n    if (!filter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create WQL filter\"));\n        goto cleanup;\n    }\n\n    /* enumerate based on the filter from this query */\n    xmlDocResponse = wsmc_action_enumerate(priv->client, p->epr.info->rootUri,\n            options, filter);\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"enumeration\") < 0)\n        goto cleanup;\n\n    /* Get context */\n    enumContext = wsmc_get_enum_context(xmlDocResponse);\n    ws_xml_destroy_doc(xmlDocResponse);\n\n    /* Pull using filter and enum context */\n    xmlDocResponse = wsmc_action_pull(priv->client, resourceUri, options,\n            filter, enumContext);\n\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"pull\") < 0)\n        goto cleanup;\n\n    /* drill down and extract EPR node children */\n    if (!(xmlNodeTemp = ws_xml_get_soap_body(xmlDocResponse))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get SOAP body\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION,\n            WSENUM_PULL_RESP))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION, WSENUM_ITEMS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING, WSA_EPR))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeAddr = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n                    WSA_ADDRESS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR address\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeRef = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n            WSA_REFERENCE_PARAMETERS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not lookup EPR item reference parameters\"));\n        goto cleanup;\n    }\n\n    /* now build a new xml doc with the EPR node children */\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n                    p->epr.name, NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add child node to methodNode\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.xmlsoap.org/ws/2004/08/addressing\", \"a\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\", \"w\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set wsman namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeAddr);\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeRef);\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n    if (filter != NULL)\n        filter_destroy(filter);\n    ws_xml_destroy_doc(xmlDocResponse);\n    VIR_FREE(enumContext);\n    VIR_FREE(query_string);\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "query_string"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "enumContext"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "xmlDocResponse"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_destroy",
          "args": [
            "filter"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_destroy",
          "args": [
            "options"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_duplicate_tree",
          "args": [
            "xmlNodeParam",
            "xmlNodeRef"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_duplicate_tree",
          "args": [
            "xmlNodeParam",
            "xmlNodeAddr"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not set wsman namespace address for xmlNodeParam\")"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not set wsman namespace address for xmlNodeParam\""
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ws_xml_ns_add",
          "args": [
            "xmlNodeParam",
            "\"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\"",
            "\"w\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not set namespace address for xmlNodeParam\")"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_ns_add",
          "args": [
            "xmlNodeParam",
            "\"http://schemas.xmlsoap.org/ws/2004/08/addressing\"",
            "\"a\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not add child node to methodNode\")"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_add_child",
          "args": [
            "*methodNode",
            "resourceUri",
            "p->epr.name",
            "NULL"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not lookup EPR item reference parameters\")"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "xmlNodeTemp",
            "0",
            "XML_NS_ADDRESSING",
            "WSA_REFERENCE_PARAMETERS"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get EPR address\")"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "xmlNodeTemp",
            "0",
            "XML_NS_ADDRESSING",
            "WSA_ADDRESS"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get EPR items\")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "xmlNodeTemp",
            "0",
            "XML_NS_ADDRESSING",
            "WSA_EPR"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get response items\")"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "xmlNodeTemp",
            "0",
            "XML_NS_ENUMERATION",
            "WSENUM_ITEMS"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get response\")"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_child",
          "args": [
            "xmlNodeTemp",
            "0",
            "XML_NS_ENUMERATION",
            "WSENUM_PULL_RESP"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get SOAP body\")"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_get_soap_body",
          "args": [
            "xmlDocResponse"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervVerifyResponse",
          "args": [
            "priv->client",
            "xmlDocResponse",
            "\"pull\""
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "hypervVerifyResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "97-149",
          "snippet": "int\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_action_pull",
          "args": [
            "priv->client",
            "resourceUri",
            "options",
            "filter",
            "enumContext"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "xmlDocResponse"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_enum_context",
          "args": [
            "xmlDocResponse"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_action_enumerate",
          "args": [
            "priv->client",
            "p->epr.info->rootUri",
            "options",
            "filter"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create WQL filter\")"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_create_simple",
          "args": [
            "WSM_WQL_FILTER_DIALECT",
            "query_string"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "p->epr.query"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_set_action_option",
          "args": [
            "options",
            "FLAG_ENUMERATION_ENUM_EPR"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not init options\")"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_options_init",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervSerializeEprParam(hypervParamPtr p, hypervPrivate *priv,\n        const char *resourceUri, WsXmlNodeH *methodNode)\n{\n    int result = -1;\n    WsXmlNodeH xmlNodeParam = NULL,\n               xmlNodeTemp = NULL,\n               xmlNodeAddr = NULL,\n               xmlNodeRef = NULL;\n    WsXmlDocH xmlDocResponse = NULL;\n    WsXmlNsH ns = NULL;\n    client_opt_t *options = NULL;\n    filter_t *filter = NULL;\n    char *enumContext = NULL;\n    char *query_string = NULL;\n\n    /* init and set up options */\n    options = wsmc_options_init();\n    if (!options) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not init options\"));\n        goto cleanup;\n    }\n    wsmc_set_action_option(options, FLAG_ENUMERATION_ENUM_EPR);\n\n    query_string = virBufferContentAndReset(p->epr.query);\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n    if (!filter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not create WQL filter\"));\n        goto cleanup;\n    }\n\n    /* enumerate based on the filter from this query */\n    xmlDocResponse = wsmc_action_enumerate(priv->client, p->epr.info->rootUri,\n            options, filter);\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"enumeration\") < 0)\n        goto cleanup;\n\n    /* Get context */\n    enumContext = wsmc_get_enum_context(xmlDocResponse);\n    ws_xml_destroy_doc(xmlDocResponse);\n\n    /* Pull using filter and enum context */\n    xmlDocResponse = wsmc_action_pull(priv->client, resourceUri, options,\n            filter, enumContext);\n\n    if (hypervVerifyResponse(priv->client, xmlDocResponse, \"pull\") < 0)\n        goto cleanup;\n\n    /* drill down and extract EPR node children */\n    if (!(xmlNodeTemp = ws_xml_get_soap_body(xmlDocResponse))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get SOAP body\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION,\n            WSENUM_PULL_RESP))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ENUMERATION, WSENUM_ITEMS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get response items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeTemp = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING, WSA_EPR))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR items\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeAddr = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n                    WSA_ADDRESS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Could not get EPR address\"));\n        goto cleanup;\n    }\n\n    if (!(xmlNodeRef = ws_xml_get_child(xmlNodeTemp, 0, XML_NS_ADDRESSING,\n            WSA_REFERENCE_PARAMETERS))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not lookup EPR item reference parameters\"));\n        goto cleanup;\n    }\n\n    /* now build a new xml doc with the EPR node children */\n    if (!(xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n                    p->epr.name, NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not add child node to methodNode\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.xmlsoap.org/ws/2004/08/addressing\", \"a\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    if (!(ns = ws_xml_ns_add(xmlNodeParam,\n                    \"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\", \"w\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not set wsman namespace address for xmlNodeParam\"));\n        goto cleanup;\n    }\n\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeAddr);\n    ws_xml_duplicate_tree(xmlNodeParam, xmlNodeRef);\n\n    /* we did it! */\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n    if (filter != NULL)\n        filter_destroy(filter);\n    ws_xml_destroy_doc(xmlDocResponse);\n    VIR_FREE(enumContext);\n    VIR_FREE(query_string);\n    return result;\n}"
  },
  {
    "function_name": "hypervSerializeSimpleParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "467-482",
    "snippet": "static int\nhypervSerializeSimpleParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    WsXmlNodeH xmlNodeParam = NULL;\n\n    xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n            p->simple.name, p->simple.value);\n    if (xmlNodeParam == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create simple param\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not create simple param\")"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not create simple param\""
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ws_xml_add_child",
          "args": [
            "*methodNode",
            "resourceUri",
            "p->simple.name",
            "p->simple.value"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervSerializeSimpleParam(hypervParamPtr p, const char *resourceUri,\n        WsXmlNodeH *methodNode)\n{\n    WsXmlNodeH xmlNodeParam = NULL;\n\n    xmlNodeParam = ws_xml_add_child(*methodNode, resourceUri,\n            p->simple.name, p->simple.value);\n    if (xmlNodeParam == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not create simple param\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervCreateInvokeXmlDoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "430-465",
    "snippet": "static int\nhypervCreateInvokeXmlDoc(hypervInvokeParamsListPtr params, WsXmlDocH *docRoot)\n{\n    int result = -1;\n    char *method = NULL;\n    WsXmlNodeH xmlNodeMethod = NULL;\n\n    method = g_strdup_printf(\"%s_INPUT\", params->method);\n\n    *docRoot = ws_xml_create_doc(NULL, method);\n    if (*docRoot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not instantiate XML document\"));\n        goto cleanup;\n    }\n\n    xmlNodeMethod = xml_parser_get_root(*docRoot);\n    if (xmlNodeMethod == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root node of XML document\"));\n        goto cleanup;\n    }\n\n    /* add resource URI as namespace */\n    ws_xml_set_ns(xmlNodeMethod, params->resourceUri, \"p\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0 && *docRoot != NULL) {\n        ws_xml_destroy_doc(*docRoot);\n        *docRoot = NULL;\n    }\n    VIR_FREE(method);\n    return result;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "method"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_destroy_doc",
          "args": [
            "*docRoot"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_set_ns",
          "args": [
            "xmlNodeMethod",
            "params->resourceUri",
            "\"p\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get root node of XML document\")"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get root node of XML document\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_parser_get_root",
          "args": [
            "*docRoot"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not instantiate XML document\")"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ws_xml_create_doc",
          "args": [
            "NULL",
            "method"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervCreateInvokeXmlDoc(hypervInvokeParamsListPtr params, WsXmlDocH *docRoot)\n{\n    int result = -1;\n    char *method = NULL;\n    WsXmlNodeH xmlNodeMethod = NULL;\n\n    method = g_strdup_printf(\"%s_INPUT\", params->method);\n\n    *docRoot = ws_xml_create_doc(NULL, method);\n    if (*docRoot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not instantiate XML document\"));\n        goto cleanup;\n    }\n\n    xmlNodeMethod = xml_parser_get_root(*docRoot);\n    if (xmlNodeMethod == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                _(\"Could not get root node of XML document\"));\n        goto cleanup;\n    }\n\n    /* add resource URI as namespace */\n    ws_xml_set_ns(xmlNodeMethod, params->resourceUri, \"p\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0 && *docRoot != NULL) {\n        ws_xml_destroy_doc(*docRoot);\n        *docRoot = NULL;\n    }\n    VIR_FREE(method);\n    return result;\n}"
  },
  {
    "function_name": "hypervGetCimTypeInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "413-427",
    "snippet": "static int\nhypervGetCimTypeInfo(hypervCimTypePtr typemap, const char *name,\n        hypervCimTypePtr *property)\n{\n    size_t i = 0;\n    while (typemap[i].name[0] != '\\0') {\n        if (STREQ(typemap[i].name, name)) {\n            *property = &typemap[i];\n            return 0;\n        }\n        i++;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "typemap[i].name",
            "name"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetCimTypeInfo(hypervCimTypePtr typemap, const char *name,\n        hypervCimTypePtr *property)\n{\n    size_t i = 0;\n    while (typemap[i].name[0] != '\\0') {\n        if (STREQ(typemap[i].name, name)) {\n            *property = &typemap[i];\n            return 0;\n        }\n        i++;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "hypervFreeEmbeddedParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "403-407",
    "snippet": "void\nhypervFreeEmbeddedParam(virHashTablePtr p)\n{\n    virHashFree(p);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "p"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeEmbeddedParam(virHashTablePtr p)\n{\n    virHashFree(p);\n}"
  },
  {
    "function_name": "hypervAddEmbeddedParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "373-395",
    "snippet": "int\nhypervAddEmbeddedParam(hypervInvokeParamsListPtr params, hypervPrivate *priv,\n        const char *name, virHashTablePtr table, hypervWmiClassInfoListPtr info)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EMBEDDED_PARAM;\n    p->embedded.name = name;\n    p->embedded.table = table;\n    p->embedded.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervGetWmiClassInfo",
          "args": [
            "priv",
            "info",
            "&classInfo"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "49-83",
          "snippet": "static int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervCheckParams",
          "args": [
            "params"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCheckParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "233-242",
          "snippet": "static inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervAddEmbeddedParam(hypervInvokeParamsListPtr params, hypervPrivate *priv,\n        const char *name, virHashTablePtr table, hypervWmiClassInfoListPtr info)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EMBEDDED_PARAM;\n    p->embedded.name = name;\n    p->embedded.table = table;\n    p->embedded.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervSetEmbeddedProperty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "356-360",
    "snippet": "int\nhypervSetEmbeddedProperty(virHashTablePtr table, const char *name, char *value)\n{\n    return virHashUpdateEntry(table, name, value);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashUpdateEntry",
          "args": [
            "table",
            "name",
            "value"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virHashUpdateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "422-427",
          "snippet": "int\nvirHashUpdateEntry(virHashTablePtr table, const void *name,\n                   void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, true);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashUpdateEntry(virHashTablePtr table, const void *name,\n                   void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervSetEmbeddedProperty(virHashTablePtr table, const char *name, char *value)\n{\n    return virHashUpdateEntry(table, name, value);\n}"
  },
  {
    "function_name": "hypervCreateEmbeddedParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "318-354",
    "snippet": "virHashTablePtr\nhypervCreateEmbeddedParam(hypervPrivate *priv, hypervWmiClassInfoListPtr info)\n{\n    size_t i;\n    int count = 0;\n    virHashTablePtr table = NULL;\n    XmlSerializerInfo *typeinfo = NULL;\n    XmlSerializerInfo *item = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        goto error;\n\n    typeinfo = classInfo->serializerInfo;\n\n    /* loop through the items to find out how many fields there are */\n    for (i = 0; typeinfo[i].name != NULL; i++) {}\n    count = i;\n\n    table = virHashCreate(count, NULL);\n    if (table == NULL)\n        goto error;\n\n    for (i = 0; typeinfo[i].name != NULL; i++) {\n        item = &typeinfo[i];\n\n        if (virHashAddEntry(table, item->name, NULL) < 0)\n            goto error;\n    }\n\n    return table;\n\n error:\n    virHashFree(table);\n    return NULL;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "table"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "table",
            "item->name",
            "NULL"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "count",
            "NULL"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetWmiClassInfo",
          "args": [
            "priv",
            "info",
            "&classInfo"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "49-83",
          "snippet": "static int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvirHashTablePtr\nhypervCreateEmbeddedParam(hypervPrivate *priv, hypervWmiClassInfoListPtr info)\n{\n    size_t i;\n    int count = 0;\n    virHashTablePtr table = NULL;\n    XmlSerializerInfo *typeinfo = NULL;\n    XmlSerializerInfo *item = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    /* Get the typeinfo out of the class info list */\n    if (hypervGetWmiClassInfo(priv, info, &classInfo) < 0)\n        goto error;\n\n    typeinfo = classInfo->serializerInfo;\n\n    /* loop through the items to find out how many fields there are */\n    for (i = 0; typeinfo[i].name != NULL; i++) {}\n    count = i;\n\n    table = virHashCreate(count, NULL);\n    if (table == NULL)\n        goto error;\n\n    for (i = 0; typeinfo[i].name != NULL; i++) {\n        item = &typeinfo[i];\n\n        if (virHashAddEntry(table, item->name, NULL) < 0)\n            goto error;\n    }\n\n    return table;\n\n error:\n    virHashFree(table);\n    return NULL;\n}"
  },
  {
    "function_name": "hypervAddEprParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "285-305",
    "snippet": "int\nhypervAddEprParam(hypervInvokeParamsListPtr params, const char *name,\n        hypervPrivate *priv, virBufferPtr query,\n        hypervWmiClassInfoListPtr eprInfo)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervGetWmiClassInfo(priv, eprInfo, &classInfo) < 0 ||\n            hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EPR_PARAM;\n    p->epr.name = name;\n    p->epr.query = query;\n    p->epr.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervCheckParams",
          "args": [
            "params"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCheckParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "233-242",
          "snippet": "static inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervGetWmiClassInfo",
          "args": [
            "priv",
            "eprInfo",
            "&classInfo"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "49-83",
          "snippet": "static int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervAddEprParam(hypervInvokeParamsListPtr params, const char *name,\n        hypervPrivate *priv, virBufferPtr query,\n        hypervWmiClassInfoListPtr eprInfo)\n{\n    hypervParamPtr p = NULL;\n    hypervWmiClassInfoPtr classInfo = NULL;\n\n    if (hypervGetWmiClassInfo(priv, eprInfo, &classInfo) < 0 ||\n            hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_EPR_PARAM;\n    p->epr.name = name;\n    p->epr.query = query;\n    p->epr.info = classInfo;\n    params->nbParams++;\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervAddSimpleParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "255-273",
    "snippet": "int\nhypervAddSimpleParam(hypervInvokeParamsListPtr params, const char *name,\n        const char *value)\n{\n    hypervParamPtr p = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_SIMPLE_PARAM;\n\n    p->simple.name = name;\n    p->simple.value = value;\n\n    params->nbParams++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervCheckParams",
          "args": [
            "params"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "hypervCheckParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "233-242",
          "snippet": "static inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervAddSimpleParam(hypervInvokeParamsListPtr params, const char *name,\n        const char *value)\n{\n    hypervParamPtr p = NULL;\n\n    if (hypervCheckParams(params) < 0)\n        return -1;\n\n    p = &params->params[params->nbParams];\n    p->type = HYPERV_SIMPLE_PARAM;\n\n    p->simple.name = name;\n    p->simple.value = value;\n\n    params->nbParams++;\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervCheckParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "233-242",
    "snippet": "static inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "params->params",
            "params->nbAvailParams",
            "5"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic inline int\nhypervCheckParams(hypervInvokeParamsListPtr params)\n{\n    if (params->nbParams + 1 > params->nbAvailParams) {\n        if (VIR_EXPAND_N(params->params, params->nbAvailParams, 5) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervFreeInvokeParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "202-231",
    "snippet": "void\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "params"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_N",
          "args": [
            "params->params",
            "params->nbAvailParams"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid parameter type passed to free\")"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid parameter type passed to free\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervFreeEmbeddedParam",
          "args": [
            "p->embedded.table"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "hypervFreeEmbeddedParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "403-407",
          "snippet": "void\nhypervFreeEmbeddedParam(virHashTablePtr p)\n{\n    virHashFree(p);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeEmbeddedParam(virHashTablePtr p)\n{\n    virHashFree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "p->epr.query"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nvoid\nhypervFreeInvokeParams(hypervInvokeParamsListPtr params)\n{\n    hypervParamPtr p = NULL;\n    size_t i = 0;\n\n    if (params == NULL)\n        return;\n\n    for (i = 0; i < params->nbParams; i++) {\n        p = &(params->params[i]);\n\n        switch (p->type) {\n            case HYPERV_SIMPLE_PARAM:\n                break;\n            case HYPERV_EPR_PARAM:\n                virBufferFreeAndReset(p->epr.query);\n                break;\n            case HYPERV_EMBEDDED_PARAM:\n                hypervFreeEmbeddedParam(p->embedded.table);\n                break;\n            default:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                        _(\"Invalid parameter type passed to free\"));\n        }\n    }\n\n    VIR_DISPOSE_N(params->params, params->nbAvailParams);\n    VIR_FREE(params);\n}"
  },
  {
    "function_name": "hypervCreateInvokeParamsList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "168-195",
    "snippet": "hypervInvokeParamsListPtr\nhypervCreateInvokeParamsList(hypervPrivate *priv, const char *method,\n        const char *selector, hypervWmiClassInfoListPtr obj)\n{\n    hypervInvokeParamsListPtr params = NULL;\n    hypervWmiClassInfoPtr info = NULL;\n\n    if (hypervGetWmiClassInfo(priv, obj, &info) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(params) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(params->params,\n                HYPERV_DEFAULT_PARAM_COUNT) < 0) {\n        VIR_FREE(params);\n        return NULL;\n    }\n\n    params->method = method;\n    params->ns = info->rootUri;\n    params->resourceUri = info->resourceUri;\n    params->selector = selector;\n    params->nbParams = 0;\n    params->nbAvailParams = HYPERV_DEFAULT_PARAM_COUNT;\n\n    return params;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "params"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "params->params",
            "HYPERV_DEFAULT_PARAM_COUNT"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "params"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervGetWmiClassInfo",
          "args": [
            "priv",
            "obj",
            "&info"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "hypervGetWmiClassInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "49-83",
          "snippet": "static int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nhypervInvokeParamsListPtr\nhypervCreateInvokeParamsList(hypervPrivate *priv, const char *method,\n        const char *selector, hypervWmiClassInfoListPtr obj)\n{\n    hypervInvokeParamsListPtr params = NULL;\n    hypervWmiClassInfoPtr info = NULL;\n\n    if (hypervGetWmiClassInfo(priv, obj, &info) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(params) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(params->params,\n                HYPERV_DEFAULT_PARAM_COUNT) < 0) {\n        VIR_FREE(params);\n        return NULL;\n    }\n\n    params->method = method;\n    params->ns = info->rootUri;\n    params->resourceUri = info->resourceUri;\n    params->selector = selector;\n    params->nbParams = 0;\n    params->nbAvailParams = HYPERV_DEFAULT_PARAM_COUNT;\n\n    return params;\n}"
  },
  {
    "function_name": "hypervVerifyResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "97-149",
    "snippet": "int\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmc_fault_destroy",
          "args": [
            "fault"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\")",
            "detail",
            "NULLSTR(fault->code)",
            "NULLSTR(fault->subcode)",
            "NULLSTR(fault->reason)",
            "NULLSTR(fault->fault_detail)"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fault->fault_detail"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fault->reason"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fault->subcode"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fault->code"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmc_get_fault_data",
          "args": [
            "response",
            "fault"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_fault_new",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_check_for_fault",
          "args": [
            "response"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Empty response during %s\")",
            "detail"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected HTTP response during %s: %d\")",
            "detail",
            "responseCode"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Transport error during %s: %s (%d)\")",
            "detail",
            "wsman_transport_get_last_error_string(lastError)",
            "lastError"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsman_transport_get_last_error_string",
          "args": [
            "lastError"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_response_code",
          "args": [
            "client"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmc_get_last_error",
          "args": [
            "client"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nint\nhypervVerifyResponse(WsManClient *client, WsXmlDocH response,\n                     const char *detail)\n{\n    int lastError = wsmc_get_last_error(client);\n    int responseCode = wsmc_get_response_code(client);\n    WsManFault *fault;\n\n    if (lastError != WS_LASTERR_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Transport error during %s: %s (%d)\"),\n                       detail, wsman_transport_get_last_error_string(lastError),\n                       lastError);\n        return -1;\n    }\n\n    /* Check the HTTP response code and report an error if it's not 200 (OK),\n     * 400 (Bad Request) or 500 (Internal Server Error) */\n    if (responseCode != 200 && responseCode != 400 && responseCode != 500) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected HTTP response during %s: %d\"),\n                       detail, responseCode);\n        return -1;\n    }\n\n    if (response == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Empty response during %s\"), detail);\n        return -1;\n    }\n\n    if (wsmc_check_for_fault(response)) {\n        fault = wsmc_fault_new();\n\n        if (fault == NULL) {\n            virReportOOMError();\n            return -1;\n        }\n\n        wsmc_get_fault_data(response, fault);\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SOAP fault during %s: code '%s', subcode '%s', \"\n                         \"reason '%s', detail '%s'\"),\n                       detail, NULLSTR(fault->code), NULLSTR(fault->subcode),\n                       NULLSTR(fault->reason), NULLSTR(fault->fault_detail));\n\n        wsmc_fault_destroy(fault);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "hypervGetWmiClassList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "85-95",
    "snippet": "static int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hypervEnumAndPull",
          "args": [
            "priv",
            "&wqlQuery",
            "wmiClass"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "hypervEnumAndPull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
          "lines": "953-1107",
          "snippet": "int\nhypervEnumAndPull(hypervPrivate *priv, hypervWqlQueryPtr wqlQuery,\n                  hypervObject **list)\n{\n    int result = -1;\n    WsSerializerContextH serializerContext;\n    client_opt_t *options = NULL;\n    char *query_string = NULL;\n    hypervWmiClassInfoPtr wmiInfo = NULL;\n    filter_t *filter = NULL;\n    WsXmlDocH response = NULL;\n    char *enumContext = NULL;\n    hypervObject *head = NULL;\n    hypervObject *tail = NULL;\n    WsXmlNodeH node = NULL;\n    XML_TYPE_PTR data = NULL;\n    hypervObject *object;\n\n    query_string = virBufferContentAndReset(wqlQuery->query);\n\n    if (list == NULL || *list != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        VIR_FREE(query_string);\n        return -1;\n    }\n\n    if (hypervGetWmiClassInfo(priv, wqlQuery->info, &wmiInfo) < 0)\n        goto cleanup;\n\n    serializerContext = wsmc_get_serialization_context(priv->client);\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n\n    if (filter == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create filter\"));\n        goto cleanup;\n    }\n\n    response = wsmc_action_enumerate(priv->client, wmiInfo->rootUri, options,\n                                     filter);\n\n    if (hypervVerifyResponse(priv->client, response, \"enumeration\") < 0)\n        goto cleanup;\n\n    enumContext = wsmc_get_enum_context(response);\n\n    ws_xml_destroy_doc(response);\n    response = NULL;\n\n    while (enumContext != NULL && *enumContext != '\\0') {\n        response = wsmc_action_pull(priv->client, wmiInfo->resourceUri, options,\n                                    filter, enumContext);\n\n        if (hypervVerifyResponse(priv->client, response, \"pull\") < 0)\n            goto cleanup;\n\n        node = ws_xml_get_soap_body(response);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup SOAP body\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ITEMS);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response items\"));\n            goto cleanup;\n        }\n\n        if (ws_xml_get_child(node, 0, wmiInfo->resourceUri,\n                             wmiInfo->name) == NULL)\n            break;\n\n        data = ws_deserialize(serializerContext, node, wmiInfo->serializerInfo,\n                              wmiInfo->name, wmiInfo->resourceUri, NULL, 0, 0);\n\n        if (data == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not deserialize pull response item\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(object) < 0)\n            goto cleanup;\n\n        object->info = wmiInfo;\n        object->data.common = data;\n\n        data = NULL;\n\n        if (head == NULL) {\n            head = object;\n        } else {\n            tail->next = object;\n        }\n\n        tail = object;\n\n        VIR_FREE(enumContext);\n        enumContext = wsmc_get_enum_context(response);\n\n        ws_xml_destroy_doc(response);\n        response = NULL;\n    }\n\n    *list = head;\n    head = NULL;\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    if (filter != NULL)\n        filter_destroy(filter);\n\n    if (data != NULL) {\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        see hypervFreeObject for a detailed explanation. */\n        if (ws_serializer_free_mem(serializerContext, data,\n                                   wmiInfo->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n    }\n\n    VIR_FREE(query_string);\n    ws_xml_destroy_doc(response);\n    VIR_FREE(enumContext);\n    hypervFreeObject(priv, head);\n\n    return result;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"openwsman.h\"",
            "#include \"virstring.h\"",
            "#include \"hyperv_wmi.h\"",
            "#include \"hyperv_private.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <wsman-soap.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define WS_SERIALIZER_FREE_MEM_WORKS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\n#define WS_SERIALIZER_FREE_MEM_WORKS 0\n\nint\nhypervEnumAndPull(hypervPrivate *priv, hypervWqlQueryPtr wqlQuery,\n                  hypervObject **list)\n{\n    int result = -1;\n    WsSerializerContextH serializerContext;\n    client_opt_t *options = NULL;\n    char *query_string = NULL;\n    hypervWmiClassInfoPtr wmiInfo = NULL;\n    filter_t *filter = NULL;\n    WsXmlDocH response = NULL;\n    char *enumContext = NULL;\n    hypervObject *head = NULL;\n    hypervObject *tail = NULL;\n    WsXmlNodeH node = NULL;\n    XML_TYPE_PTR data = NULL;\n    hypervObject *object;\n\n    query_string = virBufferContentAndReset(wqlQuery->query);\n\n    if (list == NULL || *list != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        VIR_FREE(query_string);\n        return -1;\n    }\n\n    if (hypervGetWmiClassInfo(priv, wqlQuery->info, &wmiInfo) < 0)\n        goto cleanup;\n\n    serializerContext = wsmc_get_serialization_context(priv->client);\n\n    options = wsmc_options_init();\n\n    if (options == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize options\"));\n        goto cleanup;\n    }\n\n    filter = filter_create_simple(WSM_WQL_FILTER_DIALECT, query_string);\n\n    if (filter == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create filter\"));\n        goto cleanup;\n    }\n\n    response = wsmc_action_enumerate(priv->client, wmiInfo->rootUri, options,\n                                     filter);\n\n    if (hypervVerifyResponse(priv->client, response, \"enumeration\") < 0)\n        goto cleanup;\n\n    enumContext = wsmc_get_enum_context(response);\n\n    ws_xml_destroy_doc(response);\n    response = NULL;\n\n    while (enumContext != NULL && *enumContext != '\\0') {\n        response = wsmc_action_pull(priv->client, wmiInfo->resourceUri, options,\n                                    filter, enumContext);\n\n        if (hypervVerifyResponse(priv->client, response, \"pull\") < 0)\n            goto cleanup;\n\n        node = ws_xml_get_soap_body(response);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup SOAP body\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response\"));\n            goto cleanup;\n        }\n\n        node = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ITEMS);\n\n        if (node == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not lookup pull response items\"));\n            goto cleanup;\n        }\n\n        if (ws_xml_get_child(node, 0, wmiInfo->resourceUri,\n                             wmiInfo->name) == NULL)\n            break;\n\n        data = ws_deserialize(serializerContext, node, wmiInfo->serializerInfo,\n                              wmiInfo->name, wmiInfo->resourceUri, NULL, 0, 0);\n\n        if (data == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not deserialize pull response item\"));\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(object) < 0)\n            goto cleanup;\n\n        object->info = wmiInfo;\n        object->data.common = data;\n\n        data = NULL;\n\n        if (head == NULL) {\n            head = object;\n        } else {\n            tail->next = object;\n        }\n\n        tail = object;\n\n        VIR_FREE(enumContext);\n        enumContext = wsmc_get_enum_context(response);\n\n        ws_xml_destroy_doc(response);\n        response = NULL;\n    }\n\n    *list = head;\n    head = NULL;\n\n    result = 0;\n\n cleanup:\n    if (options != NULL)\n        wsmc_options_destroy(options);\n\n    if (filter != NULL)\n        filter_destroy(filter);\n\n    if (data != NULL) {\n#if WS_SERIALIZER_FREE_MEM_WORKS\n        /* FIXME: ws_serializer_free_mem is broken in openwsman <= 2.2.6,\n         *        see hypervFreeObject for a detailed explanation. */\n        if (ws_serializer_free_mem(serializerContext, data,\n                                   wmiInfo->serializerInfo) < 0) {\n            VIR_ERROR(_(\"Could not free deserialized data\"));\n        }\n#endif\n    }\n\n    VIR_FREE(query_string);\n    ws_xml_destroy_doc(response);\n    VIR_FREE(enumContext);\n    hypervFreeObject(priv, head);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassList(hypervPrivate *priv, hypervWmiClassInfoListPtr wmiInfo,\n                      virBufferPtr query, hypervObject **wmiClass)\n{\n    hypervWqlQuery wqlQuery = HYPERV_WQL_QUERY_INITIALIZER;\n\n    wqlQuery.info = wmiInfo;\n    wqlQuery.query = query;\n\n    return hypervEnumAndPull(priv, &wqlQuery, wmiClass);\n}"
  },
  {
    "function_name": "hypervGetWmiClassInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hyperv/hyperv_wmi.c",
    "lines": "49-83",
    "snippet": "static int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}",
    "includes": [
      "#include \"virlog.h\"",
      "#include \"openwsman.h\"",
      "#include \"virstring.h\"",
      "#include \"hyperv_wmi.h\"",
      "#include \"hyperv_private.h\"",
      "#include \"virbuffer.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <wsman-soap.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not match WMI class info for version %s\")",
            "version"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not match WMI class info for version %s\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "list->objs[i]->version",
            "version"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"The WMI class info list is empty\")"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virlog.h\"\n#include \"openwsman.h\"\n#include \"virstring.h\"\n#include \"hyperv_wmi.h\"\n#include \"hyperv_private.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <wsman-soap.h>\n#include <config.h>\n\nstatic int\nhypervGetWmiClassInfo(hypervPrivate *priv, hypervWmiClassInfoListPtr list,\n                      hypervWmiClassInfoPtr *info)\n{\n    const char *version = \"v2\";\n    size_t i;\n\n    if (list->count == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The WMI class info list is empty\"));\n        return -1;\n    }\n\n    /* if there's just one WMI class and isn't versioned, assume \"shared\" */\n    if (list->count == 1 && list->objs[0]->version == NULL) {\n        *info = list->objs[0];\n        return 0;\n    }\n\n    if (priv->wmiVersion == HYPERV_WMI_VERSION_V1)\n        version = \"v1\";\n\n    for (i = 0; i < list->count; i++) {\n       if (STRCASEEQ(list->objs[i]->version, version)) {\n           *info = list->objs[i];\n           return 0;\n       }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Could not match WMI class info for version %s\"),\n                   version);\n\n    return -1;\n}"
  }
]