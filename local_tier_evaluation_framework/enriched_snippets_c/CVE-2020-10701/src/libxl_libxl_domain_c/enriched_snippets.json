[
  {
    "function_name": "libxlDomainDefCheckABIStability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1542-1563",
    "snippet": "bool\nlibxlDomainDefCheckABIStability(libxlDriverPrivatePtr driver,\n                                virDomainDefPtr src,\n                                virDomainDefPtr dst)\n{\n    virDomainDefPtr migratableDefSrc = NULL;\n    virDomainDefPtr migratableDefDst = NULL;\n    bool ret = false;\n\n    if (!(migratableDefSrc = virDomainDefCopy(src, driver->xmlopt, NULL, true)) ||\n        !(migratableDefDst = virDomainDefCopy(dst, driver->xmlopt, NULL, true)))\n        goto cleanup;\n\n    ret = virDomainDefCheckABIStability(migratableDefSrc,\n                                        migratableDefDst,\n                                        driver->xmlopt);\n\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "migratableDefDst"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefCheckABIStability",
          "args": [
            "migratableDefSrc",
            "migratableDefDst",
            "driver->xmlopt"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefCheckABIStability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "24133-24139",
          "snippet": "bool\nvirDomainDefCheckABIStability(virDomainDefPtr src,\n                              virDomainDefPtr dst,\n                              virDomainXMLOptionPtr xmlopt)\n{\n    return virDomainDefCheckABIStabilityFlags(src, dst, xmlopt, 0);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefCheckABIStability(virDomainDefPtr src,\n                              virDomainDefPtr dst,\n                              virDomainXMLOptionPtr xmlopt)\n{\n    return virDomainDefCheckABIStabilityFlags(src, dst, xmlopt, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefCopy",
          "args": [
            "dst",
            "driver->xmlopt",
            "NULL",
            "true"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30005-30024",
          "snippet": "virDomainDefPtr\nvirDomainDefCopy(virDomainDefPtr src,\n                 virDomainXMLOptionPtr xmlopt,\n                 void *parseOpaque,\n                 bool migratable)\n{\n    unsigned int format_flags = VIR_DOMAIN_DEF_FORMAT_SECURE;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE;\n    g_autofree char *xml = NULL;\n\n    if (migratable)\n        format_flags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE | VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    /* Easiest to clone via a round-trip through XML.  */\n    if (!(xml = virDomainDefFormat(src, xmlopt, format_flags)))\n        return NULL;\n\n    return virDomainDefParseString(xml, xmlopt, parseOpaque, parse_flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefCopy(virDomainDefPtr src,\n                 virDomainXMLOptionPtr xmlopt,\n                 void *parseOpaque,\n                 bool migratable)\n{\n    unsigned int format_flags = VIR_DOMAIN_DEF_FORMAT_SECURE;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE;\n    g_autofree char *xml = NULL;\n\n    if (migratable)\n        format_flags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE | VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    /* Easiest to clone via a round-trip through XML.  */\n    if (!(xml = virDomainDefFormat(src, xmlopt, format_flags)))\n        return NULL;\n\n    return virDomainDefParseString(xml, xmlopt, parseOpaque, parse_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nbool\nlibxlDomainDefCheckABIStability(libxlDriverPrivatePtr driver,\n                                virDomainDefPtr src,\n                                virDomainDefPtr dst)\n{\n    virDomainDefPtr migratableDefSrc = NULL;\n    virDomainDefPtr migratableDefDst = NULL;\n    bool ret = false;\n\n    if (!(migratableDefSrc = virDomainDefCopy(src, driver->xmlopt, NULL, true)) ||\n        !(migratableDefDst = virDomainDefCopy(dst, driver->xmlopt, NULL, true)))\n        goto cleanup;\n\n    ret = virDomainDefCheckABIStability(migratableDefSrc,\n                                        migratableDefDst,\n                                        driver->xmlopt);\n\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainStartRestore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1531-1540",
    "snippet": "int\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxlDomainStart",
          "args": [
            "driver",
            "vm",
            "start_paused",
            "restore_fd",
            "restore_ver"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainStartRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1531-1540",
          "snippet": "int\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}"
  },
  {
    "function_name": "libxlDomainStartNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1523-1529",
    "snippet": "int\nlibxlDomainStartNew(libxlDriverPrivatePtr driver,\n            virDomainObjPtr vm,\n            bool start_paused)\n{\n    return libxlDomainStart(driver, vm, start_paused, -1, LIBXL_SAVE_VERSION);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxlDomainStart",
          "args": [
            "driver",
            "vm",
            "start_paused",
            "-1",
            "LIBXL_SAVE_VERSION"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainStartRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1531-1540",
          "snippet": "int\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainStartNew(libxlDriverPrivatePtr driver,\n            virDomainObjPtr vm,\n            bool start_paused)\n{\n    return libxlDomainStart(driver, vm, start_paused, -1, LIBXL_SAVE_VERSION);\n}"
  },
  {
    "function_name": "libxlDomainStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1251-1521",
    "snippet": "static int\nlibxlDomainStart(libxlDriverPrivatePtr driver,\n                 virDomainObjPtr vm,\n                 bool start_paused,\n                 int restore_fd,\n                 uint32_t restore_ver LIBXL_DOMSTART_RESTORE_VER_ATTR)\n{\n    libxl_domain_config d_config;\n    virDomainDefPtr def = NULL;\n    virObjectEventPtr event = NULL;\n    libxlSavefileHeader hdr;\n    int ret = -1;\n    uint32_t domid = 0;\n    char *dom_xml = NULL;\n    char *managed_save_path = NULL;\n    int managed_save_fd = -1;\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    libxl_asyncprogress_how aop_console_how;\n    libxl_domain_restore_params params;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    char *config_json = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    libxl_domain_config_init(&d_config);\n\n    /* If there is a managed saved state restore it instead of starting\n     * from scratch. The old state is removed once the restoring succeeded. */\n    if (restore_fd < 0) {\n        managed_save_path = libxlDomainManagedSavePath(driver, vm);\n        if (managed_save_path == NULL)\n            goto cleanup;\n\n        if (virFileExists(managed_save_path)) {\n\n            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,\n                                                       managed_save_path,\n                                                       &def, &hdr);\n            if (managed_save_fd < 0)\n                goto cleanup;\n\n            restore_fd = managed_save_fd;\n            restore_ver = hdr.version;\n\n            if (STRNEQ(vm->def->name, def->name) ||\n                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {\n                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];\n                char def_uuidstr[VIR_UUID_STRING_BUFLEN];\n                virUUIDFormat(vm->def->uuid, vm_uuidstr);\n                virUUIDFormat(def->uuid, def_uuidstr);\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\"),\n                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);\n                goto cleanup;\n            }\n\n            virDomainObjAssignDef(vm, def, true, NULL);\n            def = NULL;\n\n            if (unlink(managed_save_path) < 0)\n                VIR_WARN(\"Failed to remove the managed state %s\",\n                         managed_save_path);\n\n            vm->hasManagedSave = false;\n        }\n        VIR_FREE(managed_save_path);\n    }\n\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                              VIR_HOOK_LIBXL_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup_dom;\n    }\n\n    if (virDomainLockProcessStart(driver->lockManager,\n                                  \"xen:///system\",\n                                  vm,\n                                  true,\n                                  NULL) < 0)\n        goto cleanup;\n\n    if (libxlNetworkPrepareDevices(vm->def) < 0)\n        goto cleanup_dom;\n\n    if (libxlBuildDomainConfig(driver->reservedGraphicsPorts, vm->def,\n                               cfg, &d_config) < 0)\n        goto cleanup_dom;\n\n    if (cfg->autoballoon && libxlDomainFreeMem(cfg->ctx, &d_config) < 0)\n        goto cleanup_dom;\n\n    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                       vm->def, hostdev_flags) < 0)\n        goto cleanup_dom;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                              VIR_HOOK_LIBXL_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup_dom;\n    }\n\n    if (priv->hookRun) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(vm->def->uuid, uuidstr);\n\n        VIR_WARN(\"Domain id='%d' name='%s' uuid='%s' is tainted: hook\",\n                 vm->def->id,\n                 vm->def->name,\n                 uuidstr);\n    }\n\n    /* Unlock virDomainObj while creating the domain */\n    virObjectUnlock(vm);\n\n    aop_console_how.for_callback = vm;\n    aop_console_how.callback = libxlConsoleCallback;\n    if (restore_fd < 0) {\n        ret = libxl_domain_create_new(cfg->ctx, &d_config,\n                                      &domid, NULL, &aop_console_how);\n    } else {\n        libxl_domain_restore_params_init(&params);\n#ifdef LIBXL_HAVE_SRM_V2\n        params.stream_version = restore_ver;\n#endif\n        ret = libxl_domain_create_restore(cfg->ctx, &d_config, &domid,\n                                          restore_fd, &params, NULL,\n                                          &aop_console_how);\n        libxl_domain_restore_params_dispose(&params);\n    }\n    virObjectLock(vm);\n\n    if (ret) {\n        if (restore_fd < 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to create new domain '%s'\"),\n                           d_config.c_info.name);\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to restore domain '%s'\"),\n                           d_config.c_info.name);\n        goto cleanup_dom;\n    }\n\n    /*\n     * The domain has been successfully created with libxl, so it should\n     * be cleaned up if there are any subsequent failures.\n     */\n    vm->def->id = domid;\n    config_json = libxl_domain_config_to_json(cfg->ctx, &d_config);\n\n    libxlLoggerOpenFile(cfg->logger, domid, vm->def->name, config_json);\n\n    if (virDomainLockProcessResume(driver->lockManager,\n                                  \"xen:///system\",\n                                  vm,\n                                  priv->lockState) < 0)\n        goto destroy_dom;\n    VIR_FREE(priv->lockState);\n\n    /* Always enable domain death events */\n    if (libxl_evenable_domain_death(cfg->ctx, vm->def->id, 0, &priv->deathW))\n        goto destroy_dom;\n\n    libxlDomainCreateIfaceNames(vm->def, &d_config);\n    libxlDomainUpdateDiskParams(vm->def, cfg->ctx);\n\n#ifdef LIBXL_HAVE_DEVICE_CHANNEL\n    if (vm->def->nchannels > 0)\n        libxlDomainCreateChannelPTY(vm->def, cfg->ctx);\n#endif\n\n    if ((dom_xml = virDomainDefFormat(vm->def, driver->xmlopt, 0)) == NULL)\n        goto destroy_dom;\n\n    if (libxl_userdata_store(cfg->ctx, domid, \"libvirt-xml\",\n                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight failed to store userdata\"));\n        goto destroy_dom;\n    }\n\n    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)\n        goto destroy_dom;\n\n    if (!start_paused) {\n        libxl_domain_unpause(cfg->ctx, domid);\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    }\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto destroy_dom;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                              VIR_HOOK_LIBXL_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup_dom;\n    }\n\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,\n                                     restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    ret = 0;\n    goto cleanup;\n\n destroy_dom:\n    ret = -1;\n    libxlDomainDestroyInternal(driver, vm);\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);\n\n cleanup_dom:\n    libxlDomainCleanup(driver, vm);\n\n cleanup:\n    libxl_domain_config_dispose(&d_config);\n    VIR_FREE(config_json);\n    VIR_FREE(dom_xml);\n    VIR_FREE(managed_save_path);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(managed_save_fd);\n    return ret;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "managed_save_fd"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "managed_save_path"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom_xml"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "config_json"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_config_dispose",
          "args": [
            "&d_config"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainCleanup",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "837-935",
          "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "VIR_DOMAIN_SHUTOFF_FAILED"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainDestroyInternal",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainDestroyInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "808-830",
          "snippet": "int\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STARTED",
            "restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_LIBXL",
            "vm->def->name",
            "VIR_HOOK_LIBXL_OP_STARTED",
            "VIR_HOOK_SUBOP_BEGIN",
            "NULL",
            "xml",
            "NULL"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "vm->def",
            "driver->xmlopt",
            "0"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_LIBXL"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->inhibitCallback",
          "args": [
            "true",
            "driver->inhibitOpaque"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_add",
          "args": [
            "&driver->nactive",
            "1"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_unpause",
          "args": [
            "cfg->ctx",
            "domid"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainSetVcpuAffinities",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainSetVcpuAffinities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "965-1006",
          "snippet": "int\nlibxlDomainSetVcpuAffinities(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    virDomainVcpuDefPtr vcpu;\n    libxl_bitmap map;\n    virBitmapPtr cpumask = NULL;\n    size_t i;\n    int ret = -1;\n\n    libxl_bitmap_init(&map);\n\n    for (i = 0; i < virDomainDefGetVcpus(vm->def); ++i) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n\n        if (!vcpu->online)\n            continue;\n\n        if (!(cpumask = vcpu->cpumask))\n            cpumask = vm->def->cpumask;\n\n        if (!cpumask)\n            continue;\n\n        if (virBitmapToData(cpumask, &map.map, (int *)&map.size) < 0)\n            goto cleanup;\n\n        if (libxl_set_vcpuaffinity(cfg->ctx, vm->def->id, i, &map, NULL) != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to pin vcpu '%zu' with libxenlight\"), i);\n            goto cleanup;\n        }\n\n        libxl_bitmap_dispose(&map); /* Also returns to freshly-init'd state */\n    }\n\n    ret = 0;\n\n cleanup:\n    libxl_bitmap_dispose(&map);\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainSetVcpuAffinities(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    virDomainVcpuDefPtr vcpu;\n    libxl_bitmap map;\n    virBitmapPtr cpumask = NULL;\n    size_t i;\n    int ret = -1;\n\n    libxl_bitmap_init(&map);\n\n    for (i = 0; i < virDomainDefGetVcpus(vm->def); ++i) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n\n        if (!vcpu->online)\n            continue;\n\n        if (!(cpumask = vcpu->cpumask))\n            cpumask = vm->def->cpumask;\n\n        if (!cpumask)\n            continue;\n\n        if (virBitmapToData(cpumask, &map.map, (int *)&map.size) < 0)\n            goto cleanup;\n\n        if (libxl_set_vcpuaffinity(cfg->ctx, vm->def->id, i, &map, NULL) != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to pin vcpu '%zu' with libxenlight\"), i);\n            goto cleanup;\n        }\n\n        libxl_bitmap_dispose(&map); /* Also returns to freshly-init'd state */\n    }\n\n    ret = 0;\n\n cleanup:\n    libxl_bitmap_dispose(&map);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libxenlight failed to store userdata\")"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libxenlight failed to store userdata\""
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_userdata_store",
          "args": [
            "cfg->ctx",
            "domid",
            "\"libvirt-xml\"",
            "(uint8_t *)dom_xml",
            "strlen(dom_xml) + 1"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dom_xml"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainCreateChannelPTY",
          "args": [
            "vm->def",
            "cfg->ctx"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCreateChannelPTY",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1205-1237",
          "snippet": "static void\nlibxlDomainCreateChannelPTY(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDefPtr chr;\n    size_t i;\n    int nchannels;\n\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainCreateChannelPTY(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDefPtr chr;\n    size_t i;\n    int nchannels;\n\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainUpdateDiskParams",
          "args": [
            "vm->def",
            "cfg->ctx"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainUpdateDiskParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1180-1202",
          "snippet": "static void\nlibxlDomainUpdateDiskParams(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_disk *disks;\n    int num_disks = 0;\n    size_t i;\n    int idx;\n\n    disks = libxl_device_disk_list(ctx, def->id, &num_disks);\n    if (!disks)\n        return;\n\n    for (i = 0; i < num_disks; i++) {\n        if ((idx = virDomainDiskIndexByName(def, disks[i].vdev, false)) < 0)\n            continue;\n\n        libxlUpdateDiskDef(def->disks[idx], &disks[i]);\n    }\n\n    for (i = 0; i < num_disks; i++)\n        libxl_device_disk_dispose(&disks[i]);\n    VIR_FREE(disks);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainUpdateDiskParams(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_disk *disks;\n    int num_disks = 0;\n    size_t i;\n    int idx;\n\n    disks = libxl_device_disk_list(ctx, def->id, &num_disks);\n    if (!disks)\n        return;\n\n    for (i = 0; i < num_disks; i++) {\n        if ((idx = virDomainDiskIndexByName(def, disks[i].vdev, false)) < 0)\n            continue;\n\n        libxlUpdateDiskDef(def->disks[idx], &disks[i]);\n    }\n\n    for (i = 0; i < num_disks; i++)\n        libxl_device_disk_dispose(&disks[i]);\n    VIR_FREE(disks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainCreateIfaceNames",
          "args": [
            "vm->def",
            "&d_config"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCreateIfaceNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1161-1178",
          "snippet": "static void\nlibxlDomainCreateIfaceNames(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets && i < d_config->num_nics; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        libxl_device_nic *x_nic = &d_config->nics[i];\n        const char *suffix =\n            x_nic->nictype != LIBXL_NIC_TYPE_VIF ? \"-emu\" : \"\";\n\n        if (net->ifname)\n            continue;\n\n        net->ifname = g_strdup_printf(LIBXL_GENERATED_PREFIX_XEN \"%d.%d%s\",\n                                      def->id, x_nic->devid, suffix);\n    }\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainCreateIfaceNames(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets && i < d_config->num_nics; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        libxl_device_nic *x_nic = &d_config->nics[i];\n        const char *suffix =\n            x_nic->nictype != LIBXL_NIC_TYPE_VIF ? \"-emu\" : \"\";\n\n        if (net->ifname)\n            continue;\n\n        net->ifname = g_strdup_printf(LIBXL_GENERATED_PREFIX_XEN \"%d.%d%s\",\n                                      def->id, x_nic->devid, suffix);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_evenable_domain_death",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "0",
            "&priv->deathW"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->lockState"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLockProcessResume",
          "args": [
            "driver->lockManager",
            "\"xen:///system\"",
            "vm",
            "priv->lockState"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockProcessResume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "215-233",
          "snippet": "int virDomainLockProcessResume(virLockManagerPluginPtr plugin,\n                               const char *uri,\n                               virDomainObjPtr dom,\n                               const char *state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%s\",\n              plugin, dom, NULLSTR(state));\n\n    if (!(lock = virDomainLockManagerNew(plugin, uri, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerAcquire(lock, state, 0, dom->def->onLockFailure, NULL);\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockProcessResume(virLockManagerPluginPtr plugin,\n                               const char *uri,\n                               virDomainObjPtr dom,\n                               const char *state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%s\",\n              plugin, dom, NULLSTR(state));\n\n    if (!(lock = virDomainLockManagerNew(plugin, uri, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerAcquire(lock, state, 0, dom->def->onLockFailure, NULL);\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlLoggerOpenFile",
          "args": [
            "cfg->logger",
            "domid",
            "vm->def->name",
            "config_json"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "libxlLoggerOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "185-214",
          "snippet": "void\nlibxlLoggerOpenFile(libxlLoggerPtr logger,\n                    int id,\n                    const char *name,\n                    const char *domain_config)\n{\n    char *path = NULL;\n    FILE *logFile = NULL;\n    char *domidstr = NULL;\n\n    path = g_strdup_printf(\"%s/%s.log\", logger->logDir, name);\n    domidstr = g_strdup_printf(\"%d\", id);\n\n    if (!(logFile = fopen(path, \"a\"))) {\n        VIR_WARN(\"Failed to open log file %s: %s\",\n                 path, g_strerror(errno));\n        goto cleanup;\n    }\n    ignore_value(virHashAddEntry(logger->files, domidstr, logFile));\n\n    /* domain_config is non NULL only when starting a new domain */\n    if (domain_config) {\n        fprintf(logFile, \"Domain start: %s\\n\", domain_config);\n        fflush(logFile);\n    }\n\n cleanup:\n    VIR_FREE(path);\n    VIR_FREE(domidstr);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nvoid\nlibxlLoggerOpenFile(libxlLoggerPtr logger,\n                    int id,\n                    const char *name,\n                    const char *domain_config)\n{\n    char *path = NULL;\n    FILE *logFile = NULL;\n    char *domidstr = NULL;\n\n    path = g_strdup_printf(\"%s/%s.log\", logger->logDir, name);\n    domidstr = g_strdup_printf(\"%d\", id);\n\n    if (!(logFile = fopen(path, \"a\"))) {\n        VIR_WARN(\"Failed to open log file %s: %s\",\n                 path, g_strerror(errno));\n        goto cleanup;\n    }\n    ignore_value(virHashAddEntry(logger->files, domidstr, logFile));\n\n    /* domain_config is non NULL only when starting a new domain */\n    if (domain_config) {\n        fprintf(logFile, \"Domain start: %s\\n\", domain_config);\n        fflush(logFile);\n    }\n\n cleanup:\n    VIR_FREE(path);\n    VIR_FREE(domidstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_config_to_json",
          "args": [
            "cfg->ctx",
            "&d_config"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight failed to restore domain '%s'\")",
            "d_config.c_info.name"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxenlight failed to create new domain '%s'\")",
            "d_config.c_info.name"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_restore_params_dispose",
          "args": [
            "&params"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_create_restore",
          "args": [
            "cfg->ctx",
            "&d_config",
            "&domid",
            "restore_fd",
            "&params",
            "NULL",
            "&aop_console_how"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_restore_params_init",
          "args": [
            "&params"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_create_new",
          "args": [
            "cfg->ctx",
            "&d_config",
            "&domid",
            "NULL",
            "&aop_console_how"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Domain id='%d' name='%s' uuid='%s' is tainted: hook\"",
            "vm->def->id",
            "vm->def->name",
            "uuidstr"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "vm->def->uuid",
            "uuidstr"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostdevPrepareDomainDevices",
          "args": [
            "hostdev_mgr",
            "LIBXL_DRIVER_NAME",
            "vm->def",
            "hostdev_flags"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareDomainDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2092-2130",
          "snippet": "int\nvirHostdevPrepareDomainDevices(virHostdevManagerPtr mgr,\n                               const char *driver,\n                               virDomainDefPtr def,\n                               unsigned int flags)\n{\n    if (!def->nhostdevs)\n        return 0;\n\n    if (!mgr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no host device manager defined\"));\n        return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        if (virHostdevPreparePCIDevices(mgr, driver,\n                                        def->name, def->uuid,\n                                        def->hostdevs,\n                                        def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        if (virHostdevPrepareUSBDevices(mgr, driver, def->name,\n                                        def->hostdevs, def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        if (virHostdevPrepareSCSIDevices(mgr, driver, def->name,\n                                         def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virHostdevManagerPtr manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virHostdevManagerPtr manager;\n\nint\nvirHostdevPrepareDomainDevices(virHostdevManagerPtr mgr,\n                               const char *driver,\n                               virDomainDefPtr def,\n                               unsigned int flags)\n{\n    if (!def->nhostdevs)\n        return 0;\n\n    if (!mgr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no host device manager defined\"));\n        return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        if (virHostdevPreparePCIDevices(mgr, driver,\n                                        def->name, def->uuid,\n                                        def->hostdevs,\n                                        def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        if (virHostdevPrepareUSBDevices(mgr, driver, def->name,\n                                        def->hostdevs, def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        if (virHostdevPrepareSCSIDevices(mgr, driver, def->name,\n                                         def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainFreeMem",
          "args": [
            "cfg->ctx",
            "&d_config"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainFreeMem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1008-1042",
          "snippet": "static int\nlibxlDomainFreeMem(libxl_ctx *ctx, libxl_domain_config *d_config)\n{\n    uint32_t needed_mem;\n    uint32_t free_mem;\n    int32_t target_mem;\n    int tries = 3;\n    int wait_secs = 10;\n\n    if (libxl_domain_need_memory(ctx, &d_config->b_info, &needed_mem) < 0)\n        goto error;\n\n    do {\n        if (libxl_get_free_memory(ctx, &free_mem) < 0)\n            goto error;\n\n        if (free_mem >= needed_mem)\n            return 0;\n\n        target_mem = free_mem - needed_mem;\n        if (libxl_set_memory_target(ctx, 0, target_mem,\n                                    /* relative */ 1, 0) < 0)\n            goto error;\n\n        if (libxl_wait_for_memory_target(ctx, 0, wait_secs) < 0)\n            goto error;\n\n        tries--;\n    } while (tries > 0);\n\n error:\n    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                   _(\"Failed to balloon domain0 memory\"));\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainFreeMem(libxl_ctx *ctx, libxl_domain_config *d_config)\n{\n    uint32_t needed_mem;\n    uint32_t free_mem;\n    int32_t target_mem;\n    int tries = 3;\n    int wait_secs = 10;\n\n    if (libxl_domain_need_memory(ctx, &d_config->b_info, &needed_mem) < 0)\n        goto error;\n\n    do {\n        if (libxl_get_free_memory(ctx, &free_mem) < 0)\n            goto error;\n\n        if (free_mem >= needed_mem)\n            return 0;\n\n        target_mem = free_mem - needed_mem;\n        if (libxl_set_memory_target(ctx, 0, target_mem,\n                                    /* relative */ 1, 0) < 0)\n            goto error;\n\n        if (libxl_wait_for_memory_target(ctx, 0, wait_secs) < 0)\n            goto error;\n\n        tries--;\n    } while (tries > 0);\n\n error:\n    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                   _(\"Failed to balloon domain0 memory\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlBuildDomainConfig",
          "args": [
            "driver->reservedGraphicsPorts",
            "vm->def",
            "cfg",
            "&d_config"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "libxlBuildDomainConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "2411-2473",
          "snippet": "int\nlibxlBuildDomainConfig(virPortAllocatorRangePtr graphicsports,\n                       virDomainDefPtr def,\n                       libxlDriverConfigPtr cfg,\n                       libxl_domain_config *d_config)\n{\n    virCapsPtr caps = cfg->caps;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_config_init(d_config);\n\n    if (libxlMakeDomCreateInfo(ctx, def, &d_config->c_info) < 0)\n        return -1;\n\n    if (libxlMakeDomBuildInfo(def, cfg, caps, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (libxlMakeVnumaList(def, ctx, d_config) < 0)\n        return -1;\n#endif\n\n    if (libxlMakeDiskList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeNicList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeVfbList(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeBuildInfoVfb(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakePCIList(def, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_PVUSB\n    if (libxlMakeUSBControllerList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeUSBList(def, d_config) < 0)\n        return -1;\n#endif\n\n#ifdef LIBXL_HAVE_DEVICE_CHANNEL\n    if (libxlMakeChannelList(cfg->channelDir, def, d_config) < 0)\n        return -1;\n#endif\n\n    /*\n     * Now that any potential VFBs are defined, update the build info with\n     * the data of the primary display. Some day libxl might implicitly do\n     * so but as it does not right now, better be explicit.\n     */\n    if (libxlMakeVideo(def, d_config) < 0)\n        return -1;\n\n    d_config->on_reboot = libxlActionFromVirLifecycle(def->onReboot);\n    d_config->on_poweroff = libxlActionFromVirLifecycle(def->onPoweroff);\n    d_config->on_crash = libxlActionFromVirLifecycle(def->onCrash);\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nint\nlibxlBuildDomainConfig(virPortAllocatorRangePtr graphicsports,\n                       virDomainDefPtr def,\n                       libxlDriverConfigPtr cfg,\n                       libxl_domain_config *d_config)\n{\n    virCapsPtr caps = cfg->caps;\n    libxl_ctx *ctx = cfg->ctx;\n    libxl_domain_config_init(d_config);\n\n    if (libxlMakeDomCreateInfo(ctx, def, &d_config->c_info) < 0)\n        return -1;\n\n    if (libxlMakeDomBuildInfo(def, cfg, caps, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (libxlMakeVnumaList(def, ctx, d_config) < 0)\n        return -1;\n#endif\n\n    if (libxlMakeDiskList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeNicList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeVfbList(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeBuildInfoVfb(graphicsports, def, d_config) < 0)\n        return -1;\n\n    if (libxlMakePCIList(def, d_config) < 0)\n        return -1;\n\n#ifdef LIBXL_HAVE_PVUSB\n    if (libxlMakeUSBControllerList(def, d_config) < 0)\n        return -1;\n\n    if (libxlMakeUSBList(def, d_config) < 0)\n        return -1;\n#endif\n\n#ifdef LIBXL_HAVE_DEVICE_CHANNEL\n    if (libxlMakeChannelList(cfg->channelDir, def, d_config) < 0)\n        return -1;\n#endif\n\n    /*\n     * Now that any potential VFBs are defined, update the build info with\n     * the data of the primary display. Some day libxl might implicitly do\n     * so but as it does not right now, better be explicit.\n     */\n    if (libxlMakeVideo(def, d_config) < 0)\n        return -1;\n\n    d_config->on_reboot = libxlActionFromVirLifecycle(def->onReboot);\n    d_config->on_poweroff = libxlActionFromVirLifecycle(def->onPoweroff);\n    d_config->on_crash = libxlActionFromVirLifecycle(def->onCrash);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlNetworkPrepareDevices",
          "args": [
            "vm->def"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "libxlNetworkPrepareDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1044-1096",
          "snippet": "static int\nlibxlNetworkPrepareDevices(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n    int ret = -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        virDomainNetType actualType;\n\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(conn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        actualType = virDomainNetGetActualType(net);\n        if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV &&\n            net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            /* Each type='hostdev' network device must also have a\n             * corresponding entry in the hostdevs array. For netdevs\n             * that are hardcoded as type='hostdev', this is already\n             * done by the parser, but for those allocated from a\n             * network / determined at runtime, we need to do it\n             * separately.\n             */\n            virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n            if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n                hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n                pcisrc->backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN;\n\n            if (virDomainHostdevInsert(def, hostdev) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlNetworkPrepareDevices(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n    int ret = -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        virDomainNetType actualType;\n\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(conn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        actualType = virDomainNetGetActualType(net);\n        if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV &&\n            net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            /* Each type='hostdev' network device must also have a\n             * corresponding entry in the hostdevs array. For netdevs\n             * that are hardcoded as type='hostdev', this is already\n             * done by the parser, but for those allocated from a\n             * network / determined at runtime, we need to do it\n             * separately.\n             */\n            virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n            if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n                hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n                pcisrc->backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN;\n\n            if (virDomainHostdevInsert(def, hostdev) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLockProcessStart",
          "args": [
            "driver->lockManager",
            "\"xen:///system\"",
            "vm",
            "true",
            "NULL"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockProcessStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "168-194",
          "snippet": "int virDomainLockProcessStart(virLockManagerPluginPtr plugin,\n                              const char *uri,\n                              virDomainObjPtr dom,\n                              bool paused,\n                              int *fd)\n{\n    virLockManagerPtr lock;\n    int ret;\n    int flags = VIR_LOCK_MANAGER_ACQUIRE_RESTRICT;\n\n    VIR_DEBUG(\"plugin=%p dom=%p paused=%d fd=%p\",\n              plugin, dom, paused, fd);\n\n    if (!(lock = virDomainLockManagerNew(plugin, uri, dom, true,\n                                         VIR_LOCK_MANAGER_NEW_STARTED)))\n        return -1;\n\n    if (paused)\n        flags |= VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY;\n\n    ret = virLockManagerAcquire(lock, NULL, flags,\n                                dom->def->onLockFailure, fd);\n\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockProcessStart(virLockManagerPluginPtr plugin,\n                              const char *uri,\n                              virDomainObjPtr dom,\n                              bool paused,\n                              int *fd)\n{\n    virLockManagerPtr lock;\n    int ret;\n    int flags = VIR_LOCK_MANAGER_ACQUIRE_RESTRICT;\n\n    VIR_DEBUG(\"plugin=%p dom=%p paused=%d fd=%p\",\n              plugin, dom, paused, fd);\n\n    if (!(lock = virDomainLockManagerNew(plugin, uri, dom, true,\n                                         VIR_LOCK_MANAGER_NEW_STARTED)))\n        return -1;\n\n    if (paused)\n        flags |= VIR_LOCK_MANAGER_ACQUIRE_REGISTER_ONLY;\n\n    ret = virLockManagerAcquire(lock, NULL, flags,\n                                dom->def->onLockFailure, fd);\n\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSetDefTransient",
          "args": [
            "driver->xmlopt",
            "vm",
            "NULL"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetDefTransient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3711-3727",
          "snippet": "int\nvirDomainObjSetDefTransient(virDomainXMLOptionPtr xmlopt,\n                            virDomainObjPtr domain,\n                            void *parseOpaque)\n{\n    if (!domain->persistent)\n        return 0;\n\n    if (domain->newDef)\n        return 0;\n\n    if (!(domain->newDef = virDomainDefCopy(domain->def, xmlopt,\n                                            parseOpaque, false)))\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjSetDefTransient(virDomainXMLOptionPtr xmlopt,\n                            virDomainObjPtr domain,\n                            void *parseOpaque)\n{\n    if (!domain->persistent)\n        return 0;\n\n    if (domain->newDef)\n        return 0;\n\n    if (!(domain->newDef = virDomainDefCopy(domain->def, xmlopt,\n                                            parseOpaque, false)))\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "managed_save_path"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to remove the managed state %s\"",
            "managed_save_path"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "managed_save_path"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjAssignDef",
          "args": [
            "vm",
            "def",
            "true",
            "NULL"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3597-3626",
          "snippet": "void virDomainObjAssignDef(virDomainObjPtr domain,\n                           virDomainDefPtr def,\n                           bool live,\n                           virDomainDefPtr *oldDef)\n{\n    if (oldDef)\n        *oldDef = NULL;\n    if (virDomainObjIsActive(domain)) {\n        if (oldDef)\n            *oldDef = domain->newDef;\n        else\n            virDomainDefFree(domain->newDef);\n        domain->newDef = def;\n    } else {\n        if (live) {\n            /* save current configuration to be restored on domain shutdown */\n            if (!domain->newDef)\n                domain->newDef = domain->def;\n            else\n                virDomainDefFree(domain->def);\n            domain->def = def;\n        } else {\n            if (oldDef)\n                *oldDef = domain->def;\n            else\n                virDomainDefFree(domain->def);\n            domain->def = def;\n        }\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainObjAssignDef(virDomainObjPtr domain,\n                           virDomainDefPtr def,\n                           bool live,\n                           virDomainDefPtr *oldDef)\n{\n    if (oldDef)\n        *oldDef = NULL;\n    if (virDomainObjIsActive(domain)) {\n        if (oldDef)\n            *oldDef = domain->newDef;\n        else\n            virDomainDefFree(domain->newDef);\n        domain->newDef = def;\n    } else {\n        if (live) {\n            /* save current configuration to be restored on domain shutdown */\n            if (!domain->newDef)\n                domain->newDef = domain->def;\n            else\n                virDomainDefFree(domain->def);\n            domain->def = def;\n        } else {\n            if (oldDef)\n                *oldDef = domain->def;\n            else\n                virDomainDefFree(domain->def);\n            domain->def = def;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\")",
            "vm->def->name",
            "vm_uuidstr",
            "def->name",
            "def_uuidstr"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "vm->def->uuid",
            "def->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vm->def->name",
            "def->name"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainSaveImageOpen",
          "args": [
            "driver",
            "cfg",
            "managed_save_path",
            "&def",
            "&hdr"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainSaveImageOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "734-801",
          "snippet": "int\nlibxlDomainSaveImageOpen(libxlDriverPrivatePtr driver,\n                         libxlDriverConfigPtr cfg G_GNUC_UNUSED,\n                         const char *from,\n                         virDomainDefPtr *ret_def,\n                         libxlSavefileHeaderPtr ret_hdr)\n{\n    int fd;\n    virDomainDefPtr def = NULL;\n    libxlSavefileHeader hdr;\n    char *xml = NULL;\n\n    if ((fd = virFileOpenAs(from, O_RDONLY, 0, -1, -1, 0)) < 0) {\n        virReportSystemError(-fd,\n                             _(\"Failed to open domain image file '%s'\"), from);\n        goto error;\n    }\n\n    if (saferead(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"failed to read libxl header\"));\n        goto error;\n    }\n\n    if (memcmp(hdr.magic, LIBXL_SAVE_MAGIC, sizeof(hdr.magic))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"image magic is incorrect\"));\n        goto error;\n    }\n\n    if (hdr.version > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"image version is not supported (%d > %d)\"),\n                       hdr.version, LIBXL_SAVE_VERSION);\n        goto error;\n    }\n\n    if (hdr.xmlLen <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid XML length: %d\"), hdr.xmlLen);\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(xml, hdr.xmlLen) < 0)\n        goto error;\n\n    if (saferead(fd, xml, hdr.xmlLen) != hdr.xmlLen) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\", _(\"failed to read XML\"));\n        goto error;\n    }\n\n    if (!(def = virDomainDefParseString(xml, driver->xmlopt, NULL,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto error;\n\n    VIR_FREE(xml);\n\n    *ret_def = def;\n    *ret_hdr = hdr;\n\n    return fd;\n\n error:\n    VIR_FREE(xml);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainSaveImageOpen(libxlDriverPrivatePtr driver,\n                         libxlDriverConfigPtr cfg G_GNUC_UNUSED,\n                         const char *from,\n                         virDomainDefPtr *ret_def,\n                         libxlSavefileHeaderPtr ret_hdr)\n{\n    int fd;\n    virDomainDefPtr def = NULL;\n    libxlSavefileHeader hdr;\n    char *xml = NULL;\n\n    if ((fd = virFileOpenAs(from, O_RDONLY, 0, -1, -1, 0)) < 0) {\n        virReportSystemError(-fd,\n                             _(\"Failed to open domain image file '%s'\"), from);\n        goto error;\n    }\n\n    if (saferead(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"failed to read libxl header\"));\n        goto error;\n    }\n\n    if (memcmp(hdr.magic, LIBXL_SAVE_MAGIC, sizeof(hdr.magic))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"image magic is incorrect\"));\n        goto error;\n    }\n\n    if (hdr.version > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"image version is not supported (%d > %d)\"),\n                       hdr.version, LIBXL_SAVE_VERSION);\n        goto error;\n    }\n\n    if (hdr.xmlLen <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid XML length: %d\"), hdr.xmlLen);\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(xml, hdr.xmlLen) < 0)\n        goto error;\n\n    if (saferead(fd, xml, hdr.xmlLen) != hdr.xmlLen) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\", _(\"failed to read XML\"));\n        goto error;\n    }\n\n    if (!(def = virDomainDefParseString(xml, driver->xmlopt, NULL,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto error;\n\n    VIR_FREE(xml);\n\n    *ret_def = def;\n    *ret_hdr = hdr;\n\n    return fd;\n\n error:\n    VIR_FREE(xml);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "managed_save_path"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainManagedSavePath",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainManagedSavePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "719-727",
          "snippet": "char *\nlibxlDomainManagedSavePath(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    char *ret;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    ret = g_strdup_printf(\"%s/%s.save\", cfg->saveDir, vm->def->name);\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nlibxlDomainManagedSavePath(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    char *ret;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    ret = g_strdup_printf(\"%s/%s.save\", cfg->saveDir, vm->def->name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_config_init",
          "args": [
            "&d_config"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainStart(libxlDriverPrivatePtr driver,\n                 virDomainObjPtr vm,\n                 bool start_paused,\n                 int restore_fd,\n                 uint32_t restore_ver LIBXL_DOMSTART_RESTORE_VER_ATTR)\n{\n    libxl_domain_config d_config;\n    virDomainDefPtr def = NULL;\n    virObjectEventPtr event = NULL;\n    libxlSavefileHeader hdr;\n    int ret = -1;\n    uint32_t domid = 0;\n    char *dom_xml = NULL;\n    char *managed_save_path = NULL;\n    int managed_save_fd = -1;\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    libxl_asyncprogress_how aop_console_how;\n    libxl_domain_restore_params params;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    char *config_json = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    libxl_domain_config_init(&d_config);\n\n    /* If there is a managed saved state restore it instead of starting\n     * from scratch. The old state is removed once the restoring succeeded. */\n    if (restore_fd < 0) {\n        managed_save_path = libxlDomainManagedSavePath(driver, vm);\n        if (managed_save_path == NULL)\n            goto cleanup;\n\n        if (virFileExists(managed_save_path)) {\n\n            managed_save_fd = libxlDomainSaveImageOpen(driver, cfg,\n                                                       managed_save_path,\n                                                       &def, &hdr);\n            if (managed_save_fd < 0)\n                goto cleanup;\n\n            restore_fd = managed_save_fd;\n            restore_ver = hdr.version;\n\n            if (STRNEQ(vm->def->name, def->name) ||\n                memcmp(vm->def->uuid, def->uuid, VIR_UUID_BUFLEN)) {\n                char vm_uuidstr[VIR_UUID_STRING_BUFLEN];\n                char def_uuidstr[VIR_UUID_STRING_BUFLEN];\n                virUUIDFormat(vm->def->uuid, vm_uuidstr);\n                virUUIDFormat(def->uuid, def_uuidstr);\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"cannot restore domain '%s' uuid %s from a file\"\n                                 \" which belongs to domain '%s' uuid %s\"),\n                               vm->def->name, vm_uuidstr, def->name, def_uuidstr);\n                goto cleanup;\n            }\n\n            virDomainObjAssignDef(vm, def, true, NULL);\n            def = NULL;\n\n            if (unlink(managed_save_path) < 0)\n                VIR_WARN(\"Failed to remove the managed state %s\",\n                         managed_save_path);\n\n            vm->hasManagedSave = false;\n        }\n        VIR_FREE(managed_save_path);\n    }\n\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, NULL) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                              VIR_HOOK_LIBXL_OP_PREPARE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup_dom;\n    }\n\n    if (virDomainLockProcessStart(driver->lockManager,\n                                  \"xen:///system\",\n                                  vm,\n                                  true,\n                                  NULL) < 0)\n        goto cleanup;\n\n    if (libxlNetworkPrepareDevices(vm->def) < 0)\n        goto cleanup_dom;\n\n    if (libxlBuildDomainConfig(driver->reservedGraphicsPorts, vm->def,\n                               cfg, &d_config) < 0)\n        goto cleanup_dom;\n\n    if (cfg->autoballoon && libxlDomainFreeMem(cfg->ctx, &d_config) < 0)\n        goto cleanup_dom;\n\n    if (virHostdevPrepareDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                       vm->def, hostdev_flags) < 0)\n        goto cleanup_dom;\n\n    /* now that we know it is about to start call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                              VIR_HOOK_LIBXL_OP_START, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup_dom;\n    }\n\n    if (priv->hookRun) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(vm->def->uuid, uuidstr);\n\n        VIR_WARN(\"Domain id='%d' name='%s' uuid='%s' is tainted: hook\",\n                 vm->def->id,\n                 vm->def->name,\n                 uuidstr);\n    }\n\n    /* Unlock virDomainObj while creating the domain */\n    virObjectUnlock(vm);\n\n    aop_console_how.for_callback = vm;\n    aop_console_how.callback = libxlConsoleCallback;\n    if (restore_fd < 0) {\n        ret = libxl_domain_create_new(cfg->ctx, &d_config,\n                                      &domid, NULL, &aop_console_how);\n    } else {\n        libxl_domain_restore_params_init(&params);\n#ifdef LIBXL_HAVE_SRM_V2\n        params.stream_version = restore_ver;\n#endif\n        ret = libxl_domain_create_restore(cfg->ctx, &d_config, &domid,\n                                          restore_fd, &params, NULL,\n                                          &aop_console_how);\n        libxl_domain_restore_params_dispose(&params);\n    }\n    virObjectLock(vm);\n\n    if (ret) {\n        if (restore_fd < 0)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to create new domain '%s'\"),\n                           d_config.c_info.name);\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"libxenlight failed to restore domain '%s'\"),\n                           d_config.c_info.name);\n        goto cleanup_dom;\n    }\n\n    /*\n     * The domain has been successfully created with libxl, so it should\n     * be cleaned up if there are any subsequent failures.\n     */\n    vm->def->id = domid;\n    config_json = libxl_domain_config_to_json(cfg->ctx, &d_config);\n\n    libxlLoggerOpenFile(cfg->logger, domid, vm->def->name, config_json);\n\n    if (virDomainLockProcessResume(driver->lockManager,\n                                  \"xen:///system\",\n                                  vm,\n                                  priv->lockState) < 0)\n        goto destroy_dom;\n    VIR_FREE(priv->lockState);\n\n    /* Always enable domain death events */\n    if (libxl_evenable_domain_death(cfg->ctx, vm->def->id, 0, &priv->deathW))\n        goto destroy_dom;\n\n    libxlDomainCreateIfaceNames(vm->def, &d_config);\n    libxlDomainUpdateDiskParams(vm->def, cfg->ctx);\n\n#ifdef LIBXL_HAVE_DEVICE_CHANNEL\n    if (vm->def->nchannels > 0)\n        libxlDomainCreateChannelPTY(vm->def, cfg->ctx);\n#endif\n\n    if ((dom_xml = virDomainDefFormat(vm->def, driver->xmlopt, 0)) == NULL)\n        goto destroy_dom;\n\n    if (libxl_userdata_store(cfg->ctx, domid, \"libvirt-xml\",\n                             (uint8_t *)dom_xml, strlen(dom_xml) + 1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxenlight failed to store userdata\"));\n        goto destroy_dom;\n    }\n\n    if (libxlDomainSetVcpuAffinities(driver, vm) < 0)\n        goto destroy_dom;\n\n    if (!start_paused) {\n        libxl_domain_unpause(cfg->ctx, domid);\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, VIR_DOMAIN_RUNNING_BOOTED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n    }\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto destroy_dom;\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n    /* finally we can call the 'started' hook script if any */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                              VIR_HOOK_LIBXL_OP_STARTED, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n        VIR_FREE(xml);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto cleanup_dom;\n    }\n\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STARTED,\n                                     restore_fd < 0 ?\n                                         VIR_DOMAIN_EVENT_STARTED_BOOTED :\n                                         VIR_DOMAIN_EVENT_STARTED_RESTORED);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    ret = 0;\n    goto cleanup;\n\n destroy_dom:\n    ret = -1;\n    libxlDomainDestroyInternal(driver, vm);\n    vm->def->id = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_FAILED);\n\n cleanup_dom:\n    libxlDomainCleanup(driver, vm);\n\n cleanup:\n    libxl_domain_config_dispose(&d_config);\n    VIR_FREE(config_json);\n    VIR_FREE(dom_xml);\n    VIR_FREE(managed_save_path);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(managed_save_fd);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainCreateChannelPTY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1205-1237",
    "snippet": "static void\nlibxlDomainCreateChannelPTY(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDefPtr chr;\n    size_t i;\n    int nchannels;\n\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_device_channel_dispose",
          "args": [
            "&x_channels[i]"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "channelinfo.u.pty.path"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chr->source->data.file.path"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_channel_getinfo",
          "args": [
            "ctx",
            "def->id",
            "&x_channels[i]",
            "&channelinfo"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_channel_list",
          "args": [
            "ctx",
            "def->id",
            "&nchannels"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainCreateChannelPTY(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDefPtr chr;\n    size_t i;\n    int nchannels;\n\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}"
  },
  {
    "function_name": "libxlDomainUpdateDiskParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1180-1202",
    "snippet": "static void\nlibxlDomainUpdateDiskParams(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_disk *disks;\n    int num_disks = 0;\n    size_t i;\n    int idx;\n\n    disks = libxl_device_disk_list(ctx, def->id, &num_disks);\n    if (!disks)\n        return;\n\n    for (i = 0; i < num_disks; i++) {\n        if ((idx = virDomainDiskIndexByName(def, disks[i].vdev, false)) < 0)\n            continue;\n\n        libxlUpdateDiskDef(def->disks[idx], &disks[i]);\n    }\n\n    for (i = 0; i < num_disks; i++)\n        libxl_device_disk_dispose(&disks[i]);\n    VIR_FREE(disks);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disks"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_disk_dispose",
          "args": [
            "&disks[i]"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlUpdateDiskDef",
          "args": [
            "def->disks[idx]",
            "&disks[i]"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "libxlUpdateDiskDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1168-1191",
          "snippet": "void\nlibxlUpdateDiskDef(virDomainDiskDefPtr l_disk, libxl_device_disk *x_disk)\n{\n    const char *driver = NULL;\n\n    if (virDomainDiskGetDriver(l_disk))\n        return;\n\n    switch (x_disk->backend) {\n    case LIBXL_DISK_BACKEND_QDISK:\n        driver = \"qemu\";\n        break;\n    case LIBXL_DISK_BACKEND_TAP:\n        driver = \"tap\";\n        break;\n    case LIBXL_DISK_BACKEND_PHY:\n        driver = \"phy\";\n        break;\n    case LIBXL_DISK_BACKEND_UNKNOWN:\n        break;\n    }\n    if (driver)\n        ignore_value(virDomainDiskSetDriver(l_disk, driver));\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nvoid\nlibxlUpdateDiskDef(virDomainDiskDefPtr l_disk, libxl_device_disk *x_disk)\n{\n    const char *driver = NULL;\n\n    if (virDomainDiskGetDriver(l_disk))\n        return;\n\n    switch (x_disk->backend) {\n    case LIBXL_DISK_BACKEND_QDISK:\n        driver = \"qemu\";\n        break;\n    case LIBXL_DISK_BACKEND_TAP:\n        driver = \"tap\";\n        break;\n    case LIBXL_DISK_BACKEND_PHY:\n        driver = \"phy\";\n        break;\n    case LIBXL_DISK_BACKEND_UNKNOWN:\n        break;\n    }\n    if (driver)\n        ignore_value(virDomainDiskSetDriver(l_disk, driver));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskIndexByName",
          "args": [
            "def",
            "disks[i].vdev",
            "false"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskIndexByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17299-17325",
          "snippet": "int\nvirDomainDiskIndexByName(virDomainDefPtr def, const char *name,\n                         bool allow_ambiguous)\n{\n    virDomainDiskDefPtr vdisk;\n    size_t i;\n    int candidate = -1;\n\n    /* We prefer the <target dev='name'/> name (it's shorter, required\n     * for all disks, and should be unambiguous), but also support\n     * <source file='name'/> (if unambiguous).  Assume dst if there is\n     * no leading slash, source name otherwise.  */\n    for (i = 0; i < def->ndisks; i++) {\n        vdisk = def->disks[i];\n        if (*name != '/') {\n            if (STREQ(vdisk->dst, name))\n                return i;\n        } else if (STREQ_NULLABLE(virDomainDiskGetSource(vdisk), name)) {\n            if (allow_ambiguous)\n                return i;\n            if (candidate >= 0)\n                return -1;\n            candidate = i;\n        }\n    }\n    return candidate;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskIndexByName(virDomainDefPtr def, const char *name,\n                         bool allow_ambiguous)\n{\n    virDomainDiskDefPtr vdisk;\n    size_t i;\n    int candidate = -1;\n\n    /* We prefer the <target dev='name'/> name (it's shorter, required\n     * for all disks, and should be unambiguous), but also support\n     * <source file='name'/> (if unambiguous).  Assume dst if there is\n     * no leading slash, source name otherwise.  */\n    for (i = 0; i < def->ndisks; i++) {\n        vdisk = def->disks[i];\n        if (*name != '/') {\n            if (STREQ(vdisk->dst, name))\n                return i;\n        } else if (STREQ_NULLABLE(virDomainDiskGetSource(vdisk), name)) {\n            if (allow_ambiguous)\n                return i;\n            if (candidate >= 0)\n                return -1;\n            candidate = i;\n        }\n    }\n    return candidate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_disk_list",
          "args": [
            "ctx",
            "def->id",
            "&num_disks"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainUpdateDiskParams(virDomainDefPtr def, libxl_ctx *ctx)\n{\n    libxl_device_disk *disks;\n    int num_disks = 0;\n    size_t i;\n    int idx;\n\n    disks = libxl_device_disk_list(ctx, def->id, &num_disks);\n    if (!disks)\n        return;\n\n    for (i = 0; i < num_disks; i++) {\n        if ((idx = virDomainDiskIndexByName(def, disks[i].vdev, false)) < 0)\n            continue;\n\n        libxlUpdateDiskDef(def->disks[idx], &disks[i]);\n    }\n\n    for (i = 0; i < num_disks; i++)\n        libxl_device_disk_dispose(&disks[i]);\n    VIR_FREE(disks);\n}"
  },
  {
    "function_name": "libxlDomainCreateIfaceNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1161-1178",
    "snippet": "static void\nlibxlDomainCreateIfaceNames(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets && i < d_config->num_nics; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        libxl_device_nic *x_nic = &d_config->nics[i];\n        const char *suffix =\n            x_nic->nictype != LIBXL_NIC_TYPE_VIF ? \"-emu\" : \"\";\n\n        if (net->ifname)\n            continue;\n\n        net->ifname = g_strdup_printf(LIBXL_GENERATED_PREFIX_XEN \"%d.%d%s\",\n                                      def->id, x_nic->devid, suffix);\n    }\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "LIBXL_GENERATED_PREFIX_XEN \"%d.%d%s\"",
            "def->id",
            "x_nic->devid",
            "suffix"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainCreateIfaceNames(virDomainDefPtr def, libxl_domain_config *d_config)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets && i < d_config->num_nics; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        libxl_device_nic *x_nic = &d_config->nics[i];\n        const char *suffix =\n            x_nic->nictype != LIBXL_NIC_TYPE_VIF ? \"-emu\" : \"\";\n\n        if (net->ifname)\n            continue;\n\n        net->ifname = g_strdup_printf(LIBXL_GENERATED_PREFIX_XEN \"%d.%d%s\",\n                                      def->id, x_nic->devid, suffix);\n    }\n}"
  },
  {
    "function_name": "libxlConsoleCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1098-1153",
    "snippet": "static void\nlibxlConsoleCallback(libxl_ctx *ctx, libxl_event *ev, void *for_callback)\n{\n    virDomainObjPtr vm = for_callback;\n    size_t i;\n    virDomainChrDefPtr chr;\n    char *console = NULL;\n    int ret;\n\n    virObjectLock(vm);\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        chr = vm->def->consoles[i];\n\n        if (i == 0 &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL)\n            chr = vm->def->serials[0];\n\n        if (chr->source->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n            libxl_console_type console_type;\n\n            console_type =\n                (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL ?\n                 LIBXL_CONSOLE_TYPE_SERIAL : LIBXL_CONSOLE_TYPE_PV);\n            ret = libxl_console_get_tty(ctx, ev->domid,\n                                        chr->target.port, console_type,\n                                        &console);\n            if (!ret) {\n                VIR_FREE(chr->source->data.file.path);\n                if (console && console[0] != '\\0')\n                    chr->source->data.file.path = g_strdup(console);\n            }\n            VIR_FREE(console);\n        }\n    }\n    for (i = 0; i < vm->def->nserials; i++) {\n        chr = vm->def->serials[i];\n\n        chr->info.alias = g_strdup_printf(\"serial%zd\", i);\n        if (chr->source->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n            if (chr->source->data.file.path)\n                continue;\n            ret = libxl_console_get_tty(ctx, ev->domid,\n                                        chr->target.port,\n                                        LIBXL_CONSOLE_TYPE_SERIAL,\n                                        &console);\n            if (!ret) {\n                VIR_FREE(chr->source->data.file.path);\n                if (console && console[0] != '\\0')\n                    chr->source->data.file.path = g_strdup(console);\n            }\n            VIR_FREE(console);\n        }\n    }\n    virObjectUnlock(vm);\n    libxl_event_free(ctx, ev);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_event_free",
          "args": [
            "ctx",
            "ev"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "console"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "console"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chr->source->data.file.path"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_console_get_tty",
          "args": [
            "ctx",
            "ev->domid",
            "chr->target.port",
            "LIBXL_CONSOLE_TYPE_SERIAL",
            "&console"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "console"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "chr->source->data.file.path"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_console_get_tty",
          "args": [
            "ctx",
            "ev->domid",
            "chr->target.port",
            "console_type",
            "&console"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlConsoleCallback(libxl_ctx *ctx, libxl_event *ev, void *for_callback)\n{\n    virDomainObjPtr vm = for_callback;\n    size_t i;\n    virDomainChrDefPtr chr;\n    char *console = NULL;\n    int ret;\n\n    virObjectLock(vm);\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        chr = vm->def->consoles[i];\n\n        if (i == 0 &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL)\n            chr = vm->def->serials[0];\n\n        if (chr->source->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n            libxl_console_type console_type;\n\n            console_type =\n                (chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL ?\n                 LIBXL_CONSOLE_TYPE_SERIAL : LIBXL_CONSOLE_TYPE_PV);\n            ret = libxl_console_get_tty(ctx, ev->domid,\n                                        chr->target.port, console_type,\n                                        &console);\n            if (!ret) {\n                VIR_FREE(chr->source->data.file.path);\n                if (console && console[0] != '\\0')\n                    chr->source->data.file.path = g_strdup(console);\n            }\n            VIR_FREE(console);\n        }\n    }\n    for (i = 0; i < vm->def->nserials; i++) {\n        chr = vm->def->serials[i];\n\n        chr->info.alias = g_strdup_printf(\"serial%zd\", i);\n        if (chr->source->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n            if (chr->source->data.file.path)\n                continue;\n            ret = libxl_console_get_tty(ctx, ev->domid,\n                                        chr->target.port,\n                                        LIBXL_CONSOLE_TYPE_SERIAL,\n                                        &console);\n            if (!ret) {\n                VIR_FREE(chr->source->data.file.path);\n                if (console && console[0] != '\\0')\n                    chr->source->data.file.path = g_strdup(console);\n            }\n            VIR_FREE(console);\n        }\n    }\n    virObjectUnlock(vm);\n    libxl_event_free(ctx, ev);\n}"
  },
  {
    "function_name": "libxlNetworkPrepareDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1044-1096",
    "snippet": "static int\nlibxlNetworkPrepareDevices(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n    int ret = -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        virDomainNetType actualType;\n\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(conn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        actualType = virDomainNetGetActualType(net);\n        if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV &&\n            net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            /* Each type='hostdev' network device must also have a\n             * corresponding entry in the hostdevs array. For netdevs\n             * that are hardcoded as type='hostdev', this is already\n             * done by the parser, but for those allocated from a\n             * network / determined at runtime, we need to do it\n             * separately.\n             */\n            virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n            if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n                hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n                pcisrc->backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN;\n\n            if (virDomainHostdevInsert(def, hostdev) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainHostdevInsert",
          "args": [
            "def",
            "hostdev"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17009-17013",
          "snippet": "int\nvirDomainHostdevInsert(virDomainDefPtr def, virDomainHostdevDefPtr hostdev)\n{\n    return VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainHostdevInsert(virDomainDefPtr def, virDomainHostdevDefPtr hostdev)\n{\n    return VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualHostdev",
          "args": [
            "net"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualHostdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30212-30222",
          "snippet": "virDomainHostdevDefPtr\nvirDomainNetGetActualHostdev(virDomainNetDefPtr iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n        return &iface->data.hostdev.def;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n        return &iface->data.network.actual->data.hostdev.def;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainHostdevDefPtr\nvirDomainNetGetActualHostdev(virDomainNetDefPtr iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n        return &iface->data.hostdev.def;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_HOSTDEV)\n        return &iface->data.network.actual->data.hostdev.def;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainActualNetDefValidate",
          "args": [
            "net"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainActualNetDefValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "6296-6354",
          "snippet": "int\nvirDomainActualNetDefValidate(const virDomainNetDef *net)\n{\n    /* Unlike virDomainNetDefValidate(), which is a static function\n     * called internally to this file, virDomainActualNetDefValidate()\n     * is a public function that can be called from a hypervisor after\n     * it has completely setup the NetDef for use by a domain,\n     * including possibly allocating a port from the network driver\n     * (which could change the effective/\"actual\" type of the NetDef,\n     * thus changing what should/shouldn't be allowed by validation).\n     *\n     * This function should contain validations not specific to a\n     * particular hypervisor (e.g. whether or not specifying bandwidth\n     * is allowed for a type of interface), but *not*\n     * hypervisor-specific things.\n     */\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n    const virNetDevBandwidth *bandwidth = virDomainNetGetActualBandwidth(net);\n\n    virMacAddrFormat(&net->mac, macstr);\n\n    if (virDomainNetGetActualVlan(net)) {\n        /* vlan configuration via libvirt is only supported for PCI\n         * Passthrough SR-IOV devices (hostdev or macvtap passthru\n         * mode) and openvswitch bridges. Otherwise log an error and\n         * fail\n         */\n        if (!(actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n              (actualType == VIR_DOMAIN_NET_TYPE_DIRECT &&\n               virDomainNetGetActualDirectMode(net) == VIR_NETDEV_MACVLAN_MODE_PASSTHRU) ||\n              (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE &&\n               vport  && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"interface %s - vlan tag not supported for this connection type\"),\n                           macstr);\n            return -1;\n        }\n    }\n\n    /* bandwidth configuration via libvirt is not supported for\n     * hostdev network devices\n     */\n    if (bandwidth && actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"interface %s - bandwidth settings are not supported \"\n                         \"for hostdev interfaces\"),\n                       macstr);\n        return -1;\n    }\n\n    if (virDomainNetDefValidatePortOptions(macstr, actualType, vport,\n                                           virDomainNetGetActualPortOptionsIsolated(net)) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainActualNetDefValidate(const virDomainNetDef *net)\n{\n    /* Unlike virDomainNetDefValidate(), which is a static function\n     * called internally to this file, virDomainActualNetDefValidate()\n     * is a public function that can be called from a hypervisor after\n     * it has completely setup the NetDef for use by a domain,\n     * including possibly allocating a port from the network driver\n     * (which could change the effective/\"actual\" type of the NetDef,\n     * thus changing what should/shouldn't be allowed by validation).\n     *\n     * This function should contain validations not specific to a\n     * particular hypervisor (e.g. whether or not specifying bandwidth\n     * is allowed for a type of interface), but *not*\n     * hypervisor-specific things.\n     */\n    char macstr[VIR_MAC_STRING_BUFLEN];\n    virDomainNetType actualType = virDomainNetGetActualType(net);\n    const virNetDevVPortProfile *vport = virDomainNetGetActualVirtPortProfile(net);\n    const virNetDevBandwidth *bandwidth = virDomainNetGetActualBandwidth(net);\n\n    virMacAddrFormat(&net->mac, macstr);\n\n    if (virDomainNetGetActualVlan(net)) {\n        /* vlan configuration via libvirt is only supported for PCI\n         * Passthrough SR-IOV devices (hostdev or macvtap passthru\n         * mode) and openvswitch bridges. Otherwise log an error and\n         * fail\n         */\n        if (!(actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV ||\n              (actualType == VIR_DOMAIN_NET_TYPE_DIRECT &&\n               virDomainNetGetActualDirectMode(net) == VIR_NETDEV_MACVLAN_MODE_PASSTHRU) ||\n              (actualType == VIR_DOMAIN_NET_TYPE_BRIDGE &&\n               vport  && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"interface %s - vlan tag not supported for this connection type\"),\n                           macstr);\n            return -1;\n        }\n    }\n\n    /* bandwidth configuration via libvirt is not supported for\n     * hostdev network devices\n     */\n    if (bandwidth && actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"interface %s - bandwidth settings are not supported \"\n                         \"for hostdev interfaces\"),\n                       macstr);\n        return -1;\n    }\n\n    if (virDomainNetDefValidatePortOptions(macstr, actualType, vport,\n                                           virDomainNetGetActualPortOptionsIsolated(net)) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetAllocateActualDevice",
          "args": [
            "conn",
            "def",
            "net"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetAllocateActualDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31498-31504",
          "snippet": "int\nvirDomainNetAllocateActualDevice(virConnectPtr conn,\n                                 virDomainDefPtr dom,\n                                 virDomainNetDefPtr iface)\n{\n    return virDomainNetCreatePort(conn, dom, iface, 0);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetAllocateActualDevice(virConnectPtr conn,\n                                 virDomainDefPtr dom,\n                                 virDomainNetDefPtr iface)\n{\n    return virDomainNetCreatePort(conn, dom, iface, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectNetwork",
          "args": [],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "169-172",
          "snippet": "virConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectNetwork;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectNetwork;\n\nvirConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlNetworkPrepareDevices(virDomainDefPtr def)\n{\n    size_t i;\n    virConnectPtr conn = NULL;\n    int ret = -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        virDomainNetType actualType;\n\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                goto cleanup;\n            if (virDomainNetAllocateActualDevice(conn, def, net) < 0)\n                goto cleanup;\n        }\n\n        /* final validation now that actual type is known */\n        if (virDomainActualNetDefValidate(net) < 0)\n            return -1;\n\n        actualType = virDomainNetGetActualType(net);\n        if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV &&\n            net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            /* Each type='hostdev' network device must also have a\n             * corresponding entry in the hostdevs array. For netdevs\n             * that are hardcoded as type='hostdev', this is already\n             * done by the parser, but for those allocated from a\n             * network / determined at runtime, we need to do it\n             * separately.\n             */\n            virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n            if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n                hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n                pcisrc->backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN;\n\n            if (virDomainHostdevInsert(def, hostdev) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainFreeMem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "1008-1042",
    "snippet": "static int\nlibxlDomainFreeMem(libxl_ctx *ctx, libxl_domain_config *d_config)\n{\n    uint32_t needed_mem;\n    uint32_t free_mem;\n    int32_t target_mem;\n    int tries = 3;\n    int wait_secs = 10;\n\n    if (libxl_domain_need_memory(ctx, &d_config->b_info, &needed_mem) < 0)\n        goto error;\n\n    do {\n        if (libxl_get_free_memory(ctx, &free_mem) < 0)\n            goto error;\n\n        if (free_mem >= needed_mem)\n            return 0;\n\n        target_mem = free_mem - needed_mem;\n        if (libxl_set_memory_target(ctx, 0, target_mem,\n                                    /* relative */ 1, 0) < 0)\n            goto error;\n\n        if (libxl_wait_for_memory_target(ctx, 0, wait_secs) < 0)\n            goto error;\n\n        tries--;\n    } while (tries > 0);\n\n error:\n    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                   _(\"Failed to balloon domain0 memory\"));\n    return -1;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to balloon domain0 memory\")"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to balloon domain0 memory\""
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_wait_for_memory_target",
          "args": [
            "ctx",
            "0",
            "wait_secs"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_set_memory_target",
          "args": [
            "ctx",
            "0",
            "target_mem",
            "/* relative */1",
            "0"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_free_memory",
          "args": [
            "ctx",
            "&free_mem"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_need_memory",
          "args": [
            "ctx",
            "&d_config->b_info",
            "&needed_mem"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainFreeMem(libxl_ctx *ctx, libxl_domain_config *d_config)\n{\n    uint32_t needed_mem;\n    uint32_t free_mem;\n    int32_t target_mem;\n    int tries = 3;\n    int wait_secs = 10;\n\n    if (libxl_domain_need_memory(ctx, &d_config->b_info, &needed_mem) < 0)\n        goto error;\n\n    do {\n        if (libxl_get_free_memory(ctx, &free_mem) < 0)\n            goto error;\n\n        if (free_mem >= needed_mem)\n            return 0;\n\n        target_mem = free_mem - needed_mem;\n        if (libxl_set_memory_target(ctx, 0, target_mem,\n                                    /* relative */ 1, 0) < 0)\n            goto error;\n\n        if (libxl_wait_for_memory_target(ctx, 0, wait_secs) < 0)\n            goto error;\n\n        tries--;\n    } while (tries > 0);\n\n error:\n    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                   _(\"Failed to balloon domain0 memory\"));\n    return -1;\n}"
  },
  {
    "function_name": "libxlDomainSetVcpuAffinities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "965-1006",
    "snippet": "int\nlibxlDomainSetVcpuAffinities(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    virDomainVcpuDefPtr vcpu;\n    libxl_bitmap map;\n    virBitmapPtr cpumask = NULL;\n    size_t i;\n    int ret = -1;\n\n    libxl_bitmap_init(&map);\n\n    for (i = 0; i < virDomainDefGetVcpus(vm->def); ++i) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n\n        if (!vcpu->online)\n            continue;\n\n        if (!(cpumask = vcpu->cpumask))\n            cpumask = vm->def->cpumask;\n\n        if (!cpumask)\n            continue;\n\n        if (virBitmapToData(cpumask, &map.map, (int *)&map.size) < 0)\n            goto cleanup;\n\n        if (libxl_set_vcpuaffinity(cfg->ctx, vm->def->id, i, &map, NULL) != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to pin vcpu '%zu' with libxenlight\"), i);\n            goto cleanup;\n        }\n\n        libxl_bitmap_dispose(&map); /* Also returns to freshly-init'd state */\n    }\n\n    ret = 0;\n\n cleanup:\n    libxl_bitmap_dispose(&map);\n    return ret;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_bitmap_dispose",
          "args": [
            "&map"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_dispose",
          "args": [
            "&map"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to pin vcpu '%zu' with libxenlight\")",
            "i"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to pin vcpu '%zu' with libxenlight\""
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_set_vcpuaffinity",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "i",
            "&map",
            "NULL"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapToData",
          "args": [
            "cpumask",
            "&map.map",
            "(int *)&map.size"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapToDataBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "805-828",
          "snippet": "void\nvirBitmapToDataBuf(virBitmapPtr bitmap,\n                   unsigned char *bytes,\n                   size_t len)\n{\n    size_t nbytes = bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT);\n    unsigned long *l;\n    size_t i, j;\n\n    memset(bytes, 0, len);\n\n    /* If bitmap and buffer differ in size, only fill to the smaller length */\n    len = MIN(len, nbytes);\n\n    /* htole64 is not available, so we do the conversion by hand */\n    l = bitmap->map;\n    for (i = j = 0; i < len; i++, j++) {\n        if (j == sizeof(*l)) {\n            j = 0;\n            l++;\n        }\n        bytes[i] = *l >> (j * CHAR_BIT);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nvoid\nvirBitmapToDataBuf(virBitmapPtr bitmap,\n                   unsigned char *bytes,\n                   size_t len)\n{\n    size_t nbytes = bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT);\n    unsigned long *l;\n    size_t i, j;\n\n    memset(bytes, 0, len);\n\n    /* If bitmap and buffer differ in size, only fill to the smaller length */\n    len = MIN(len, nbytes);\n\n    /* htole64 is not available, so we do the conversion by hand */\n    l = bitmap->map;\n    for (i = j = 0; i < len; i++, j++) {\n        if (j == sizeof(*l)) {\n            j = 0;\n            l++;\n        }\n        bytes[i] = *l >> (j * CHAR_BIT);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpu",
          "args": [
            "vm->def",
            "i"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusTopology",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2066-2090",
          "snippet": "int\nvirDomainDefGetVcpusTopology(const virDomainDef *def,\n                             unsigned int *maxvcpus)\n{\n    unsigned long long tmp;\n\n    if (!def->cpu || def->cpu->sockets == 0)\n        return 1;\n\n    tmp = def->cpu->sockets;\n\n    /* multiplication of 32bit numbers fits into a 64bit variable */\n    if ((tmp *= def->cpu->dies) > UINT_MAX ||\n        (tmp *= def->cpu->cores) > UINT_MAX ||\n        (tmp *= def->cpu->threads) > UINT_MAX) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cpu topology results in more than %u cpus\"), UINT_MAX);\n        return -1;\n    }\n\n    if (maxvcpus)\n        *maxvcpus = tmp;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefGetVcpusTopology(const virDomainDef *def,\n                             unsigned int *maxvcpus)\n{\n    unsigned long long tmp;\n\n    if (!def->cpu || def->cpu->sockets == 0)\n        return 1;\n\n    tmp = def->cpu->sockets;\n\n    /* multiplication of 32bit numbers fits into a 64bit variable */\n    if ((tmp *= def->cpu->dies) > UINT_MAX ||\n        (tmp *= def->cpu->cores) > UINT_MAX ||\n        (tmp *= def->cpu->threads) > UINT_MAX) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cpu topology results in more than %u cpus\"), UINT_MAX);\n        return -1;\n    }\n\n    if (maxvcpus)\n        *maxvcpus = tmp;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "vm->def"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_bitmap_init",
          "args": [
            "&map"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainSetVcpuAffinities(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    virDomainVcpuDefPtr vcpu;\n    libxl_bitmap map;\n    virBitmapPtr cpumask = NULL;\n    size_t i;\n    int ret = -1;\n\n    libxl_bitmap_init(&map);\n\n    for (i = 0; i < virDomainDefGetVcpus(vm->def); ++i) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n\n        if (!vcpu->online)\n            continue;\n\n        if (!(cpumask = vcpu->cpumask))\n            cpumask = vm->def->cpumask;\n\n        if (!cpumask)\n            continue;\n\n        if (virBitmapToData(cpumask, &map.map, (int *)&map.size) < 0)\n            goto cleanup;\n\n        if (libxl_set_vcpuaffinity(cfg->ctx, vm->def->id, i, &map, NULL) != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to pin vcpu '%zu' with libxenlight\"), i);\n            goto cleanup;\n        }\n\n        libxl_bitmap_dispose(&map); /* Also returns to freshly-init'd state */\n    }\n\n    ret = 0;\n\n cleanup:\n    libxl_bitmap_dispose(&map);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainAutoCoreDump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "942-963",
    "snippet": "int\nlibxlDomainAutoCoreDump(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    g_autoptr(GDateTime) now = g_date_time_new_now_local();\n    g_autofree char *nowstr = NULL;\n    char *dumpfile = NULL;\n\n    nowstr = g_date_time_format(now, \"%Y-%m-%d-%H:%M:%S\");\n\n    dumpfile = g_strdup_printf(\"%s/%s-%s\", cfg->autoDumpDir, vm->def->name,\n                               nowstr);\n\n    /* Unlock virDomainObj while dumping core */\n    virObjectUnlock(vm);\n    libxl_domain_core_dump(cfg->ctx, vm->def->id, dumpfile, NULL);\n    virObjectLock(vm);\n\n    VIR_FREE(dumpfile);\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dumpfile"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_core_dump",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "dumpfile",
            "NULL"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s-%s\"",
            "cfg->autoDumpDir",
            "vm->def->name",
            "nowstr"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_date_time_format",
          "args": [
            "now",
            "\"%Y-%m-%d-%H:%M:%S\""
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_date_time_new_now_local",
          "args": [],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainAutoCoreDump(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    g_autoptr(GDateTime) now = g_date_time_new_now_local();\n    g_autofree char *nowstr = NULL;\n    char *dumpfile = NULL;\n\n    nowstr = g_date_time_format(now, \"%Y-%m-%d-%H:%M:%S\");\n\n    dumpfile = g_strdup_printf(\"%s/%s-%s\", cfg->autoDumpDir, vm->def->name,\n                               nowstr);\n\n    /* Unlock virDomainObj while dumping core */\n    virObjectUnlock(vm);\n    libxl_domain_core_dump(cfg->ctx, vm->def->id, dumpfile, NULL);\n    virObjectLock(vm);\n\n    VIR_FREE(dumpfile);\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "837-935",
    "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjRemoveTransientDef",
          "args": [
            "vm"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjRemoveTransientDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3735-3745",
          "snippet": "void\nvirDomainObjRemoveTransientDef(virDomainObjPtr domain)\n{\n    if (!domain->newDef)\n        return;\n\n    virDomainDefFree(domain->def);\n    domain->def = domain->newDef;\n    domain->def->id = -1;\n    domain->newDef = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjRemoveTransientDef(virDomainObjPtr domain)\n{\n    if (!domain->newDef)\n        return;\n\n    virDomainDefFree(domain->def);\n    domain->def = domain->newDef;\n    domain->def->id = -1;\n    domain->newDef = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_LIBXL",
            "vm->def->name",
            "VIR_HOOK_LIBXL_OP_RELEASE",
            "VIR_HOOK_SUBOP_END",
            "NULL",
            "xml",
            "NULL"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "vm->def",
            "driver->xmlopt",
            "0"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_LIBXL"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "file"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to remove domain XML for %s\"",
            "vm->def->name"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "file"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.xml\"",
            "cfg->stateDir",
            "vm->def->name"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to release network device '%s'\"",
            "NULLSTR(net->ifname)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "net->ifname"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetReleaseActualDevice",
          "args": [
            "conn",
            "vm->def",
            "net"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetReleaseActualDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "31536-31564",
          "snippet": "int\nvirDomainNetReleaseActualDevice(virConnectPtr conn,\n                                virDomainDefPtr dom G_GNUC_UNUSED,\n                                virDomainNetDefPtr iface)\n{\n    virNetworkPtr net = NULL;\n    virNetworkPortPtr port = NULL;\n    int ret = -1;\n\n    /* Port might not exist if a failure occurred during VM startup */\n    if (!virUUIDIsValid(iface->data.network.portid)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(port = virNetworkPortLookupByUUID(net, iface->data.network.portid)))\n        goto cleanup;\n\n    if (virNetworkPortDelete(port, 0) < 0)\n        goto cleanup;\n\n cleanup:\n    virObjectUnref(port);\n    virObjectUnref(net);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetReleaseActualDevice(virConnectPtr conn,\n                                virDomainDefPtr dom G_GNUC_UNUSED,\n                                virDomainNetDefPtr iface)\n{\n    virNetworkPtr net = NULL;\n    virNetworkPortPtr port = NULL;\n    int ret = -1;\n\n    /* Port might not exist if a failure occurred during VM startup */\n    if (!virUUIDIsValid(iface->data.network.portid)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(net = virNetworkLookupByName(conn, iface->data.network.name)))\n        goto cleanup;\n\n    if (!(port = virNetworkPortLookupByUUID(net, iface->data.network.portid)))\n        goto cleanup;\n\n    if (virNetworkPortDelete(port, 0) < 0)\n        goto cleanup;\n\n cleanup:\n    virObjectUnref(port);\n    virObjectUnref(net);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectNetwork",
          "args": [],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "169-172",
          "snippet": "virConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectNetwork;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectNetwork;\n\nvirConnectPtr virGetConnectNetwork(void)\n{\n    return virGetConnectGeneric(&connectNetwork, \"network\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetRemoveHostdev",
          "args": [
            "vm->def",
            "net"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetRemoveHostdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17537-17554",
          "snippet": "void\nvirDomainNetRemoveHostdev(virDomainDefPtr def,\n                          virDomainNetDefPtr net)\n{\n    /* hostdev net devices are normally in the hostdevs array, but\n     * might have already been removed by the time we get here */\n    virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n    size_t i;\n\n    if (hostdev) {\n        for (i = 0; i < def->nhostdevs; i++) {\n            if (def->hostdevs[i] == hostdev) {\n                virDomainHostdevRemove(def, i);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetRemoveHostdev(virDomainDefPtr def,\n                          virDomainNetDefPtr net)\n{\n    /* hostdev net devices are normally in the hostdevs array, but\n     * might have already been removed by the time we get here */\n    virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n    size_t i;\n\n    if (hostdev) {\n        for (i = 0; i < def->nhostdevs; i++) {\n            if (def->hostdevs[i] == hostdev) {\n                virDomainHostdevRemove(def, i);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "net->ifname"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "net->ifname",
            "LIBXL_GENERATED_PREFIX_XEN"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not mark port %d as unused\"",
            "vnc_port"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "vnc_port"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->inhibitCallback",
          "args": [
            "false",
            "driver->inhibitOpaque"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_dec_and_test",
          "args": [
            "&driver->nactive"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_evdisable_domain_death",
          "args": [
            "cfg->ctx",
            "priv->deathW"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlLoggerCloseFile",
          "args": [
            "cfg->logger",
            "vm->def->id"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "libxlLoggerCloseFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "216-225",
          "snippet": "void\nlibxlLoggerCloseFile(libxlLoggerPtr logger, int id)\n{\n    char *domidstr = NULL;\n    domidstr = g_strdup_printf(\"%d\", id);\n\n    ignore_value(virHashRemoveEntry(logger->files, domidstr));\n\n    VIR_FREE(domidstr);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nvoid\nlibxlLoggerCloseFile(libxlLoggerPtr logger, int id)\n{\n    char *domidstr = NULL;\n    domidstr = g_strdup_printf(\"%d\", id);\n\n    ignore_value(virHashRemoveEntry(logger->files, domidstr));\n\n    VIR_FREE(domidstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Preserving lock state '%s'\"",
            "NULLSTR(priv->lockState)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "priv->lockState"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to release lease on %s\"",
            "vm->def->name"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLockProcessPause",
          "args": [
            "driver->lockManager",
            "vm",
            "&priv->lockState"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockProcessPause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "196-213",
          "snippet": "int virDomainLockProcessPause(virLockManagerPluginPtr plugin,\n                              virDomainObjPtr dom,\n                              char **state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%p\",\n              plugin, dom, state);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerRelease(lock, state, 0);\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockProcessPause(virLockManagerPluginPtr plugin,\n                              virDomainObjPtr dom,\n                              char **state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%p\",\n              plugin, dom, state);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerRelease(lock, state, 0);\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->lockState"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachDomainDevices",
          "args": [
            "hostdev_mgr",
            "LIBXL_DRIVER_NAME",
            "vm->def",
            "hostdev_flags",
            "NULL"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachDomainDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2135-2160",
          "snippet": "void\nvirHostdevReAttachDomainDevices(virHostdevManagerPtr mgr,\n                                const char *driver,\n                                virDomainDefPtr def,\n                                unsigned int flags,\n                                const char *oldStateDir)\n{\n    if (!def->nhostdevs || !mgr)\n        return;\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        virHostdevReAttachPCIDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs,\n                                     oldStateDir);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        virHostdevReAttachUSBDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        virHostdevReAttachSCSIDevices(mgr, driver, def->name,\n                                      def->hostdevs, def->nhostdevs);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachDomainDevices(virHostdevManagerPtr mgr,\n                                const char *driver,\n                                virDomainDefPtr def,\n                                unsigned int flags,\n                                const char *oldStateDir)\n{\n    if (!def->nhostdevs || !mgr)\n        return;\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        virHostdevReAttachPCIDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs,\n                                     oldStateDir);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        virHostdevReAttachUSBDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        virHostdevReAttachSCSIDevices(mgr, driver, def->name,\n                                      def->hostdevs, def->nhostdevs);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
  },
  {
    "function_name": "libxlDomainDestroyInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "808-830",
    "snippet": "int\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_destroy",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "NULL"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainSaveImageOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "734-801",
    "snippet": "int\nlibxlDomainSaveImageOpen(libxlDriverPrivatePtr driver,\n                         libxlDriverConfigPtr cfg G_GNUC_UNUSED,\n                         const char *from,\n                         virDomainDefPtr *ret_def,\n                         libxlSavefileHeaderPtr ret_hdr)\n{\n    int fd;\n    virDomainDefPtr def = NULL;\n    libxlSavefileHeader hdr;\n    char *xml = NULL;\n\n    if ((fd = virFileOpenAs(from, O_RDONLY, 0, -1, -1, 0)) < 0) {\n        virReportSystemError(-fd,\n                             _(\"Failed to open domain image file '%s'\"), from);\n        goto error;\n    }\n\n    if (saferead(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"failed to read libxl header\"));\n        goto error;\n    }\n\n    if (memcmp(hdr.magic, LIBXL_SAVE_MAGIC, sizeof(hdr.magic))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"image magic is incorrect\"));\n        goto error;\n    }\n\n    if (hdr.version > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"image version is not supported (%d > %d)\"),\n                       hdr.version, LIBXL_SAVE_VERSION);\n        goto error;\n    }\n\n    if (hdr.xmlLen <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid XML length: %d\"), hdr.xmlLen);\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(xml, hdr.xmlLen) < 0)\n        goto error;\n\n    if (saferead(fd, xml, hdr.xmlLen) != hdr.xmlLen) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\", _(\"failed to read XML\"));\n        goto error;\n    }\n\n    if (!(def = virDomainDefParseString(xml, driver->xmlopt, NULL,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto error;\n\n    VIR_FREE(xml);\n\n    *ret_def = def;\n    *ret_hdr = hdr;\n\n    return fd;\n\n error:\n    VIR_FREE(xml);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xml",
            "driver->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"failed to read XML\")"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to read XML\""
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fd",
            "xml",
            "hdr.xmlLen"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "xml",
            "hdr.xmlLen"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"invalid XML length: %d\")",
            "hdr.xmlLen"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"image version is not supported (%d > %d)\")",
            "hdr.version",
            "LIBXL_SAVE_VERSION"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"image magic is incorrect\")"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "hdr.magic",
            "LIBXL_SAVE_MAGIC",
            "sizeof(hdr.magic)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"failed to read libxl header\")"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-fd",
            "_(\"Failed to open domain image file '%s'\")",
            "from"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileOpenAs",
          "args": [
            "from",
            "O_RDONLY",
            "0",
            "-1",
            "-1",
            "0"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virFileOpenAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2817-2829",
          "snippet": "int\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileOpenAs(const char *path G_GNUC_UNUSED,\n              int openflags G_GNUC_UNUSED,\n              mode_t mode G_GNUC_UNUSED,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED,\n              unsigned int flags_unused G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virFileOpenAs is not implemented for WIN32\"));\n\n    return -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainSaveImageOpen(libxlDriverPrivatePtr driver,\n                         libxlDriverConfigPtr cfg G_GNUC_UNUSED,\n                         const char *from,\n                         virDomainDefPtr *ret_def,\n                         libxlSavefileHeaderPtr ret_hdr)\n{\n    int fd;\n    virDomainDefPtr def = NULL;\n    libxlSavefileHeader hdr;\n    char *xml = NULL;\n\n    if ((fd = virFileOpenAs(from, O_RDONLY, 0, -1, -1, 0)) < 0) {\n        virReportSystemError(-fd,\n                             _(\"Failed to open domain image file '%s'\"), from);\n        goto error;\n    }\n\n    if (saferead(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"failed to read libxl header\"));\n        goto error;\n    }\n\n    if (memcmp(hdr.magic, LIBXL_SAVE_MAGIC, sizeof(hdr.magic))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"image magic is incorrect\"));\n        goto error;\n    }\n\n    if (hdr.version > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"image version is not supported (%d > %d)\"),\n                       hdr.version, LIBXL_SAVE_VERSION);\n        goto error;\n    }\n\n    if (hdr.xmlLen <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"invalid XML length: %d\"), hdr.xmlLen);\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(xml, hdr.xmlLen) < 0)\n        goto error;\n\n    if (saferead(fd, xml, hdr.xmlLen) != hdr.xmlLen) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\", _(\"failed to read XML\"));\n        goto error;\n    }\n\n    if (!(def = virDomainDefParseString(xml, driver->xmlopt, NULL,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto error;\n\n    VIR_FREE(xml);\n\n    *ret_def = def;\n    *ret_hdr = hdr;\n\n    return fd;\n\n error:\n    VIR_FREE(xml);\n    virDomainDefFree(def);\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}"
  },
  {
    "function_name": "libxlDomainManagedSavePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "719-727",
    "snippet": "char *\nlibxlDomainManagedSavePath(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    char *ret;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    ret = g_strdup_printf(\"%s/%s.save\", cfg->saveDir, vm->def->name);\n    return ret;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.save\"",
            "cfg->saveDir",
            "vm->def->name"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nlibxlDomainManagedSavePath(libxlDriverPrivatePtr driver, virDomainObjPtr vm)\n{\n    char *ret;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    ret = g_strdup_printf(\"%s/%s.save\", cfg->saveDir, vm->def->name);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainEventHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "658-717",
    "snippet": "void\nlibxlDomainEventHandler(void *data, VIR_LIBXL_EVENT_CONST libxl_event *event)\n{\n    libxlDriverPrivatePtr driver = data;\n    libxl_shutdown_reason xl_reason = event->u.domain_shutdown.shutdown_reason;\n    struct libxlShutdownThreadInfo *shutdown_info = NULL;\n    virThread thread;\n    g_autoptr(libxlDriverConfig) cfg = NULL;\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (event->type != LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN &&\n            event->type != LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        VIR_INFO(\"Unhandled event type %d\", event->type);\n        goto error;\n    }\n\n    /*\n     * Similar to the xl implementation, ignore SUSPEND.  Any actions needed\n     * after calling libxl_domain_suspend() are handled by its callers.\n     */\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_SUSPEND)\n        goto error;\n\n    /*\n     * Start a thread to handle shutdown.  We don't want to be tying up\n     * libxl's event machinery by doing a potentially lengthy shutdown.\n     */\n    if (VIR_ALLOC(shutdown_info) < 0)\n        goto error;\n\n    shutdown_info->driver = driver;\n    shutdown_info->event = (libxl_event *)event;\n    name = g_strdup_printf(\"ev-%d\", event->domid);\n    if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN)\n        ret = virThreadCreateFull(&thread, false, libxlDomainShutdownThread,\n                                  name, false, shutdown_info);\n    else if (event->type == LIBXL_EVENT_TYPE_DOMAIN_DEATH)\n        ret = virThreadCreateFull(&thread, false, libxlDomainDeathThread,\n                                  name, false, shutdown_info);\n\n    if (ret < 0) {\n        /*\n         * Not much we can do on error here except log it.\n         */\n        VIR_ERROR(_(\"Failed to create thread to handle domain shutdown\"));\n        goto error;\n    }\n\n    /*\n     * libxlShutdownThreadInfo and libxl_event are freed in shutdown thread\n     */\n    return;\n\n error:\n    cfg = libxlDriverConfigGet(driver);\n    /* Cast away any const */\n    libxl_event_free(cfg->ctx, (libxl_event *)event);\n    VIR_FREE(shutdown_info);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "shutdown_info"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_event_free",
          "args": [
            "cfg->ctx",
            "(libxl_event *)event"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to create thread to handle domain shutdown\")"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create thread to handle domain shutdown\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&thread",
            "false",
            "libxlDomainDeathThread",
            "name",
            "false",
            "shutdown_info"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"ev-%d\"",
            "event->domid"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "shutdown_info"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Unhandled event type %d\"",
            "event->type"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainEventHandler(void *data, VIR_LIBXL_EVENT_CONST libxl_event *event)\n{\n    libxlDriverPrivatePtr driver = data;\n    libxl_shutdown_reason xl_reason = event->u.domain_shutdown.shutdown_reason;\n    struct libxlShutdownThreadInfo *shutdown_info = NULL;\n    virThread thread;\n    g_autoptr(libxlDriverConfig) cfg = NULL;\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (event->type != LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN &&\n            event->type != LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        VIR_INFO(\"Unhandled event type %d\", event->type);\n        goto error;\n    }\n\n    /*\n     * Similar to the xl implementation, ignore SUSPEND.  Any actions needed\n     * after calling libxl_domain_suspend() are handled by its callers.\n     */\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_SUSPEND)\n        goto error;\n\n    /*\n     * Start a thread to handle shutdown.  We don't want to be tying up\n     * libxl's event machinery by doing a potentially lengthy shutdown.\n     */\n    if (VIR_ALLOC(shutdown_info) < 0)\n        goto error;\n\n    shutdown_info->driver = driver;\n    shutdown_info->event = (libxl_event *)event;\n    name = g_strdup_printf(\"ev-%d\", event->domid);\n    if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN)\n        ret = virThreadCreateFull(&thread, false, libxlDomainShutdownThread,\n                                  name, false, shutdown_info);\n    else if (event->type == LIBXL_EVENT_TYPE_DOMAIN_DEATH)\n        ret = virThreadCreateFull(&thread, false, libxlDomainDeathThread,\n                                  name, false, shutdown_info);\n\n    if (ret < 0) {\n        /*\n         * Not much we can do on error here except log it.\n         */\n        VIR_ERROR(_(\"Failed to create thread to handle domain shutdown\"));\n        goto error;\n    }\n\n    /*\n     * libxlShutdownThreadInfo and libxl_event are freed in shutdown thread\n     */\n    return;\n\n error:\n    cfg = libxlDriverConfigGet(driver);\n    /* Cast away any const */\n    libxl_event_free(cfg->ctx, (libxl_event *)event);\n    VIR_FREE(shutdown_info);\n}"
  },
  {
    "function_name": "libxlDomainDeathThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "610-652",
    "snippet": "static void\nlibxlDomainDeathThread(void *opaque)\n{\n    struct libxlShutdownThreadInfo *shutdown_info = opaque;\n    virDomainObjPtr vm = NULL;\n    libxl_event *ev = shutdown_info->event;\n    libxlDriverPrivatePtr driver = shutdown_info->driver;\n    virObjectEventPtr dom_event = NULL;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv;\n\n    vm = virDomainObjListFindByID(driver->domains, ev->domid);\n    if (!vm) {\n        /* vm->def->id already cleared, means the death was handled by the\n         * driver already */\n        goto cleanup;\n    }\n\n    priv = vm->privateData;\n\n    if (priv->ignoreDeathEvent) {\n        priv->ignoreDeathEvent = false;\n        goto cleanup;\n    }\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_DESTROYED);\n    dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_STOPPED,\n                                                  VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, dom_event);\n    libxl_event_free(cfg->ctx, ev);\n    VIR_FREE(shutdown_info);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "shutdown_info"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_event_free",
          "args": [
            "cfg->ctx",
            "ev"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "dom_event"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainCleanup",
          "args": [
            "driver",
            "vm"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "837-935",
          "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_DESTROYED"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "VIR_DOMAIN_SHUTOFF_DESTROYED"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjBeginJob",
          "args": [
            "driver",
            "vm",
            "LIBXL_JOB_MODIFY"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjBeginJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "109-155",
          "snippet": "int\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_JOB_WAIT_TIME (1000ull * 30)"
          ],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define LIBXL_JOB_WAIT_TIME (1000ull * 30)\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nint\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByID",
          "args": [
            "driver->domains",
            "ev->domid"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "114-134",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByID(virDomainObjListPtr doms,\n                         int id)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virHashSearch(doms->objs, virDomainObjListSearchID, &id, NULL);\n    virObjectRef(obj);\n    virObjectRWUnlock(doms);\n    if (obj) {\n        virObjectLock(obj);\n        if (obj->removing) {\n            virObjectUnlock(obj);\n            virObjectUnref(obj);\n            obj = NULL;\n        }\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByID(virDomainObjListPtr doms,\n                         int id)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virHashSearch(doms->objs, virDomainObjListSearchID, &id, NULL);\n    virObjectRef(obj);\n    virObjectRWUnlock(doms);\n    if (obj) {\n        virObjectLock(obj);\n        if (obj->removing) {\n            virObjectUnlock(obj);\n            virObjectUnref(obj);\n            obj = NULL;\n        }\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainDeathThread(void *opaque)\n{\n    struct libxlShutdownThreadInfo *shutdown_info = opaque;\n    virDomainObjPtr vm = NULL;\n    libxl_event *ev = shutdown_info->event;\n    libxlDriverPrivatePtr driver = shutdown_info->driver;\n    virObjectEventPtr dom_event = NULL;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv;\n\n    vm = virDomainObjListFindByID(driver->domains, ev->domid);\n    if (!vm) {\n        /* vm->def->id already cleared, means the death was handled by the\n         * driver already */\n        goto cleanup;\n    }\n\n    priv = vm->privateData;\n\n    if (priv->ignoreDeathEvent) {\n        priv->ignoreDeathEvent = false;\n        goto cleanup;\n    }\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_DESTROYED);\n    dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_STOPPED,\n                                                  VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, dom_event);\n    libxl_event_free(cfg->ctx, ev);\n    VIR_FREE(shutdown_info);\n}"
  },
  {
    "function_name": "libxlDomainShutdownThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "475-608",
    "snippet": "static void\nlibxlDomainShutdownThread(void *opaque)\n{\n    struct libxlShutdownThreadInfo *shutdown_info = opaque;\n    virDomainObjPtr vm = NULL;\n    libxl_event *ev = shutdown_info->event;\n    libxlDriverPrivatePtr driver = shutdown_info->driver;\n    virObjectEventPtr dom_event = NULL;\n    libxl_shutdown_reason xl_reason = ev->u.domain_shutdown.shutdown_reason;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxl_domain_config d_config;\n\n    libxl_domain_config_init(&d_config);\n\n    vm = virDomainObjListFindByID(driver->domains, ev->domid);\n    if (!vm) {\n        VIR_INFO(\"Received event for unknown domain ID %d\", ev->domid);\n        goto cleanup;\n    }\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_POWEROFF) {\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n\n        dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                           VIR_DOMAIN_EVENT_STOPPED,\n                                           VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN);\n        switch ((virDomainLifecycleAction) vm->def->onPoweroff) {\n        case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n            goto endjob;\n        }\n    } else if (xl_reason == LIBXL_SHUTDOWN_REASON_CRASH) {\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_CRASHED);\n\n        dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                           VIR_DOMAIN_EVENT_STOPPED,\n                                           VIR_DOMAIN_EVENT_STOPPED_CRASHED);\n        switch ((virDomainLifecycleAction) vm->def->onCrash) {\n        case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n            libxlDomainAutoCoreDump(driver, vm);\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n            libxlDomainAutoCoreDump(driver, vm);\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        }\n    } else if (xl_reason == LIBXL_SHUTDOWN_REASON_REBOOT) {\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n\n        dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                           VIR_DOMAIN_EVENT_STOPPED,\n                                           VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN);\n        switch ((virDomainLifecycleAction) vm->def->onReboot) {\n        case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n            goto endjob;\n        }\n#ifdef LIBXL_HAVE_SOFT_RESET\n    } else if (xl_reason == LIBXL_SHUTDOWN_REASON_SOFT_RESET) {\n        libxlDomainObjPrivatePtr priv = vm->privateData;\n\n        if (libxl_retrieve_domain_configuration(cfg->ctx, vm->def->id,\n                                                &d_config) != 0) {\n            VIR_ERROR(_(\"Failed to retrieve config for VM '%s'. \"\n                        \"Unable to perform soft reset. Destroying VM\"),\n                      vm->def->name);\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        }\n\n        if (priv->deathW) {\n            libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n            priv->deathW = NULL;\n        }\n\n        if (libxl_domain_soft_reset(cfg->ctx, &d_config, vm->def->id,\n                                    NULL, NULL) != 0) {\n            VIR_ERROR(_(\"Failed to soft reset VM '%s'. Destroying VM\"),\n                      vm->def->name);\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        }\n        libxl_evenable_domain_death(cfg->ctx, vm->def->id, 0, &priv->deathW);\n        libxl_domain_unpause(cfg->ctx, vm->def->id);\n#endif\n    } else {\n        VIR_INFO(\"Unhandled shutdown_reason %d\", xl_reason);\n    }\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, dom_event);\n    libxl_event_free(cfg->ctx, ev);\n    VIR_FREE(shutdown_info);\n    libxl_domain_config_dispose(&d_config);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_domain_config_dispose",
          "args": [
            "&d_config"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "shutdown_info"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_event_free",
          "args": [
            "cfg->ctx",
            "ev"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "dom_event"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Unhandled shutdown_reason %d\"",
            "xl_reason"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_unpause",
          "args": [
            "cfg->ctx",
            "vm->def->id"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_evenable_domain_death",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "0",
            "&priv->deathW"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainShutdownHandleDestroy",
          "args": [
            "driver",
            "vm"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainShutdownHandleDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "444-452",
          "snippet": "static void\nlibxlDomainShutdownHandleDestroy(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainShutdownHandleDestroy(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to soft reset VM '%s'. Destroying VM\")",
            "vm->def->name"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to soft reset VM '%s'. Destroying VM\""
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_soft_reset",
          "args": [
            "cfg->ctx",
            "&d_config",
            "vm->def->id",
            "NULL",
            "NULL"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_evdisable_domain_death",
          "args": [
            "cfg->ctx",
            "priv->deathW"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to retrieve config for VM '%s'. \"\n                        \"Unable to perform soft reset. Destroying VM\")",
            "vm->def->name"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_retrieve_domain_configuration",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "&d_config"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainShutdownHandleRestart",
          "args": [
            "driver",
            "vm"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainShutdownHandleRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "455-465",
          "snippet": "static void\nlibxlDomainShutdownHandleRestart(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (libxlDomainStartNew(driver, vm, false) < 0) {\n        VIR_ERROR(_(\"Failed to restart VM '%s': %s\"),\n                  vm->def->name, virGetLastErrorMessage());\n    }\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainShutdownHandleRestart(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (libxlDomainStartNew(driver, vm, false) < 0) {\n        VIR_ERROR(_(\"Failed to restart VM '%s': %s\"),\n                  vm->def->name, virGetLastErrorMessage());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "VIR_DOMAIN_SHUTOFF_SHUTDOWN"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainAutoCoreDump",
          "args": [
            "driver",
            "vm"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainAutoCoreDump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "942-963",
          "snippet": "int\nlibxlDomainAutoCoreDump(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    g_autoptr(GDateTime) now = g_date_time_new_now_local();\n    g_autofree char *nowstr = NULL;\n    char *dumpfile = NULL;\n\n    nowstr = g_date_time_format(now, \"%Y-%m-%d-%H:%M:%S\");\n\n    dumpfile = g_strdup_printf(\"%s/%s-%s\", cfg->autoDumpDir, vm->def->name,\n                               nowstr);\n\n    /* Unlock virDomainObj while dumping core */\n    virObjectUnlock(vm);\n    libxl_domain_core_dump(cfg->ctx, vm->def->id, dumpfile, NULL);\n    virObjectLock(vm);\n\n    VIR_FREE(dumpfile);\n    return 0;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainAutoCoreDump(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    g_autoptr(GDateTime) now = g_date_time_new_now_local();\n    g_autofree char *nowstr = NULL;\n    char *dumpfile = NULL;\n\n    nowstr = g_date_time_format(now, \"%Y-%m-%d-%H:%M:%S\");\n\n    dumpfile = g_strdup_printf(\"%s/%s-%s\", cfg->autoDumpDir, vm->def->name,\n                               nowstr);\n\n    /* Unlock virDomainObj while dumping core */\n    virObjectUnlock(vm);\n    libxl_domain_core_dump(cfg->ctx, vm->def->id, dumpfile, NULL);\n    virObjectLock(vm);\n\n    VIR_FREE(dumpfile);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjBeginJob",
          "args": [
            "driver",
            "vm",
            "LIBXL_JOB_MODIFY"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjBeginJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "109-155",
          "snippet": "int\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_JOB_WAIT_TIME (1000ull * 30)"
          ],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define LIBXL_JOB_WAIT_TIME (1000ull * 30)\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nint\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Received event for unknown domain ID %d\"",
            "ev->domid"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListFindByID",
          "args": [
            "driver->domains",
            "ev->domid"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListFindByID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "114-134",
          "snippet": "virDomainObjPtr\nvirDomainObjListFindByID(virDomainObjListPtr doms,\n                         int id)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virHashSearch(doms->objs, virDomainObjListSearchID, &id, NULL);\n    virObjectRef(obj);\n    virObjectRWUnlock(doms);\n    if (obj) {\n        virObjectLock(obj);\n        if (obj->removing) {\n            virObjectUnlock(obj);\n            virObjectUnref(obj);\n            obj = NULL;\n        }\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virDomainObjListDispose(void *obj);\n\nvirDomainObjPtr\nvirDomainObjListFindByID(virDomainObjListPtr doms,\n                         int id)\n{\n    virDomainObjPtr obj;\n\n    virObjectRWLockRead(doms);\n    obj = virHashSearch(doms->objs, virDomainObjListSearchID, &id, NULL);\n    virObjectRef(obj);\n    virObjectRWUnlock(doms);\n    if (obj) {\n        virObjectLock(obj);\n        if (obj->removing) {\n            virObjectUnlock(obj);\n            virObjectUnref(obj);\n            obj = NULL;\n        }\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_config_init",
          "args": [
            "&d_config"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainShutdownThread(void *opaque)\n{\n    struct libxlShutdownThreadInfo *shutdown_info = opaque;\n    virDomainObjPtr vm = NULL;\n    libxl_event *ev = shutdown_info->event;\n    libxlDriverPrivatePtr driver = shutdown_info->driver;\n    virObjectEventPtr dom_event = NULL;\n    libxl_shutdown_reason xl_reason = ev->u.domain_shutdown.shutdown_reason;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxl_domain_config d_config;\n\n    libxl_domain_config_init(&d_config);\n\n    vm = virDomainObjListFindByID(driver->domains, ev->domid);\n    if (!vm) {\n        VIR_INFO(\"Received event for unknown domain ID %d\", ev->domid);\n        goto cleanup;\n    }\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_POWEROFF) {\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n\n        dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                           VIR_DOMAIN_EVENT_STOPPED,\n                                           VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN);\n        switch ((virDomainLifecycleAction) vm->def->onPoweroff) {\n        case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n            goto endjob;\n        }\n    } else if (xl_reason == LIBXL_SHUTDOWN_REASON_CRASH) {\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_CRASHED);\n\n        dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                           VIR_DOMAIN_EVENT_STOPPED,\n                                           VIR_DOMAIN_EVENT_STOPPED_CRASHED);\n        switch ((virDomainLifecycleAction) vm->def->onCrash) {\n        case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n            libxlDomainAutoCoreDump(driver, vm);\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n            libxlDomainAutoCoreDump(driver, vm);\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        }\n    } else if (xl_reason == LIBXL_SHUTDOWN_REASON_REBOOT) {\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_SHUTDOWN);\n\n        dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                           VIR_DOMAIN_EVENT_STOPPED,\n                                           VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN);\n        switch ((virDomainLifecycleAction) vm->def->onReboot) {\n        case VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY:\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME:\n            libxlDomainShutdownHandleRestart(driver, vm);\n            goto endjob;\n        case VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART:\n        case VIR_DOMAIN_LIFECYCLE_ACTION_LAST:\n            goto endjob;\n        }\n#ifdef LIBXL_HAVE_SOFT_RESET\n    } else if (xl_reason == LIBXL_SHUTDOWN_REASON_SOFT_RESET) {\n        libxlDomainObjPrivatePtr priv = vm->privateData;\n\n        if (libxl_retrieve_domain_configuration(cfg->ctx, vm->def->id,\n                                                &d_config) != 0) {\n            VIR_ERROR(_(\"Failed to retrieve config for VM '%s'. \"\n                        \"Unable to perform soft reset. Destroying VM\"),\n                      vm->def->name);\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        }\n\n        if (priv->deathW) {\n            libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n            priv->deathW = NULL;\n        }\n\n        if (libxl_domain_soft_reset(cfg->ctx, &d_config, vm->def->id,\n                                    NULL, NULL) != 0) {\n            VIR_ERROR(_(\"Failed to soft reset VM '%s'. Destroying VM\"),\n                      vm->def->name);\n            libxlDomainShutdownHandleDestroy(driver, vm);\n            goto endjob;\n        }\n        libxl_evenable_domain_death(cfg->ctx, vm->def->id, 0, &priv->deathW);\n        libxl_domain_unpause(cfg->ctx, vm->def->id);\n#endif\n    } else {\n        VIR_INFO(\"Unhandled shutdown_reason %d\", xl_reason);\n    }\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, dom_event);\n    libxl_event_free(cfg->ctx, ev);\n    VIR_FREE(shutdown_info);\n    libxl_domain_config_dispose(&d_config);\n}"
  },
  {
    "function_name": "libxlDomainShutdownHandleRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "455-465",
    "snippet": "static void\nlibxlDomainShutdownHandleRestart(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (libxlDomainStartNew(driver, vm, false) < 0) {\n        VIR_ERROR(_(\"Failed to restart VM '%s': %s\"),\n                  vm->def->name, virGetLastErrorMessage());\n    }\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to restart VM '%s': %s\")",
            "vm->def->name",
            "virGetLastErrorMessage()"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to restart VM '%s': %s\""
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainStartNew",
          "args": [
            "driver",
            "vm",
            "false"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainStartNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1523-1529",
          "snippet": "int\nlibxlDomainStartNew(libxlDriverPrivatePtr driver,\n            virDomainObjPtr vm,\n            bool start_paused)\n{\n    return libxlDomainStart(driver, vm, start_paused, -1, LIBXL_SAVE_VERSION);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainStartNew(libxlDriverPrivatePtr driver,\n            virDomainObjPtr vm,\n            bool start_paused)\n{\n    return libxlDomainStart(driver, vm, start_paused, -1, LIBXL_SAVE_VERSION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainCleanup",
          "args": [
            "driver",
            "vm"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "837-935",
          "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainDestroyInternal",
          "args": [
            "driver",
            "vm"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainDestroyInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "808-830",
          "snippet": "int\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainShutdownHandleRestart(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (libxlDomainStartNew(driver, vm, false) < 0) {\n        VIR_ERROR(_(\"Failed to restart VM '%s': %s\"),\n                  vm->def->name, virGetLastErrorMessage());\n    }\n}"
  },
  {
    "function_name": "libxlDomainShutdownHandleDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "444-452",
    "snippet": "static void\nlibxlDomainShutdownHandleDestroy(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainCleanup",
          "args": [
            "driver",
            "vm"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "837-935",
          "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainDestroyInternal",
          "args": [
            "driver",
            "vm"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainDestroyInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "808-830",
          "snippet": "int\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainShutdownHandleDestroy(libxlDriverPrivatePtr driver,\n                                 virDomainObjPtr vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n}"
  },
  {
    "function_name": "libxlDomainDefPostParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "366-433",
    "snippet": "static int\nlibxlDomainDefPostParse(virDomainDefPtr def,\n                        unsigned int parseFlags G_GNUC_UNUSED,\n                        void *opaque,\n                        void *parseOpaque G_GNUC_UNUSED)\n{\n    libxlDriverPrivatePtr driver = opaque;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    if (!virCapabilitiesDomainSupported(cfg->caps, def->os.type,\n                                        def->os.arch,\n                                        def->virtType))\n        return -1;\n\n    /* Xen PV domains always have a PV console, so add one to the domain config\n     * via post-parse callback if not explicitly specified in the XML. */\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM && def->nconsoles == 0) {\n        virDomainChrDefPtr chrdef;\n\n        if (!(chrdef = virDomainChrDefNew(NULL)))\n            return -1;\n\n        chrdef->source->type = VIR_DOMAIN_CHR_TYPE_PTY;\n        chrdef->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n        chrdef->target.port = 0;\n        chrdef->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n\n        if (VIR_ALLOC_N(def->consoles, 1) < 0) {\n            virDomainChrDefFree(chrdef);\n            return -1;\n        }\n\n        def->nconsoles = 1;\n        def->consoles[0] = chrdef;\n    }\n\n    /* add implicit input devices */\n    if (xenDomainDefAddImplicitInputDevice(def) < 0)\n        return -1;\n\n    /* For x86_64 HVM */\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM &&\n        def->os.arch == VIR_ARCH_X86_64) {\n        /* always enable pae */\n        def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n\n        /* if vnuma is effective enable acpi */\n        if (virDomainNumaGetNodeCount(def->numa) > 0)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n    }\n\n    /* add implicit balloon device */\n    if (def->memballoon == NULL) {\n        virDomainMemballoonDefPtr memballoon;\n        if (VIR_ALLOC(memballoon) < 0)\n            return -1;\n\n        memballoon->model = VIR_DOMAIN_MEMBALLOON_MODEL_XEN;\n        def->memballoon = memballoon;\n    }\n\n    /* add implicit xenbus device */\n    if (virDomainControllerFindByType(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS) == -1)\n        if (virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS, -1, -1) == NULL)\n            return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefAddController",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_XENBUS",
            "-1",
            "-1"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "18932-18952",
          "snippet": "virDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainControllerFindByType",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_XENBUS"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerFindByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17867-17879",
          "snippet": "int\nvirDomainControllerFindByType(virDomainDefPtr def,\n                              int type)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == type)\n            return i;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainControllerFindByType(virDomainDefPtr def,\n                              int type)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == type)\n            return i;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "memballoon"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCount",
          "args": [
            "def->numa"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1137-1144",
          "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenDomainDefAddImplicitInputDevice",
          "args": [
            "def"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xenDomainDefAddImplicitInputDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2453-2472",
          "snippet": "int\nxenDomainDefAddImplicitInputDevice(virDomainDefPtr def)\n{\n    virDomainInputBus implicitInputBus = VIR_DOMAIN_INPUT_BUS_XEN;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n        implicitInputBus = VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_KBD,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenDomainDefAddImplicitInputDevice(virDomainDefPtr def)\n{\n    virDomainInputBus implicitInputBus = VIR_DOMAIN_INPUT_BUS_XEN;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n        implicitInputBus = VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_KBD,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "chrdef"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->consoles",
            "1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesDomainSupported",
          "args": [
            "cfg->caps",
            "def->os.type",
            "def->os.arch",
            "def->virtType"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "787-801",
          "snippet": "bool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainDefPostParse(virDomainDefPtr def,\n                        unsigned int parseFlags G_GNUC_UNUSED,\n                        void *opaque,\n                        void *parseOpaque G_GNUC_UNUSED)\n{\n    libxlDriverPrivatePtr driver = opaque;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n\n    if (!virCapabilitiesDomainSupported(cfg->caps, def->os.type,\n                                        def->os.arch,\n                                        def->virtType))\n        return -1;\n\n    /* Xen PV domains always have a PV console, so add one to the domain config\n     * via post-parse callback if not explicitly specified in the XML. */\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM && def->nconsoles == 0) {\n        virDomainChrDefPtr chrdef;\n\n        if (!(chrdef = virDomainChrDefNew(NULL)))\n            return -1;\n\n        chrdef->source->type = VIR_DOMAIN_CHR_TYPE_PTY;\n        chrdef->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n        chrdef->target.port = 0;\n        chrdef->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n\n        if (VIR_ALLOC_N(def->consoles, 1) < 0) {\n            virDomainChrDefFree(chrdef);\n            return -1;\n        }\n\n        def->nconsoles = 1;\n        def->consoles[0] = chrdef;\n    }\n\n    /* add implicit input devices */\n    if (xenDomainDefAddImplicitInputDevice(def) < 0)\n        return -1;\n\n    /* For x86_64 HVM */\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM &&\n        def->os.arch == VIR_ARCH_X86_64) {\n        /* always enable pae */\n        def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n\n        /* if vnuma is effective enable acpi */\n        if (virDomainNumaGetNodeCount(def->numa) > 0)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n    }\n\n    /* add implicit balloon device */\n    if (def->memballoon == NULL) {\n        virDomainMemballoonDefPtr memballoon;\n        if (VIR_ALLOC(memballoon) < 0)\n            return -1;\n\n        memballoon->model = VIR_DOMAIN_MEMBALLOON_MODEL_XEN;\n        def->memballoon = memballoon;\n    }\n\n    /* add implicit xenbus device */\n    if (virDomainControllerFindByType(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS) == -1)\n        if (virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS, -1, -1) == NULL)\n            return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainDeviceDefPostParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "277-364",
    "snippet": "static int\nlibxlDomainDeviceDefPostParse(virDomainDeviceDefPtr dev,\n                              const virDomainDef *def,\n                              unsigned int parseFlags G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              void *parseOpaque G_GNUC_UNUSED)\n{\n    if (dev->type == VIR_DOMAIN_DEVICE_CHR &&\n        dev->data.chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n        dev->data.chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE &&\n        def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n        dev->data.chr->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n\n    if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV ||\n        (dev->type == VIR_DOMAIN_DEVICE_NET &&\n         dev->data.net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV)) {\n\n        virDomainHostdevDefPtr hostdev;\n        virDomainHostdevSubsysPCIPtr pcisrc;\n\n        if (dev->type == VIR_DOMAIN_DEVICE_NET)\n            hostdev = &dev->data.net->data.hostdev.def;\n        else\n            hostdev = dev->data.hostdev;\n        pcisrc = &hostdev->source.subsys.u.pci;\n\n        /* forbid capabilities mode hostdev in this kind of hypervisor */\n        if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"hostdev mode 'capabilities' is not \"\n                             \"supported in %s\"),\n                           virDomainVirtTypeToString(def->virtType));\n            return -1;\n        }\n\n        if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n            pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT)\n            pcisrc->backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN;\n    }\n\n    if (dev->type == VIR_DOMAIN_DEVICE_VIDEO && def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        int dm_type = libxlDomainGetEmulatorType(def);\n\n        switch (dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n            if (dev->data.video->vram == 0) {\n                if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN)\n                    dev->data.video->vram = 16 * 1024;\n                else\n                    dev->data.video->vram = 8 * 1024;\n                }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n            if (dev->data.video->vram == 0) {\n                if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN)\n                    dev->data.video->vram = 8 * 1024;\n                else\n                    dev->data.video->vram = 4 * 1024;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            if (dev->data.video->vram == 0)\n                dev->data.video->vram = 128 * 1024;\n            break;\n        }\n    }\n\n    if (dev->type == VIR_DOMAIN_DEVICE_DISK) {\n        virDomainDiskDefPtr disk = dev->data.disk;\n        int actual_type = virStorageSourceGetActualType(disk->src);\n        int format = virDomainDiskGetFormat(disk);\n\n        /* for network-based disks, set 'qemu' as the default driver */\n        if (actual_type == VIR_STORAGE_TYPE_NETWORK) {\n            if (!virDomainDiskGetDriver(disk) &&\n                virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                return -1;\n        }\n\n        /* xl.cfg default format is raw. See xl-disk-configuration(5) */\n        if (format == VIR_STORAGE_FILE_NONE)\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDiskSetFormat",
          "args": [
            "disk",
            "VIR_STORAGE_FILE_RAW"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2209-2213",
          "snippet": "void\nvirDomainDiskSetFormat(virDomainDiskDefPtr def, int format)\n{\n    def->src->format = format;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetFormat(virDomainDiskDefPtr def, int format)\n{\n    def->src->format = format;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetDriver",
          "args": [
            "disk",
            "\"qemu\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2192-2199",
          "snippet": "int\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetDriver",
          "args": [
            "disk"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2185-2189",
          "snippet": "const char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetFormat",
          "args": [
            "disk"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2202-2206",
          "snippet": "int\nvirDomainDiskGetFormat(virDomainDiskDefPtr def)\n{\n    return def->src->format;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetFormat(virDomainDiskDefPtr def)\n{\n    return def->src->format;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "disk->src"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainGetEmulatorType",
          "args": [
            "def"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainGetEmulatorType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "777-806",
          "snippet": "int\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\"\n\nint\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"hostdev mode 'capabilities' is not \"\n                             \"supported in %s\")",
            "virDomainVirtTypeToString(def->virtType)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "def->virtType"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"hostdev mode 'capabilities' is not \"\n                             \"supported in %s\""
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainDeviceDefPostParse(virDomainDeviceDefPtr dev,\n                              const virDomainDef *def,\n                              unsigned int parseFlags G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED,\n                              void *parseOpaque G_GNUC_UNUSED)\n{\n    if (dev->type == VIR_DOMAIN_DEVICE_CHR &&\n        dev->data.chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n        dev->data.chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE &&\n        def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n        dev->data.chr->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n\n    if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV ||\n        (dev->type == VIR_DOMAIN_DEVICE_NET &&\n         dev->data.net->type == VIR_DOMAIN_NET_TYPE_HOSTDEV)) {\n\n        virDomainHostdevDefPtr hostdev;\n        virDomainHostdevSubsysPCIPtr pcisrc;\n\n        if (dev->type == VIR_DOMAIN_DEVICE_NET)\n            hostdev = &dev->data.net->data.hostdev.def;\n        else\n            hostdev = dev->data.hostdev;\n        pcisrc = &hostdev->source.subsys.u.pci;\n\n        /* forbid capabilities mode hostdev in this kind of hypervisor */\n        if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"hostdev mode 'capabilities' is not \"\n                             \"supported in %s\"),\n                           virDomainVirtTypeToString(def->virtType));\n            return -1;\n        }\n\n        if (hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n            pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT)\n            pcisrc->backend = VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN;\n    }\n\n    if (dev->type == VIR_DOMAIN_DEVICE_VIDEO && def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        int dm_type = libxlDomainGetEmulatorType(def);\n\n        switch (dev->data.video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n            if (dev->data.video->vram == 0) {\n                if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN)\n                    dev->data.video->vram = 16 * 1024;\n                else\n                    dev->data.video->vram = 8 * 1024;\n                }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n            if (dev->data.video->vram == 0) {\n                if (dm_type == LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN)\n                    dev->data.video->vram = 8 * 1024;\n                else\n                    dev->data.video->vram = 4 * 1024;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            if (dev->data.video->vram == 0)\n                dev->data.video->vram = 128 * 1024;\n            break;\n        }\n    }\n\n    if (dev->type == VIR_DOMAIN_DEVICE_DISK) {\n        virDomainDiskDefPtr disk = dev->data.disk;\n        int actual_type = virStorageSourceGetActualType(disk->src);\n        int format = virDomainDiskGetFormat(disk);\n\n        /* for network-based disks, set 'qemu' as the default driver */\n        if (actual_type == VIR_STORAGE_TYPE_NETWORK) {\n            if (!virDomainDiskGetDriver(disk) &&\n                virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                return -1;\n        }\n\n        /* xl.cfg default format is raw. See xl-disk-configuration(5) */\n        if (format == VIR_STORAGE_FILE_NONE)\n            virDomainDiskSetFormat(disk, VIR_STORAGE_FILE_RAW);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainObjPrivateXMLFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "257-267",
    "snippet": "static int\nlibxlDomainObjPrivateXMLFormat(virBufferPtr buf,\n                               virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->lockState)\n        virBufferAsprintf(buf, \"<lockstate>%s</lockstate>\\n\", priv->lockState);\n\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<lockstate>%s</lockstate>\\n\"",
            "priv->lockState"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainObjPrivateXMLFormat(virBufferPtr buf,\n                               virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->lockState)\n        virBufferAsprintf(buf, \"<lockstate>%s</lockstate>\\n\", priv->lockState);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainObjPrivateXMLParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "245-255",
    "snippet": "static int\nlibxlDomainObjPrivateXMLParse(xmlXPathContextPtr ctxt,\n                              virDomainObjPtr vm,\n                              virDomainDefParserConfigPtr config G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n\n    priv->lockState = virXPathString(\"string(./lockstate)\", ctxt);\n\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./lockstate)\"",
            "ctxt"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainObjPrivateXMLParse(xmlXPathContextPtr ctxt,\n                              virDomainObjPtr vm,\n                              virDomainDefParserConfigPtr config G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n\n    priv->lockState = virXPathString(\"string(./lockstate)\", ctxt);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainObjPrivateFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "236-243",
    "snippet": "static void\nlibxlDomainObjPrivateFree(void *data)\n{\n    libxlDomainObjPrivatePtr priv = data;\n\n    VIR_FREE(priv->lockState);\n    virObjectUnref(priv);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "priv"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->lockState"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateFree(void *data)\n{\n    libxlDomainObjPrivatePtr priv = data;\n\n    VIR_FREE(priv->lockState);\n    virObjectUnref(priv);\n}"
  },
  {
    "function_name": "libxlDomainObjPrivateDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "227-234",
    "snippet": "static void\nlibxlDomainObjPrivateDispose(void *obj)\n{\n    libxlDomainObjPrivatePtr priv = obj;\n\n    libxlDomainObjFreeJob(priv);\n    virChrdevFree(priv->devs);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nlibxlDomainObjPrivateDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virChrdevFree",
          "args": [
            "priv->devs"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "297-309",
          "snippet": "void virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjFreeJob",
          "args": [
            "priv"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjFreeJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "90-95",
          "snippet": "static void\nlibxlDomainObjFreeJob(libxlDomainObjPrivatePtr priv)\n{\n    ignore_value(virCondDestroy(&priv->job.cond));\n    VIR_FREE(priv->job.current);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjFreeJob(libxlDomainObjPrivatePtr priv)\n{\n    ignore_value(virCondDestroy(&priv->job.cond));\n    VIR_FREE(priv->job.current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj)\n{\n    libxlDomainObjPrivatePtr priv = obj;\n\n    libxlDomainObjFreeJob(priv);\n    virChrdevFree(priv->devs);\n}"
  },
  {
    "function_name": "libxlDomainObjPrivateAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "202-225",
    "snippet": "static void *\nlibxlDomainObjPrivateAlloc(void *opaque G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivatePtr priv;\n\n    if (libxlDomainObjPrivateInitialize() < 0)\n        return NULL;\n\n    if (!(priv = virObjectLockableNew(libxlDomainObjPrivateClass)))\n        return NULL;\n\n    if (!(priv->devs = virChrdevAlloc())) {\n        virObjectUnref(priv);\n        return NULL;\n    }\n\n    if (libxlDomainObjInitJob(priv) < 0) {\n        virChrdevFree(priv->devs);\n        virObjectUnref(priv);\n        return NULL;\n    }\n\n    return priv;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr libxlDomainObjPrivateClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "priv"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virChrdevFree",
          "args": [
            "priv->devs"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "297-309",
          "snippet": "void virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virChrdevFree(virChrdevsPtr devs)\n{\n    if (!devs)\n        return;\n\n    virMutexLock(&devs->lock);\n    virHashForEach(devs->hash, virChrdevFreeClearCallbacks, NULL);\n    virHashFree(devs->hash);\n    virMutexUnlock(&devs->lock);\n    virMutexDestroy(&devs->lock);\n\n    VIR_FREE(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjInitJob",
          "args": [
            "priv"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjInitJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "67-79",
          "snippet": "static int\nlibxlDomainObjInitJob(libxlDomainObjPrivatePtr priv)\n{\n    memset(&priv->job, 0, sizeof(priv->job));\n\n    if (virCondInit(&priv->job.cond) < 0)\n        return -1;\n\n    if (VIR_ALLOC(priv->job.current) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainObjInitJob(libxlDomainObjPrivatePtr priv)\n{\n    memset(&priv->job, 0, sizeof(priv->job));\n\n    if (virCondInit(&priv->job.cond) < 0)\n        return -1;\n\n    if (VIR_ALLOC(priv->job.current) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virChrdevAlloc",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virChrdevAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virchrdev.c",
          "lines": "255-277",
          "snippet": "virChrdevsPtr virChrdevAlloc(void)\n{\n    virChrdevsPtr devs;\n    if (VIR_ALLOC(devs) < 0)\n        return NULL;\n\n    if (virMutexInit(&devs->lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to init device stream mutex\"));\n        VIR_FREE(devs);\n        return NULL;\n    }\n\n    /* there will hardly be any devices most of the time, the hash\n     * does not have to be huge */\n    if (!(devs->hash = virHashCreate(3, virChrdevHashEntryFree)))\n        goto error;\n\n    return devs;\n error:\n    virChrdevFree(devs);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"internal.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virhash.h\"",
            "#include \"virchrdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"internal.h\"\n#include \"virfdstream.h\"\n#include \"virhash.h\"\n#include \"virchrdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirChrdevsPtr virChrdevAlloc(void)\n{\n    virChrdevsPtr devs;\n    if (VIR_ALLOC(devs) < 0)\n        return NULL;\n\n    if (virMutexInit(&devs->lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to init device stream mutex\"));\n        VIR_FREE(devs);\n        return NULL;\n    }\n\n    /* there will hardly be any devices most of the time, the hash\n     * does not have to be huge */\n    if (!(devs->hash = virHashCreate(3, virChrdevHashEntryFree)))\n        goto error;\n\n    return devs;\n error:\n    virChrdevFree(devs);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "libxlDomainObjPrivateClass"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjPrivateInitialize",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr libxlDomainObjPrivateClass;\n\nstatic void *\nlibxlDomainObjPrivateAlloc(void *opaque G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivatePtr priv;\n\n    if (libxlDomainObjPrivateInitialize() < 0)\n        return NULL;\n\n    if (!(priv = virObjectLockableNew(libxlDomainObjPrivateClass)))\n        return NULL;\n\n    if (!(priv->devs = virChrdevAlloc())) {\n        virObjectUnref(priv);\n        return NULL;\n    }\n\n    if (libxlDomainObjInitJob(priv) < 0) {\n        virChrdevFree(priv->devs);\n        virObjectUnref(priv);\n        return NULL;\n    }\n\n    return priv;\n}"
  },
  {
    "function_name": "libxlDomainJobUpdateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "181-200",
    "snippet": "int\nlibxlDomainJobUpdateTime(struct libxlDomainJobObj *job)\n{\n    virDomainJobInfoPtr jobInfo = job->current;\n    unsigned long long now;\n\n    if (!job->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < job->started) {\n        job->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - job->started;\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virTimeMillisNow",
          "args": [
            "&now"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeMillisNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "214-222",
          "snippet": "int virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainJobUpdateTime(struct libxlDomainJobObj *job)\n{\n    virDomainJobInfoPtr jobInfo = job->current;\n    unsigned long long now;\n\n    if (!job->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < job->started) {\n        job->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - job->started;\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainObjEndJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "167-179",
    "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nlibxlDomainObjPrivateDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCondSignal",
          "args": [
            "&priv->job.cond"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virCondSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "170-173",
          "snippet": "void virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondSignal(virCondPtr c)\n{\n    pthread_cond_signal(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjResetJob",
          "args": [
            "priv"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjResetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "81-88",
          "snippet": "static void\nlibxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)\n{\n    struct libxlDomainJobObj *job = &priv->job;\n\n    job->active = LIBXL_JOB_NONE;\n    job->owner = 0;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)\n{\n    struct libxlDomainJobObj *job = &priv->job;\n\n    job->active = LIBXL_JOB_NONE;\n    job->owner = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Stopping job: %s\"",
            "libxlDomainJobTypeToString(job)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainJobTypeToString",
          "args": [
            "job"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
  },
  {
    "function_name": "libxlDomainObjBeginJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "109-155",
    "snippet": "int\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LIBXL_JOB_WAIT_TIME (1000ull * 30)"
    ],
    "globals_used": [
      "static void\nlibxlDomainObjPrivateDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot acquire job mutex\")"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot acquire job mutex\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_TIMEOUT",
            "\"%s\"",
            "_(\"cannot acquire state change lock\")"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\"",
            "libxlDomainJobTypeToString(job)",
            "obj->def->name",
            "libxlDomainJobTypeToString(priv->job.active)",
            "priv->job.owner"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainJobTypeToString",
          "args": [
            "priv->job.active"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainJobTypeToString",
          "args": [
            "job"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadSelfID",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadSelfID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "298-311",
          "snippet": "unsigned long long virThreadSelfID(void)\n{\n#if defined(HAVE_SYS_SYSCALL_H) && defined(SYS_gettid) && defined(__linux__)\n    pid_t tid = syscall(SYS_gettid);\n    return tid;\n#else\n    union {\n        unsigned long long l;\n        pthread_t t;\n    } u;\n    u.t = pthread_self();\n    return u.l;\n#endif\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nunsigned long long virThreadSelfID(void)\n{\n#if defined(HAVE_SYS_SYSCALL_H) && defined(SYS_gettid) && defined(__linux__)\n    pid_t tid = syscall(SYS_gettid);\n    return tid;\n#else\n    union {\n        unsigned long long l;\n        pthread_t t;\n    } u;\n    u.t = pthread_self();\n    return u.l;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Starting job: %s\"",
            "libxlDomainJobTypeToString(job)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainJobTypeToString",
          "args": [
            "job"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainObjResetJob",
          "args": [
            "priv"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjResetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "81-88",
          "snippet": "static void\nlibxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)\n{\n    struct libxlDomainJobObj *job = &priv->job;\n\n    job->active = LIBXL_JOB_NONE;\n    job->owner = 0;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)\n{\n    struct libxlDomainJobObj *job = &priv->job;\n\n    job->active = LIBXL_JOB_NONE;\n    job->owner = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondWaitUntil",
          "args": [
            "&priv->job.cond",
            "&obj->parent.lock",
            "then"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virCondWaitUntil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "155-168",
          "snippet": "int virCondWaitUntil(virCondPtr c, virMutexPtr m, unsigned long long whenms)\n{\n    int ret;\n    struct timespec ts;\n\n    ts.tv_sec = whenms / 1000;\n    ts.tv_nsec = (whenms % 1000) * 1000000;\n\n    if ((ret = pthread_cond_timedwait(&c->cond, &m->lock, &ts)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondWaitUntil(virCondPtr c, virMutexPtr m, unsigned long long whenms)\n{\n    int ret;\n    struct timespec ts;\n\n    ts.tv_sec = whenms / 1000;\n    ts.tv_nsec = (whenms % 1000) * 1000000;\n\n    if ((ret = pthread_cond_timedwait(&c->cond, &m->lock, &ts)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Wait normal job condition for starting job: %s\"",
            "libxlDomainJobTypeToString(job)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainJobTypeToString",
          "args": [
            "job"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTimeMillisNow",
          "args": [
            "&now"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeMillisNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "214-222",
          "snippet": "int virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define LIBXL_JOB_WAIT_TIME (1000ull * 30)\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nint\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}"
  },
  {
    "function_name": "libxlDomainObjFreeJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "90-95",
    "snippet": "static void\nlibxlDomainObjFreeJob(libxlDomainObjPrivatePtr priv)\n{\n    ignore_value(virCondDestroy(&priv->job.cond));\n    VIR_FREE(priv->job.current);\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->job.current"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virCondDestroy(&priv->job.cond)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&priv->job.cond"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjFreeJob(libxlDomainObjPrivatePtr priv)\n{\n    ignore_value(virCondDestroy(&priv->job.cond));\n    VIR_FREE(priv->job.current);\n}"
  },
  {
    "function_name": "libxlDomainObjResetJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "81-88",
    "snippet": "static void\nlibxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)\n{\n    struct libxlDomainJobObj *job = &priv->job;\n\n    job->active = LIBXL_JOB_NONE;\n    job->owner = 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)\n{\n    struct libxlDomainJobObj *job = &priv->job;\n\n    job->active = LIBXL_JOB_NONE;\n    job->owner = 0;\n}"
  },
  {
    "function_name": "libxlDomainObjInitJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "67-79",
    "snippet": "static int\nlibxlDomainObjInitJob(libxlDomainObjPrivatePtr priv)\n{\n    memset(&priv->job, 0, sizeof(priv->job));\n\n    if (virCondInit(&priv->job.cond) < 0)\n        return -1;\n\n    if (VIR_ALLOC(priv->job.current) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv->job.current"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&priv->job.cond"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&priv->job",
            "0",
            "sizeof(priv->job)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainObjInitJob(libxlDomainObjPrivatePtr priv)\n{\n    memset(&priv->job, 0, sizeof(priv->job));\n\n    if (virCondInit(&priv->job.cond) < 0)\n        return -1;\n\n    if (VIR_ALLOC(priv->job.current) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainObjPrivateOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
    "lines": "56-63",
    "snippet": "static int\nlibxlDomainObjPrivateOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(libxlDomainObjPrivate, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"driver.h\"",
      "#include \"xen_common.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virhook.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"libxl_domain.h\"",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "libxlDomainObjPrivate",
            "virClassForObjectLockable()"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nlibxlDomainObjPrivateOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(libxlDomainObjPrivate, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]