[
  {
    "function_name": "virNetClientProgramCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "266-400",
    "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "(*infds)[i]"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Unexpected message status %d\")",
            "msg->header.status"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected message status %d\""
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramDispatchError",
          "args": [
            "prog",
            "msg"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "115-189",
          "snippet": "static int\nvirNetClientProgramDispatchError(virNetClientProgramPtr prog G_GNUC_UNUSED,\n                                 virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    /* Interop for virErrorNumber glitch in 0.8.0, if server is\n     * 0.7.1 through 0.7.7; see comments in virterror.h. */\n    switch (err.code) {\n    case VIR_WAR_NO_NWFILTER:\n        /* no way to tell old VIR_WAR_NO_SECRET apart from\n         * VIR_WAR_NO_NWFILTER, but both are very similar\n         * warnings, so ignore the difference */\n        break;\n    case VIR_ERR_INVALID_NWFILTER:\n    case VIR_ERR_NO_NWFILTER:\n    case VIR_ERR_BUILD_FIREWALL:\n        /* server was trying to pass VIR_ERR_INVALID_SECRET,\n         * VIR_ERR_NO_SECRET, or VIR_ERR_CONFIG_UNSUPPORTED */\n        if (err.domain != VIR_FROM_NWFILTER)\n            err.code += 4;\n        break;\n    case VIR_WAR_NO_SECRET:\n        if (err.domain == VIR_FROM_QEMU)\n            err.code = VIR_ERR_OPERATION_TIMEOUT;\n        break;\n    case VIR_ERR_INVALID_SECRET:\n        if (err.domain == VIR_FROM_XEN)\n            err.code = VIR_ERR_MIGRATE_PERSIST_FAILED;\n        break;\n    default:\n        /* Nothing to alter. */\n        break;\n    }\n\n    if ((err.domain == VIR_FROM_REMOTE || err.domain == VIR_FROM_RPC) &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          VIR_ERR_NO_SUPPORT,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", *err.message);\n    } else {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          err.code,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", err.message ? *err.message : _(\"Unknown error\"));\n    }\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientProgramDispatchError(virNetClientProgramPtr prog G_GNUC_UNUSED,\n                                 virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    /* Interop for virErrorNumber glitch in 0.8.0, if server is\n     * 0.7.1 through 0.7.7; see comments in virterror.h. */\n    switch (err.code) {\n    case VIR_WAR_NO_NWFILTER:\n        /* no way to tell old VIR_WAR_NO_SECRET apart from\n         * VIR_WAR_NO_NWFILTER, but both are very similar\n         * warnings, so ignore the difference */\n        break;\n    case VIR_ERR_INVALID_NWFILTER:\n    case VIR_ERR_NO_NWFILTER:\n    case VIR_ERR_BUILD_FIREWALL:\n        /* server was trying to pass VIR_ERR_INVALID_SECRET,\n         * VIR_ERR_NO_SECRET, or VIR_ERR_CONFIG_UNSUPPORTED */\n        if (err.domain != VIR_FROM_NWFILTER)\n            err.code += 4;\n        break;\n    case VIR_WAR_NO_SECRET:\n        if (err.domain == VIR_FROM_QEMU)\n            err.code = VIR_ERR_OPERATION_TIMEOUT;\n        break;\n    case VIR_ERR_INVALID_SECRET:\n        if (err.domain == VIR_FROM_XEN)\n            err.code = VIR_ERR_MIGRATE_PERSIST_FAILED;\n        break;\n    default:\n        /* Nothing to alter. */\n        break;\n    }\n\n    if ((err.domain == VIR_FROM_REMOTE || err.domain == VIR_FROM_RPC) &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          VIR_ERR_NO_SUPPORT,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", *err.message);\n    } else {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          err.code,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", err.message ? *err.message : _(\"Unknown error\"));\n    }\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "ret_filter",
            "ret"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot set close-on-exec %d\")",
            "(*infds)[i]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "(*infds)[i]",
            "false"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot duplicate FD %d\")",
            "msg->fds[i]"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*infds",
            "*ninfds"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected message serial %d != %d\")",
            "msg->header.serial",
            "serial"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected message proc %d != %d\")",
            "msg->header.proc",
            "proc"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected message type %d\")",
            "msg->header.type"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientSendWithReply",
          "args": [
            "client",
            "msg"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendWithReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2143-2153",
          "snippet": "int virNetClientSendWithReply(virNetClientPtr client,\n                              virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, true, false);\n    virObjectUnlock(client);\n    if (ret < 0)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendWithReply(virNetClientPtr client,\n                              virNetMessagePtr msg)\n{\n    int ret;\n    virObjectLock(client);\n    ret = virNetClientSendInternal(client, msg, true, false);\n    virObjectUnlock(client);\n    if (ret < 0)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayload",
          "args": [
            "msg",
            "args_filter",
            "args"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeNumFDs",
          "args": [
            "msg"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeNumFDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "275-304",
          "snippet": "int virNetMessageEncodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs = msg->nfds;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Too many FDs to send %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    VIR_DEBUG(\"Send %zu FDs to peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs = msg->nfds;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Too many FDs to send %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    VIR_DEBUG(\"Send %zu FDs to peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot set close-on-exec %d\")",
            "msg->fds[i]"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot duplicate FD %d\")",
            "outfds[i]"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg->fds",
            "noutfds"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virNetClientProgramDispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "206-263",
    "snippet": "int virNetClientProgramDispatch(virNetClientProgramPtr prog,\n                                virNetClientPtr client,\n                                virNetMessagePtr msg)\n{\n    virNetClientProgramEventPtr event;\n    char *evdata;\n\n    VIR_DEBUG(\"prog=%d ver=%d type=%d status=%d serial=%d proc=%d\",\n              msg->header.prog, msg->header.vers, msg->header.type,\n              msg->header.status, msg->header.serial, msg->header.proc);\n\n    /* Check version, etc. */\n    if (msg->header.prog != prog->program) {\n        VIR_ERROR(_(\"program mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.prog, prog->program);\n        return -1;\n    }\n\n    if (msg->header.vers != prog->version) {\n        VIR_ERROR(_(\"version mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.vers, prog->version);\n        return -1;\n    }\n\n    if (msg->header.status != VIR_NET_OK) {\n        VIR_ERROR(_(\"status mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.status, VIR_NET_OK);\n        return -1;\n    }\n\n    if (msg->header.type != VIR_NET_MESSAGE) {\n        VIR_ERROR(_(\"type mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.type, VIR_NET_MESSAGE);\n        return -1;\n    }\n\n    event = virNetClientProgramGetEvent(prog, msg->header.proc);\n\n    if (!event) {\n        VIR_ERROR(_(\"No event expected with procedure 0x%x\"),\n                  msg->header.proc);\n        return -1;\n    }\n\n    if (VIR_ALLOC_N(evdata, event->msg_len) < 0)\n        return -1;\n\n    if (virNetMessageDecodePayload(msg, event->msg_filter, evdata) < 0)\n        goto cleanup;\n\n    event->func(prog, client, evdata, prog->eventOpaque);\n\n    xdr_free(event->msg_filter, evdata);\n\n cleanup:\n    VIR_FREE(evdata);\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "evdata"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "event->msg_filter",
            "evdata"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->func",
          "args": [
            "prog",
            "client",
            "evdata",
            "prog->eventOpaque"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "event->msg_filter",
            "evdata"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "evdata",
            "event->msg_len"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"No event expected with procedure 0x%x\")",
            "msg->header.proc"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No event expected with procedure 0x%x\""
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetEvent",
          "args": [
            "prog",
            "msg->header.proc"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "192-203",
          "snippet": "static virNetClientProgramEventPtr virNetClientProgramGetEvent(virNetClientProgramPtr prog,\n                                                               int procedure)\n{\n    size_t i;\n\n    for (i = 0; i < prog->nevents; i++) {\n        if (prog->events[i].proc == procedure)\n            return &prog->events[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetClientProgramEventPtr virNetClientProgramGetEvent(virNetClientProgramPtr prog,\n                                                               int procedure)\n{\n    size_t i;\n\n    for (i = 0; i < prog->nevents; i++) {\n        if (prog->events[i].proc == procedure)\n            return &prog->events[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"type mismatch in event (actual 0x%x, expected 0x%x)\")",
            "msg->header.type",
            "VIR_NET_MESSAGE"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"status mismatch in event (actual 0x%x, expected 0x%x)\")",
            "msg->header.status",
            "VIR_NET_OK"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"version mismatch in event (actual 0x%x, expected 0x%x)\")",
            "msg->header.vers",
            "prog->version"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"program mismatch in event (actual 0x%x, expected 0x%x)\")",
            "msg->header.prog",
            "prog->program"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"prog=%d ver=%d type=%d status=%d serial=%d proc=%d\"",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.type",
            "msg->header.status",
            "msg->header.serial",
            "msg->header.proc"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramDispatch(virNetClientProgramPtr prog,\n                                virNetClientPtr client,\n                                virNetMessagePtr msg)\n{\n    virNetClientProgramEventPtr event;\n    char *evdata;\n\n    VIR_DEBUG(\"prog=%d ver=%d type=%d status=%d serial=%d proc=%d\",\n              msg->header.prog, msg->header.vers, msg->header.type,\n              msg->header.status, msg->header.serial, msg->header.proc);\n\n    /* Check version, etc. */\n    if (msg->header.prog != prog->program) {\n        VIR_ERROR(_(\"program mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.prog, prog->program);\n        return -1;\n    }\n\n    if (msg->header.vers != prog->version) {\n        VIR_ERROR(_(\"version mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.vers, prog->version);\n        return -1;\n    }\n\n    if (msg->header.status != VIR_NET_OK) {\n        VIR_ERROR(_(\"status mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.status, VIR_NET_OK);\n        return -1;\n    }\n\n    if (msg->header.type != VIR_NET_MESSAGE) {\n        VIR_ERROR(_(\"type mismatch in event (actual 0x%x, expected 0x%x)\"),\n                  msg->header.type, VIR_NET_MESSAGE);\n        return -1;\n    }\n\n    event = virNetClientProgramGetEvent(prog, msg->header.proc);\n\n    if (!event) {\n        VIR_ERROR(_(\"No event expected with procedure 0x%x\"),\n                  msg->header.proc);\n        return -1;\n    }\n\n    if (VIR_ALLOC_N(evdata, event->msg_len) < 0)\n        return -1;\n\n    if (virNetMessageDecodePayload(msg, event->msg_filter, evdata) < 0)\n        goto cleanup;\n\n    event->func(prog, client, evdata, prog->eventOpaque);\n\n    xdr_free(event->msg_filter, evdata);\n\n cleanup:\n    VIR_FREE(evdata);\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientProgramGetEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "192-203",
    "snippet": "static virNetClientProgramEventPtr virNetClientProgramGetEvent(virNetClientProgramPtr prog,\n                                                               int procedure)\n{\n    size_t i;\n\n    for (i = 0; i < prog->nevents; i++) {\n        if (prog->events[i].proc == procedure)\n            return &prog->events[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetClientProgramEventPtr virNetClientProgramGetEvent(virNetClientProgramPtr prog,\n                                                               int procedure)\n{\n    size_t i;\n\n    for (i = 0; i < prog->nevents; i++) {\n        if (prog->events[i].proc == procedure)\n            return &prog->events[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virNetClientProgramDispatchError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "115-189",
    "snippet": "static int\nvirNetClientProgramDispatchError(virNetClientProgramPtr prog G_GNUC_UNUSED,\n                                 virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    /* Interop for virErrorNumber glitch in 0.8.0, if server is\n     * 0.7.1 through 0.7.7; see comments in virterror.h. */\n    switch (err.code) {\n    case VIR_WAR_NO_NWFILTER:\n        /* no way to tell old VIR_WAR_NO_SECRET apart from\n         * VIR_WAR_NO_NWFILTER, but both are very similar\n         * warnings, so ignore the difference */\n        break;\n    case VIR_ERR_INVALID_NWFILTER:\n    case VIR_ERR_NO_NWFILTER:\n    case VIR_ERR_BUILD_FIREWALL:\n        /* server was trying to pass VIR_ERR_INVALID_SECRET,\n         * VIR_ERR_NO_SECRET, or VIR_ERR_CONFIG_UNSUPPORTED */\n        if (err.domain != VIR_FROM_NWFILTER)\n            err.code += 4;\n        break;\n    case VIR_WAR_NO_SECRET:\n        if (err.domain == VIR_FROM_QEMU)\n            err.code = VIR_ERR_OPERATION_TIMEOUT;\n        break;\n    case VIR_ERR_INVALID_SECRET:\n        if (err.domain == VIR_FROM_XEN)\n            err.code = VIR_ERR_MIGRATE_PERSIST_FAILED;\n        break;\n    default:\n        /* Nothing to alter. */\n        break;\n    }\n\n    if ((err.domain == VIR_FROM_REMOTE || err.domain == VIR_FROM_RPC) &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          VIR_ERR_NO_SUPPORT,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", *err.message);\n    } else {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          err.code,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", err.message ? *err.message : _(\"Unknown error\"));\n    }\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t)xdr_virNetMessageError",
            "(void*)&err"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virRaiseErrorFull",
          "args": [
            "__FILE__",
            "__FUNCTION__",
            "__LINE__",
            "err.domain",
            "err.code",
            "err.level",
            "err.str1 ? *err.str1 : NULL",
            "err.str2 ? *err.str2 : NULL",
            "err.str3 ? *err.str3 : NULL",
            "err.int1",
            "err.int2",
            "\"%s\"",
            "err.message ? *err.message : _(\"Unknown error\")"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virRaiseErrorFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "784-858",
          "snippet": "void\nvirRaiseErrorFull(const char *filename,\n                  const char *funcname,\n                  size_t linenr,\n                  int domain,\n                  int code,\n                  virErrorLevel level,\n                  const char *str1,\n                  const char *str2,\n                  const char *str3,\n                  int int1,\n                  int int2,\n                  const char *fmt, ...)\n{\n    int save_errno = errno;\n    virErrorPtr to;\n    char *str;\n    virLogMetadata meta[] = {\n        { .key = \"LIBVIRT_DOMAIN\", .s = NULL, .iv = domain },\n        { .key = \"LIBVIRT_CODE\", .s = NULL, .iv = code },\n        { .key = NULL },\n    };\n\n    /*\n     * All errors are recorded in thread local storage\n     * For compatibility, public API calls will copy them\n     * to the per-connection error object when necessary\n     */\n    to = virLastErrorObject();\n    if (!to) {\n        errno = save_errno;\n        return; /* Hit OOM allocating thread error object, sod all we can do now */\n    }\n\n    virResetError(to);\n\n    if (code == VIR_ERR_OK) {\n        errno = save_errno;\n        return;\n    }\n\n    /*\n     * formats the message; drop message on OOM situations\n     */\n    if (fmt == NULL) {\n        str = g_strdup(_(\"No error message provided\"));\n    } else {\n        va_list ap;\n        va_start(ap, fmt);\n        str = g_strdup_vprintf(fmt, ap);\n        va_end(ap);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    /*\n     * Deliberately not setting conn, dom & net fields since\n     * they're utterly unsafe\n     */\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    to->str1 = g_strdup(str1);\n    to->str2 = g_strdup(str2);\n    to->str3 = g_strdup(str3);\n    to->int1 = int1;\n    to->int2 = int2;\n\n    virRaiseErrorLog(filename, funcname, linenr,\n                     to, meta);\n\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirRaiseErrorFull(const char *filename,\n                  const char *funcname,\n                  size_t linenr,\n                  int domain,\n                  int code,\n                  virErrorLevel level,\n                  const char *str1,\n                  const char *str2,\n                  const char *str3,\n                  int int1,\n                  int int2,\n                  const char *fmt, ...)\n{\n    int save_errno = errno;\n    virErrorPtr to;\n    char *str;\n    virLogMetadata meta[] = {\n        { .key = \"LIBVIRT_DOMAIN\", .s = NULL, .iv = domain },\n        { .key = \"LIBVIRT_CODE\", .s = NULL, .iv = code },\n        { .key = NULL },\n    };\n\n    /*\n     * All errors are recorded in thread local storage\n     * For compatibility, public API calls will copy them\n     * to the per-connection error object when necessary\n     */\n    to = virLastErrorObject();\n    if (!to) {\n        errno = save_errno;\n        return; /* Hit OOM allocating thread error object, sod all we can do now */\n    }\n\n    virResetError(to);\n\n    if (code == VIR_ERR_OK) {\n        errno = save_errno;\n        return;\n    }\n\n    /*\n     * formats the message; drop message on OOM situations\n     */\n    if (fmt == NULL) {\n        str = g_strdup(_(\"No error message provided\"));\n    } else {\n        va_list ap;\n        va_start(ap, fmt);\n        str = g_strdup_vprintf(fmt, ap);\n        va_end(ap);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    /*\n     * Deliberately not setting conn, dom & net fields since\n     * they're utterly unsafe\n     */\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    to->str1 = g_strdup(str1);\n    to->str2 = g_strdup(str2);\n    to->str3 = g_strdup(str3);\n    to->int1 = int1;\n    to->int2 = int2;\n\n    virRaiseErrorLog(filename, funcname, linenr,\n                     to, meta);\n\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown error\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "*err.message",
            "\"unknown procedure\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "(xdrproc_t)xdr_virNetMessageError",
            "&err"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&err",
            "0",
            "sizeof(err)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetClientProgramDispatchError(virNetClientProgramPtr prog G_GNUC_UNUSED,\n                                 virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    /* Interop for virErrorNumber glitch in 0.8.0, if server is\n     * 0.7.1 through 0.7.7; see comments in virterror.h. */\n    switch (err.code) {\n    case VIR_WAR_NO_NWFILTER:\n        /* no way to tell old VIR_WAR_NO_SECRET apart from\n         * VIR_WAR_NO_NWFILTER, but both are very similar\n         * warnings, so ignore the difference */\n        break;\n    case VIR_ERR_INVALID_NWFILTER:\n    case VIR_ERR_NO_NWFILTER:\n    case VIR_ERR_BUILD_FIREWALL:\n        /* server was trying to pass VIR_ERR_INVALID_SECRET,\n         * VIR_ERR_NO_SECRET, or VIR_ERR_CONFIG_UNSUPPORTED */\n        if (err.domain != VIR_FROM_NWFILTER)\n            err.code += 4;\n        break;\n    case VIR_WAR_NO_SECRET:\n        if (err.domain == VIR_FROM_QEMU)\n            err.code = VIR_ERR_OPERATION_TIMEOUT;\n        break;\n    case VIR_ERR_INVALID_SECRET:\n        if (err.domain == VIR_FROM_XEN)\n            err.code = VIR_ERR_MIGRATE_PERSIST_FAILED;\n        break;\n    default:\n        /* Nothing to alter. */\n        break;\n    }\n\n    if ((err.domain == VIR_FROM_REMOTE || err.domain == VIR_FROM_RPC) &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          VIR_ERR_NO_SUPPORT,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", *err.message);\n    } else {\n        virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                          err.domain,\n                          err.code,\n                          err.level,\n                          err.str1 ? *err.str1 : NULL,\n                          err.str2 ? *err.str2 : NULL,\n                          err.str3 ? *err.str3 : NULL,\n                          err.int1,\n                          err.int2,\n                          \"%s\", err.message ? *err.message : _(\"Unknown error\"));\n    }\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientProgramMatches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "105-112",
    "snippet": "int virNetClientProgramMatches(virNetClientProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramMatches(virNetClientProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientProgramGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "99-102",
    "snippet": "unsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}"
  },
  {
    "function_name": "virNetClientProgramGetProgram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "93-96",
    "snippet": "unsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}"
  },
  {
    "function_name": "virNetClientProgramDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "88-90",
    "snippet": "void virNetClientProgramDispose(void *obj G_GNUC_UNUSED)\n{\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientProgramDispose(void *obj);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientProgramDispose(void *obj);\n\nvoid virNetClientProgramDispose(void *obj G_GNUC_UNUSED)\n{\n}"
  },
  {
    "function_name": "virNetClientProgramNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "64-85",
    "snippet": "virNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetClientProgramClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virNetClientProgramClass"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramInitialize",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientProgramClass;\n\nvirNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}"
  },
  {
    "function_name": "virNetClientProgramOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
    "lines": "53-59",
    "snippet": "static int virNetClientProgramOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetClientProgram, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetprotocol.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientprogram.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetClientProgram",
            "virClassForObject()"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientProgramOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetClientProgram, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  }
]