[
  {
    "function_name": "virSecurityDACDomainSetPathLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2532-2549",
    "snippet": "static int\nvirSecurityDACDomainSetPathLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 const char *path,\n                                 bool allowSubtree G_GNUC_UNUSED)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, path, user, group, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "path",
            "user",
            "group",
            "true"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "seclabel",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACDomainSetPathLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 const char *path,\n                                 bool allowSubtree G_GNUC_UNUSED)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, path, user, group, true);\n}"
  },
  {
    "function_name": "virSecurityDACGetBaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2524-2530",
    "snippet": "static const char *\nvirSecurityDACGetBaseLabel(virSecurityManagerPtr mgr,\n                           int virt G_GNUC_UNUSED)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    return priv->baselabel;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const char *\nvirSecurityDACGetBaseLabel(virSecurityManagerPtr mgr,\n                           int virt G_GNUC_UNUSED)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    return priv->baselabel;\n}"
  },
  {
    "function_name": "virSecurityDACGetMountOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2517-2522",
    "snippet": "static char *\nvirSecurityDACGetMountOptions(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr vm G_GNUC_UNUSED)\n{\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nvirSecurityDACGetMountOptions(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr vm G_GNUC_UNUSED)\n{\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityDACSetTapFDLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2509-2515",
    "snippet": "static int\nvirSecurityDACSetTapFDLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                            virDomainDefPtr def G_GNUC_UNUSED,\n                            int fd G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetTapFDLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                            virDomainDefPtr def G_GNUC_UNUSED,\n                            int fd G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetImageFDLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2501-2507",
    "snippet": "static int\nvirSecurityDACSetImageFDLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def G_GNUC_UNUSED,\n                              int fd G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetImageFDLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def G_GNUC_UNUSED,\n                              int fd G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACClearSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2494-2499",
    "snippet": "static int\nvirSecurityDACClearSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACClearSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2486-2491",
    "snippet": "static int\nvirSecurityDACSetSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                             virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                             virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetDaemonSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2478-2483",
    "snippet": "static int\nvirSecurityDACSetDaemonSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                   virDomainDefPtr vm G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetDaemonSocketLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                   virDomainDefPtr vm G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACGetProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2453-2476",
    "snippet": "static int\nvirSecurityDACGetProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def,\n                              pid_t pid,\n                              virSecurityLabelPtr seclabel)\n{\n    virSecurityLabelDefPtr secdef =\n        virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (secdef == NULL) {\n        VIR_DEBUG(\"missing label for DAC security \"\n                  \"driver in domain %s\", def->name);\n\n        if (virSecurityDACGetProcessLabelInternal(pid, seclabel) < 0)\n            return -1;\n        return 0;\n    }\n\n    if (secdef->label)\n        ignore_value(virStrcpy(seclabel->label, secdef->label,\n                               VIR_SECURITY_LABEL_BUFLEN));\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpy(seclabel->label, secdef->label,\n                               VIR_SECURITY_LABEL_BUFLEN)"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "seclabel->label",
            "secdef->label",
            "VIR_SECURITY_LABEL_BUFLEN"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetProcessLabelInternal",
          "args": [
            "pid",
            "seclabel"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACGetProcessLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "2443-2450",
          "snippet": "static int\nvirSecurityDACGetProcessLabelInternal(pid_t pid G_GNUC_UNUSED,\n                                      virSecurityLabelPtr seclabel G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot get process uid and gid on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACGetProcessLabelInternal(pid_t pid G_GNUC_UNUSED,\n                                      virSecurityLabelPtr seclabel G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot get process uid and gid on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"missing label for DAC security \"\n                  \"driver in domain %s\"",
            "def->name"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACGetProcessLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def,\n                              pid_t pid,\n                              virSecurityLabelPtr seclabel)\n{\n    virSecurityLabelDefPtr secdef =\n        virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (secdef == NULL) {\n        VIR_DEBUG(\"missing label for DAC security \"\n                  \"driver in domain %s\", def->name);\n\n        if (virSecurityDACGetProcessLabelInternal(pid, seclabel) < 0)\n            return -1;\n        return 0;\n    }\n\n    if (secdef->label)\n        ignore_value(virStrcpy(seclabel->label, secdef->label,\n                               VIR_SECURITY_LABEL_BUFLEN));\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACGetProcessLabelInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2443-2450",
    "snippet": "static int\nvirSecurityDACGetProcessLabelInternal(pid_t pid G_GNUC_UNUSED,\n                                      virSecurityLabelPtr seclabel G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot get process uid and gid on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Cannot get process uid and gid on this platform\")"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot get process uid and gid on this platform\""
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACGetProcessLabelInternal(pid_t pid G_GNUC_UNUSED,\n                                      virSecurityLabelPtr seclabel G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot get process uid and gid on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityDACGetProcessLabelInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2417-2441",
    "snippet": "static int\nvirSecurityDACGetProcessLabelInternal(pid_t pid,\n                                      virSecurityLabelPtr seclabel)\n{\n    struct kinfo_proc p;\n    int mib[4];\n    size_t len = 4;\n\n    sysctlnametomib(\"kern.proc.pid\", mib, &len);\n\n    len = sizeof(struct kinfo_proc);\n    mib[3] = pid;\n\n    if (sysctl(mib, 4, &p, &len, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to get PID %d uid and gid via sysctl\"),\n                             pid);\n        return -1;\n    }\n\n    g_snprintf(seclabel->label, VIR_SECURITY_LABEL_BUFLEN,\n               \"+%u:+%u\", (unsigned int)p.ki_uid, (unsigned int)p.ki_groups[0]);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "seclabel->label",
            "VIR_SECURITY_LABEL_BUFLEN",
            "\"+%u:+%u\"",
            "(unsigned int)p.ki_uid",
            "(unsigned int)p.ki_groups[0]"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get PID %d uid and gid via sysctl\")",
            "pid"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to get PID %d uid and gid via sysctl\""
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctl",
          "args": [
            "mib",
            "4",
            "&p",
            "&len",
            "NULL",
            "0"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlnametomib",
          "args": [
            "\"kern.proc.pid\"",
            "mib",
            "&len"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACGetProcessLabelInternal(pid_t pid,\n                                      virSecurityLabelPtr seclabel)\n{\n    struct kinfo_proc p;\n    int mib[4];\n    size_t len = 4;\n\n    sysctlnametomib(\"kern.proc.pid\", mib, &len);\n\n    len = sizeof(struct kinfo_proc);\n    mib[3] = pid;\n\n    if (sysctl(mib, 4, &p, &len, NULL, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to get PID %d uid and gid via sysctl\"),\n                             pid);\n        return -1;\n    }\n\n    g_snprintf(seclabel->label, VIR_SECURITY_LABEL_BUFLEN,\n               \"+%u:+%u\", (unsigned int)p.ki_uid, (unsigned int)p.ki_groups[0]);\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACGetProcessLabelInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2389-2415",
    "snippet": "static int\nvirSecurityDACGetProcessLabelInternal(pid_t pid,\n                                      virSecurityLabelPtr seclabel)\n{\n    struct stat sb;\n    char *path = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"Getting DAC user and group on process '%d'\", pid);\n\n    path = g_strdup_printf(\"/proc/%d\", (int)pid);\n\n    if (g_lstat(path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to get uid and gid for PID %d via procfs\"),\n                             pid);\n        goto cleanup;\n    }\n\n    g_snprintf(seclabel->label, VIR_SECURITY_LABEL_BUFLEN,\n               \"+%u:+%u\", (unsigned int)sb.st_uid, (unsigned int)sb.st_gid);\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "seclabel->label",
            "VIR_SECURITY_LABEL_BUFLEN",
            "\"+%u:+%u\"",
            "(unsigned int)sb.st_uid",
            "(unsigned int)sb.st_gid"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get uid and gid for PID %d via procfs\")",
            "pid"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to get uid and gid for PID %d via procfs\""
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_lstat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%d\"",
            "(int)pid"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Getting DAC user and group on process '%d'\"",
            "pid"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACGetProcessLabelInternal(pid_t pid,\n                                      virSecurityLabelPtr seclabel)\n{\n    struct stat sb;\n    char *path = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"Getting DAC user and group on process '%d'\", pid);\n\n    path = g_strdup_printf(\"/proc/%d\", (int)pid);\n\n    if (g_lstat(path, &sb) < 0) {\n        virReportSystemError(errno,\n                             _(\"unable to get uid and gid for PID %d via procfs\"),\n                             pid);\n        goto cleanup;\n    }\n\n    g_snprintf(seclabel->label, VIR_SECURITY_LABEL_BUFLEN,\n               \"+%u:+%u\", (unsigned int)sb.st_uid, (unsigned int)sb.st_gid);\n    ret = 0;\n\n cleanup:\n    VIR_FREE(path);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACReserveLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2380-2386",
    "snippet": "static int\nvirSecurityDACReserveLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                           virDomainDefPtr def G_GNUC_UNUSED,\n                           pid_t pid G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACReserveLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                           virDomainDefPtr def G_GNUC_UNUSED,\n                           pid_t pid G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACReleaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2373-2378",
    "snippet": "static int\nvirSecurityDACReleaseLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                           virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACReleaseLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                           virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACGenLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2309-2371",
    "snippet": "static int\nvirSecurityDACGenLabel(virSecurityManagerPtr mgr,\n                       virDomainDefPtr def)\n{\n    int rc = -1;\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel == NULL)\n        return rc;\n\n    if (seclabel->imagelabel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"security image label already \"\n                         \"defined for VM\"));\n        return rc;\n    }\n\n    if (seclabel->model\n        && STRNEQ(seclabel->model, SECURITY_DAC_NAME)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label model %s is not supported \"\n                         \"with selinux\"),\n                       seclabel->model);\n            return rc;\n    }\n\n    switch ((virDomainSeclabelType)seclabel->type) {\n    case VIR_DOMAIN_SECLABEL_STATIC:\n        if (seclabel->label == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing label for static security \"\n                             \"driver in domain %s\"), def->name);\n            return rc;\n        }\n        break;\n    case VIR_DOMAIN_SECLABEL_DYNAMIC:\n        seclabel->label = g_strdup_printf(\"+%u:+%u\", (unsigned int)priv->user,\n                                          (unsigned int)priv->group);\n        if (seclabel->label == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"cannot generate dac user and group id \"\n                             \"for domain %s\"), def->name);\n            return rc;\n        }\n        break;\n    case VIR_DOMAIN_SECLABEL_NONE:\n        /* no op */\n        return 0;\n    case VIR_DOMAIN_SECLABEL_DEFAULT:\n    case VIR_DOMAIN_SECLABEL_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected security label type '%s'\"),\n                       virDomainSeclabelTypeToString(seclabel->type));\n        return rc;\n    }\n\n    if (seclabel->relabel && !seclabel->imagelabel)\n        seclabel->imagelabel = g_strdup(seclabel->label);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "seclabel->label"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected security label type '%s'\")",
            "virDomainSeclabelTypeToString(seclabel->type)"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSeclabelTypeToString",
          "args": [
            "seclabel->type"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected security label type '%s'\""
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot generate dac user and group id \"\n                             \"for domain %s\")",
            "def->name"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing label for static security \"\n                             \"driver in domain %s\")",
            "def->name"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label model %s is not supported \"\n                         \"with selinux\")",
            "seclabel->model"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "seclabel->model",
            "SECURITY_DAC_NAME"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"security image label already \"\n                         \"defined for VM\")"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACGenLabel(virSecurityManagerPtr mgr,\n                       virDomainDefPtr def)\n{\n    int rc = -1;\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel == NULL)\n        return rc;\n\n    if (seclabel->imagelabel) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"security image label already \"\n                         \"defined for VM\"));\n        return rc;\n    }\n\n    if (seclabel->model\n        && STRNEQ(seclabel->model, SECURITY_DAC_NAME)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"security label model %s is not supported \"\n                         \"with selinux\"),\n                       seclabel->model);\n            return rc;\n    }\n\n    switch ((virDomainSeclabelType)seclabel->type) {\n    case VIR_DOMAIN_SECLABEL_STATIC:\n        if (seclabel->label == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing label for static security \"\n                             \"driver in domain %s\"), def->name);\n            return rc;\n        }\n        break;\n    case VIR_DOMAIN_SECLABEL_DYNAMIC:\n        seclabel->label = g_strdup_printf(\"+%u:+%u\", (unsigned int)priv->user,\n                                          (unsigned int)priv->group);\n        if (seclabel->label == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"cannot generate dac user and group id \"\n                             \"for domain %s\"), def->name);\n            return rc;\n        }\n        break;\n    case VIR_DOMAIN_SECLABEL_NONE:\n        /* no op */\n        return 0;\n    case VIR_DOMAIN_SECLABEL_DEFAULT:\n    case VIR_DOMAIN_SECLABEL_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected security label type '%s'\"),\n                       virDomainSeclabelTypeToString(seclabel->type));\n        return rc;\n    }\n\n    if (seclabel->relabel && !seclabel->imagelabel)\n        seclabel->imagelabel = g_strdup(seclabel->label);\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACVerify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2302-2307",
    "snippet": "static int\nvirSecurityDACVerify(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                     virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACVerify(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                     virDomainDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetChildProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2278-2299",
    "snippet": "static int\nvirSecurityDACSetChildProcessLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virCommandPtr cmd)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    uid_t user;\n    gid_t group;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting child to drop privileges to %u:%u\",\n              (unsigned int)user, (unsigned int)group);\n\n    virCommandSetUID(cmd, user);\n    virCommandSetGID(cmd, group);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandSetGID",
          "args": [
            "cmd",
            "group"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetGID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1111-1118",
          "snippet": "void\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetUID",
          "args": [
            "cmd",
            "user"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1120-1127",
          "snippet": "void\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting child to drop privileges to %u:%u\"",
            "(unsigned int)user",
            "(unsigned int)group"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "secdef",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetChildProcessLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virCommandPtr cmd)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    uid_t user;\n    gid_t group;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting child to drop privileges to %u:%u\",\n              (unsigned int)user, (unsigned int)group);\n\n    virCommandSetUID(cmd, user);\n    virCommandSetGID(cmd, group);\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2252-2275",
    "snippet": "static int\nvirSecurityDACSetProcessLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    uid_t user;\n    gid_t group;\n    gid_t *groups;\n    int ngroups;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, &groups, &ngroups) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Dropping privileges to %u:%u, %d supplemental groups\",\n              (unsigned int)user, (unsigned int)group, ngroups);\n\n    if (virSetUIDGID(user, group, groups, ngroups) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSetUIDGID",
          "args": [
            "user",
            "group",
            "groups",
            "ngroups"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "virSetUIDGID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1147-1156",
          "snippet": "int\nvirSetUIDGID(uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             gid_t *groups G_GNUC_UNUSED,\n             int ngroups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virSetUIDGID is not available\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirSetUIDGID(uid_t uid G_GNUC_UNUSED,\n             gid_t gid G_GNUC_UNUSED,\n             gid_t *groups G_GNUC_UNUSED,\n             int ngroups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"virSetUIDGID is not available\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dropping privileges to %u:%u, %d supplemental groups\"",
            "(unsigned int)user",
            "(unsigned int)group",
            "ngroups"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "secdef",
            "priv",
            "&user",
            "&group",
            "&groups",
            "&ngroups"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetProcessLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    uid_t user;\n    gid_t group;\n    gid_t *groups;\n    int ngroups;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, &groups, &ngroups) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Dropping privileges to %u:%u, %d supplemental groups\",\n              (unsigned int)user, (unsigned int)group, ngroups);\n\n    if (virSetUIDGID(user, group, groups, ngroups) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreSavedStateLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2238-2249",
    "snippet": "static int\nvirSecurityDACRestoreSavedStateLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def G_GNUC_UNUSED,\n                                     const char *savefile)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    return virSecurityDACRestoreFileLabel(mgr, savefile);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "savefile"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreSavedStateLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr def G_GNUC_UNUSED,\n                                     const char *savefile)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    return virSecurityDACRestoreFileLabel(mgr, savefile);\n}"
  },
  {
    "function_name": "virSecurityDACSetSavedStateLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2219-2235",
    "snippet": "static int\nvirSecurityDACSetSavedStateLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 const char *savefile)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    uid_t user;\n    gid_t group;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetImageIds(secdef, priv, &user, &group) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, savefile, user, group, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "savefile",
            "user",
            "group",
            "true"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetImageIds",
          "args": [
            "secdef",
            "priv",
            "&user",
            "&group"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetSavedStateLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def,\n                                 const char *savefile)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    uid_t user;\n    gid_t group;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (virSecurityDACGetImageIds(secdef, priv, &user, &group) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, savefile, user, group, true);\n}"
  },
  {
    "function_name": "virSecurityDACSetAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2106-2216",
    "snippet": "static int\nvirSecurityDACSetAllLabel(virSecurityManagerPtr mgr,\n                          virDomainDefPtr def,\n                          const char *stdin_path G_GNUC_UNUSED,\n                          bool chardevStdioLogd,\n                          bool migrated G_GNUC_UNUSED)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    size_t i;\n    uid_t user;\n    gid_t group;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* XXX fixme - we need to recursively label the entire tree :-( */\n        if (virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_DIR)\n            continue;\n        if (virSecurityDACSetImageLabel(mgr, def, def->disks[i]->src,\n                                        VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN |\n                                        VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ngraphics; i++) {\n        if (virSecurityDACSetGraphicsLabel(mgr, def, def->graphics[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecurityDACSetInputLabel(mgr, def, def->inputs[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecurityDACSetHostdevLabel(mgr,\n                                          def,\n                                          def->hostdevs[i],\n                                          NULL) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecurityDACSetMemoryLabel(mgr,\n                                         def,\n                                         def->mems[i]) < 0)\n            return -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd,\n    };\n\n    if (virDomainChrDefForeach(def,\n                               true,\n                               virSecurityDACSetChardevCallback,\n                               &chardevData) < 0)\n        return -1;\n\n    if (def->tpm) {\n        if (virSecurityDACSetTPMFileLabel(mgr,\n                                          def,\n                                          def->tpm) < 0)\n            return -1;\n    }\n\n    if (def->sev) {\n        if (virSecurityDACSetSEVLabel(mgr, def) < 0)\n            return -1;\n    }\n\n    if (virSecurityDACGetImageIds(secdef, priv, &user, &group))\n        return -1;\n\n    if (def->os.loader && def->os.loader->nvram &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.loader->nvram,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.kernel &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.kernel,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.initrd &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.initrd,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.dtb &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.dtb,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.slic_table &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.slic_table,\n                                   user, group, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "def->os.slic_table",
            "user",
            "group",
            "true"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetImageIds",
          "args": [
            "secdef",
            "priv",
            "&user",
            "&group"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetSEVLabel",
          "args": [
            "mgr",
            "def"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetSEVLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "2076-2103",
          "snippet": "static int\nvirSecurityDACSetSEVLabel(virSecurityManagerPtr mgr,\n                          virDomainDefPtr def)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* Skip chowning /dev/sev if namespaces are disabled as we'd significantly\n     * increase the chance of a DOS attack on SEV\n     */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, DEV_SEV,\n                                   user, group, true) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEV_SEV \"/dev/sev\"",
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define DEV_SEV \"/dev/sev\"\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetSEVLabel(virSecurityManagerPtr mgr,\n                          virDomainDefPtr def)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* Skip chowning /dev/sev if namespaces are disabled as we'd significantly\n     * increase the chance of a DOS attack on SEV\n     */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, DEV_SEV,\n                                   user, group, true) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetTPMFileLabel",
          "args": [
            "mgr",
            "def",
            "def->tpm"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetTPMFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1738-1761",
          "snippet": "static int\nvirSecurityDACSetTPMFileLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.passthrough.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.emulator.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetTPMFileLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.passthrough.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.emulator.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefForeach",
          "args": [
            "def",
            "true",
            "virSecurityDACSetChardevCallback",
            "&chardevData"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29835-29886",
          "snippet": "int\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetMemoryLabel",
          "args": [
            "mgr",
            "def",
            "def->mems[i]"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetMemoryLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "2039-2073",
          "snippet": "static int\nvirSecurityDACSetMemoryLabel(virSecurityManagerPtr mgr,\n                             virDomainDefPtr def,\n                             virDomainMemoryDefPtr mem)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n        if (seclabel && !seclabel->relabel)\n            return 0;\n\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         mem->nvdimmPath,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetMemoryLabel(virSecurityManagerPtr mgr,\n                             virDomainDefPtr def,\n                             virDomainMemoryDefPtr mem)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n        if (seclabel && !seclabel->relabel)\n            return 0;\n\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         mem->nvdimmPath,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetHostdevLabel",
          "args": [
            "mgr",
            "def",
            "def->hostdevs[i]",
            "NULL"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetHostdevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1230-1360",
          "snippet": "static int\nvirSecurityDACSetHostdevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainHostdevDefPtr dev,\n                              const char *vroot)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityDACCallbackData cbdata;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACSetImageLabel() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    cbdata.manager = mgr;\n    cbdata.secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (cbdata.secdef && !cbdata.secdef->relabel)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb,\n                                      virSecurityDACSetUSBLabel,\n                                      &cbdata);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACSetHostdevLabelHelper(vfioGroupDev,\n                                                      false,\n                                                      &cbdata);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci,\n                                          virSecurityDACSetPCILabel,\n                                          &cbdata);\n        }\n\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecurityDACSetSCSILabel,\n                                       &cbdata);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACSetHostLabel,\n                                            &cbdata);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACSetHostdevLabelHelper(vfiodev, true, &cbdata);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetHostdevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainHostdevDefPtr dev,\n                              const char *vroot)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityDACCallbackData cbdata;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACSetImageLabel() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    cbdata.manager = mgr;\n    cbdata.secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (cbdata.secdef && !cbdata.secdef->relabel)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb,\n                                      virSecurityDACSetUSBLabel,\n                                      &cbdata);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACSetHostdevLabelHelper(vfioGroupDev,\n                                                      false,\n                                                      &cbdata);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci,\n                                          virSecurityDACSetPCILabel,\n                                          &cbdata);\n        }\n\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecurityDACSetSCSILabel,\n                                       &cbdata);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACSetHostLabel,\n                                            &cbdata);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACSetHostdevLabelHelper(vfiodev, true, &cbdata);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetInputLabel",
          "args": [
            "mgr",
            "def",
            "def->inputs[i]"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetInputLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1834-1869",
          "snippet": "static int\nvirSecurityDACSetInputLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virDomainInputDefPtr input)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         input->source.evdev,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetInputLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virDomainInputDefPtr input)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         input->source.evdev,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetGraphicsLabel",
          "args": [
            "mgr",
            "def",
            "def->graphics[i]"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetGraphicsLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1787-1818",
          "snippet": "static int\nvirSecurityDACSetGraphicsLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def,\n                               virDomainGraphicsDefPtr gfx)\n\n{\n    const char *rendernode = virDomainGraphicsGetRenderNode(gfx);\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* There's nothing to relabel */\n    if (!rendernode)\n        return 0;\n\n    /* Skip chowning the shared render file if namespaces are disabled */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, rendernode, user, group, true) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetGraphicsLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def,\n                               virDomainGraphicsDefPtr gfx)\n\n{\n    const char *rendernode = virDomainGraphicsGetRenderNode(gfx);\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* There's nothing to relabel */\n    if (!rendernode)\n        return 0;\n\n    /* Skip chowning the shared render file if namespaces are disabled */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, rendernode, user, group, true) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetImageLabel",
          "args": [
            "mgr",
            "def",
            "def->disks[i]->src",
            "VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN |\n                                        VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetImageLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1003-1010",
          "snippet": "static int\nvirSecurityDACSetImageLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virStorageSourcePtr src,\n                            virSecurityDomainImageLabelFlags flags)\n{\n    return virSecurityDACSetImageLabelRelative(mgr, def, src, src, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetImageLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virStorageSourcePtr src,\n                            virSecurityDomainImageLabelFlags flags)\n{\n    return virSecurityDACSetImageLabelRelative(mgr, def, src, src, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "def->disks[i]"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetAllLabel(virSecurityManagerPtr mgr,\n                          virDomainDefPtr def,\n                          const char *stdin_path G_GNUC_UNUSED,\n                          bool chardevStdioLogd,\n                          bool migrated G_GNUC_UNUSED)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    size_t i;\n    uid_t user;\n    gid_t group;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    for (i = 0; i < def->ndisks; i++) {\n        /* XXX fixme - we need to recursively label the entire tree :-( */\n        if (virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_DIR)\n            continue;\n        if (virSecurityDACSetImageLabel(mgr, def, def->disks[i]->src,\n                                        VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN |\n                                        VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ngraphics; i++) {\n        if (virSecurityDACSetGraphicsLabel(mgr, def, def->graphics[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecurityDACSetInputLabel(mgr, def, def->inputs[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecurityDACSetHostdevLabel(mgr,\n                                          def,\n                                          def->hostdevs[i],\n                                          NULL) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecurityDACSetMemoryLabel(mgr,\n                                         def,\n                                         def->mems[i]) < 0)\n            return -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd,\n    };\n\n    if (virDomainChrDefForeach(def,\n                               true,\n                               virSecurityDACSetChardevCallback,\n                               &chardevData) < 0)\n        return -1;\n\n    if (def->tpm) {\n        if (virSecurityDACSetTPMFileLabel(mgr,\n                                          def,\n                                          def->tpm) < 0)\n            return -1;\n    }\n\n    if (def->sev) {\n        if (virSecurityDACSetSEVLabel(mgr, def) < 0)\n            return -1;\n    }\n\n    if (virSecurityDACGetImageIds(secdef, priv, &user, &group))\n        return -1;\n\n    if (def->os.loader && def->os.loader->nvram &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.loader->nvram,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.kernel &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.kernel,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.initrd &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.initrd,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.dtb &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.dtb,\n                                   user, group, true) < 0)\n        return -1;\n\n    if (def->os.slic_table &&\n        virSecurityDACSetOwnership(mgr, NULL,\n                                   def->os.slic_table,\n                                   user, group, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetSEVLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2076-2103",
    "snippet": "static int\nvirSecurityDACSetSEVLabel(virSecurityManagerPtr mgr,\n                          virDomainDefPtr def)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* Skip chowning /dev/sev if namespaces are disabled as we'd significantly\n     * increase the chance of a DOS attack on SEV\n     */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, DEV_SEV,\n                                   user, group, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DEV_SEV \"/dev/sev\"",
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "DEV_SEV",
            "user",
            "group",
            "true"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "seclabel",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define DEV_SEV \"/dev/sev\"\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetSEVLabel(virSecurityManagerPtr mgr,\n                          virDomainDefPtr def)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* Skip chowning /dev/sev if namespaces are disabled as we'd significantly\n     * increase the chance of a DOS attack on SEV\n     */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, DEV_SEV,\n                                   user, group, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetMemoryLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2039-2073",
    "snippet": "static int\nvirSecurityDACSetMemoryLabel(virSecurityManagerPtr mgr,\n                             virDomainDefPtr def,\n                             virDomainMemoryDefPtr mem)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n        if (seclabel && !seclabel->relabel)\n            return 0;\n\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         mem->nvdimmPath,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "mem->nvdimmPath",
            "user",
            "group",
            "true"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "seclabel",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetMemoryLabel(virSecurityManagerPtr mgr,\n                             virDomainDefPtr def,\n                             virDomainMemoryDefPtr mem)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n        if (seclabel && !seclabel->relabel)\n            return 0;\n\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         mem->nvdimmPath,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACSetChardevCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "2027-2036",
    "snippet": "static int\nvirSecurityDACSetChardevCallback(virDomainDefPtr def,\n                                 virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecurityDACSetChardevLabel(data->mgr, def, dev->source,\n                                         data->chardevStdioLogd);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetChardevLabel",
          "args": [
            "data->mgr",
            "def",
            "dev->source",
            "data->chardevStdioLogd"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1622-1630",
          "snippet": "static int\nvirSecurityDACSetChardevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainChrSourceDefPtr dev_source,\n                              bool chardevStdioLogd)\n{\n    return virSecurityDACSetChardevLabelHelper(mgr, def, dev_source,\n                                               chardevStdioLogd, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetChardevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainChrSourceDefPtr dev_source,\n                              bool chardevStdioLogd)\n{\n    return virSecurityDACSetChardevLabelHelper(mgr, def, dev_source,\n                                               chardevStdioLogd, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetChardevCallback(virDomainDefPtr def,\n                                 virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecurityDACSetChardevLabel(data->mgr, def, dev->source,\n                                         data->chardevStdioLogd);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1928-2024",
    "snippet": "static int\nvirSecurityDACRestoreAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              bool migrated,\n                              bool chardevStdioLogd)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    size_t i;\n    int rc = 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    VIR_DEBUG(\"Restoring security label on %s migrated=%d\",\n              def->name, migrated);\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (virSecurityDACRestoreImageLabelInt(mgr,\n                                               def,\n                                               def->disks[i]->src,\n                                               migrated) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->ngraphics; i++) {\n        if (virSecurityDACRestoreGraphicsLabel(mgr, def, def->graphics[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecurityDACRestoreInputLabel(mgr, def, def->inputs[i]) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecurityDACRestoreHostdevLabel(mgr,\n                                              def,\n                                              def->hostdevs[i],\n                                              NULL) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecurityDACRestoreMemoryLabel(mgr,\n                                             def,\n                                             def->mems[i]) < 0)\n            rc = -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd,\n    };\n\n    if (virDomainChrDefForeach(def,\n                               false,\n                               virSecurityDACRestoreChardevCallback,\n                               &chardevData) < 0)\n        rc = -1;\n\n    if (def->tpm) {\n        if (virSecurityDACRestoreTPMFileLabel(mgr,\n                                              def,\n                                              def->tpm) < 0)\n            rc = -1;\n    }\n\n    if (def->sev) {\n        if (virSecurityDACRestoreSEVLabel(mgr, def) < 0)\n            rc = -1;\n    }\n\n    if (def->os.loader && def->os.loader->nvram &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.loader->nvram) < 0)\n        rc = -1;\n\n    if (def->os.kernel &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.kernel) < 0)\n        rc = -1;\n\n    if (def->os.initrd &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.initrd) < 0)\n        rc = -1;\n\n    if (def->os.dtb &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.dtb) < 0)\n        rc = -1;\n\n    if (def->os.slic_table &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.slic_table) < 0)\n        rc = -1;\n\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "def->os.slic_table"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreSEVLabel",
          "args": [
            "mgr",
            "def"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreSEVLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1918-1925",
          "snippet": "static int\nvirSecurityDACRestoreSEVLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def G_GNUC_UNUSED)\n{\n    /* we only label /dev/sev when running with namespaces, so we don't need to\n     * restore anything */\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreSEVLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def G_GNUC_UNUSED)\n{\n    /* we only label /dev/sev when running with namespaces, so we don't need to\n     * restore anything */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreTPMFileLabel",
          "args": [
            "mgr",
            "def",
            "def->tpm"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreTPMFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1764-1784",
          "snippet": "static int\nvirSecurityDACRestoreTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreChardevLabelHelper(mgr, def,\n                                                      &tpm->data.passthrough.source,\n                                                      false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreChardevLabelHelper(mgr, def,\n                                                      &tpm->data.passthrough.source,\n                                                      false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefForeach",
          "args": [
            "def",
            "false",
            "virSecurityDACRestoreChardevCallback",
            "&chardevData"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29835-29886",
          "snippet": "int\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreMemoryLabel",
          "args": [
            "mgr",
            "def",
            "def->mems[i]"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreMemoryLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1895-1915",
          "snippet": "static int\nvirSecurityDACRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def G_GNUC_UNUSED,\n                                 virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        ret = virSecurityDACRestoreFileLabel(mgr, mem->nvdimmPath);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def G_GNUC_UNUSED,\n                                 virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        ret = virSecurityDACRestoreFileLabel(mgr, mem->nvdimmPath);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreHostdevLabel",
          "args": [
            "mgr",
            "def",
            "def->hostdevs[i]",
            "NULL"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreHostdevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1403-1523",
          "snippet": "static int\nvirSecurityDACRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACRestoreImageLabelInt() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecurityDACRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                         vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecurityDACRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecurityDACRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACRestoreFileLabel(mgr, vfiodev);\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACRestoreImageLabelInt() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecurityDACRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                         vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecurityDACRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecurityDACRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACRestoreFileLabel(mgr, vfiodev);\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreInputLabel",
          "args": [
            "mgr",
            "def",
            "def->inputs[i]"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreInputLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1871-1892",
          "snippet": "static int\nvirSecurityDACRestoreInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainInputDefPtr input)\n{\n    int ret = -1;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreFileLabel(mgr, input->source.evdev);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainInputDefPtr input)\n{\n    int ret = -1;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreFileLabel(mgr, input->source.evdev);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreGraphicsLabel",
          "args": [
            "mgr",
            "def",
            "def->graphics[i]"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreGraphicsLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1821-1831",
          "snippet": "static int\nvirSecurityDACRestoreGraphicsLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               virDomainDefPtr def G_GNUC_UNUSED,\n                               virDomainGraphicsDefPtr gfx G_GNUC_UNUSED)\n\n{\n    /* The only graphics labelling we do is dependent on mountNamespaces,\n       in which case 'restoring' the label doesn't actually accomplish\n       anything, so there's nothing to do here */\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreGraphicsLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               virDomainDefPtr def G_GNUC_UNUSED,\n                               virDomainGraphicsDefPtr gfx G_GNUC_UNUSED)\n\n{\n    /* The only graphics labelling we do is dependent on mountNamespaces,\n       in which case 'restoring' the label doesn't actually accomplish\n       anything, so there's nothing to do here */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreImageLabelInt",
          "args": [
            "mgr",
            "def",
            "def->disks[i]->src",
            "migrated"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreImageLabelInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1084-1101",
          "snippet": "static int\nvirSecurityDACRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virStorageSourcePtr src,\n                                   bool migrated)\n{\n    if (virSecurityDACRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecurityDACRestoreImageLabelSingle(mgr,\n                                              def,\n                                              src->externalDataStore,\n                                              migrated) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virStorageSourcePtr src,\n                                   bool migrated)\n{\n    if (virSecurityDACRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecurityDACRestoreImageLabelSingle(mgr,\n                                              def,\n                                              src->externalDataStore,\n                                              migrated) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Restoring security label on %s migrated=%d\"",
            "def->name",
            "migrated"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRestoreAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              bool migrated,\n                              bool chardevStdioLogd)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    size_t i;\n    int rc = 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    VIR_DEBUG(\"Restoring security label on %s migrated=%d\",\n              def->name, migrated);\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (virSecurityDACRestoreImageLabelInt(mgr,\n                                               def,\n                                               def->disks[i]->src,\n                                               migrated) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->ngraphics; i++) {\n        if (virSecurityDACRestoreGraphicsLabel(mgr, def, def->graphics[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (virSecurityDACRestoreInputLabel(mgr, def, def->inputs[i]) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (virSecurityDACRestoreHostdevLabel(mgr,\n                                              def,\n                                              def->hostdevs[i],\n                                              NULL) < 0)\n            rc = -1;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (virSecurityDACRestoreMemoryLabel(mgr,\n                                             def,\n                                             def->mems[i]) < 0)\n            rc = -1;\n    }\n\n    struct _virSecuritySELinuxChardevCallbackData chardevData = {\n        .mgr = mgr,\n        .chardevStdioLogd = chardevStdioLogd,\n    };\n\n    if (virDomainChrDefForeach(def,\n                               false,\n                               virSecurityDACRestoreChardevCallback,\n                               &chardevData) < 0)\n        rc = -1;\n\n    if (def->tpm) {\n        if (virSecurityDACRestoreTPMFileLabel(mgr,\n                                              def,\n                                              def->tpm) < 0)\n            rc = -1;\n    }\n\n    if (def->sev) {\n        if (virSecurityDACRestoreSEVLabel(mgr, def) < 0)\n            rc = -1;\n    }\n\n    if (def->os.loader && def->os.loader->nvram &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.loader->nvram) < 0)\n        rc = -1;\n\n    if (def->os.kernel &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.kernel) < 0)\n        rc = -1;\n\n    if (def->os.initrd &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.initrd) < 0)\n        rc = -1;\n\n    if (def->os.dtb &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.dtb) < 0)\n        rc = -1;\n\n    if (def->os.slic_table &&\n        virSecurityDACRestoreFileLabel(mgr, def->os.slic_table) < 0)\n        rc = -1;\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreSEVLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1918-1925",
    "snippet": "static int\nvirSecurityDACRestoreSEVLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def G_GNUC_UNUSED)\n{\n    /* we only label /dev/sev when running with namespaces, so we don't need to\n     * restore anything */\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreSEVLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                              virDomainDefPtr def G_GNUC_UNUSED)\n{\n    /* we only label /dev/sev when running with namespaces, so we don't need to\n     * restore anything */\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreMemoryLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1895-1915",
    "snippet": "static int\nvirSecurityDACRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def G_GNUC_UNUSED,\n                                 virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        ret = virSecurityDACRestoreFileLabel(mgr, mem->nvdimmPath);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "mem->nvdimmPath"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr def G_GNUC_UNUSED,\n                                 virDomainMemoryDefPtr mem)\n{\n    int ret = -1;\n\n    switch ((virDomainMemoryModel) mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n        ret = virSecurityDACRestoreFileLabel(mgr, mem->nvdimmPath);\n        break;\n\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreInputLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1871-1892",
    "snippet": "static int\nvirSecurityDACRestoreInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainInputDefPtr input)\n{\n    int ret = -1;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreFileLabel(mgr, input->source.evdev);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "input->source.evdev"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainInputDefPtr input)\n{\n    int ret = -1;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreFileLabel(mgr, input->source.evdev);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACSetInputLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1834-1869",
    "snippet": "static int\nvirSecurityDACSetInputLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virDomainInputDefPtr input)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         input->source.evdev,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "input->source.evdev",
            "user",
            "group",
            "true"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "seclabel",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetInputLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virDomainInputDefPtr input)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    switch ((virDomainInputType)input->type) {\n    case VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH:\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         input->source.evdev,\n                                         user, group, true);\n        break;\n\n    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n    case VIR_DOMAIN_INPUT_TYPE_KBD:\n    case VIR_DOMAIN_INPUT_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreGraphicsLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1821-1831",
    "snippet": "static int\nvirSecurityDACRestoreGraphicsLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               virDomainDefPtr def G_GNUC_UNUSED,\n                               virDomainGraphicsDefPtr gfx G_GNUC_UNUSED)\n\n{\n    /* The only graphics labelling we do is dependent on mountNamespaces,\n       in which case 'restoring' the label doesn't actually accomplish\n       anything, so there's nothing to do here */\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreGraphicsLabel(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               virDomainDefPtr def G_GNUC_UNUSED,\n                               virDomainGraphicsDefPtr gfx G_GNUC_UNUSED)\n\n{\n    /* The only graphics labelling we do is dependent on mountNamespaces,\n       in which case 'restoring' the label doesn't actually accomplish\n       anything, so there's nothing to do here */\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetGraphicsLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1787-1818",
    "snippet": "static int\nvirSecurityDACSetGraphicsLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def,\n                               virDomainGraphicsDefPtr gfx)\n\n{\n    const char *rendernode = virDomainGraphicsGetRenderNode(gfx);\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* There's nothing to relabel */\n    if (!rendernode)\n        return 0;\n\n    /* Skip chowning the shared render file if namespaces are disabled */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, rendernode, user, group, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "rendernode",
            "user",
            "group",
            "true"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "seclabel",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetRenderNode",
          "args": [
            "gfx"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetRenderNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32154-32175",
          "snippet": "const char *\nvirDomainGraphicsGetRenderNode(const virDomainGraphicsDef *graphics)\n{\n    const char *ret = NULL;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        ret = graphics->data.spice.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        ret = graphics->data.egl_headless.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainGraphicsGetRenderNode(const virDomainGraphicsDef *graphics)\n{\n    const char *ret = NULL;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        ret = graphics->data.spice.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        ret = graphics->data.egl_headless.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetGraphicsLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr def,\n                               virDomainGraphicsDefPtr gfx)\n\n{\n    const char *rendernode = virDomainGraphicsGetRenderNode(gfx);\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    uid_t user;\n    gid_t group;\n\n    /* There's nothing to relabel */\n    if (!rendernode)\n        return 0;\n\n    /* Skip chowning the shared render file if namespaces are disabled */\n    if (!priv->mountNamespace)\n        return 0;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (seclabel && !seclabel->relabel)\n        return 0;\n\n    if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    if (virSecurityDACSetOwnership(mgr, NULL, rendernode, user, group, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreTPMFileLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1764-1784",
    "snippet": "static int\nvirSecurityDACRestoreTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreChardevLabelHelper(mgr, def,\n                                                      &tpm->data.passthrough.source,\n                                                      false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreChardevLabelHelper",
          "args": [
            "mgr",
            "def",
            "&tpm->data.passthrough.source",
            "false",
            "false"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreChardevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1633-1706",
          "snippet": "static int\nvirSecurityDACRestoreChardevLabelHelper(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainChrSourceDefPtr dev_source,\n                                        bool chardevStdioLogd,\n                                        bool recall)\n{\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                     dev_source->data.file.path,\n                                                     recall);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACRestoreFileLabelInternal(mgr, NULL, out, recall) < 0 ||\n                virSecurityDACRestoreFileLabelInternal(mgr, NULL, in, recall) < 0)\n                goto done;\n        } else if (virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                          dev_source->data.file.path,\n                                                          recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen &&\n            virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                   dev_source->data.nix.path,\n                                                   recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreChardevLabelHelper(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainChrSourceDefPtr dev_source,\n                                        bool chardevStdioLogd,\n                                        bool recall)\n{\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                     dev_source->data.file.path,\n                                                     recall);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACRestoreFileLabelInternal(mgr, NULL, out, recall) < 0 ||\n                virSecurityDACRestoreFileLabelInternal(mgr, NULL, in, recall) < 0)\n                goto done;\n        } else if (virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                          dev_source->data.file.path,\n                                                          recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen &&\n            virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                   dev_source->data.nix.path,\n                                                   recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreTPMFileLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACRestoreChardevLabelHelper(mgr, def,\n                                                      &tpm->data.passthrough.source,\n                                                      false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        /* swtpm will have removed the Unix socket upon termination */\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACSetTPMFileLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1738-1761",
    "snippet": "static int\nvirSecurityDACSetTPMFileLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.passthrough.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.emulator.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetChardevLabelHelper",
          "args": [
            "mgr",
            "def",
            "&tpm->data.emulator.source",
            "false",
            "false"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetChardevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1526-1619",
          "snippet": "static int\nvirSecurityDACSetChardevLabelHelper(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainChrSourceDefPtr dev_source,\n                                    bool chardevStdioLogd,\n                                    bool remember)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel && chr_seclabel->label) {\n        if (virParseOwnershipIds(chr_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n    }\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         dev_source->data.file.path,\n                                         user, group, remember);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACSetOwnership(mgr, NULL, in, user, group, remember) < 0 ||\n                virSecurityDACSetOwnership(mgr, NULL, out, user, group, remember) < 0)\n                goto done;\n        } else if (virSecurityDACSetOwnership(mgr, NULL,\n                                              dev_source->data.file.path,\n                                              user, group, remember) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen ||\n            (dev_source->data.nix.path &&\n             virFileExists(dev_source->data.nix.path))) {\n            /* Also label mode='bind' sockets if they exist,\n             * e.g. because they were created by libvirt\n             * and passed via FD */\n            if (virSecurityDACSetOwnership(mgr, NULL,\n                                           dev_source->data.nix.path,\n                                           user, group, remember) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetChardevLabelHelper(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainChrSourceDefPtr dev_source,\n                                    bool chardevStdioLogd,\n                                    bool remember)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel && chr_seclabel->label) {\n        if (virParseOwnershipIds(chr_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n    }\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         dev_source->data.file.path,\n                                         user, group, remember);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACSetOwnership(mgr, NULL, in, user, group, remember) < 0 ||\n                virSecurityDACSetOwnership(mgr, NULL, out, user, group, remember) < 0)\n                goto done;\n        } else if (virSecurityDACSetOwnership(mgr, NULL,\n                                              dev_source->data.file.path,\n                                              user, group, remember) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen ||\n            (dev_source->data.nix.path &&\n             virFileExists(dev_source->data.nix.path))) {\n            /* Also label mode='bind' sockets if they exist,\n             * e.g. because they were created by libvirt\n             * and passed via FD */\n            if (virSecurityDACSetOwnership(mgr, NULL,\n                                           dev_source->data.nix.path,\n                                           user, group, remember) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetTPMFileLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainTPMDefPtr tpm)\n{\n    int ret = 0;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.passthrough.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        ret = virSecurityDACSetChardevLabelHelper(mgr, def,\n                                                  &tpm->data.emulator.source,\n                                                  false, false);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreChardevCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1726-1735",
    "snippet": "static int\nvirSecurityDACRestoreChardevCallback(virDomainDefPtr def,\n                                     virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                     void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecurityDACRestoreChardevLabel(data->mgr, def, dev->source,\n                                             data->chardevStdioLogd);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreChardevLabel",
          "args": [
            "data->mgr",
            "def",
            "dev->source",
            "data->chardevStdioLogd"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1709-1717",
          "snippet": "static int\nvirSecurityDACRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n{\n    return virSecurityDACRestoreChardevLabelHelper(mgr, def, dev_source,\n                                                   chardevStdioLogd, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n{\n    return virSecurityDACRestoreChardevLabelHelper(mgr, def, dev_source,\n                                                   chardevStdioLogd, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreChardevCallback(virDomainDefPtr def,\n                                     virDomainChrDefPtr dev G_GNUC_UNUSED,\n                                     void *opaque)\n{\n    struct _virSecuritySELinuxChardevCallbackData *data = opaque;\n\n    return virSecurityDACRestoreChardevLabel(data->mgr, def, dev->source,\n                                             data->chardevStdioLogd);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1709-1717",
    "snippet": "static int\nvirSecurityDACRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n{\n    return virSecurityDACRestoreChardevLabelHelper(mgr, def, dev_source,\n                                                   chardevStdioLogd, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreChardevLabelHelper",
          "args": [
            "mgr",
            "def",
            "dev_source",
            "chardevStdioLogd",
            "true"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreChardevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1633-1706",
          "snippet": "static int\nvirSecurityDACRestoreChardevLabelHelper(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainChrSourceDefPtr dev_source,\n                                        bool chardevStdioLogd,\n                                        bool recall)\n{\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                     dev_source->data.file.path,\n                                                     recall);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACRestoreFileLabelInternal(mgr, NULL, out, recall) < 0 ||\n                virSecurityDACRestoreFileLabelInternal(mgr, NULL, in, recall) < 0)\n                goto done;\n        } else if (virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                          dev_source->data.file.path,\n                                                          recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen &&\n            virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                   dev_source->data.nix.path,\n                                                   recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreChardevLabelHelper(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainChrSourceDefPtr dev_source,\n                                        bool chardevStdioLogd,\n                                        bool recall)\n{\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                     dev_source->data.file.path,\n                                                     recall);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACRestoreFileLabelInternal(mgr, NULL, out, recall) < 0 ||\n                virSecurityDACRestoreFileLabelInternal(mgr, NULL, in, recall) < 0)\n                goto done;\n        } else if (virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                          dev_source->data.file.path,\n                                                          recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen &&\n            virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                   dev_source->data.nix.path,\n                                                   recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n{\n    return virSecurityDACRestoreChardevLabelHelper(mgr, def, dev_source,\n                                                   chardevStdioLogd, true);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreChardevLabelHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1633-1706",
    "snippet": "static int\nvirSecurityDACRestoreChardevLabelHelper(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainChrSourceDefPtr dev_source,\n                                        bool chardevStdioLogd,\n                                        bool recall)\n{\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                     dev_source->data.file.path,\n                                                     recall);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACRestoreFileLabelInternal(mgr, NULL, out, recall) < 0 ||\n                virSecurityDACRestoreFileLabelInternal(mgr, NULL, in, recall) < 0)\n                goto done;\n        } else if (virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                          dev_source->data.file.path,\n                                                          recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen &&\n            virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                   dev_source->data.nix.path,\n                                                   recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [
      "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "out"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "in"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabelInternal",
          "args": [
            "mgr",
            "NULL",
            "dev_source->data.nix.path",
            "recall"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "847-885",
          "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "out"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.in\"",
            "dev_source->data.file.path"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrSourceDefGetSecurityLabelDef",
          "args": [
            "dev_source",
            "SECURITY_DAC_NAME"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrSourceDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30603-30617",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreChardevLabelHelper(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr def G_GNUC_UNUSED,\n                                        virDomainChrSourceDefPtr dev_source,\n                                        bool chardevStdioLogd,\n                                        bool recall)\n{\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                     dev_source->data.file.path,\n                                                     recall);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACRestoreFileLabelInternal(mgr, NULL, out, recall) < 0 ||\n                virSecurityDACRestoreFileLabelInternal(mgr, NULL, in, recall) < 0)\n                goto done;\n        } else if (virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                          dev_source->data.file.path,\n                                                          recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen &&\n            virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                   dev_source->data.nix.path,\n                                                   recall) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACSetChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1622-1630",
    "snippet": "static int\nvirSecurityDACSetChardevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainChrSourceDefPtr dev_source,\n                              bool chardevStdioLogd)\n{\n    return virSecurityDACSetChardevLabelHelper(mgr, def, dev_source,\n                                               chardevStdioLogd, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetChardevLabelHelper",
          "args": [
            "mgr",
            "def",
            "dev_source",
            "chardevStdioLogd",
            "true"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetChardevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1526-1619",
          "snippet": "static int\nvirSecurityDACSetChardevLabelHelper(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainChrSourceDefPtr dev_source,\n                                    bool chardevStdioLogd,\n                                    bool remember)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel && chr_seclabel->label) {\n        if (virParseOwnershipIds(chr_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n    }\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         dev_source->data.file.path,\n                                         user, group, remember);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACSetOwnership(mgr, NULL, in, user, group, remember) < 0 ||\n                virSecurityDACSetOwnership(mgr, NULL, out, user, group, remember) < 0)\n                goto done;\n        } else if (virSecurityDACSetOwnership(mgr, NULL,\n                                              dev_source->data.file.path,\n                                              user, group, remember) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen ||\n            (dev_source->data.nix.path &&\n             virFileExists(dev_source->data.nix.path))) {\n            /* Also label mode='bind' sockets if they exist,\n             * e.g. because they were created by libvirt\n             * and passed via FD */\n            if (virSecurityDACSetOwnership(mgr, NULL,\n                                           dev_source->data.nix.path,\n                                           user, group, remember) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetChardevLabelHelper(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainChrSourceDefPtr dev_source,\n                                    bool chardevStdioLogd,\n                                    bool remember)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel && chr_seclabel->label) {\n        if (virParseOwnershipIds(chr_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n    }\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         dev_source->data.file.path,\n                                         user, group, remember);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACSetOwnership(mgr, NULL, in, user, group, remember) < 0 ||\n                virSecurityDACSetOwnership(mgr, NULL, out, user, group, remember) < 0)\n                goto done;\n        } else if (virSecurityDACSetOwnership(mgr, NULL,\n                                              dev_source->data.file.path,\n                                              user, group, remember) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen ||\n            (dev_source->data.nix.path &&\n             virFileExists(dev_source->data.nix.path))) {\n            /* Also label mode='bind' sockets if they exist,\n             * e.g. because they were created by libvirt\n             * and passed via FD */\n            if (virSecurityDACSetOwnership(mgr, NULL,\n                                           dev_source->data.nix.path,\n                                           user, group, remember) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetChardevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainChrSourceDefPtr dev_source,\n                              bool chardevStdioLogd)\n{\n    return virSecurityDACSetChardevLabelHelper(mgr, def, dev_source,\n                                               chardevStdioLogd, true);\n}"
  },
  {
    "function_name": "virSecurityDACSetChardevLabelHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1526-1619",
    "snippet": "static int\nvirSecurityDACSetChardevLabelHelper(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainChrSourceDefPtr dev_source,\n                                    bool chardevStdioLogd,\n                                    bool remember)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel && chr_seclabel->label) {\n        if (virParseOwnershipIds(chr_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n    }\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         dev_source->data.file.path,\n                                         user, group, remember);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACSetOwnership(mgr, NULL, in, user, group, remember) < 0 ||\n                virSecurityDACSetOwnership(mgr, NULL, out, user, group, remember) < 0)\n                goto done;\n        } else if (virSecurityDACSetOwnership(mgr, NULL,\n                                              dev_source->data.file.path,\n                                              user, group, remember) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen ||\n            (dev_source->data.nix.path &&\n             virFileExists(dev_source->data.nix.path))) {\n            /* Also label mode='bind' sockets if they exist,\n             * e.g. because they were created by libvirt\n             * and passed via FD */\n            if (virSecurityDACSetOwnership(mgr, NULL,\n                                           dev_source->data.nix.path,\n                                           user, group, remember) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "out"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "in"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "dev_source->data.nix.path",
            "user",
            "group",
            "remember"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "dev_source->data.nix.path"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.out\"",
            "dev_source->data.file.path"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "seclabel",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virParseOwnershipIds",
          "args": [
            "chr_seclabel->label",
            "&user",
            "&group"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "virParseOwnershipIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1521-1564",
          "snippet": "int\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrSourceDefGetSecurityLabelDef",
          "args": [
            "dev_source",
            "SECURITY_DAC_NAME"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrSourceDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30603-30617",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityDeviceLabelDefPtr\nvirDomainChrSourceDefGetSecurityLabelDef(virDomainChrSourceDefPtr def,\n                                         const char *model)\n{\n    size_t i;\n\n    if (def == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (STREQ_NULLABLE(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetChardevLabelHelper(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virDomainChrSourceDefPtr dev_source,\n                                    bool chardevStdioLogd,\n                                    bool remember)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr seclabel;\n    virSecurityDeviceLabelDefPtr chr_seclabel = NULL;\n    char *in = NULL, *out = NULL;\n    int ret = -1;\n    uid_t user;\n    gid_t group;\n\n    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    chr_seclabel = virDomainChrSourceDefGetSecurityLabelDef(dev_source,\n                                                            SECURITY_DAC_NAME);\n\n    if (chr_seclabel && !chr_seclabel->relabel)\n        return 0;\n\n    if (!chr_seclabel &&\n        dev_source->type == VIR_DOMAIN_CHR_TYPE_FILE &&\n        chardevStdioLogd)\n        return 0;\n\n    if (chr_seclabel && chr_seclabel->label) {\n        if (virParseOwnershipIds(chr_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetIds(seclabel, priv, &user, &group, NULL, NULL) < 0)\n            return -1;\n    }\n\n    switch ((virDomainChrType)dev_source->type) {\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n        ret = virSecurityDACSetOwnership(mgr, NULL,\n                                         dev_source->data.file.path,\n                                         user, group, remember);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        in = g_strdup_printf(\"%s.in\", dev_source->data.file.path);\n        out = g_strdup_printf(\"%s.out\", dev_source->data.file.path);\n        if (virFileExists(in) && virFileExists(out)) {\n            if (virSecurityDACSetOwnership(mgr, NULL, in, user, group, remember) < 0 ||\n                virSecurityDACSetOwnership(mgr, NULL, out, user, group, remember) < 0)\n                goto done;\n        } else if (virSecurityDACSetOwnership(mgr, NULL,\n                                              dev_source->data.file.path,\n                                              user, group, remember) < 0) {\n            goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        if (!dev_source->data.nix.listen ||\n            (dev_source->data.nix.path &&\n             virFileExists(dev_source->data.nix.path))) {\n            /* Also label mode='bind' sockets if they exist,\n             * e.g. because they were created by libvirt\n             * and passed via FD */\n            if (virSecurityDACSetOwnership(mgr, NULL,\n                                           dev_source->data.nix.path,\n                                           user, group, remember) < 0)\n                goto done;\n        }\n        ret = 0;\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_SPICEPORT:\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    case VIR_DOMAIN_CHR_TYPE_SPICEVMC:\n    case VIR_DOMAIN_CHR_TYPE_NMDM:\n    case VIR_DOMAIN_CHR_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n done:\n    VIR_FREE(in);\n    VIR_FREE(out);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreHostdevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1403-1523",
    "snippet": "static int\nvirSecurityDACRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACRestoreImageLabelInt() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecurityDACRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                         vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecurityDACRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecurityDACRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACRestoreFileLabel(mgr, vfiodev);\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfiodev"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "vfiodev"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceGetIOMMUGroupDev",
          "args": [
            "mdevsrc->uuidstr"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "205-234",
          "snippet": "char *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nchar *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFree",
          "args": [
            "host"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "266-277",
          "snippet": "void\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFileIterate",
          "args": [
            "host",
            "virSecurityDACRestoreHostLabel",
            "mgr"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "225-231",
          "snippet": "int\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceNew",
          "args": [
            "hostsrc->wwpn"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "248-263",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\"\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFree",
          "args": [
            "scsi"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "242-257",
          "snippet": "void\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFileIterate",
          "args": [
            "scsi",
            "virSecurityDACRestoreSCSILabel",
            "mgr"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "331-337",
          "snippet": "int\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "dev->readonly",
            "dev->shareable"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pci"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFileIterate",
          "args": [
            "pci",
            "virSecurityDACRestorePCILabel",
            "mgr"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1720-1762",
          "snippet": "int virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfioGroupDev"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabelInternal",
          "args": [
            "mgr",
            "NULL",
            "vfioGroupDev",
            "false"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "847-885",
          "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetIOMMUGroupDev",
          "args": [
            "pci"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1971-1995",
          "snippet": "char *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFree",
          "args": [
            "usb"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "353-363",
          "snippet": "void\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFileIterate",
          "args": [
            "usb",
            "virSecurityDACRestoreUSBLabel",
            "mgr"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "409-414",
          "snippet": "int virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "vroot"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (!priv->dynamicOwnership || (secdef && !secdef->relabel))\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACRestoreImageLabelInt() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb, virSecurityDACRestoreUSBLabel, mgr);\n        virUSBDeviceFree(usb);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACRestoreFileLabelInternal(mgr, NULL,\n                                                         vfioGroupDev, false);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci, virSecurityDACRestorePCILabel, mgr);\n        }\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi, virSecurityDACRestoreSCSILabel, mgr);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACRestoreHostLabel,\n                                            mgr);\n        virSCSIVHostDeviceFree(host);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACRestoreFileLabel(mgr, vfiodev);\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreHostLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1393-1400",
    "snippet": "static int\nvirSecurityDACRestoreHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                               const char *file,\n                               void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "file"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                               const char *file,\n                               void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreSCSILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1383-1390",
    "snippet": "static int\nvirSecurityDACRestoreSCSILabel(virSCSIDevicePtr dev G_GNUC_UNUSED,\n                               const char *file,\n                               void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "file"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreSCSILabel(virSCSIDevicePtr dev G_GNUC_UNUSED,\n                               const char *file,\n                               void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreUSBLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1373-1380",
    "snippet": "static int\nvirSecurityDACRestoreUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                              const char *file,\n                              void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "file"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                              const char *file,\n                              void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}"
  },
  {
    "function_name": "virSecurityDACRestorePCILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1363-1370",
    "snippet": "static int\nvirSecurityDACRestorePCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                              const char *file,\n                              void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabel",
          "args": [
            "mgr",
            "file"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "888-893",
          "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestorePCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                              const char *file,\n                              void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityDACRestoreFileLabel(mgr, file);\n}"
  },
  {
    "function_name": "virSecurityDACSetHostdevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1230-1360",
    "snippet": "static int\nvirSecurityDACSetHostdevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainHostdevDefPtr dev,\n                              const char *vroot)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityDACCallbackData cbdata;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACSetImageLabel() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    cbdata.manager = mgr;\n    cbdata.secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (cbdata.secdef && !cbdata.secdef->relabel)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb,\n                                      virSecurityDACSetUSBLabel,\n                                      &cbdata);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACSetHostdevLabelHelper(vfioGroupDev,\n                                                      false,\n                                                      &cbdata);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci,\n                                          virSecurityDACSetPCILabel,\n                                          &cbdata);\n        }\n\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecurityDACSetSCSILabel,\n                                       &cbdata);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACSetHostLabel,\n                                            &cbdata);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACSetHostdevLabelHelper(vfiodev, true, &cbdata);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfiodev"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetHostdevLabelHelper",
          "args": [
            "vfiodev",
            "true",
            "&cbdata"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1175-1191",
          "snippet": "static int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceGetIOMMUGroupDev",
          "args": [
            "mdevsrc->uuidstr"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "205-234",
          "snippet": "char *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nchar *\nvirMediatedDeviceGetIOMMUGroupDev(const char *uuidstr)\n{\n    g_autofree char *result_path = NULL;\n    g_autofree char *result_file = NULL;\n    g_autofree char *iommu_path = NULL;\n    g_autofree char *dev_path = virMediatedDeviceGetSysfsPath(uuidstr);\n    char *vfio_path = NULL;\n\n    if (!dev_path)\n        return NULL;\n\n    iommu_path = g_strdup_printf(\"%s/iommu_group\", dev_path);\n\n    if (!virFileExists(iommu_path)) {\n        virReportSystemError(errno, _(\"failed to access '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    if (virFileResolveLink(iommu_path, &result_path) < 0) {\n        virReportSystemError(errno, _(\"failed to resolve '%s'\"), iommu_path);\n        return NULL;\n    }\n\n    result_file = g_path_get_basename(result_path);\n\n    vfio_path = g_strdup_printf(\"/dev/vfio/%s\", result_file);\n\n    return vfio_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFree",
          "args": [
            "host"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "266-277",
          "snippet": "void\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirSCSIVHostDeviceFree(virSCSIVHostDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s: freeing\", dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceFileIterate",
          "args": [
            "host",
            "virSecurityDACSetHostLabel",
            "&cbdata"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "225-231",
          "snippet": "int\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirSCSIVHostDeviceFileIterate(virSCSIVHostDevicePtr dev,\n                              virSCSIVHostDeviceFileActor actor,\n                              void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceNew",
          "args": [
            "hostsrc->wwpn"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "248-263",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\"\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFree",
          "args": [
            "scsi"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "242-257",
          "snippet": "void\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirSCSIDeviceFree(virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->id);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->sg_path);\n    for (i = 0; i < dev->n_used_by; i++)\n        virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n    VIR_FREE(dev->used_by);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceFileIterate",
          "args": [
            "scsi",
            "virSecurityDACSetSCSILabel",
            "&cbdata"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "331-337",
          "snippet": "int\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceFileIterate(virSCSIDevicePtr dev,\n                         virSCSIDeviceFileActor actor,\n                         void *opaque)\n{\n    return (actor)(dev, dev->sg_path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "dev->readonly",
            "dev->shareable"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pci"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFileIterate",
          "args": [
            "pci",
            "virSecurityDACSetPCILabel",
            "&cbdata"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1720-1762",
          "snippet": "int virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfioGroupDev"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetIOMMUGroupDev",
          "args": [
            "pci"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1971-1995",
          "snippet": "char *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFree",
          "args": [
            "usb"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "353-363",
          "snippet": "void\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFileIterate",
          "args": [
            "usb",
            "virSecurityDACSetUSBLabel",
            "&cbdata"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "409-414",
          "snippet": "int virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "vroot"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACSetHostdevLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr def,\n                              virDomainHostdevDefPtr dev,\n                              const char *vroot)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityDACCallbackData cbdata;\n    virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n    virDomainHostdevSubsysPCIPtr pcisrc = &dev->source.subsys.u.pci;\n    virDomainHostdevSubsysSCSIPtr scsisrc = &dev->source.subsys.u.scsi;\n    virDomainHostdevSubsysSCSIVHostPtr hostsrc = &dev->source.subsys.u.scsi_host;\n    virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n    int ret = -1;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n        return 0;\n\n    /* Like virSecurityDACSetImageLabel() for a networked disk,\n     * do nothing for an iSCSI hostdev\n     */\n    if (dev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI &&\n        scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n        return 0;\n\n    cbdata.manager = mgr;\n    cbdata.secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n\n    if (cbdata.secdef && !cbdata.secdef->relabel)\n        return 0;\n\n    switch ((virDomainHostdevSubsysType)dev->source.subsys.type) {\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n        virUSBDevicePtr usb;\n\n        if (dev->missing)\n            return 0;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, vroot)))\n            return -1;\n\n        ret = virUSBDeviceFileIterate(usb,\n                                      virSecurityDACSetUSBLabel,\n                                      &cbdata);\n        virUSBDeviceFree(usb);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n        virPCIDevicePtr pci =\n            virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                            pcisrc->addr.slot, pcisrc->addr.function);\n\n        if (!pci)\n            return -1;\n\n        if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n            char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);\n\n            if (!vfioGroupDev) {\n                virPCIDeviceFree(pci);\n                return -1;\n            }\n            ret = virSecurityDACSetHostdevLabelHelper(vfioGroupDev,\n                                                      false,\n                                                      &cbdata);\n            VIR_FREE(vfioGroupDev);\n        } else {\n            ret = virPCIDeviceFileIterate(pci,\n                                          virSecurityDACSetPCILabel,\n                                          &cbdata);\n        }\n\n        virPCIDeviceFree(pci);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: {\n        virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n        virSCSIDevicePtr scsi =\n            virSCSIDeviceNew(NULL,\n                             scsihostsrc->adapter, scsihostsrc->bus,\n                             scsihostsrc->target, scsihostsrc->unit,\n                             dev->readonly, dev->shareable);\n\n        if (!scsi)\n            return -1;\n\n        ret = virSCSIDeviceFileIterate(scsi,\n                                       virSecurityDACSetSCSILabel,\n                                       &cbdata);\n        virSCSIDeviceFree(scsi);\n\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST: {\n        virSCSIVHostDevicePtr host = virSCSIVHostDeviceNew(hostsrc->wwpn);\n\n        if (!host)\n            return -1;\n\n        ret = virSCSIVHostDeviceFileIterate(host,\n                                            virSecurityDACSetHostLabel,\n                                            &cbdata);\n        virSCSIVHostDeviceFree(host);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n        char *vfiodev = NULL;\n\n        if (!(vfiodev = virMediatedDeviceGetIOMMUGroupDev(mdevsrc->uuidstr)))\n            return -1;\n\n        ret = virSecurityDACSetHostdevLabelHelper(vfiodev, true, &cbdata);\n\n        VIR_FREE(vfiodev);\n        break;\n    }\n\n    case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n        ret = 0;\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACSetHostLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1221-1227",
    "snippet": "static int\nvirSecurityDACSetHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                           const char *file,\n                           void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1175-1191",
          "snippet": "static int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetHostLabel(virSCSIVHostDevicePtr dev G_GNUC_UNUSED,\n                           const char *file,\n                           void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecurityDACSetSCSILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1212-1218",
    "snippet": "static int\nvirSecurityDACSetSCSILabel(virSCSIDevicePtr dev G_GNUC_UNUSED,\n                           const char *file,\n                           void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1175-1191",
          "snippet": "static int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetSCSILabel(virSCSIDevicePtr dev G_GNUC_UNUSED,\n                           const char *file,\n                           void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecurityDACSetUSBLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1203-1209",
    "snippet": "static int\nvirSecurityDACSetUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                          const char *file,\n                          void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1175-1191",
          "snippet": "static int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetUSBLabel(virUSBDevicePtr dev G_GNUC_UNUSED,\n                          const char *file,\n                          void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecurityDACSetPCILabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1194-1200",
    "snippet": "static int\nvirSecurityDACSetPCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                          const char *file,\n                          void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetHostdevLabelHelper",
          "args": [
            "file",
            "true",
            "opaque"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetHostdevLabelHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1175-1191",
          "snippet": "static int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetPCILabel(virPCIDevicePtr dev G_GNUC_UNUSED,\n                          const char *file,\n                          void *opaque)\n{\n    return virSecurityDACSetHostdevLabelHelper(file, true, opaque);\n}"
  },
  {
    "function_name": "virSecurityDACSetHostdevLabelHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1175-1191",
    "snippet": "static int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "NULL",
            "file",
            "user",
            "group",
            "remember"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "secdef",
            "priv",
            "&user",
            "&group",
            "NULL",
            "NULL"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetHostdevLabelHelper(const char *file,\n                                    bool remember,\n                                    void *opaque)\n{\n    virSecurityDACCallbackDataPtr cbdata = opaque;\n    virSecurityManagerPtr mgr = cbdata->manager;\n    virSecurityLabelDefPtr secdef = cbdata->secdef;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    uid_t user;\n    gid_t group;\n\n    if (virSecurityDACGetIds(secdef, priv, &user, &group, NULL, NULL) < 0)\n        return -1;\n\n    return virSecurityDACSetOwnership(mgr, NULL, file, user, group, remember);\n}"
  },
  {
    "function_name": "virSecurityDACMoveImageMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1139-1172",
    "snippet": "static int\nvirSecurityDACMoveImageMetadata(virSecurityManagerPtr mgr,\n                                pid_t pid,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr dst)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    struct virSecurityDACMoveImageMetadataData data = { .mgr = mgr, 0 };\n    int rc;\n\n    /* If dynamicOwnership is turned off, or owner remembering is\n     * not enabled there's nothing for us to do. */\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    if (src && virStorageSourceIsLocalStorage(src))\n        data.src = src->path;\n\n    if (dst && virStorageSourceIsLocalStorage(dst))\n        data.dst = dst->path;\n\n    if (!data.src)\n        return 0;\n\n    if (pid == -1) {\n        rc = virProcessRunInFork(virSecurityDACMoveImageMetadataHelper, &data);\n    } else {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecurityDACMoveImageMetadataHelper,\n                                           &data);\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virProcessRunInMountNamespace",
          "args": [
            "pid",
            "virSecurityDACMoveImageMetadataHelper",
            "&data"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInMountNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1115-1123",
          "snippet": "int\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessRunInFork",
          "args": [
            "virSecurityDACMoveImageMetadataHelper",
            "&data"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInFork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1267-1274",
          "snippet": "int\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "dst"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACMoveImageMetadata(virSecurityManagerPtr mgr,\n                                pid_t pid,\n                                virStorageSourcePtr src,\n                                virStorageSourcePtr dst)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    struct virSecurityDACMoveImageMetadataData data = { .mgr = mgr, 0 };\n    int rc;\n\n    /* If dynamicOwnership is turned off, or owner remembering is\n     * not enabled there's nothing for us to do. */\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    if (src && virStorageSourceIsLocalStorage(src))\n        data.src = src->path;\n\n    if (dst && virStorageSourceIsLocalStorage(dst))\n        data.dst = dst->path;\n\n    if (!data.src)\n        return 0;\n\n    if (pid == -1) {\n        rc = virProcessRunInFork(virSecurityDACMoveImageMetadataHelper, &data);\n    } else {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecurityDACMoveImageMetadataHelper,\n                                           &data);\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virSecurityDACMoveImageMetadataHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1121-1136",
    "snippet": "static int\nvirSecurityDACMoveImageMetadataHelper(pid_t pid G_GNUC_UNUSED,\n                                      void *opaque)\n{\n    struct virSecurityDACMoveImageMetadataData *data = opaque;\n    const char *paths[2] = { data->src, data->dst };\n    virSecurityManagerMetadataLockStatePtr state;\n    int ret;\n\n    if (!(state = virSecurityManagerMetadataLock(data->mgr, paths, G_N_ELEMENTS(paths))))\n        return -1;\n\n    ret = virSecurityMoveRememberedLabel(SECURITY_DAC_NAME, data->src, data->dst);\n    virSecurityManagerMetadataUnlock(data->mgr, &state);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataUnlock",
          "args": [
            "data->mgr",
            "&state"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1400-1429",
          "snippet": "void\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvoid\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityMoveRememberedLabel",
          "args": [
            "SECURITY_DAC_NAME",
            "data->src",
            "data->dst"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityMoveRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "444-530",
          "snippet": "int\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityMoveRememberedLabel(const char *name,\n                               const char *src,\n                               const char *dst)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *ref_value = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *attr_value = NULL;\n    g_autofree char *timestamp_name = NULL;\n    g_autofree char *timestamp_value = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)) ||\n        !(attr_name = virSecurityGetAttrName(name)) ||\n        !(timestamp_name = virSecurityGetTimestampAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(src, ref_name, &ref_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, attr_name, &attr_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (virFileGetXAttrQuiet(src, timestamp_name, &timestamp_value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 attr_name, src);\n            return -1;\n        }\n    }\n\n    if (ref_value &&\n        virFileRemoveXAttr(src, ref_name) < 0) {\n        return -1;\n    }\n\n    if (attr_value &&\n        virFileRemoveXAttr(src, attr_name) < 0) {\n        return -1;\n    }\n\n    if (timestamp_value &&\n        virFileRemoveXAttr(src, timestamp_name) < 0) {\n        return -1;\n    }\n\n    if (dst) {\n        if (ref_value &&\n            virFileSetXAttr(dst, ref_name, ref_value) < 0) {\n            return -1;\n        }\n\n        if (attr_value &&\n            virFileSetXAttr(dst, attr_name, attr_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            return -1;\n        }\n\n        if (timestamp_value &&\n            virFileSetXAttr(dst, timestamp_name, timestamp_value) < 0) {\n            ignore_value(virFileRemoveXAttr(dst, ref_name));\n            ignore_value(virFileRemoveXAttr(dst, attr_name));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataLock",
          "args": [
            "data->mgr",
            "paths",
            "G_N_ELEMENTS(paths)"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1283-1397",
          "snippet": "virSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvirSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "paths"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACMoveImageMetadataHelper(pid_t pid G_GNUC_UNUSED,\n                                      void *opaque)\n{\n    struct virSecurityDACMoveImageMetadataData *data = opaque;\n    const char *paths[2] = { data->src, data->dst };\n    virSecurityManagerMetadataLockStatePtr state;\n    int ret;\n\n    if (!(state = virSecurityManagerMetadataLock(data->mgr, paths, G_N_ELEMENTS(paths))))\n        return -1;\n\n    ret = virSecurityMoveRememberedLabel(SECURITY_DAC_NAME, data->src, data->dst);\n    virSecurityManagerMetadataUnlock(data->mgr, &state);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1104-1111",
    "snippet": "static int\nvirSecurityDACRestoreImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags G_GNUC_UNUSED)\n{\n    return virSecurityDACRestoreImageLabelInt(mgr, def, src, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreImageLabelInt",
          "args": [
            "mgr",
            "def",
            "src",
            "false"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreImageLabelInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1084-1101",
          "snippet": "static int\nvirSecurityDACRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virStorageSourcePtr src,\n                                   bool migrated)\n{\n    if (virSecurityDACRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecurityDACRestoreImageLabelSingle(mgr,\n                                              def,\n                                              src->externalDataStore,\n                                              migrated) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virStorageSourcePtr src,\n                                   bool migrated)\n{\n    if (virSecurityDACRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecurityDACRestoreImageLabelSingle(mgr,\n                                              def,\n                                              src->externalDataStore,\n                                              migrated) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr def,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags G_GNUC_UNUSED)\n{\n    return virSecurityDACRestoreImageLabelInt(mgr, def, src, false);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreImageLabelInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1084-1101",
    "snippet": "static int\nvirSecurityDACRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virStorageSourcePtr src,\n                                   bool migrated)\n{\n    if (virSecurityDACRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecurityDACRestoreImageLabelSingle(mgr,\n                                              def,\n                                              src->externalDataStore,\n                                              migrated) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreImageLabelSingle",
          "args": [
            "mgr",
            "def",
            "src->externalDataStore",
            "migrated"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreImageLabelSingle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "1012-1081",
          "snippet": "static int\nvirSecurityDACRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virStorageSourcePtr src,\n                                      bool migrated)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    /* Don't restore labels on readoly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_DAC_NAME);\n    if (disk_seclabel && !disk_seclabel->relabel)\n        return 0;\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n\n        return virSecurityDACRestoreFileLabelInternal(mgr, NULL, vfioGroupDev, false);\n    }\n\n    return virSecurityDACRestoreFileLabelInternal(mgr, src, NULL, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virStorageSourcePtr src,\n                                      bool migrated)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    /* Don't restore labels on readoly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_DAC_NAME);\n    if (disk_seclabel && !disk_seclabel->relabel)\n        return 0;\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n\n        return virSecurityDACRestoreFileLabelInternal(mgr, NULL, vfioGroupDev, false);\n    }\n\n    return virSecurityDACRestoreFileLabelInternal(mgr, src, NULL, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreImageLabelInt(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def,\n                                   virStorageSourcePtr src,\n                                   bool migrated)\n{\n    if (virSecurityDACRestoreImageLabelSingle(mgr, def, src, migrated) < 0)\n        return -1;\n\n    if (src->externalDataStore &&\n        virSecurityDACRestoreImageLabelSingle(mgr,\n                                              def,\n                                              src->externalDataStore,\n                                              migrated) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACRestoreImageLabelSingle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1012-1081",
    "snippet": "static int\nvirSecurityDACRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virStorageSourcePtr src,\n                                      bool migrated)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    /* Don't restore labels on readoly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_DAC_NAME);\n    if (disk_seclabel && !disk_seclabel->relabel)\n        return 0;\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n\n        return virSecurityDACRestoreFileLabelInternal(mgr, NULL, vfioGroupDev, false);\n    }\n\n    return virSecurityDACRestoreFileLabelInternal(mgr, src, NULL, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabelInternal",
          "args": [
            "mgr",
            "src",
            "NULL",
            "true"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "847-885",
          "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupDev",
          "args": [
            "&nvme->pciAddr"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1953-1965",
          "snippet": "char *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping image label restore on %s because FS is shared\"",
            "src->path"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsSharedFS",
          "args": [
            "src->path"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsSharedFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3699-3712",
          "snippet": "int virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetSecurityLabelDef",
          "args": [
            "src",
            "SECURITY_DAC_NAME"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2105-2117",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRestoreImageLabelSingle(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virStorageSourcePtr src,\n                                      bool migrated)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    /* Don't restore labels on readoly/shared disks, because other VMs may\n     * still be accessing these. Alternatively we could iterate over all\n     * running domains and try to figure out if it is in use, but this would\n     * not work for clustered filesystems, since we can't see running VMs using\n     * the file on other nodes. Safest bet is thus to skip the restore step. */\n    if (src->readonly || src->shared)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src,\n                                                        SECURITY_DAC_NAME);\n    if (disk_seclabel && !disk_seclabel->relabel)\n        return 0;\n\n    /* If we have a shared FS and are doing migration, we must not change\n     * ownership, because that kills access on the destination host which is\n     * sub-optimal for the guest VM's I/O attempts :-) */\n    if (migrated) {\n        int rc = 1;\n\n        if (virStorageSourceIsLocalStorage(src)) {\n            if (!src->path)\n                return 0;\n\n            if ((rc = virFileIsSharedFS(src->path)) < 0)\n                return -1;\n        }\n\n        if (rc == 1) {\n            VIR_DEBUG(\"Skipping image label restore on %s because FS is shared\",\n                      src->path);\n            return 0;\n        }\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        /* Ideally, we would check if there is not another PCI\n         * device within domain def that is in the same IOMMU\n         * group. But we're not doing that for hostdevs yet. */\n\n        return virSecurityDACRestoreFileLabelInternal(mgr, NULL, vfioGroupDev, false);\n    }\n\n    return virSecurityDACRestoreFileLabelInternal(mgr, src, NULL, true);\n}"
  },
  {
    "function_name": "virSecurityDACSetImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "1003-1010",
    "snippet": "static int\nvirSecurityDACSetImageLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virStorageSourcePtr src,\n                            virSecurityDomainImageLabelFlags flags)\n{\n    return virSecurityDACSetImageLabelRelative(mgr, def, src, src, flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetImageLabelRelative",
          "args": [
            "mgr",
            "def",
            "src",
            "src",
            "flags"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetImageLabelRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "971-1001",
          "snippet": "static int\nvirSecurityDACSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecurityDACSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecurityDACSetImageLabelRelative(mgr,\n                                                def,\n                                                n->externalDataStore,\n                                                parent,\n                                                flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecurityDACSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecurityDACSetImageLabelRelative(mgr,\n                                                def,\n                                                n->externalDataStore,\n                                                parent,\n                                                flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetImageLabel(virSecurityManagerPtr mgr,\n                            virDomainDefPtr def,\n                            virStorageSourcePtr src,\n                            virSecurityDomainImageLabelFlags flags)\n{\n    return virSecurityDACSetImageLabelRelative(mgr, def, src, src, flags);\n}"
  },
  {
    "function_name": "virSecurityDACSetImageLabelRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "971-1001",
    "snippet": "static int\nvirSecurityDACSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecurityDACSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecurityDACSetImageLabelRelative(mgr,\n                                                def,\n                                                n->externalDataStore,\n                                                parent,\n                                                flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetImageLabelRelative",
          "args": [
            "mgr",
            "def",
            "n->externalDataStore",
            "parent",
            "flags"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetImageLabelRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "971-1001",
          "snippet": "static int\nvirSecurityDACSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecurityDACSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecurityDACSetImageLabelRelative(mgr,\n                                                def,\n                                                n->externalDataStore,\n                                                parent,\n                                                flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetImageLabelInternal",
          "args": [
            "mgr",
            "def",
            "n",
            "parent",
            "isChainTop"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetImageLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "896-968",
          "snippet": "static int\nvirSecurityDACSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    bool isChainTop)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    bool remember;\n    uid_t user;\n    gid_t group;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src, SECURITY_DAC_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_DAC_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(disk_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else if (parent_seclabel &&\n               (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(parent_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetImageIds(secdef, priv, &user, &group))\n            return -1;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        return virSecurityDACSetOwnership(mgr, NULL, vfioGroupDev, user, group, false);\n    }\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    return virSecurityDACSetOwnership(mgr, src, NULL, user, group, remember);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    bool isChainTop)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    bool remember;\n    uid_t user;\n    gid_t group;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src, SECURITY_DAC_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_DAC_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(disk_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else if (parent_seclabel &&\n               (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(parent_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetImageIds(secdef, priv, &user, &group))\n            return -1;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        return virSecurityDACSetOwnership(mgr, NULL, vfioGroupDev, user, group, false);\n    }\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    return virSecurityDACSetOwnership(mgr, src, NULL, user, group, remember);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "n"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetImageLabelRelative(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    virSecurityDomainImageLabelFlags flags)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n\n        if (virSecurityDACSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)\n            return -1;\n\n        if (n->externalDataStore &&\n            virSecurityDACSetImageLabelRelative(mgr,\n                                                def,\n                                                n->externalDataStore,\n                                                parent,\n                                                flags) < 0)\n            return -1;\n\n        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))\n            break;\n\n        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetImageLabelInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "896-968",
    "snippet": "static int\nvirSecurityDACSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    bool isChainTop)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    bool remember;\n    uid_t user;\n    gid_t group;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src, SECURITY_DAC_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_DAC_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(disk_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else if (parent_seclabel &&\n               (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(parent_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetImageIds(secdef, priv, &user, &group))\n            return -1;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        return virSecurityDACSetOwnership(mgr, NULL, vfioGroupDev, user, group, false);\n    }\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    return virSecurityDACSetOwnership(mgr, src, NULL, user, group, remember);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "mgr",
            "src",
            "NULL",
            "user",
            "group",
            "remember"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupDev",
          "args": [
            "&nvme->pciAddr"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1953-1965",
          "snippet": "char *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetImageIds",
          "args": [
            "secdef",
            "priv",
            "&user",
            "&group"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virParseOwnershipIds",
          "args": [
            "parent_seclabel->label",
            "&user",
            "&group"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "virParseOwnershipIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1521-1564",
          "snippet": "int\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetSecurityLabelDef",
          "args": [
            "parent",
            "SECURITY_DAC_NAME"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2105-2117",
          "snippet": "virSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirSecurityDeviceLabelDefPtr\nvirStorageSourceGetSecurityLabelDef(virStorageSourcePtr src,\n                                    const char *model)\n{\n    size_t i;\n\n    for (i = 0; i < src->nseclabels; i++) {\n        if (STREQ_NULLABLE(src->seclabels[i]->model, model))\n            return src->seclabels[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "SECURITY_DAC_NAME"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetImageLabelInternal(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr def,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr parent,\n                                    bool isChainTop)\n{\n    virSecurityLabelDefPtr secdef;\n    virSecurityDeviceLabelDefPtr disk_seclabel;\n    virSecurityDeviceLabelDefPtr parent_seclabel = NULL;\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    bool remember;\n    uid_t user;\n    gid_t group;\n\n    if (!priv->dynamicOwnership)\n        return 0;\n\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_DAC_NAME);\n    if (secdef && !secdef->relabel)\n        return 0;\n\n    disk_seclabel = virStorageSourceGetSecurityLabelDef(src, SECURITY_DAC_NAME);\n    parent_seclabel = virStorageSourceGetSecurityLabelDef(parent,\n                                                          SECURITY_DAC_NAME);\n\n    if (disk_seclabel && (!disk_seclabel->relabel || disk_seclabel->label)) {\n        if (!disk_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(disk_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else if (parent_seclabel &&\n               (!parent_seclabel->relabel || parent_seclabel->label)) {\n        if (!parent_seclabel->relabel)\n            return 0;\n\n        if (virParseOwnershipIds(parent_seclabel->label, &user, &group) < 0)\n            return -1;\n    } else {\n        if (virSecurityDACGetImageIds(secdef, priv, &user, &group))\n            return -1;\n    }\n\n    /* This is not very clean. But so far we don't have NVMe\n     * storage pool backend so that its chownCallback would be\n     * called. And this place looks least offensive. */\n    if (src->type == VIR_STORAGE_TYPE_NVME) {\n        const virStorageSourceNVMeDef *nvme = src->nvme;\n        g_autofree char *vfioGroupDev = NULL;\n\n        if (!(vfioGroupDev = virPCIDeviceAddressGetIOMMUGroupDev(&nvme->pciAddr)))\n            return -1;\n\n        return virSecurityDACSetOwnership(mgr, NULL, vfioGroupDev, user, group, false);\n    }\n\n    /* We can't do restore on shared resources safely. Not even\n     * with refcounting implemented in XATTRs because if there\n     * was a domain running with the feature turned off the\n     * refcounter in XATTRs would not reflect the actual number\n     * of times the resource is in use and thus the last restore\n     * on the resource (which actually restores the original\n     * owner) might cut off access to the domain with the feature\n     * disabled.\n     * For disks, a shared resource is the whole backing chain\n     * but the top layer, or read only image, or disk explicitly\n     * marked as shared.\n     */\n    remember = isChainTop && !src->readonly && !src->shared;\n\n    return virSecurityDACSetOwnership(mgr, src, NULL, user, group, remember);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreFileLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "888-893",
    "snippet": "static int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabelInternal",
          "args": [
            "mgr",
            "NULL",
            "path",
            "true"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "847-885",
          "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACRestoreFileLabel(virSecurityManagerPtr mgr,\n                               const char *path)\n{\n    return virSecurityDACRestoreFileLabelInternal(mgr, NULL, path, true);\n}"
  },
  {
    "function_name": "virSecurityDACRestoreFileLabelInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "847-885",
    "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnershipInternal",
          "args": [
            "priv",
            "src",
            "path",
            "uid",
            "gid"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnershipInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "692-764",
          "snippet": "static int\nvirSecurityDACSetOwnershipInternal(const virSecurityDACData *priv,\n                                   const virStorageSource *src,\n                                   const char *path,\n                                   uid_t uid,\n                                   gid_t gid)\n{\n    int rc;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if (priv && src && priv->chownCallback) {\n        rc = priv->chownCallback(src, uid, gid);\n        /* here path is used only for error messages */\n        path = NULLSTR(src->path);\n\n        /* on -2 returned an error was already reported */\n        if (rc == -2)\n            return -1;\n    } else {\n        struct stat sb;\n\n        if (!path) {\n            if (!src || !src->path)\n                return 0;\n\n            if (!virStorageSourceIsLocalStorage(src))\n                return 0;\n\n            path = src->path;\n        }\n\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        if (sb.st_uid == uid && sb.st_gid == gid) {\n            /* nothing to chown */\n            return 0;\n        }\n\n#ifdef WIN32\n        rc = ENOSYS;\n#else /* !WIN32 */\n        rc = chown(path, uid, gid);\n#endif /* !WIN32 */\n    }\n\n    if (rc < 0) {\n        if (errno == EOPNOTSUPP || errno == EINVAL) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EPERM) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EROFS) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\",\n                     (long)uid, (long)gid, path);\n        } else {\n            virReportSystemError(errno,\n                                 _(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\"),\n                                 (long)uid, (long)gid, path);\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetOwnershipInternal(const virSecurityDACData *priv,\n                                   const virStorageSource *src,\n                                   const char *path,\n                                   uid_t uid,\n                                   gid_t gid)\n{\n    int rc;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if (priv && src && priv->chownCallback) {\n        rc = priv->chownCallback(src, uid, gid);\n        /* here path is used only for error messages */\n        path = NULLSTR(src->path);\n\n        /* on -2 returned an error was already reported */\n        if (rc == -2)\n            return -1;\n    } else {\n        struct stat sb;\n\n        if (!path) {\n            if (!src || !src->path)\n                return 0;\n\n            if (!virStorageSourceIsLocalStorage(src))\n                return 0;\n\n            path = src->path;\n        }\n\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        if (sb.st_uid == uid && sb.st_gid == gid) {\n            /* nothing to chown */\n            return 0;\n        }\n\n#ifdef WIN32\n        rc = ENOSYS;\n#else /* !WIN32 */\n        rc = chown(path, uid, gid);\n#endif /* !WIN32 */\n    }\n\n    if (rc < 0) {\n        if (errno == EOPNOTSUPP || errno == EINVAL) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EPERM) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EROFS) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\",\n                     (long)uid, (long)gid, path);\n        } else {\n            virReportSystemError(errno,\n                                 _(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\"),\n                                 (long)uid, (long)gid, path);\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Restoring DAC user and group on '%s' to %ld:%ld\"",
            "NULLSTR(src ? src->path : path)",
            "(long)uid",
            "(long)gid"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src ? src->path : path"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACRecallLabel",
          "args": [
            "priv",
            "path",
            "&uid",
            "&gid"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRecallLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "476-500",
          "snippet": "static int\nvirSecurityDACRecallLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                          const char *path,\n                          uid_t *uid,\n                          gid_t *gid)\n{\n    char *label;\n    int ret = -1;\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_DAC_NAME, path, &label);\n    if (rv < 0)\n        return rv;\n\n    if (!label)\n        return 1;\n\n    if (virParseOwnershipIds(label, uid, gid) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(label);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRecallLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                          const char *path,\n                          uid_t *uid,\n                          gid_t *gid)\n{\n    char *label;\n    int ret = -1;\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_DAC_NAME, path, &label);\n    if (rv < 0)\n        return rv;\n\n    if (!label)\n        return 1;\n\n    if (virParseOwnershipIds(label, uid, gid) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(label);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACTransactionAppend",
          "args": [
            "path",
            "src",
            "uid",
            "gid",
            "recall",
            "true"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACTransactionAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "173-190",
          "snippet": "static int\nvirSecurityDACTransactionAppend(const char *path,\n                                const virStorageSource *src,\n                                uid_t uid,\n                                gid_t gid,\n                                bool remember,\n                                bool restore)\n{\n    virSecurityDACChownListPtr list = virThreadLocalGet(&chownList);\n    if (!list)\n        return 0;\n\n    if (virSecurityDACChownListAppend(list, path, src,\n                                      uid, gid, remember, restore) < 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal chownList;",
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACTransactionAppend(const char *path,\n                                const virStorageSource *src,\n                                uid_t uid,\n                                gid_t gid,\n                                bool remember,\n                                bool restore)\n{\n    virSecurityDACChownListPtr list = virThreadLocalGet(&chownList);\n    if (!list)\n        return 0;\n\n    if (virSecurityDACChownListAppend(list, path, src,\n                                      uid, gid, remember, restore) < 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
  },
  {
    "function_name": "virSecurityDACSetOwnership",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "767-844",
    "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&origerr"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\"",
            "NULLSTR(src ? src->path : path)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src ? src->path : path"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabelInternal",
          "args": [
            "mgr",
            "src",
            "path",
            "remember"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "847-885",
          "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&origerr"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnershipInternal",
          "args": [
            "priv",
            "src",
            "path",
            "uid",
            "gid"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnershipInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "692-764",
          "snippet": "static int\nvirSecurityDACSetOwnershipInternal(const virSecurityDACData *priv,\n                                   const virStorageSource *src,\n                                   const char *path,\n                                   uid_t uid,\n                                   gid_t gid)\n{\n    int rc;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if (priv && src && priv->chownCallback) {\n        rc = priv->chownCallback(src, uid, gid);\n        /* here path is used only for error messages */\n        path = NULLSTR(src->path);\n\n        /* on -2 returned an error was already reported */\n        if (rc == -2)\n            return -1;\n    } else {\n        struct stat sb;\n\n        if (!path) {\n            if (!src || !src->path)\n                return 0;\n\n            if (!virStorageSourceIsLocalStorage(src))\n                return 0;\n\n            path = src->path;\n        }\n\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        if (sb.st_uid == uid && sb.st_gid == gid) {\n            /* nothing to chown */\n            return 0;\n        }\n\n#ifdef WIN32\n        rc = ENOSYS;\n#else /* !WIN32 */\n        rc = chown(path, uid, gid);\n#endif /* !WIN32 */\n    }\n\n    if (rc < 0) {\n        if (errno == EOPNOTSUPP || errno == EINVAL) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EPERM) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EROFS) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\",\n                     (long)uid, (long)gid, path);\n        } else {\n            virReportSystemError(errno,\n                                 _(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\"),\n                                 (long)uid, (long)gid, path);\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetOwnershipInternal(const virSecurityDACData *priv,\n                                   const virStorageSource *src,\n                                   const char *path,\n                                   uid_t uid,\n                                   gid_t gid)\n{\n    int rc;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if (priv && src && priv->chownCallback) {\n        rc = priv->chownCallback(src, uid, gid);\n        /* here path is used only for error messages */\n        path = NULLSTR(src->path);\n\n        /* on -2 returned an error was already reported */\n        if (rc == -2)\n            return -1;\n    } else {\n        struct stat sb;\n\n        if (!path) {\n            if (!src || !src->path)\n                return 0;\n\n            if (!virStorageSourceIsLocalStorage(src))\n                return 0;\n\n            path = src->path;\n        }\n\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        if (sb.st_uid == uid && sb.st_gid == gid) {\n            /* nothing to chown */\n            return 0;\n        }\n\n#ifdef WIN32\n        rc = ENOSYS;\n#else /* !WIN32 */\n        rc = chown(path, uid, gid);\n#endif /* !WIN32 */\n    }\n\n    if (rc < 0) {\n        if (errno == EOPNOTSUPP || errno == EINVAL) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EPERM) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EROFS) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\",\n                     (long)uid, (long)gid, path);\n        } else {\n            virReportSystemError(errno,\n                                 _(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\"),\n                                 (long)uid, (long)gid, path);\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting DAC user and group on '%s' to '%ld:%ld'\"",
            "NULLSTR(src ? src->path : path)",
            "(long)uid",
            "(long)gid"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src ? src->path : path"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\")",
            "path"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\""
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACRememberLabel",
          "args": [
            "priv",
            "path",
            "sb.st_uid",
            "sb.st_gid"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRememberLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "445-459",
          "snippet": "static int\nvirSecurityDACRememberLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                            const char *path,\n                            uid_t uid,\n                            gid_t gid)\n{\n    char *label = NULL;\n    int ret = -1;\n\n    label = g_strdup_printf(\"+%u:+%u\", (unsigned int)uid, (unsigned int)gid);\n\n    ret = virSecuritySetRememberedLabel(SECURITY_DAC_NAME, path, label);\n    VIR_FREE(label);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SECURITY_DAC_NAME \"dac\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRememberLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                            const char *path,\n                            uid_t uid,\n                            gid_t gid)\n{\n    char *label = NULL;\n    int ret = -1;\n\n    label = g_strdup_printf(\"+%u:+%u\", (unsigned int)uid, (unsigned int)gid);\n\n    ret = virSecuritySetRememberedLabel(SECURITY_DAC_NAME, path, label);\n    VIR_FREE(label);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to stat: %s\")",
            "path"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACTransactionAppend",
          "args": [
            "path",
            "src",
            "uid",
            "gid",
            "remember",
            "false"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACTransactionAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "173-190",
          "snippet": "static int\nvirSecurityDACTransactionAppend(const char *path,\n                                const virStorageSource *src,\n                                uid_t uid,\n                                gid_t gid,\n                                bool remember,\n                                bool restore)\n{\n    virSecurityDACChownListPtr list = virThreadLocalGet(&chownList);\n    if (!list)\n        return 0;\n\n    if (virSecurityDACChownListAppend(list, path, src,\n                                      uid, gid, remember, restore) < 0)\n        return -1;\n\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal chownList;",
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACTransactionAppend(const char *path,\n                                const virStorageSource *src,\n                                uid_t uid,\n                                gid_t gid,\n                                bool remember,\n                                bool restore)\n{\n    virSecurityDACChownListPtr list = virThreadLocalGet(&chownList);\n    if (!list)\n        return 0;\n\n    if (virSecurityDACChownListAppend(list, path, src,\n                                      uid, gid, remember, restore) < 0)\n        return -1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityDACSetOwnershipInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "692-764",
    "snippet": "static int\nvirSecurityDACSetOwnershipInternal(const virSecurityDACData *priv,\n                                   const virStorageSource *src,\n                                   const char *path,\n                                   uid_t uid,\n                                   gid_t gid)\n{\n    int rc;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if (priv && src && priv->chownCallback) {\n        rc = priv->chownCallback(src, uid, gid);\n        /* here path is used only for error messages */\n        path = NULLSTR(src->path);\n\n        /* on -2 returned an error was already reported */\n        if (rc == -2)\n            return -1;\n    } else {\n        struct stat sb;\n\n        if (!path) {\n            if (!src || !src->path)\n                return 0;\n\n            if (!virStorageSourceIsLocalStorage(src))\n                return 0;\n\n            path = src->path;\n        }\n\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        if (sb.st_uid == uid && sb.st_gid == gid) {\n            /* nothing to chown */\n            return 0;\n        }\n\n#ifdef WIN32\n        rc = ENOSYS;\n#else /* !WIN32 */\n        rc = chown(path, uid, gid);\n#endif /* !WIN32 */\n    }\n\n    if (rc < 0) {\n        if (errno == EOPNOTSUPP || errno == EINVAL) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EPERM) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EROFS) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\",\n                     (long)uid, (long)gid, path);\n        } else {\n            virReportSystemError(errno,\n                                 _(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\"),\n                                 (long)uid, (long)gid, path);\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\")",
            "(long)uid",
            "(long)gid",
            "path"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\""
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\"",
            "(long)uid",
            "(long)gid",
            "path"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\"",
            "(long)uid",
            "(long)gid",
            "path"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\"",
            "(long)uid",
            "(long)gid",
            "path"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "path",
            "uid",
            "gid"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to stat: %s\")",
            "path"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "src->path"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv->chownCallback",
          "args": [
            "src",
            "uid",
            "gid"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACSetOwnershipInternal(const virSecurityDACData *priv,\n                                   const virStorageSource *src,\n                                   const char *path,\n                                   uid_t uid,\n                                   gid_t gid)\n{\n    int rc;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if (priv && src && priv->chownCallback) {\n        rc = priv->chownCallback(src, uid, gid);\n        /* here path is used only for error messages */\n        path = NULLSTR(src->path);\n\n        /* on -2 returned an error was already reported */\n        if (rc == -2)\n            return -1;\n    } else {\n        struct stat sb;\n\n        if (!path) {\n            if (!src || !src->path)\n                return 0;\n\n            if (!virStorageSourceIsLocalStorage(src))\n                return 0;\n\n            path = src->path;\n        }\n\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        if (sb.st_uid == uid && sb.st_gid == gid) {\n            /* nothing to chown */\n            return 0;\n        }\n\n#ifdef WIN32\n        rc = ENOSYS;\n#else /* !WIN32 */\n        rc = chown(path, uid, gid);\n#endif /* !WIN32 */\n    }\n\n    if (rc < 0) {\n        if (errno == EOPNOTSUPP || errno == EINVAL) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"supported by filesystem\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EPERM) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"permitted\",\n                     (long)uid, (long)gid, path);\n        } else if (errno == EROFS) {\n            VIR_INFO(\"Setting user and group to '%ld:%ld' on '%s' not \"\n                     \"possible on readonly filesystem\",\n                     (long)uid, (long)gid, path);\n        } else {\n            virReportSystemError(errno,\n                                 _(\"unable to set user and group to '%ld:%ld' \"\n                                   \"on '%s'\"),\n                                 (long)uid, (long)gid, path);\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACTransactionAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "677-689",
    "snippet": "static void\nvirSecurityDACTransactionAbort(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virSecurityDACChownListPtr list;\n\n    list = virThreadLocalGet(&chownList);\n    if (!list)\n        return;\n\n    if (virThreadLocalSet(&chownList, NULL) < 0)\n        VIR_DEBUG(\"Unable to clear thread local variable\");\n    virSecurityDACChownListFree(list);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal chownList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACChownListFree",
          "args": [
            "list"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACChownListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "135-151",
          "snippet": "static void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to clear thread local variable\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadLocalSet",
          "args": [
            "&chownList",
            "NULL"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "352-360",
          "snippet": "int virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&chownList"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\n\nstatic void\nvirSecurityDACTransactionAbort(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    virSecurityDACChownListPtr list;\n\n    list = virThreadLocalGet(&chownList);\n    if (!list)\n        return;\n\n    if (virThreadLocalSet(&chownList, NULL) < 0)\n        VIR_DEBUG(\"Unable to clear thread local variable\");\n    virSecurityDACChownListFree(list);\n}"
  },
  {
    "function_name": "virSecurityDACTransactionCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "619-669",
    "snippet": "static int\nvirSecurityDACTransactionCommit(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                pid_t pid,\n                                bool lock)\n{\n    virSecurityDACChownListPtr list;\n    int rc;\n    int ret = -1;\n\n    list = virThreadLocalGet(&chownList);\n    if (!list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No transaction is set\"));\n        goto cleanup;\n    }\n\n    if (virThreadLocalSet(&chownList, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to clear thread local variable\"));\n        goto cleanup;\n    }\n\n    list->lock = lock;\n\n    if (pid != -1) {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecurityDACTransactionRun,\n                                           list);\n        if (rc < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_SYSTEM_ERROR)\n                pid = -1;\n            else\n                goto cleanup;\n        }\n    }\n\n    if (pid == -1) {\n        if (lock)\n            rc = virProcessRunInFork(virSecurityDACTransactionRun, list);\n        else\n            rc = virSecurityDACTransactionRun(pid, list);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecurityDACChownListFree(list);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal chownList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACChownListFree",
          "args": [
            "list"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACChownListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "135-151",
          "snippet": "static void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACTransactionRun",
          "args": [
            "pid",
            "list"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACTransactionRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "217-306",
          "snippet": "static int\nvirSecurityDACTransactionRun(pid_t pid G_GNUC_UNUSED,\n                             void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv = 0;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    for (i = 0; i < list->nItems; i++) {\n        virSecurityDACChownItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecurityDACSetOwnership(list->manager,\n                                            item->src,\n                                            item->path,\n                                            item->uid,\n                                            item->gid,\n                                            remember);\n        } else {\n            rv = virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                        item->src,\n                                                        item->path,\n                                                        remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecurityDACChownItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                   item->src,\n                                                   item->path,\n                                                   remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\",\n                     NULLSTR(item->src ? item->src->path : item->path));\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACTransactionRun(pid_t pid G_GNUC_UNUSED,\n                             void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv = 0;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    for (i = 0; i < list->nItems; i++) {\n        virSecurityDACChownItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecurityDACSetOwnership(list->manager,\n                                            item->src,\n                                            item->path,\n                                            item->uid,\n                                            item->gid,\n                                            remember);\n        } else {\n            rv = virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                        item->src,\n                                                        item->path,\n                                                        remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecurityDACChownItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                   item->src,\n                                                   item->path,\n                                                   remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\",\n                     NULLSTR(item->src ? item->src->path : item->path));\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessRunInFork",
          "args": [
            "virSecurityDACTransactionRun",
            "list"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInFork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1267-1274",
          "snippet": "int\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInFork(virProcessForkCallback cb G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Process spawning is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessRunInMountNamespace",
          "args": [
            "pid",
            "virSecurityDACTransactionRun",
            "list"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessRunInMountNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1115-1123",
          "snippet": "int\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessRunInMountNamespace(pid_t pid G_GNUC_UNUSED,\n                              virProcessNamespaceCallback cb G_GNUC_UNUSED,\n                              void *opaque G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Namespaces are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to clear thread local variable\")"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to clear thread local variable\""
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalSet",
          "args": [
            "&chownList",
            "NULL"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "352-360",
          "snippet": "int virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No transaction is set\")"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&chownList"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\n\nstatic int\nvirSecurityDACTransactionCommit(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                pid_t pid,\n                                bool lock)\n{\n    virSecurityDACChownListPtr list;\n    int rc;\n    int ret = -1;\n\n    list = virThreadLocalGet(&chownList);\n    if (!list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No transaction is set\"));\n        goto cleanup;\n    }\n\n    if (virThreadLocalSet(&chownList, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to clear thread local variable\"));\n        goto cleanup;\n    }\n\n    list->lock = lock;\n\n    if (pid != -1) {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecurityDACTransactionRun,\n                                           list);\n        if (rc < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_SYSTEM_ERROR)\n                pid = -1;\n            else\n                goto cleanup;\n        }\n    }\n\n    if (pid == -1) {\n        if (lock)\n            rc = virProcessRunInFork(virSecurityDACTransactionRun, list);\n        else\n            rc = virSecurityDACTransactionRun(pid, list);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virSecurityDACChownListFree(list);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACTransactionStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "571-596",
    "snippet": "static int\nvirSecurityDACTransactionStart(virSecurityManagerPtr mgr)\n{\n    virSecurityDACChownListPtr list;\n\n    list = virThreadLocalGet(&chownList);\n    if (list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Another relabel transaction is already started\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(list) < 0)\n        return -1;\n\n    list->manager = virObjectRef(mgr);\n\n    if (virThreadLocalSet(&chownList, list) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set thread local variable\"));\n        virSecurityDACChownListFree(list);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal chownList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACChownListFree",
          "args": [
            "list"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACChownListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "135-151",
          "snippet": "static void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to set thread local variable\")"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set thread local variable\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalSet",
          "args": [
            "&chownList",
            "list"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "352-360",
          "snippet": "int virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalSet(virThreadLocalPtr l, void *val)\n{\n    int err = pthread_setspecific(l->key, val);\n    if (err) {\n        errno = err;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "mgr"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "list"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Another relabel transaction is already started\")"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&chownList"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\n\nstatic int\nvirSecurityDACTransactionStart(virSecurityManagerPtr mgr)\n{\n    virSecurityDACChownListPtr list;\n\n    list = virThreadLocalGet(&chownList);\n    if (list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Another relabel transaction is already started\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(list) < 0)\n        return -1;\n\n    list->manager = virObjectRef(mgr);\n\n    if (virThreadLocalSet(&chownList, list) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set thread local variable\"));\n        virSecurityDACChownListFree(list);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACPreFork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "543-556",
    "snippet": "static int\nvirSecurityDACPreFork(virSecurityManagerPtr mgr)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int ngroups;\n\n    VIR_FREE(priv->groups);\n    priv->ngroups = 0;\n    if ((ngroups = virGetGroupList(priv->user, priv->group,\n                                   &priv->groups)) < 0)\n        return -1;\n    priv->ngroups = ngroups;\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virGetGroupList",
          "args": [
            "priv->user",
            "priv->group",
            "&priv->groups"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virGetGroupList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1059-1065",
          "snippet": "int\nvirGetGroupList(uid_t uid G_GNUC_UNUSED, gid_t gid G_GNUC_UNUSED,\n                gid_t **list)\n{\n    *list = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirGetGroupList(uid_t uid G_GNUC_UNUSED, gid_t gid G_GNUC_UNUSED,\n                gid_t **list)\n{\n    *list = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->groups"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACPreFork(virSecurityManagerPtr mgr)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int ngroups;\n\n    VIR_FREE(priv->groups);\n    priv->ngroups = 0;\n    if ((ngroups = virGetGroupList(priv->user, priv->group,\n                                   &priv->groups)) < 0)\n        return -1;\n    priv->ngroups = ngroups;\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACGetDOI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "537-541",
    "snippet": "static const char *\nvirSecurityDACGetDOI(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    return \"0\";\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const char *\nvirSecurityDACGetDOI(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    return \"0\";\n}"
  },
  {
    "function_name": "virSecurityDACGetModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "531-535",
    "snippet": "static const char *\nvirSecurityDACGetModel(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    return SECURITY_DAC_NAME;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic const char *\nvirSecurityDACGetModel(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    return SECURITY_DAC_NAME;\n}"
  },
  {
    "function_name": "virSecurityDACClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "521-528",
    "snippet": "static int\nvirSecurityDACClose(virSecurityManagerPtr mgr)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    VIR_FREE(priv->groups);\n    VIR_FREE(priv->baselabel);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->baselabel"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->groups"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityDACClose(virSecurityManagerPtr mgr)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    VIR_FREE(priv->groups);\n    VIR_FREE(priv->baselabel);\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "508-519",
    "snippet": "static int\nvirSecurityDACOpen(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    if (virThreadLocalInit(&chownList,\n                           virSecurityDACChownListFree) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize thread local variable\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal chownList;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to initialize thread local variable\")"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to initialize thread local variable\""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalInit",
          "args": [
            "&chownList",
            "virSecurityDACChownListFree"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "336-345",
          "snippet": "int virThreadLocalInit(virThreadLocalPtr l,\n                       virThreadLocalCleanup c)\n{\n    int ret;\n    if ((ret = pthread_key_create(&l->key, c)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadLocalInit(virThreadLocalPtr l,\n                       virThreadLocalCleanup c)\n{\n    int ret;\n    if ((ret = pthread_key_create(&l->key, c)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\n\nstatic int\nvirSecurityDACOpen(virSecurityManagerPtr mgr G_GNUC_UNUSED)\n{\n    if (virThreadLocalInit(&chownList,\n                           virSecurityDACChownListFree) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize thread local variable\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACProbe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "502-506",
    "snippet": "static virSecurityDriverStatus\nvirSecurityDACProbe(const char *virtDriver G_GNUC_UNUSED)\n{\n    return SECURITY_DRIVER_ENABLE;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virSecurityDriverStatus\nvirSecurityDACProbe(const char *virtDriver G_GNUC_UNUSED)\n{\n    return SECURITY_DRIVER_ENABLE;\n}"
  },
  {
    "function_name": "virSecurityDACRecallLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "476-500",
    "snippet": "static int\nvirSecurityDACRecallLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                          const char *path,\n                          uid_t *uid,\n                          gid_t *gid)\n{\n    char *label;\n    int ret = -1;\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_DAC_NAME, path, &label);\n    if (rv < 0)\n        return rv;\n\n    if (!label)\n        return 1;\n\n    if (virParseOwnershipIds(label, uid, gid) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(label);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "label"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virParseOwnershipIds",
          "args": [
            "label",
            "uid",
            "gid"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "virParseOwnershipIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1521-1564",
          "snippet": "int\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityGetRememberedLabel",
          "args": [
            "SECURITY_DAC_NAME",
            "path",
            "&label"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityGetRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "263-337",
          "snippet": "int\nvirSecurityGetRememberedLabel(const char *name,\n                              const char *path,\n                              char **label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    *label = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENODATA || errno == ENOTSUP)\n            return -2;\n\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             ref_name,\n                             path);\n        return -1;\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            return -2;\n    }\n\n    if (virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount--;\n\n    if (refcount > 0) {\n        value = g_strdup_printf(\"%u\", refcount);\n\n        if (virFileSetXAttr(path, ref_name, value) < 0)\n            return -1;\n    } else {\n        if (virFileRemoveXAttr(path, ref_name) < 0)\n            return -1;\n\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileGetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virFileRemoveXAttr(path, attr_name) < 0)\n            return -1;\n\n        if (virSecurityRemoveTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecurityGetRememberedLabel(const char *name,\n                              const char *path,\n                              char **label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    *label = NULL;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENODATA || errno == ENOTSUP)\n            return -2;\n\n        virReportSystemError(errno,\n                             _(\"Unable to get XATTR %s on %s\"),\n                             ref_name,\n                             path);\n        return -1;\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            return -2;\n    }\n\n    if (virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount--;\n\n    if (refcount > 0) {\n        value = g_strdup_printf(\"%u\", refcount);\n\n        if (virFileSetXAttr(path, ref_name, value) < 0)\n            return -1;\n    } else {\n        if (virFileRemoveXAttr(path, ref_name) < 0)\n            return -1;\n\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileGetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virFileRemoveXAttr(path, attr_name) < 0)\n            return -1;\n\n        if (virSecurityRemoveTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRecallLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                          const char *path,\n                          uid_t *uid,\n                          gid_t *gid)\n{\n    char *label;\n    int ret = -1;\n    int rv;\n\n    rv = virSecurityGetRememberedLabel(SECURITY_DAC_NAME, path, &label);\n    if (rv < 0)\n        return rv;\n\n    if (!label)\n        return 1;\n\n    if (virParseOwnershipIds(label, uid, gid) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(label);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACRememberLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "445-459",
    "snippet": "static int\nvirSecurityDACRememberLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                            const char *path,\n                            uid_t uid,\n                            gid_t gid)\n{\n    char *label = NULL;\n    int ret = -1;\n\n    label = g_strdup_printf(\"+%u:+%u\", (unsigned int)uid, (unsigned int)gid);\n\n    ret = virSecuritySetRememberedLabel(SECURITY_DAC_NAME, path, label);\n    VIR_FREE(label);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SECURITY_DAC_NAME \"dac\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "label"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecuritySetRememberedLabel",
          "args": [
            "SECURITY_DAC_NAME",
            "path",
            "label"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "virSecuritySetRememberedLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_util.c",
          "lines": "360-428",
          "snippet": "int\nvirSecuritySetRememberedLabel(const char *name,\n                              const char *path,\n                              const char *label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name,\n                                 path);\n            return -1;\n        }\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            VIR_FREE(value);\n    }\n\n    if (value &&\n        virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount++;\n\n    if (refcount == 1) {\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileSetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virSecurityAddTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    value = g_strdup_printf(\"%u\", refcount);\n\n    if (virFileSetXAttr(path, ref_name, value) < 0)\n        return -1;\n\n    return refcount;\n}",
          "includes": [
            "#include \"security_util.h\"",
            "#include \"virhostuptime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security_util.h\"\n#include \"virhostuptime.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirSecuritySetRememberedLabel(const char *name,\n                              const char *path,\n                              const char *label)\n{\n    g_autofree char *ref_name = NULL;\n    g_autofree char *attr_name = NULL;\n    g_autofree char *value = NULL;\n    unsigned int refcount = 0;\n\n    if (!(ref_name = virSecurityGetRefCountAttrName(name)))\n        return -1;\n\n    if (virFileGetXAttrQuiet(path, ref_name, &value) < 0) {\n        if (errno == ENOSYS || errno == ENOTSUP) {\n            return -2;\n        } else if (errno != ENODATA) {\n            virReportSystemError(errno,\n                                 _(\"Unable to get XATTR %s on %s\"),\n                                 ref_name,\n                                 path);\n            return -1;\n        }\n    }\n\n    if (value) {\n        int rc;\n\n        /* Do this after we've tried to get refcounter to ensure underlying FS\n         * supports XATTRs and @path has refcounter attribute set, because\n         * validator might throws a warning. */\n        if ((rc = virSecurityValidateTimestamp(name, path)) < 0)\n            return rc;\n\n        /* Invalid label is like a non-existent one */\n        if (rc == 1)\n            VIR_FREE(value);\n    }\n\n    if (value &&\n        virStrToLong_ui(value, NULL, 10, &refcount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed refcount %s on %s\"),\n                       value, path);\n        return -1;\n    }\n\n    VIR_FREE(value);\n\n    refcount++;\n\n    if (refcount == 1) {\n        if (!(attr_name = virSecurityGetAttrName(name)))\n            return -1;\n\n        if (virFileSetXAttr(path, attr_name, label) < 0)\n            return -1;\n\n        if (virSecurityAddTimestamp(name, path) < 0)\n            return -1;\n    }\n\n    value = g_strdup_printf(\"%u\", refcount);\n\n    if (virFileSetXAttr(path, ref_name, value) < 0)\n        return -1;\n\n    return refcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"+%u:+%u\"",
            "(unsigned int)uid",
            "(unsigned int)gid"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SECURITY_DAC_NAME \"dac\"\n\nstatic int\nvirSecurityDACRememberLabel(virSecurityDACDataPtr priv G_GNUC_UNUSED,\n                            const char *path,\n                            uid_t uid,\n                            gid_t gid)\n{\n    char *label = NULL;\n    int ret = -1;\n\n    label = g_strdup_printf(\"+%u:+%u\", (unsigned int)uid, (unsigned int)gid);\n\n    ret = virSecuritySetRememberedLabel(SECURITY_DAC_NAME, path, label);\n    VIR_FREE(label);\n    return ret;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "410-431",
    "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DAC imagelabel couldn't be determined\")"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DAC imagelabel couldn't be determined\""
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACParseImageIds",
          "args": [
            "seclabel",
            "uidPtr",
            "gidPtr"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetImageIds",
          "args": [
            "virSecurityLabelDefPtrseclabel",
            "virSecurityDACDataPtrpriv",
            "uid_t *uidPtr",
            "gid_t *gidPtr"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "396-408",
    "snippet": "static int\nATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nvirSecurityDACParseImageIds(virSecurityLabelDefPtr seclabel,\n                            uid_t *uidPtr, gid_t *gidPtr)\n{\n    if (!seclabel || !seclabel->imagelabel)\n        return 1;\n\n    if (virParseOwnershipIds(seclabel->imagelabel, uidPtr, gidPtr) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virParseOwnershipIds",
          "args": [
            "seclabel->imagelabel",
            "uidPtr",
            "gidPtr"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "virParseOwnershipIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1521-1564",
          "snippet": "int\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACParseImageIds",
          "args": [
            "virSecurityLabelDefPtrseclabel",
            "uid_t *uidPtr",
            "gid_t *gidPtr"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "3"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nvirSecurityDACParseImageIds(virSecurityLabelDefPtr seclabel,\n                            uid_t *uidPtr, gid_t *gidPtr)\n{\n    if (!seclabel || !seclabel->imagelabel)\n        return 1;\n\n    if (virParseOwnershipIds(seclabel->imagelabel, uidPtr, gidPtr) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "365-392",
    "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetIds(virSecurityLabelDefPtr seclabel,\n                     virSecurityDACDataPtr priv,\n                     uid_t *uidPtr, gid_t *gidPtr,\n                     gid_t **groups, int *ngroups)\n{\n    int ret;\n\n    if (groups)\n        *groups = priv ? priv->groups : NULL;\n    if (ngroups)\n        *ngroups = priv ? priv->ngroups : 0;\n\n    if ((ret = virSecurityDACParseIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC seclabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DAC seclabel couldn't be determined\")"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DAC seclabel couldn't be determined\""
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACParseIds",
          "args": [
            "seclabel",
            "uidPtr",
            "gidPtr"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACGetIds",
          "args": [
            "virSecurityLabelDefPtrseclabel",
            "virSecurityDACDataPtrpriv",
            "uid_t *uidPtr",
            "gid_t *gidPtr",
            "gid_t **groups",
            "int *ngroups"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetIds(virSecurityLabelDefPtr seclabel,\n                     virSecurityDACDataPtr priv,\n                     uid_t *uidPtr, gid_t *gidPtr,\n                     gid_t **groups, int *ngroups)\n{\n    int ret;\n\n    if (groups)\n        *groups = priv ? priv->groups : NULL;\n    if (ngroups)\n        *ngroups = priv ? priv->ngroups : 0;\n\n    if ((ret = virSecurityDACParseIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC seclabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}"
  },
  {
    "function_name": "ATTRIBUTE_NONNULL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "351-363",
    "snippet": "static int\nATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nvirSecurityDACParseIds(virSecurityLabelDefPtr seclabel,\n                       uid_t *uidPtr, gid_t *gidPtr)\n{\n    if (!seclabel || !seclabel->label)\n        return 1;\n\n    if (virParseOwnershipIds(seclabel->label, uidPtr, gidPtr) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virParseOwnershipIds",
          "args": [
            "seclabel->label",
            "uidPtr",
            "gidPtr"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virParseOwnershipIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1521-1564",
          "snippet": "int\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseOwnershipIds(const char *label, uid_t *uidPtr, gid_t *gidPtr)\n{\n    int rc = -1;\n    uid_t theuid;\n    gid_t thegid;\n    char *tmp_label = NULL;\n    char *sep = NULL;\n    char *owner = NULL;\n    char *group = NULL;\n\n    tmp_label = g_strdup(label);\n\n    /* Split label */\n    sep = strchr(tmp_label, ':');\n    if (sep == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to parse uid and gid from '%s'\"),\n                       label);\n        goto cleanup;\n    }\n    *sep = '\\0';\n    owner = tmp_label;\n    group = sep + 1;\n\n    /* Parse owner and group, error message is defined by\n     * virGetUserID or virGetGroupID.\n     */\n    if (virGetUserID(owner, &theuid) < 0 ||\n        virGetGroupID(group, &thegid) < 0)\n        goto cleanup;\n\n    if (uidPtr)\n        *uidPtr = theuid;\n    if (gidPtr)\n        *gidPtr = thegid;\n\n    rc = 0;\n\n cleanup:\n    VIR_FREE(tmp_label);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACParseIds",
          "args": [
            "virSecurityLabelDefPtrseclabel",
            "uid_t *uidPtr",
            "gid_t *gidPtr"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTRIBUTE_NONNULL",
          "args": [
            "3"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "410-431",
          "snippet": "static int\nATTRIBUTE_NONNULL(3) ATTRIBUTE_NONNULL(4)\nvirSecurityDACGetImageIds(virSecurityLabelDefPtr seclabel,\n                          virSecurityDACDataPtr priv,\n                          uid_t *uidPtr, gid_t *gidPtr)\n{\n    int ret;\n\n    if ((ret = virSecurityDACParseImageIds(seclabel, uidPtr, gidPtr)) <= 0)\n        return ret;\n\n    if (!priv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DAC imagelabel couldn't be determined\"));\n        return -1;\n    }\n\n    *uidPtr = priv->user;\n    *gidPtr = priv->group;\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3)\nvirSecurityDACParseIds(virSecurityLabelDefPtr seclabel,\n                       uid_t *uidPtr, gid_t *gidPtr)\n{\n    if (!seclabel || !seclabel->label)\n        return 1;\n\n    if (virParseOwnershipIds(seclabel->label, uidPtr, gidPtr) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACSetChownCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "342-348",
    "snippet": "void\nvirSecurityDACSetChownCallback(virSecurityManagerPtr mgr,\n                               virSecurityManagerDACChownCallback chownCallback)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->chownCallback = chownCallback;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityDACSetChownCallback(virSecurityManagerPtr mgr,\n                               virSecurityManagerDACChownCallback chownCallback)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->chownCallback = chownCallback;\n}"
  },
  {
    "function_name": "virSecurityDACSetMountNamespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "333-339",
    "snippet": "void\nvirSecurityDACSetMountNamespace(virSecurityManagerPtr mgr,\n                                bool mountNamespace)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->mountNamespace = mountNamespace;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityDACSetMountNamespace(virSecurityManagerPtr mgr,\n                                bool mountNamespace)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->mountNamespace = mountNamespace;\n}"
  },
  {
    "function_name": "virSecurityDACSetDynamicOwnership",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "325-331",
    "snippet": "void\nvirSecurityDACSetDynamicOwnership(virSecurityManagerPtr mgr,\n                                  bool dynamicOwnership)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->dynamicOwnership = dynamicOwnership;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityDACSetDynamicOwnership(virSecurityManagerPtr mgr,\n                                  bool dynamicOwnership)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->dynamicOwnership = dynamicOwnership;\n}"
  },
  {
    "function_name": "virSecurityDACSetUserAndGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "310-323",
    "snippet": "int\nvirSecurityDACSetUserAndGroup(virSecurityManagerPtr mgr,\n                              uid_t user,\n                              gid_t group)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->user = user;\n    priv->group = group;\n\n    priv->baselabel = g_strdup_printf(\"+%u:+%u\", (unsigned int)user,\n                                      (unsigned int)group);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"+%u:+%u\"",
            "(unsigned int)user",
            "(unsigned int)group"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetPrivateData",
          "args": [
            "mgr"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "321-325",
          "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityDACSetUserAndGroup(virSecurityManagerPtr mgr,\n                              uid_t user,\n                              gid_t group)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->user = user;\n    priv->group = group;\n\n    priv->baselabel = g_strdup_printf(\"+%u:+%u\", (unsigned int)user,\n                                      (unsigned int)group);\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityDACTransactionRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "217-306",
    "snippet": "static int\nvirSecurityDACTransactionRun(pid_t pid G_GNUC_UNUSED,\n                             void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv = 0;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    for (i = 0; i < list->nItems; i++) {\n        virSecurityDACChownItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecurityDACSetOwnership(list->manager,\n                                            item->src,\n                                            item->path,\n                                            item->uid,\n                                            item->gid,\n                                            remember);\n        } else {\n            rv = virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                        item->src,\n                                                        item->path,\n                                                        remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecurityDACChownItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                   item->src,\n                                                   item->path,\n                                                   remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\",\n                     NULLSTR(item->src ? item->src->path : item->path));\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "paths"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataUnlock",
          "args": [
            "list->manager",
            "&state"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1400-1429",
          "snippet": "void\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvoid\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring failed restore attempt on %s\"",
            "NULLSTR(item->src ? item->src->path : item->path)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "item->src ? item->src->path : item->path"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDACRestoreFileLabelInternal",
          "args": [
            "list->manager",
            "item->src",
            "item->path",
            "remember"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACRestoreFileLabelInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "847-885",
          "snippet": "static int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                                  const virStorageSource *src,\n                                                  const char *path,\n                                                  bool recall);\n\nstatic int\nvirSecurityDACRestoreFileLabelInternal(virSecurityManagerPtr mgr,\n                                       const virStorageSource *src,\n                                       const char *path,\n                                       bool recall)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    int rv;\n    uid_t uid = 0;  /* By default return to root:root */\n    gid_t gid = 0;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rv = virSecurityDACTransactionAppend(path, src, uid, gid, recall, true)) < 0)\n        return -1;\n    else if (rv > 0)\n        return 0;\n\n    if (recall && path) {\n        rv = virSecurityDACRecallLabel(priv, path, &uid, &gid);\n        if (rv == -2) {\n            /* Not supported. Don't error though. */\n        } else if (rv < 0) {\n            return -1;\n        } else if (rv > 0) {\n            return 0;\n        }\n    }\n\n    VIR_INFO(\"Restoring DAC user and group on '%s' to %ld:%ld\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    return virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetOwnership",
          "args": [
            "list->manager",
            "item->src",
            "item->path",
            "item->uid",
            "item->gid",
            "remember"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "767-844",
          "snippet": "static int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                           const virStorageSource *src,\n                           const char *path,\n                           uid_t uid,\n                           gid_t gid,\n                           bool remember)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virErrorPtr origerr;\n    struct stat sb;\n    int refcount;\n    int rc;\n\n    if (!path && src && src->path &&\n        virStorageSourceIsLocalStorage(src))\n        path = src->path;\n\n    /* Be aware that this function might run in a separate process.\n     * Therefore, any driver state changes would be thrown away. */\n\n    if ((rc = virSecurityDACTransactionAppend(path, src,\n                                              uid, gid, remember, false)) < 0)\n        return -1;\n    else if (rc > 0)\n        return 0;\n\n    if (remember && path) {\n        if (stat(path, &sb) < 0) {\n            virReportSystemError(errno, _(\"unable to stat: %s\"), path);\n            return -1;\n        }\n\n        refcount = virSecurityDACRememberLabel(priv, path, sb.st_uid, sb.st_gid);\n        if (refcount == -2) {\n            /* Not supported. Don't error though. */\n        } else if (refcount < 0) {\n            return -1;\n        } else if (refcount > 1) {\n            /* Refcount is greater than 1 which means that there\n             * is @refcount domains using the @path. Do not\n             * change the label (as it would almost certainly\n             * cause the other domains to lose access to the\n             * @path). However, the refcounter was incremented in\n             * XATTRs so decrease it. */\n            if (sb.st_uid != uid || sb.st_gid != gid) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Setting different DAC user or group on %s \"\n                                 \"which is already in use\"), path);\n                goto error;\n            }\n        }\n    }\n\n    VIR_INFO(\"Setting DAC user and group on '%s' to '%ld:%ld'\",\n             NULLSTR(src ? src->path : path), (long)uid, (long)gid);\n\n    if (virSecurityDACSetOwnershipInternal(priv, src, path, uid, gid) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&origerr);\n    /* Try to restore the label. This is done so that XATTRs\n     * are left in the same state as when the control entered\n     * this function. However, if our attempt fails, there's\n     * not much we can do. XATTRs refcounting is fubar'ed and\n     * the only option we have is warn users. */\n    if (virSecurityDACRestoreFileLabelInternal(mgr, src, path, remember) < 0)\n        VIR_WARN(\"Unable to restore label on '%s'. \"\n                 \"XATTRs might have been left in inconsistent state.\",\n                 NULLSTR(src ? src->path : path));\n\n    virErrorRestore(&origerr);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "item->path",
            "state->paths[j]"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerMetadataLock",
          "args": [
            "list->manager",
            "paths",
            "npaths"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerMetadataLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1283-1397",
          "snippet": "virSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define METADATA_LEN 1",
            "#define METADATA_OFFSET 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvirSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY_INPLACE",
          "args": [
            "paths",
            "npaths",
            "p"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "paths",
            "list->nItems"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACTransactionRun(pid_t pid G_GNUC_UNUSED,\n                             void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    virSecurityManagerMetadataLockStatePtr state;\n    const char **paths = NULL;\n    size_t npaths = 0;\n    size_t i;\n    int rv = 0;\n    int ret = -1;\n\n    if (list->lock) {\n        if (VIR_ALLOC_N(paths, list->nItems) < 0)\n            return -1;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            const char *p = item->path;\n\n            if (item->remember)\n                VIR_APPEND_ELEMENT_COPY_INPLACE(paths, npaths, p);\n        }\n\n        if (!(state = virSecurityManagerMetadataLock(list->manager, paths, npaths)))\n            goto cleanup;\n\n        for (i = 0; i < list->nItems; i++) {\n            virSecurityDACChownItemPtr item = list->items[i];\n            size_t j;\n\n            for (j = 0; j < state->nfds; j++) {\n                if (STREQ_NULLABLE(item->path, state->paths[j]))\n                    break;\n            }\n\n            /* If path wasn't locked, don't try to remember its label. */\n            if (j == state->nfds)\n                item->remember = false;\n        }\n    }\n\n    for (i = 0; i < list->nItems; i++) {\n        virSecurityDACChownItemPtr item = list->items[i];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            rv = virSecurityDACSetOwnership(list->manager,\n                                            item->src,\n                                            item->path,\n                                            item->uid,\n                                            item->gid,\n                                            remember);\n        } else {\n            rv = virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                        item->src,\n                                                        item->path,\n                                                        remember);\n        }\n\n        if (rv < 0)\n            break;\n    }\n\n    for (; rv < 0 && i > 0; i--) {\n        virSecurityDACChownItemPtr item = list->items[i - 1];\n        const bool remember = item->remember && list->lock;\n\n        if (!item->restore) {\n            virSecurityDACRestoreFileLabelInternal(list->manager,\n                                                   item->src,\n                                                   item->path,\n                                                   remember);\n        } else {\n            VIR_WARN(\"Ignoring failed restore attempt on %s\",\n                     NULLSTR(item->src ? item->src->path : item->path));\n        }\n    }\n\n    if (list->lock)\n        virSecurityManagerMetadataUnlock(list->manager, &state);\n\n    if (rv < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(paths);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityDACTransactionAppend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "173-190",
    "snippet": "static int\nvirSecurityDACTransactionAppend(const char *path,\n                                const virStorageSource *src,\n                                uid_t uid,\n                                gid_t gid,\n                                bool remember,\n                                bool restore)\n{\n    virSecurityDACChownListPtr list = virThreadLocalGet(&chownList);\n    if (!list)\n        return 0;\n\n    if (virSecurityDACChownListAppend(list, path, src,\n                                      uid, gid, remember, restore) < 0)\n        return -1;\n\n    return 1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virThreadLocal chownList;",
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACChownListAppend",
          "args": [
            "list",
            "path",
            "src",
            "uid",
            "gid",
            "remember",
            "restore"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACChownListAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "98-133",
          "snippet": "static int\nvirSecurityDACChownListAppend(virSecurityDACChownListPtr list,\n                              const char *path,\n                              const virStorageSource *src,\n                              uid_t uid,\n                              gid_t gid,\n                              bool remember,\n                              bool restore)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    virSecurityDACChownItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    tmp = g_strdup(path);\n\n    item->path = tmp;\n    item->src = src;\n    item->uid = uid;\n    item->gid = gid;\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    tmp = NULL;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(item);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACChownListAppend(virSecurityDACChownListPtr list,\n                              const char *path,\n                              const virStorageSource *src,\n                              uid_t uid,\n                              gid_t gid,\n                              bool remember,\n                              bool restore)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    virSecurityDACChownItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    tmp = g_strdup(path);\n\n    item->path = tmp;\n    item->src = src;\n    item->uid = uid;\n    item->gid = gid;\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    tmp = NULL;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(item);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadLocalGet",
          "args": [
            "&chownList"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadLocalGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "347-350",
          "snippet": "void *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid *virThreadLocalGet(virThreadLocalPtr l)\n{\n    return pthread_getspecific(l->key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirThreadLocal chownList;\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACTransactionAppend(const char *path,\n                                const virStorageSource *src,\n                                uid_t uid,\n                                gid_t gid,\n                                bool remember,\n                                bool restore)\n{\n    virSecurityDACChownListPtr list = virThreadLocalGet(&chownList);\n    if (!list)\n        return 0;\n\n    if (virSecurityDACChownListAppend(list, path, src,\n                                      uid, gid, remember, restore) < 0)\n        return -1;\n\n    return 1;\n}"
  },
  {
    "function_name": "virSecurityDACChownListFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "135-151",
    "snippet": "static void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "list->manager"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list->items"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list->items[i]"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list->items[i]->path"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nvirSecurityDACChownListFree(void *opaque)\n{\n    virSecurityDACChownListPtr list = opaque;\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nItems; i++) {\n        VIR_FREE(list->items[i]->path);\n        VIR_FREE(list->items[i]);\n    }\n    VIR_FREE(list->items);\n    virObjectUnref(list->manager);\n    VIR_FREE(list);\n}"
  },
  {
    "function_name": "virSecurityDACChownListAppend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
    "lines": "98-133",
    "snippet": "static int\nvirSecurityDACChownListAppend(virSecurityDACChownListPtr list,\n                              const char *path,\n                              const virStorageSource *src,\n                              uid_t uid,\n                              gid_t gid,\n                              bool remember,\n                              bool restore)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    virSecurityDACChownItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    tmp = g_strdup(path);\n\n    item->path = tmp;\n    item->src = src;\n    item->uid = uid;\n    item->gid = gid;\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    tmp = NULL;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(item);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virscsivhost.h\"",
      "#include \"virscsi.h\"",
      "#include \"virusb.h\"",
      "#include \"virpci.h\"",
      "#include \"virmdev.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"security_util.h\"",
      "#include \"security_dac.h\"",
      "# include <sys/user.h>",
      "# include <sys/sysctl.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "list->items",
            "list->nItems",
            "item"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "item"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityDACSetOwnership(virSecurityManagerPtr mgr,\n                                      const virStorageSource *src,\n                                      const char *path,\n                                      uid_t uid,\n                                      gid_t gid,\n                                      bool remember);\n\nstatic int\nvirSecurityDACChownListAppend(virSecurityDACChownListPtr list,\n                              const char *path,\n                              const virStorageSource *src,\n                              uid_t uid,\n                              gid_t gid,\n                              bool remember,\n                              bool restore)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    virSecurityDACChownItemPtr item = NULL;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n\n    tmp = g_strdup(path);\n\n    item->path = tmp;\n    item->src = src;\n    item->uid = uid;\n    item->gid = gid;\n    item->remember = remember;\n    item->restore = restore;\n\n    if (VIR_APPEND_ELEMENT(list->items, list->nItems, item) < 0)\n        goto cleanup;\n\n    tmp = NULL;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(item);\n    return ret;\n}"
  }
]