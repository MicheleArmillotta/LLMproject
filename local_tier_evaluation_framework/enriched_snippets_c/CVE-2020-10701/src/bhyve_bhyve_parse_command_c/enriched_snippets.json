[
  {
    "function_name": "bhyveParseCommandLineString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "842-894",
    "snippet": "virDomainDefPtr\nbhyveParseCommandLineString(const char* nativeConfig,\n                            unsigned caps,\n                            virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDefPtr def = NULL;\n    int bhyve_argc = 0;\n    char **bhyve_argv = NULL;\n    int loader_argc = 0;\n    char **loader_argv = NULL;\n\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    /* Initialize defaults. */\n    def->virtType = VIR_DOMAIN_VIRT_BHYVE;\n    if (virUUIDGenerate(def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to generate uuid\"));\n        virDomainDefFree(def);\n        def = NULL;\n        goto cleanup;\n    }\n    def->id = -1;\n    def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME;\n\n    if (bhyveCommandLineToArgv(nativeConfig,\n                               &loader_argc, &loader_argv,\n                               &bhyve_argc, &bhyve_argv)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to convert the command string to argv-lists\"));\n        goto error;\n    }\n\n    if (bhyveParseBhyveCommandLine(def, xmlopt, caps, bhyve_argc, bhyve_argv))\n        goto error;\n    if (loader_argv && STREQ(loader_argv[0], \"/usr/sbin/bhyveload\")) {\n        if (bhyveParseBhyveLoadCommandLine(def, loader_argc, loader_argv))\n            goto error;\n    } else if (loader_argv) {\n        if (bhyveParseCustomLoaderCommandLine(def, loader_argc, loader_argv))\n            goto error;\n    }\n\n cleanup:\n    virStringListFree(loader_argv);\n    virStringListFree(bhyve_argv);\n    return def;\n error:\n    virDomainDefFree(def);\n    def = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "bhyve_argv"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveParseCustomLoaderCommandLine",
          "args": [
            "def",
            "loader_argc",
            "loader_argv"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseCustomLoaderCommandLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "828-840",
          "snippet": "static int\nbhyveParseCustomLoaderCommandLine(virDomainDefPtr def,\n                                  int argc G_GNUC_UNUSED,\n                                  char **argv)\n{\n    if (!argv)\n        return -1;\n\n    def->os.bootloader = g_strdup(argv[0]);\n    def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseCustomLoaderCommandLine(virDomainDefPtr def,\n                                  int argc G_GNUC_UNUSED,\n                                  char **argv)\n{\n    if (!argv)\n        return -1;\n\n    def->os.bootloader = g_strdup(argv[0]);\n    def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveParseBhyveLoadCommandLine",
          "args": [
            "def",
            "loader_argc",
            "loader_argv"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseBhyveLoadCommandLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "748-824",
          "snippet": "static int\nbhyveParseBhyveLoadCommandLine(virDomainDefPtr def,\n                               int argc, char **argv)\n{\n    /* bhyveload called with default arguments when only -m and -d are given.\n     * Store this in a bit field and check if only those two options are given\n     * later */\n    unsigned arguments = 0;\n    size_t memory = 0;\n    size_t i = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'd':\n            CONSUME_ARG(arg);\n            arguments |= 1;\n            /* Iterate over the disks of the domain trying to match up the\n             * source */\n            for (i = 0; i < def->ndisks; i++) {\n                if (STREQ(virDomainDiskGetSource(def->disks[i]),\n                          arg)) {\n                    def->disks[i]->info.bootIndex = i;\n                    break;\n                }\n            }\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            arguments |= 2;\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        default:\n            arguments |= 4;\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (arguments != 3) {\n        /* Set os.bootloader since virDomainDefFormatInternal will only format\n         * the bootloader arguments if os->bootloader is set. */\n        def->os.bootloader = g_strdup(argv[0]);\n        def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyveLoadCommandLine(virDomainDefPtr def,\n                               int argc, char **argv)\n{\n    /* bhyveload called with default arguments when only -m and -d are given.\n     * Store this in a bit field and check if only those two options are given\n     * later */\n    unsigned arguments = 0;\n    size_t memory = 0;\n    size_t i = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'd':\n            CONSUME_ARG(arg);\n            arguments |= 1;\n            /* Iterate over the disks of the domain trying to match up the\n             * source */\n            for (i = 0; i < def->ndisks; i++) {\n                if (STREQ(virDomainDiskGetSource(def->disks[i]),\n                          arg)) {\n                    def->disks[i]->info.bootIndex = i;\n                    break;\n                }\n            }\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            arguments |= 2;\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        default:\n            arguments |= 4;\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (arguments != 3) {\n        /* Set os.bootloader since virDomainDefFormatInternal will only format\n         * the bootloader arguments if os->bootloader is set. */\n        def->os.bootloader = g_strdup(argv[0]);\n        def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "loader_argv[0]",
            "\"/usr/sbin/bhyveload\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParseBhyveCommandLine",
          "args": [
            "def",
            "xmlopt",
            "caps",
            "bhyve_argc",
            "bhyve_argv"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseBhyveCommandLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "638-743",
          "snippet": "static int\nbhyveParseBhyveCommandLine(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned caps,\n                           int argc, char **argv)\n{\n    int vcpus = 1;\n    size_t memory = 0;\n    unsigned nahcidisks = 0;\n    unsigned nvirtiodisks = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'A':\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'c':\n            CONSUME_ARG(arg);\n            if (virStrToLong_i(arg, NULL, 10, &vcpus) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse number of vCPUs\"));\n                return -1;\n            }\n            if (virDomainDefSetVcpusMax(def, vcpus, xmlopt) < 0)\n                return -1;\n            if (virDomainDefSetVcpus(def, vcpus) < 0)\n                return -1;\n            break;\n        case 'l':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyveLPCArg(def, caps, arg))\n                return -1;\n            break;\n        case 's':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyvePCIArg(def,\n                                      xmlopt,\n                                      caps,\n                                      &nahcidisks,\n                                      &nvirtiodisks,\n                                      arg))\n                return -1;\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        case 'I':\n            /* While this flag was deprecated in FreeBSD r257423, keep checking\n             * for it for backwards compatibility. */\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'u':\n            def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_UTC;\n            break;\n        case 'U':\n            CONSUME_ARG(arg);\n            if (virUUIDParse(arg, def->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Cannot parse UUID '%s'\"), arg);\n                return -1;\n            }\n            break;\n        case 'S':\n            def->mem.locked = true;\n            break;\n        case 'p':\n        case 'g':\n            CONSUME_ARG(arg);\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyveCommandLine(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned caps,\n                           int argc, char **argv)\n{\n    int vcpus = 1;\n    size_t memory = 0;\n    unsigned nahcidisks = 0;\n    unsigned nvirtiodisks = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'A':\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'c':\n            CONSUME_ARG(arg);\n            if (virStrToLong_i(arg, NULL, 10, &vcpus) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse number of vCPUs\"));\n                return -1;\n            }\n            if (virDomainDefSetVcpusMax(def, vcpus, xmlopt) < 0)\n                return -1;\n            if (virDomainDefSetVcpus(def, vcpus) < 0)\n                return -1;\n            break;\n        case 'l':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyveLPCArg(def, caps, arg))\n                return -1;\n            break;\n        case 's':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyvePCIArg(def,\n                                      xmlopt,\n                                      caps,\n                                      &nahcidisks,\n                                      &nvirtiodisks,\n                                      arg))\n                return -1;\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        case 'I':\n            /* While this flag was deprecated in FreeBSD r257423, keep checking\n             * for it for backwards compatibility. */\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'u':\n            def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_UTC;\n            break;\n        case 'U':\n            CONSUME_ARG(arg);\n            if (virUUIDParse(arg, def->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Cannot parse UUID '%s'\"), arg);\n                return -1;\n            }\n            break;\n        case 'S':\n            def->mem.locked = true;\n            break;\n        case 'p':\n        case 'g':\n            CONSUME_ARG(arg);\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to convert the command string to argv-lists\")"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert the command string to argv-lists\""
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bhyveCommandLineToArgv",
          "args": [
            "nativeConfig",
            "&loader_argc",
            "&loader_argv",
            "&bhyve_argc",
            "&bhyve_argv"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveCommandLineToArgv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "119-265",
          "snippet": "static int\nbhyveCommandLineToArgv(const char *nativeConfig,\n                      int *loader_argc,\n                      char ***loader_argv,\n                      int *bhyve_argc,\n                      char ***bhyve_argv)\n{\n    const char *curr = NULL;\n    char *nativeConfig_unescaped = NULL;\n    const char *start;\n    const char *next;\n    char *line;\n    char **lines = NULL;\n    size_t i;\n    size_t line_count = 0;\n    size_t lines_alloc = 0;\n    char **_bhyve_argv = NULL;\n    char **_loader_argv = NULL;\n\n    nativeConfig_unescaped = bhyveParseCommandLineUnescape(nativeConfig);\n    if (nativeConfig_unescaped == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to unescape command line string\"));\n        goto error;\n    }\n\n    curr = nativeConfig_unescaped;\n\n    /* Iterate over string, splitting on sequences of '\\n' */\n    while (curr && *curr != '\\0') {\n        start = curr;\n        next = strchr(curr, '\\n');\n\n        if (next)\n            line = g_strndup(curr, next - curr);\n        else\n            line = g_strdup(curr);\n\n        if (VIR_RESIZE_N(lines, lines_alloc, line_count, 2) < 0) {\n            VIR_FREE(line);\n            goto error;\n        }\n\n        if (*line)\n            lines[line_count++] = line;\n        lines[line_count] = NULL;\n\n        while (next && (*next == '\\n' || *next == '\\r'\n                        || STRPREFIX(next, \"\\r\\n\")))\n            next++;\n\n        curr = next;\n    }\n\n    for (i = 0; i < line_count; i++) {\n        curr = lines[i];\n        size_t j;\n        char **arglist = NULL;\n        size_t args_count = 0;\n        size_t args_alloc = 0;\n\n        /* iterate over each line, splitting on sequences of ' '. This code is\n         * adapted from qemu/qemu_parse_command.c. */\n        while (curr && *curr != '\\0') {\n            char *arg;\n            start = curr;\n\n            if (*start == '\\'') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\\'');\n            } else if (*start == '\"') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\"');\n            } else {\n                next = strchr(start, ' ');\n            }\n\n            if (next)\n                arg = g_strndup(curr, next - curr);\n            else\n                arg = g_strdup(curr);\n\n            if (next && (*next == '\\'' || *next == '\"'))\n                next++;\n\n            if (VIR_RESIZE_N(arglist, args_alloc, args_count, 2) < 0) {\n                VIR_FREE(arg);\n                goto error;\n            }\n\n            arglist[args_count++] = arg;\n            arglist[args_count] = NULL;\n\n            while (next && g_ascii_isspace(*next))\n                next++;\n\n            curr = next;\n        }\n\n        VIR_FREE(nativeConfig_unescaped);\n\n        /* To prevent a memory leak here, only set the argument lists when\n         * the first matching command is found. This shouldn't really be a\n         * problem, since usually no multiple loaders or bhyverun commands\n         * are specified (this wouldn't really be valid anyways).\n         * Otherwise, later argument lists may be assigned to _argv without\n         * freeing the earlier ones. */\n        if (!_bhyve_argv && STREQ(arglist[0], \"/usr/sbin/bhyve\")) {\n            if ((VIR_REALLOC_N(_bhyve_argv, args_count + 1) < 0)\n                || (!bhyve_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _bhyve_argv[j] = arglist[j];\n            _bhyve_argv[j] = NULL;\n            *bhyve_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else if (!_loader_argv) {\n            if ((VIR_REALLOC_N(_loader_argv, args_count + 1) < 0)\n                || (!loader_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _loader_argv[j] = arglist[j];\n            _loader_argv[j] = NULL;\n            *loader_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else {\n            /* To prevent a use-after-free here, only free the argument list\n             * when it is definitely not going to be used */\n            virStringListFree(arglist);\n        }\n    }\n\n    *loader_argv = _loader_argv;\n    if (!(*bhyve_argv = _bhyve_argv))\n        goto error;\n\n    virStringListFree(lines);\n    return 0;\n\n error:\n    VIR_FREE(_loader_argv);\n    VIR_FREE(_bhyve_argv);\n    virStringListFree(lines);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveCommandLineToArgv(const char *nativeConfig,\n                      int *loader_argc,\n                      char ***loader_argv,\n                      int *bhyve_argc,\n                      char ***bhyve_argv)\n{\n    const char *curr = NULL;\n    char *nativeConfig_unescaped = NULL;\n    const char *start;\n    const char *next;\n    char *line;\n    char **lines = NULL;\n    size_t i;\n    size_t line_count = 0;\n    size_t lines_alloc = 0;\n    char **_bhyve_argv = NULL;\n    char **_loader_argv = NULL;\n\n    nativeConfig_unescaped = bhyveParseCommandLineUnescape(nativeConfig);\n    if (nativeConfig_unescaped == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to unescape command line string\"));\n        goto error;\n    }\n\n    curr = nativeConfig_unescaped;\n\n    /* Iterate over string, splitting on sequences of '\\n' */\n    while (curr && *curr != '\\0') {\n        start = curr;\n        next = strchr(curr, '\\n');\n\n        if (next)\n            line = g_strndup(curr, next - curr);\n        else\n            line = g_strdup(curr);\n\n        if (VIR_RESIZE_N(lines, lines_alloc, line_count, 2) < 0) {\n            VIR_FREE(line);\n            goto error;\n        }\n\n        if (*line)\n            lines[line_count++] = line;\n        lines[line_count] = NULL;\n\n        while (next && (*next == '\\n' || *next == '\\r'\n                        || STRPREFIX(next, \"\\r\\n\")))\n            next++;\n\n        curr = next;\n    }\n\n    for (i = 0; i < line_count; i++) {\n        curr = lines[i];\n        size_t j;\n        char **arglist = NULL;\n        size_t args_count = 0;\n        size_t args_alloc = 0;\n\n        /* iterate over each line, splitting on sequences of ' '. This code is\n         * adapted from qemu/qemu_parse_command.c. */\n        while (curr && *curr != '\\0') {\n            char *arg;\n            start = curr;\n\n            if (*start == '\\'') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\\'');\n            } else if (*start == '\"') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\"');\n            } else {\n                next = strchr(start, ' ');\n            }\n\n            if (next)\n                arg = g_strndup(curr, next - curr);\n            else\n                arg = g_strdup(curr);\n\n            if (next && (*next == '\\'' || *next == '\"'))\n                next++;\n\n            if (VIR_RESIZE_N(arglist, args_alloc, args_count, 2) < 0) {\n                VIR_FREE(arg);\n                goto error;\n            }\n\n            arglist[args_count++] = arg;\n            arglist[args_count] = NULL;\n\n            while (next && g_ascii_isspace(*next))\n                next++;\n\n            curr = next;\n        }\n\n        VIR_FREE(nativeConfig_unescaped);\n\n        /* To prevent a memory leak here, only set the argument lists when\n         * the first matching command is found. This shouldn't really be a\n         * problem, since usually no multiple loaders or bhyverun commands\n         * are specified (this wouldn't really be valid anyways).\n         * Otherwise, later argument lists may be assigned to _argv without\n         * freeing the earlier ones. */\n        if (!_bhyve_argv && STREQ(arglist[0], \"/usr/sbin/bhyve\")) {\n            if ((VIR_REALLOC_N(_bhyve_argv, args_count + 1) < 0)\n                || (!bhyve_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _bhyve_argv[j] = arglist[j];\n            _bhyve_argv[j] = NULL;\n            *bhyve_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else if (!_loader_argv) {\n            if ((VIR_REALLOC_N(_loader_argv, args_count + 1) < 0)\n                || (!loader_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _loader_argv[j] = arglist[j];\n            _loader_argv[j] = NULL;\n            *loader_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else {\n            /* To prevent a use-after-free here, only free the argument list\n             * when it is definitely not going to be used */\n            virStringListFree(arglist);\n        }\n    }\n\n    *loader_argv = _loader_argv;\n    if (!(*bhyve_argv = _bhyve_argv))\n        goto error;\n\n    virStringListFree(lines);\n    return 0;\n\n error:\n    VIR_FREE(_loader_argv);\n    VIR_FREE(_bhyve_argv);\n    virStringListFree(lines);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to generate uuid\")"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "def->uuid"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nvirDomainDefPtr\nbhyveParseCommandLineString(const char* nativeConfig,\n                            unsigned caps,\n                            virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDefPtr def = NULL;\n    int bhyve_argc = 0;\n    char **bhyve_argv = NULL;\n    int loader_argc = 0;\n    char **loader_argv = NULL;\n\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    /* Initialize defaults. */\n    def->virtType = VIR_DOMAIN_VIRT_BHYVE;\n    if (virUUIDGenerate(def->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to generate uuid\"));\n        virDomainDefFree(def);\n        def = NULL;\n        goto cleanup;\n    }\n    def->id = -1;\n    def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME;\n\n    if (bhyveCommandLineToArgv(nativeConfig,\n                               &loader_argc, &loader_argv,\n                               &bhyve_argc, &bhyve_argv)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to convert the command string to argv-lists\"));\n        goto error;\n    }\n\n    if (bhyveParseBhyveCommandLine(def, xmlopt, caps, bhyve_argc, bhyve_argv))\n        goto error;\n    if (loader_argv && STREQ(loader_argv[0], \"/usr/sbin/bhyveload\")) {\n        if (bhyveParseBhyveLoadCommandLine(def, loader_argc, loader_argv))\n            goto error;\n    } else if (loader_argv) {\n        if (bhyveParseCustomLoaderCommandLine(def, loader_argc, loader_argv))\n            goto error;\n    }\n\n cleanup:\n    virStringListFree(loader_argv);\n    virStringListFree(bhyve_argv);\n    return def;\n error:\n    virDomainDefFree(def);\n    def = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "bhyveParseCustomLoaderCommandLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "828-840",
    "snippet": "static int\nbhyveParseCustomLoaderCommandLine(virDomainDefPtr def,\n                                  int argc G_GNUC_UNUSED,\n                                  char **argv)\n{\n    if (!argv)\n        return -1;\n\n    def->os.bootloader = g_strdup(argv[0]);\n    def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListJoin",
          "args": [
            "(const char**) &argv[1]",
            "\" \""
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "147-162",
          "snippet": "char *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "argv[0]"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseCustomLoaderCommandLine(virDomainDefPtr def,\n                                  int argc G_GNUC_UNUSED,\n                                  char **argv)\n{\n    if (!argv)\n        return -1;\n\n    def->os.bootloader = g_strdup(argv[0]);\n    def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveParseBhyveLoadCommandLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "748-824",
    "snippet": "static int\nbhyveParseBhyveLoadCommandLine(virDomainDefPtr def,\n                               int argc, char **argv)\n{\n    /* bhyveload called with default arguments when only -m and -d are given.\n     * Store this in a bit field and check if only those two options are given\n     * later */\n    unsigned arguments = 0;\n    size_t memory = 0;\n    size_t i = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'd':\n            CONSUME_ARG(arg);\n            arguments |= 1;\n            /* Iterate over the disks of the domain trying to match up the\n             * source */\n            for (i = 0; i < def->ndisks; i++) {\n                if (STREQ(virDomainDiskGetSource(def->disks[i]),\n                          arg)) {\n                    def->disks[i]->info.bootIndex = i;\n                    break;\n                }\n            }\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            arguments |= 2;\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        default:\n            arguments |= 4;\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (arguments != 3) {\n        /* Set os.bootloader since virDomainDefFormatInternal will only format\n         * the bootloader arguments if os->bootloader is set. */\n        def->os.bootloader = g_strdup(argv[0]);\n        def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse arguments: VM name mismatch\")"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to parse arguments: VM name mismatch\""
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "def->name",
            "argv[argc]"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListJoin",
          "args": [
            "(const char**) &argv[1]",
            "\" \""
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "147-162",
          "snippet": "char *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse arguments for bhyve command\")"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "memory"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse memory: size mismatch\")"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse memory\")"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParseMemsize",
          "args": [
            "arg",
            "&memory"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseMemsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "90-114",
          "snippet": "static int\nbhyveParseMemsize(const char *arg, size_t *ret_memsize)\n{\n    size_t val;\n    int error;\n\n    if (virStrToLong_ul(arg, NULL, 10, &val) == 0) {\n        /*\n         * For the sake of backward compatibility if the memory size\n         * specified on the command line is less than a megabyte then\n         * it is interpreted as being in units of MB.\n         */\n        if (val < 1024 * 1024UL)\n            val *= 1024 * 1024UL;\n        *ret_memsize = val;\n        error = 0;\n    } else {\n        error = expand_number(arg, ret_memsize);\n    }\n\n    /* use memory in KiB here */\n    *ret_memsize /= 1024UL;\n\n    return error;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseMemsize(const char *arg, size_t *ret_memsize)\n{\n    size_t val;\n    int error;\n\n    if (virStrToLong_ul(arg, NULL, 10, &val) == 0) {\n        /*\n         * For the sake of backward compatibility if the memory size\n         * specified on the command line is less than a megabyte then\n         * it is interpreted as being in units of MB.\n         */\n        if (val < 1024 * 1024UL)\n            val *= 1024 * 1024UL;\n        *ret_memsize = val;\n        error = 0;\n    } else {\n        error = expand_number(arg, ret_memsize);\n    }\n\n    /* use memory in KiB here */\n    *ret_memsize /= 1024UL;\n\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "virDomainDiskGetSource(def->disks[i])",
            "arg"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def->disks[i]"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyveLoadCommandLine(virDomainDefPtr def,\n                               int argc, char **argv)\n{\n    /* bhyveload called with default arguments when only -m and -d are given.\n     * Store this in a bit field and check if only those two options are given\n     * later */\n    unsigned arguments = 0;\n    size_t memory = 0;\n    size_t i = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'd':\n            CONSUME_ARG(arg);\n            arguments |= 1;\n            /* Iterate over the disks of the domain trying to match up the\n             * source */\n            for (i = 0; i < def->ndisks; i++) {\n                if (STREQ(virDomainDiskGetSource(def->disks[i]),\n                          arg)) {\n                    def->disks[i]->info.bootIndex = i;\n                    break;\n                }\n            }\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            arguments |= 2;\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        default:\n            arguments |= 4;\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (arguments != 3) {\n        /* Set os.bootloader since virDomainDefFormatInternal will only format\n         * the bootloader arguments if os->bootloader is set. */\n        def->os.bootloader = g_strdup(argv[0]);\n        def->os.bootloaderArgs = virStringListJoin((const char**) &argv[1], \" \");\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveParseBhyveCommandLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "638-743",
    "snippet": "static int\nbhyveParseBhyveCommandLine(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned caps,\n                           int argc, char **argv)\n{\n    int vcpus = 1;\n    size_t memory = 0;\n    unsigned nahcidisks = 0;\n    unsigned nvirtiodisks = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'A':\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'c':\n            CONSUME_ARG(arg);\n            if (virStrToLong_i(arg, NULL, 10, &vcpus) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse number of vCPUs\"));\n                return -1;\n            }\n            if (virDomainDefSetVcpusMax(def, vcpus, xmlopt) < 0)\n                return -1;\n            if (virDomainDefSetVcpus(def, vcpus) < 0)\n                return -1;\n            break;\n        case 'l':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyveLPCArg(def, caps, arg))\n                return -1;\n            break;\n        case 's':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyvePCIArg(def,\n                                      xmlopt,\n                                      caps,\n                                      &nahcidisks,\n                                      &nvirtiodisks,\n                                      arg))\n                return -1;\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        case 'I':\n            /* While this flag was deprecated in FreeBSD r257423, keep checking\n             * for it for backwards compatibility. */\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'u':\n            def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_UTC;\n            break;\n        case 'U':\n            CONSUME_ARG(arg);\n            if (virUUIDParse(arg, def->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Cannot parse UUID '%s'\"), arg);\n                return -1;\n            }\n            break;\n        case 'S':\n            def->mem.locked = true;\n            break;\n        case 'p':\n        case 'g':\n            CONSUME_ARG(arg);\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse arguments: VM name mismatch\")"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to parse arguments: VM name mismatch\""
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "def->name",
            "argv[argc]"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse arguments for bhyve command\")"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse UUID '%s'\")",
            "arg"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "arg",
            "def->uuid"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "memory"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse memory: size mismatch\")"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse memory\")"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParseMemsize",
          "args": [
            "arg",
            "&memory"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseMemsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "90-114",
          "snippet": "static int\nbhyveParseMemsize(const char *arg, size_t *ret_memsize)\n{\n    size_t val;\n    int error;\n\n    if (virStrToLong_ul(arg, NULL, 10, &val) == 0) {\n        /*\n         * For the sake of backward compatibility if the memory size\n         * specified on the command line is less than a megabyte then\n         * it is interpreted as being in units of MB.\n         */\n        if (val < 1024 * 1024UL)\n            val *= 1024 * 1024UL;\n        *ret_memsize = val;\n        error = 0;\n    } else {\n        error = expand_number(arg, ret_memsize);\n    }\n\n    /* use memory in KiB here */\n    *ret_memsize /= 1024UL;\n\n    return error;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseMemsize(const char *arg, size_t *ret_memsize)\n{\n    size_t val;\n    int error;\n\n    if (virStrToLong_ul(arg, NULL, 10, &val) == 0) {\n        /*\n         * For the sake of backward compatibility if the memory size\n         * specified on the command line is less than a megabyte then\n         * it is interpreted as being in units of MB.\n         */\n        if (val < 1024 * 1024UL)\n            val *= 1024 * 1024UL;\n        *ret_memsize = val;\n        error = 0;\n    } else {\n        error = expand_number(arg, ret_memsize);\n    }\n\n    /* use memory in KiB here */\n    *ret_memsize /= 1024UL;\n\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParseBhyvePCIArg",
          "args": [
            "def",
            "xmlopt",
            "caps",
            "&nahcidisks",
            "&nvirtiodisks",
            "arg"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseBhyvePCIArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "555-625",
          "snippet": "static int\nbhyveParseBhyvePCIArg(virDomainDefPtr def,\n                      virDomainXMLOptionPtr xmlopt,\n                      unsigned caps,\n                      unsigned *nvirtiodisk,\n                      unsigned *nahcidisk,\n                      const char *arg)\n{\n    /* -s slot,emulation[,conf] */\n    const char *separator = NULL;\n    char *slotdef = NULL;\n    char *emulation = NULL;\n    char *conf = NULL;\n    unsigned bus, slot, function;\n\n    separator = strchr(arg, ',');\n\n    if (!separator)\n        goto error;\n    else\n        separator++; /* Skip comma */\n\n    slotdef = g_strndup(arg, separator - arg - 1);\n\n    conf = strchr(separator+1, ',');\n    if (conf) {\n        conf++; /* Skip initial comma */\n        emulation = g_strndup(separator, conf - separator - 1);\n    } else {\n        emulation = g_strdup(separator);\n    }\n\n    if (bhyveParsePCISlot(slotdef, &bus, &slot, &function) < 0)\n        goto error;\n\n    if (STREQ(emulation, \"ahci-cd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_CDROM,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"ahci-hd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-blk\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_VIRTIO,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-net\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_VIRTIO, conf);\n    else if (STREQ(emulation, \"e1000\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_E1000, conf);\n\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return 0;\n error:\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyvePCIArg(virDomainDefPtr def,\n                      virDomainXMLOptionPtr xmlopt,\n                      unsigned caps,\n                      unsigned *nvirtiodisk,\n                      unsigned *nahcidisk,\n                      const char *arg)\n{\n    /* -s slot,emulation[,conf] */\n    const char *separator = NULL;\n    char *slotdef = NULL;\n    char *emulation = NULL;\n    char *conf = NULL;\n    unsigned bus, slot, function;\n\n    separator = strchr(arg, ',');\n\n    if (!separator)\n        goto error;\n    else\n        separator++; /* Skip comma */\n\n    slotdef = g_strndup(arg, separator - arg - 1);\n\n    conf = strchr(separator+1, ',');\n    if (conf) {\n        conf++; /* Skip initial comma */\n        emulation = g_strndup(separator, conf - separator - 1);\n    } else {\n        emulation = g_strdup(separator);\n    }\n\n    if (bhyveParsePCISlot(slotdef, &bus, &slot, &function) < 0)\n        goto error;\n\n    if (STREQ(emulation, \"ahci-cd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_CDROM,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"ahci-hd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-blk\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_VIRTIO,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-net\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_VIRTIO, conf);\n    else if (STREQ(emulation, \"e1000\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_E1000, conf);\n\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return 0;\n error:\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParseBhyveLPCArg",
          "args": [
            "def",
            "caps",
            "arg"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseBhyveLPCArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "267-351",
          "snippet": "static int\nbhyveParseBhyveLPCArg(virDomainDefPtr def,\n                      unsigned caps G_GNUC_UNUSED,\n                      const char *arg)\n{\n    /* -l emulation[,config] */\n    const char *separator = NULL;\n    const char *param = NULL;\n    size_t last = 0;\n    virDomainChrDefPtr chr = NULL;\n    char *type = NULL;\n\n    separator = strchr(arg, ',');\n    param = separator + 1;\n\n    if (!separator)\n        goto error;\n\n    type = g_strndup(arg, separator - arg);\n\n    /* Only support com%d */\n    if (STRPREFIX(type, \"com\") && type[4] == 0) {\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto error;\n\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_NMDM;\n        chr->source->data.nmdm.master = NULL;\n        chr->source->data.nmdm.slave = NULL;\n        chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n        if (!STRPREFIX(param, \"/dev/nmdm\")) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to set com port %s: does not start with \"\n                             \"'/dev/nmdm'.\"), type);\n                goto error;\n        }\n\n        chr->source->data.nmdm.master = g_strdup(param);\n        chr->source->data.nmdm.slave = g_strdup(chr->source->data.file.path);\n\n        /* If the last character of the master is 'A', the slave will be 'B'\n         * and vice versa */\n        last = strlen(chr->source->data.nmdm.master) - 1;\n        switch (chr->source->data.file.path[last]) {\n            case 'A':\n                chr->source->data.nmdm.slave[last] = 'B';\n                break;\n            case 'B':\n                chr->source->data.nmdm.slave[last] = 'A';\n                break;\n            default:\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Failed to set slave for %s: last letter not \"\n                                 \"'A' or 'B'\"),\n                               NULLSTR(chr->source->data.nmdm.master));\n                goto error;\n        }\n\n        switch (type[3]-'0') {\n        case 1:\n        case 2:\n            chr->target.port = type[3] - '1';\n            break;\n        default:\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to parse %s: only com1 and com2\"\n                             \" supported.\"), type);\n            goto error;\n            break;\n        }\n\n        if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0) {\n            virDomainChrDefFree(chr);\n            goto error;\n        }\n    }\n\n    VIR_FREE(type);\n    return 0;\n\n error:\n    virDomainChrDefFree(chr);\n    VIR_FREE(type);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyveLPCArg(virDomainDefPtr def,\n                      unsigned caps G_GNUC_UNUSED,\n                      const char *arg)\n{\n    /* -l emulation[,config] */\n    const char *separator = NULL;\n    const char *param = NULL;\n    size_t last = 0;\n    virDomainChrDefPtr chr = NULL;\n    char *type = NULL;\n\n    separator = strchr(arg, ',');\n    param = separator + 1;\n\n    if (!separator)\n        goto error;\n\n    type = g_strndup(arg, separator - arg);\n\n    /* Only support com%d */\n    if (STRPREFIX(type, \"com\") && type[4] == 0) {\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto error;\n\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_NMDM;\n        chr->source->data.nmdm.master = NULL;\n        chr->source->data.nmdm.slave = NULL;\n        chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n        if (!STRPREFIX(param, \"/dev/nmdm\")) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to set com port %s: does not start with \"\n                             \"'/dev/nmdm'.\"), type);\n                goto error;\n        }\n\n        chr->source->data.nmdm.master = g_strdup(param);\n        chr->source->data.nmdm.slave = g_strdup(chr->source->data.file.path);\n\n        /* If the last character of the master is 'A', the slave will be 'B'\n         * and vice versa */\n        last = strlen(chr->source->data.nmdm.master) - 1;\n        switch (chr->source->data.file.path[last]) {\n            case 'A':\n                chr->source->data.nmdm.slave[last] = 'B';\n                break;\n            case 'B':\n                chr->source->data.nmdm.slave[last] = 'A';\n                break;\n            default:\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Failed to set slave for %s: last letter not \"\n                                 \"'A' or 'B'\"),\n                               NULLSTR(chr->source->data.nmdm.master));\n                goto error;\n        }\n\n        switch (type[3]-'0') {\n        case 1:\n        case 2:\n            chr->target.port = type[3] - '1';\n            break;\n        default:\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to parse %s: only com1 and com2\"\n                             \" supported.\"), type);\n            goto error;\n            break;\n        }\n\n        if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0) {\n            virDomainChrDefFree(chr);\n            goto error;\n        }\n    }\n\n    VIR_FREE(type);\n    return 0;\n\n error:\n    virDomainChrDefFree(chr);\n    VIR_FREE(type);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "def",
            "vcpus"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "def",
            "vcpus",
            "xmlopt"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to parse number of vCPUs\")"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "arg",
            "NULL",
            "10",
            "&vcpus"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CONSUME_ARG",
          "args": [
            "arg"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyveCommandLine(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned caps,\n                           int argc, char **argv)\n{\n    int vcpus = 1;\n    size_t memory = 0;\n    unsigned nahcidisks = 0;\n    unsigned nvirtiodisks = 0;\n    size_t opti;\n    const char *arg;\n\n    for (opti = 1; opti < argc; opti++) {\n        if (argv[opti][0] != '-')\n            break;\n\n        switch (argv[opti][1]) {\n        case 'A':\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'c':\n            CONSUME_ARG(arg);\n            if (virStrToLong_i(arg, NULL, 10, &vcpus) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse number of vCPUs\"));\n                return -1;\n            }\n            if (virDomainDefSetVcpusMax(def, vcpus, xmlopt) < 0)\n                return -1;\n            if (virDomainDefSetVcpus(def, vcpus) < 0)\n                return -1;\n            break;\n        case 'l':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyveLPCArg(def, caps, arg))\n                return -1;\n            break;\n        case 's':\n            CONSUME_ARG(arg);\n            if (bhyveParseBhyvePCIArg(def,\n                                      xmlopt,\n                                      caps,\n                                      &nahcidisks,\n                                      &nvirtiodisks,\n                                      arg))\n                return -1;\n            break;\n        case 'm':\n            CONSUME_ARG(arg);\n            if (bhyveParseMemsize(arg, &memory)) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"Failed to parse memory\"));\n                return -1;\n            }\n            if (def->mem.cur_balloon != 0 && def->mem.cur_balloon != memory) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Failed to parse memory: size mismatch\"));\n                return -1;\n            }\n            def->mem.cur_balloon = memory;\n            virDomainDefSetMemoryTotal(def, memory);\n            break;\n        case 'I':\n            /* While this flag was deprecated in FreeBSD r257423, keep checking\n             * for it for backwards compatibility. */\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n            break;\n        case 'u':\n            def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_UTC;\n            break;\n        case 'U':\n            CONSUME_ARG(arg);\n            if (virUUIDParse(arg, def->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Cannot parse UUID '%s'\"), arg);\n                return -1;\n            }\n            break;\n        case 'S':\n            def->mem.locked = true;\n            break;\n        case 'p':\n        case 'g':\n            CONSUME_ARG(arg);\n        }\n    }\n\n    if (argc != opti) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments for bhyve command\"));\n        return -1;\n    }\n\n    if (def->name == NULL) {\n        def->name = g_strdup(argv[argc]);\n    } else if (STRNEQ(def->name, argv[argc])) {\n        /* the vm name of the loader and the bhyverun command differ, throw an\n         * error here */\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to parse arguments: VM name mismatch\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveParseBhyvePCIArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "555-625",
    "snippet": "static int\nbhyveParseBhyvePCIArg(virDomainDefPtr def,\n                      virDomainXMLOptionPtr xmlopt,\n                      unsigned caps,\n                      unsigned *nvirtiodisk,\n                      unsigned *nahcidisk,\n                      const char *arg)\n{\n    /* -s slot,emulation[,conf] */\n    const char *separator = NULL;\n    char *slotdef = NULL;\n    char *emulation = NULL;\n    char *conf = NULL;\n    unsigned bus, slot, function;\n\n    separator = strchr(arg, ',');\n\n    if (!separator)\n        goto error;\n    else\n        separator++; /* Skip comma */\n\n    slotdef = g_strndup(arg, separator - arg - 1);\n\n    conf = strchr(separator+1, ',');\n    if (conf) {\n        conf++; /* Skip initial comma */\n        emulation = g_strndup(separator, conf - separator - 1);\n    } else {\n        emulation = g_strdup(separator);\n    }\n\n    if (bhyveParsePCISlot(slotdef, &bus, &slot, &function) < 0)\n        goto error;\n\n    if (STREQ(emulation, \"ahci-cd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_CDROM,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"ahci-hd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-blk\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_VIRTIO,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-net\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_VIRTIO, conf);\n    else if (STREQ(emulation, \"e1000\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_E1000, conf);\n\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return 0;\n error:\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slotdef"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "emulation"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slotdef"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "emulation"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParsePCINet",
          "args": [
            "def",
            "xmlopt",
            "caps",
            "bus",
            "slot",
            "function",
            "VIR_DOMAIN_NET_MODEL_E1000",
            "conf"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParsePCINet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "479-553",
          "snippet": "static int\nbhyveParsePCINet(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 unsigned caps G_GNUC_UNUSED,\n                 unsigned bus,\n                 unsigned slot,\n                 unsigned function,\n                 int model,\n                 const char *config)\n{\n    /* -s slot,virtio-net,tapN[,mac=xx:xx:xx:xx:xx:xx] */\n\n    virDomainNetDefPtr net = NULL;\n    const char *separator = NULL;\n    const char *mac = NULL;\n\n    if (!(net = virDomainNetDefNew(xmlopt)))\n        goto cleanup;\n\n    /* As we only support interface type='bridge' and cannot\n     * guess the actual bridge name from the command line,\n     * try to come up with some reasonable defaults */\n    net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    net->data.bridge.brname = g_strdup(\"virbr0\");\n\n    net->model = model;\n    net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    net->info.addr.pci.bus = bus;\n    net->info.addr.pci.slot = slot;\n    net->info.addr.pci.function = function;\n\n    if (!config)\n        goto error;\n\n    if (!STRPREFIX(config, \"tap\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only tap devices supported\"));\n        goto error;\n    }\n\n    separator = strchr(config, ',');\n    if (separator)\n        net->ifname = g_strndup(config, separator - config);\n    else\n        net->ifname = g_strdup(config);\n\n    if (!separator)\n        goto cleanup;\n\n    if (!STRPREFIX(++separator, \"mac=\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only mac option can be specified for virt-net\"));\n        goto error;\n    }\n    mac = separator + 4;\n\n    if (virMacAddrParse(mac, &net->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse mac address '%s'\"),\n                       mac);\n        goto cleanup;\n     }\n\n cleanup:\n    if (!mac)\n        virDomainNetGenerateMAC(xmlopt, &net->mac);\n\n    if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n        goto error;\n    return 0;\n\n error:\n    virDomainNetDefFree(net);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParsePCINet(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 unsigned caps G_GNUC_UNUSED,\n                 unsigned bus,\n                 unsigned slot,\n                 unsigned function,\n                 int model,\n                 const char *config)\n{\n    /* -s slot,virtio-net,tapN[,mac=xx:xx:xx:xx:xx:xx] */\n\n    virDomainNetDefPtr net = NULL;\n    const char *separator = NULL;\n    const char *mac = NULL;\n\n    if (!(net = virDomainNetDefNew(xmlopt)))\n        goto cleanup;\n\n    /* As we only support interface type='bridge' and cannot\n     * guess the actual bridge name from the command line,\n     * try to come up with some reasonable defaults */\n    net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    net->data.bridge.brname = g_strdup(\"virbr0\");\n\n    net->model = model;\n    net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    net->info.addr.pci.bus = bus;\n    net->info.addr.pci.slot = slot;\n    net->info.addr.pci.function = function;\n\n    if (!config)\n        goto error;\n\n    if (!STRPREFIX(config, \"tap\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only tap devices supported\"));\n        goto error;\n    }\n\n    separator = strchr(config, ',');\n    if (separator)\n        net->ifname = g_strndup(config, separator - config);\n    else\n        net->ifname = g_strdup(config);\n\n    if (!separator)\n        goto cleanup;\n\n    if (!STRPREFIX(++separator, \"mac=\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only mac option can be specified for virt-net\"));\n        goto error;\n    }\n    mac = separator + 4;\n\n    if (virMacAddrParse(mac, &net->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse mac address '%s'\"),\n                       mac);\n        goto cleanup;\n     }\n\n cleanup:\n    if (!mac)\n        virDomainNetGenerateMAC(xmlopt, &net->mac);\n\n    if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n        goto error;\n    return 0;\n\n error:\n    virDomainNetDefFree(net);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "emulation",
            "\"e1000\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "emulation",
            "\"virtio-net\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParsePCIDisk",
          "args": [
            "def",
            "caps",
            "bus",
            "slot",
            "function",
            "VIR_DOMAIN_DISK_BUS_VIRTIO",
            "VIR_DOMAIN_DISK_DEVICE_DISK",
            "nvirtiodisk",
            "nahcidisk",
            "conf"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParsePCIDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "409-477",
          "snippet": "static int\nbhyveParsePCIDisk(virDomainDefPtr def,\n                  unsigned caps G_GNUC_UNUSED,\n                  unsigned pcibus,\n                  unsigned pcislot,\n                  unsigned function,\n                  int bus,\n                  int device,\n                  unsigned *nvirtiodisk,\n                  unsigned *nahcidisk,\n                  char *config)\n{\n    /* -s slot,virtio-blk|ahci-cd|ahci-hd,/path/to/file */\n    const char *separator = NULL;\n    int idx = -1;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (!(disk = virDomainDiskDefNew(NULL)))\n        return 0;\n\n    disk->bus = bus;\n    disk->device = device;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    disk->info.addr.pci.bus = pcibus;\n    disk->info.addr.pci.slot = pcislot;\n    disk->info.addr.pci.function = function;\n\n    if (STRPREFIX(config, \"/dev/\"))\n        disk->src->type = VIR_STORAGE_TYPE_BLOCK;\n    else\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n\n    if (!config)\n        goto error;\n\n    separator = strchr(config, ',');\n    if (separator)\n        disk->src->path = g_strndup(config, separator - config);\n    else\n        disk->src->path = g_strdup(config);\n\n    if (bus == VIR_DOMAIN_DISK_BUS_VIRTIO) {\n        idx = *nvirtiodisk;\n        *nvirtiodisk += 1;\n        disk->dst = g_strdup(\"vda\");\n    } else if (bus == VIR_DOMAIN_DISK_BUS_SATA) {\n        idx = *nahcidisk;\n        *nahcidisk += 1;\n        disk->dst = g_strdup(\"sda\");\n    }\n\n    if (idx > 'z' - 'a') {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disks\"));\n        goto error;\n    }\n\n    disk->dst[2] = 'a' + idx;\n\n    if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainDiskDefFree(disk);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParsePCIDisk(virDomainDefPtr def,\n                  unsigned caps G_GNUC_UNUSED,\n                  unsigned pcibus,\n                  unsigned pcislot,\n                  unsigned function,\n                  int bus,\n                  int device,\n                  unsigned *nvirtiodisk,\n                  unsigned *nahcidisk,\n                  char *config)\n{\n    /* -s slot,virtio-blk|ahci-cd|ahci-hd,/path/to/file */\n    const char *separator = NULL;\n    int idx = -1;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (!(disk = virDomainDiskDefNew(NULL)))\n        return 0;\n\n    disk->bus = bus;\n    disk->device = device;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    disk->info.addr.pci.bus = pcibus;\n    disk->info.addr.pci.slot = pcislot;\n    disk->info.addr.pci.function = function;\n\n    if (STRPREFIX(config, \"/dev/\"))\n        disk->src->type = VIR_STORAGE_TYPE_BLOCK;\n    else\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n\n    if (!config)\n        goto error;\n\n    separator = strchr(config, ',');\n    if (separator)\n        disk->src->path = g_strndup(config, separator - config);\n    else\n        disk->src->path = g_strdup(config);\n\n    if (bus == VIR_DOMAIN_DISK_BUS_VIRTIO) {\n        idx = *nvirtiodisk;\n        *nvirtiodisk += 1;\n        disk->dst = g_strdup(\"vda\");\n    } else if (bus == VIR_DOMAIN_DISK_BUS_SATA) {\n        idx = *nahcidisk;\n        *nahcidisk += 1;\n        disk->dst = g_strdup(\"sda\");\n    }\n\n    if (idx > 'z' - 'a') {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disks\"));\n        goto error;\n    }\n\n    disk->dst[2] = 'a' + idx;\n\n    if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainDiskDefFree(disk);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "emulation",
            "\"virtio-blk\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "emulation",
            "\"ahci-hd\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "emulation",
            "\"ahci-cd\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParsePCISlot",
          "args": [
            "slotdef",
            "&bus",
            "&slot",
            "&function"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParsePCISlot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "353-407",
          "snippet": "static int\nbhyveParsePCISlot(const char *slotdef,\n                  unsigned *bus,\n                  unsigned *slot,\n                  unsigned *function)\n{\n    /* slot[:function] | bus:slot:function */\n    const char *curr = NULL;\n    const char *next = NULL;\n    unsigned values[3];\n    size_t i;\n\n    curr = slotdef;\n    for (i = 0; i < 3; i++) {\n       char *val = NULL;\n\n       next = strchr(curr, ':');\n\n       if (next)\n           val = g_strndup(curr, next - curr);\n       else\n           val = g_strdup(curr);\n\n       if (virStrToLong_ui(val, NULL, 10, &values[i]) < 0)\n           return -1;\n\n       VIR_FREE(val);\n\n       if (!next)\n           break;\n\n       curr = next +1;\n    }\n\n    *bus = 0;\n    *slot = 0;\n    *function = 0;\n\n    switch (i + 1) {\n    case 2:\n        /* pcislot[:function] */\n        *function = values[1];\n    case 1:\n        *slot = values[0];\n        break;\n    case 3:\n        /* bus:pcislot:function */\n        *bus = values[0];\n        *slot = values[1];\n        *function = values[2];\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParsePCISlot(const char *slotdef,\n                  unsigned *bus,\n                  unsigned *slot,\n                  unsigned *function)\n{\n    /* slot[:function] | bus:slot:function */\n    const char *curr = NULL;\n    const char *next = NULL;\n    unsigned values[3];\n    size_t i;\n\n    curr = slotdef;\n    for (i = 0; i < 3; i++) {\n       char *val = NULL;\n\n       next = strchr(curr, ':');\n\n       if (next)\n           val = g_strndup(curr, next - curr);\n       else\n           val = g_strdup(curr);\n\n       if (virStrToLong_ui(val, NULL, 10, &values[i]) < 0)\n           return -1;\n\n       VIR_FREE(val);\n\n       if (!next)\n           break;\n\n       curr = next +1;\n    }\n\n    *bus = 0;\n    *slot = 0;\n    *function = 0;\n\n    switch (i + 1) {\n    case 2:\n        /* pcislot[:function] */\n        *function = values[1];\n    case 1:\n        *slot = values[0];\n        break;\n    case 3:\n        /* bus:pcislot:function */\n        *bus = values[0];\n        *slot = values[1];\n        *function = values[2];\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "separator"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "separator",
            "conf - separator - 1"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "separator+1",
            "','"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "arg",
            "separator - arg - 1"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "','"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyvePCIArg(virDomainDefPtr def,\n                      virDomainXMLOptionPtr xmlopt,\n                      unsigned caps,\n                      unsigned *nvirtiodisk,\n                      unsigned *nahcidisk,\n                      const char *arg)\n{\n    /* -s slot,emulation[,conf] */\n    const char *separator = NULL;\n    char *slotdef = NULL;\n    char *emulation = NULL;\n    char *conf = NULL;\n    unsigned bus, slot, function;\n\n    separator = strchr(arg, ',');\n\n    if (!separator)\n        goto error;\n    else\n        separator++; /* Skip comma */\n\n    slotdef = g_strndup(arg, separator - arg - 1);\n\n    conf = strchr(separator+1, ',');\n    if (conf) {\n        conf++; /* Skip initial comma */\n        emulation = g_strndup(separator, conf - separator - 1);\n    } else {\n        emulation = g_strdup(separator);\n    }\n\n    if (bhyveParsePCISlot(slotdef, &bus, &slot, &function) < 0)\n        goto error;\n\n    if (STREQ(emulation, \"ahci-cd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_CDROM,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"ahci-hd\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_SATA,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-blk\"))\n        bhyveParsePCIDisk(def, caps, bus, slot, function,\n                          VIR_DOMAIN_DISK_BUS_VIRTIO,\n                          VIR_DOMAIN_DISK_DEVICE_DISK,\n                          nvirtiodisk,\n                          nahcidisk,\n                          conf);\n    else if (STREQ(emulation, \"virtio-net\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_VIRTIO, conf);\n    else if (STREQ(emulation, \"e1000\"))\n        bhyveParsePCINet(def, xmlopt, caps, bus, slot, function,\n                         VIR_DOMAIN_NET_MODEL_E1000, conf);\n\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return 0;\n error:\n    VIR_FREE(emulation);\n    VIR_FREE(slotdef);\n    return -1;\n}"
  },
  {
    "function_name": "bhyveParsePCINet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "479-553",
    "snippet": "static int\nbhyveParsePCINet(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 unsigned caps G_GNUC_UNUSED,\n                 unsigned bus,\n                 unsigned slot,\n                 unsigned function,\n                 int model,\n                 const char *config)\n{\n    /* -s slot,virtio-net,tapN[,mac=xx:xx:xx:xx:xx:xx] */\n\n    virDomainNetDefPtr net = NULL;\n    const char *separator = NULL;\n    const char *mac = NULL;\n\n    if (!(net = virDomainNetDefNew(xmlopt)))\n        goto cleanup;\n\n    /* As we only support interface type='bridge' and cannot\n     * guess the actual bridge name from the command line,\n     * try to come up with some reasonable defaults */\n    net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    net->data.bridge.brname = g_strdup(\"virbr0\");\n\n    net->model = model;\n    net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    net->info.addr.pci.bus = bus;\n    net->info.addr.pci.slot = slot;\n    net->info.addr.pci.function = function;\n\n    if (!config)\n        goto error;\n\n    if (!STRPREFIX(config, \"tap\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only tap devices supported\"));\n        goto error;\n    }\n\n    separator = strchr(config, ',');\n    if (separator)\n        net->ifname = g_strndup(config, separator - config);\n    else\n        net->ifname = g_strdup(config);\n\n    if (!separator)\n        goto cleanup;\n\n    if (!STRPREFIX(++separator, \"mac=\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only mac option can be specified for virt-net\"));\n        goto error;\n    }\n    mac = separator + 4;\n\n    if (virMacAddrParse(mac, &net->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse mac address '%s'\"),\n                       mac);\n        goto cleanup;\n     }\n\n cleanup:\n    if (!mac)\n        virDomainNetGenerateMAC(xmlopt, &net->mac);\n\n    if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n        goto error;\n    return 0;\n\n error:\n    virDomainNetDefFree(net);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNetDefFree",
          "args": [
            "net"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2481-2489",
          "snippet": "void\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->nets",
            "def->nnets",
            "net"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGenerateMAC",
          "args": [
            "xmlopt",
            "&net->mac"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGenerateMAC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "11353-11358",
          "snippet": "void\nvirDomainNetGenerateMAC(virDomainXMLOptionPtr xmlopt,\n                        virMacAddrPtr mac)\n{\n    virMacAddrGenerate(xmlopt->config.macPrefix, mac);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetGenerateMAC(virDomainXMLOptionPtr xmlopt,\n                        virMacAddrPtr mac)\n{\n    virMacAddrGenerate(xmlopt->config.macPrefix, mac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse mac address '%s'\")",
            "mac"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to parse mac address '%s'\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "mac",
            "&net->mac"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only mac option can be specified for virt-net\")"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "++separator",
            "\"mac=\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "config",
            "separator - config"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "config",
            "','"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only tap devices supported\")"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "config",
            "\"tap\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetDefNew",
          "args": [
            "xmlopt"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "14783-14798",
          "snippet": "virDomainNetDefPtr\nvirDomainNetDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainNetDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.networkNew &&\n        !(def->privateData = xmlopt->privateData.networkNew())) {\n        virDomainNetDefFree(def);\n        def = NULL;\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetDefPtr\nvirDomainNetDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainNetDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.networkNew &&\n        !(def->privateData = xmlopt->privateData.networkNew())) {\n        virDomainNetDefFree(def);\n        def = NULL;\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParsePCINet(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 unsigned caps G_GNUC_UNUSED,\n                 unsigned bus,\n                 unsigned slot,\n                 unsigned function,\n                 int model,\n                 const char *config)\n{\n    /* -s slot,virtio-net,tapN[,mac=xx:xx:xx:xx:xx:xx] */\n\n    virDomainNetDefPtr net = NULL;\n    const char *separator = NULL;\n    const char *mac = NULL;\n\n    if (!(net = virDomainNetDefNew(xmlopt)))\n        goto cleanup;\n\n    /* As we only support interface type='bridge' and cannot\n     * guess the actual bridge name from the command line,\n     * try to come up with some reasonable defaults */\n    net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    net->data.bridge.brname = g_strdup(\"virbr0\");\n\n    net->model = model;\n    net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    net->info.addr.pci.bus = bus;\n    net->info.addr.pci.slot = slot;\n    net->info.addr.pci.function = function;\n\n    if (!config)\n        goto error;\n\n    if (!STRPREFIX(config, \"tap\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only tap devices supported\"));\n        goto error;\n    }\n\n    separator = strchr(config, ',');\n    if (separator)\n        net->ifname = g_strndup(config, separator - config);\n    else\n        net->ifname = g_strdup(config);\n\n    if (!separator)\n        goto cleanup;\n\n    if (!STRPREFIX(++separator, \"mac=\")) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Only mac option can be specified for virt-net\"));\n        goto error;\n    }\n    mac = separator + 4;\n\n    if (virMacAddrParse(mac, &net->mac) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse mac address '%s'\"),\n                       mac);\n        goto cleanup;\n     }\n\n cleanup:\n    if (!mac)\n        virDomainNetGenerateMAC(xmlopt, &net->mac);\n\n    if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n        goto error;\n    return 0;\n\n error:\n    virDomainNetDefFree(net);\n    return -1;\n}"
  },
  {
    "function_name": "bhyveParsePCIDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "409-477",
    "snippet": "static int\nbhyveParsePCIDisk(virDomainDefPtr def,\n                  unsigned caps G_GNUC_UNUSED,\n                  unsigned pcibus,\n                  unsigned pcislot,\n                  unsigned function,\n                  int bus,\n                  int device,\n                  unsigned *nvirtiodisk,\n                  unsigned *nahcidisk,\n                  char *config)\n{\n    /* -s slot,virtio-blk|ahci-cd|ahci-hd,/path/to/file */\n    const char *separator = NULL;\n    int idx = -1;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (!(disk = virDomainDiskDefNew(NULL)))\n        return 0;\n\n    disk->bus = bus;\n    disk->device = device;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    disk->info.addr.pci.bus = pcibus;\n    disk->info.addr.pci.slot = pcislot;\n    disk->info.addr.pci.function = function;\n\n    if (STRPREFIX(config, \"/dev/\"))\n        disk->src->type = VIR_STORAGE_TYPE_BLOCK;\n    else\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n\n    if (!config)\n        goto error;\n\n    separator = strchr(config, ',');\n    if (separator)\n        disk->src->path = g_strndup(config, separator - config);\n    else\n        disk->src->path = g_strdup(config);\n\n    if (bus == VIR_DOMAIN_DISK_BUS_VIRTIO) {\n        idx = *nvirtiodisk;\n        *nvirtiodisk += 1;\n        disk->dst = g_strdup(\"vda\");\n    } else if (bus == VIR_DOMAIN_DISK_BUS_SATA) {\n        idx = *nahcidisk;\n        *nahcidisk += 1;\n        disk->dst = g_strdup(\"sda\");\n    }\n\n    if (idx > 'z' - 'a') {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disks\"));\n        goto error;\n    }\n\n    disk->dst[2] = 'a' + idx;\n\n    if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainDiskDefFree(disk);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDiskDefFree",
          "args": [
            "disk"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2117-2138",
          "snippet": "void\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->disks",
            "def->ndisks",
            "disk"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"too many disks\")"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"too many disks\""
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "config",
            "separator - config"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "config",
            "','"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "config",
            "\"/dev/\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "NULL"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParsePCIDisk(virDomainDefPtr def,\n                  unsigned caps G_GNUC_UNUSED,\n                  unsigned pcibus,\n                  unsigned pcislot,\n                  unsigned function,\n                  int bus,\n                  int device,\n                  unsigned *nvirtiodisk,\n                  unsigned *nahcidisk,\n                  char *config)\n{\n    /* -s slot,virtio-blk|ahci-cd|ahci-hd,/path/to/file */\n    const char *separator = NULL;\n    int idx = -1;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (!(disk = virDomainDiskDefNew(NULL)))\n        return 0;\n\n    disk->bus = bus;\n    disk->device = device;\n\n    disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_PCI;\n    disk->info.addr.pci.bus = pcibus;\n    disk->info.addr.pci.slot = pcislot;\n    disk->info.addr.pci.function = function;\n\n    if (STRPREFIX(config, \"/dev/\"))\n        disk->src->type = VIR_STORAGE_TYPE_BLOCK;\n    else\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n\n    if (!config)\n        goto error;\n\n    separator = strchr(config, ',');\n    if (separator)\n        disk->src->path = g_strndup(config, separator - config);\n    else\n        disk->src->path = g_strdup(config);\n\n    if (bus == VIR_DOMAIN_DISK_BUS_VIRTIO) {\n        idx = *nvirtiodisk;\n        *nvirtiodisk += 1;\n        disk->dst = g_strdup(\"vda\");\n    } else if (bus == VIR_DOMAIN_DISK_BUS_SATA) {\n        idx = *nahcidisk;\n        *nahcidisk += 1;\n        disk->dst = g_strdup(\"sda\");\n    }\n\n    if (idx > 'z' - 'a') {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disks\"));\n        goto error;\n    }\n\n    disk->dst[2] = 'a' + idx;\n\n    if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDomainDiskDefFree(disk);\n    return -1;\n}"
  },
  {
    "function_name": "bhyveParsePCISlot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "353-407",
    "snippet": "static int\nbhyveParsePCISlot(const char *slotdef,\n                  unsigned *bus,\n                  unsigned *slot,\n                  unsigned *function)\n{\n    /* slot[:function] | bus:slot:function */\n    const char *curr = NULL;\n    const char *next = NULL;\n    unsigned values[3];\n    size_t i;\n\n    curr = slotdef;\n    for (i = 0; i < 3; i++) {\n       char *val = NULL;\n\n       next = strchr(curr, ':');\n\n       if (next)\n           val = g_strndup(curr, next - curr);\n       else\n           val = g_strdup(curr);\n\n       if (virStrToLong_ui(val, NULL, 10, &values[i]) < 0)\n           return -1;\n\n       VIR_FREE(val);\n\n       if (!next)\n           break;\n\n       curr = next +1;\n    }\n\n    *bus = 0;\n    *slot = 0;\n    *function = 0;\n\n    switch (i + 1) {\n    case 2:\n        /* pcislot[:function] */\n        *function = values[1];\n    case 1:\n        *slot = values[0];\n        break;\n    case 3:\n        /* bus:pcislot:function */\n        *bus = values[0];\n        *slot = values[1];\n        *function = values[2];\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "val"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "val",
            "NULL",
            "10",
            "&values[i]"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "curr"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "curr",
            "next - curr"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "curr",
            "':'"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParsePCISlot(const char *slotdef,\n                  unsigned *bus,\n                  unsigned *slot,\n                  unsigned *function)\n{\n    /* slot[:function] | bus:slot:function */\n    const char *curr = NULL;\n    const char *next = NULL;\n    unsigned values[3];\n    size_t i;\n\n    curr = slotdef;\n    for (i = 0; i < 3; i++) {\n       char *val = NULL;\n\n       next = strchr(curr, ':');\n\n       if (next)\n           val = g_strndup(curr, next - curr);\n       else\n           val = g_strdup(curr);\n\n       if (virStrToLong_ui(val, NULL, 10, &values[i]) < 0)\n           return -1;\n\n       VIR_FREE(val);\n\n       if (!next)\n           break;\n\n       curr = next +1;\n    }\n\n    *bus = 0;\n    *slot = 0;\n    *function = 0;\n\n    switch (i + 1) {\n    case 2:\n        /* pcislot[:function] */\n        *function = values[1];\n    case 1:\n        *slot = values[0];\n        break;\n    case 3:\n        /* bus:pcislot:function */\n        *bus = values[0];\n        *slot = values[1];\n        *function = values[2];\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "bhyveParseBhyveLPCArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "267-351",
    "snippet": "static int\nbhyveParseBhyveLPCArg(virDomainDefPtr def,\n                      unsigned caps G_GNUC_UNUSED,\n                      const char *arg)\n{\n    /* -l emulation[,config] */\n    const char *separator = NULL;\n    const char *param = NULL;\n    size_t last = 0;\n    virDomainChrDefPtr chr = NULL;\n    char *type = NULL;\n\n    separator = strchr(arg, ',');\n    param = separator + 1;\n\n    if (!separator)\n        goto error;\n\n    type = g_strndup(arg, separator - arg);\n\n    /* Only support com%d */\n    if (STRPREFIX(type, \"com\") && type[4] == 0) {\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto error;\n\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_NMDM;\n        chr->source->data.nmdm.master = NULL;\n        chr->source->data.nmdm.slave = NULL;\n        chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n        if (!STRPREFIX(param, \"/dev/nmdm\")) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to set com port %s: does not start with \"\n                             \"'/dev/nmdm'.\"), type);\n                goto error;\n        }\n\n        chr->source->data.nmdm.master = g_strdup(param);\n        chr->source->data.nmdm.slave = g_strdup(chr->source->data.file.path);\n\n        /* If the last character of the master is 'A', the slave will be 'B'\n         * and vice versa */\n        last = strlen(chr->source->data.nmdm.master) - 1;\n        switch (chr->source->data.file.path[last]) {\n            case 'A':\n                chr->source->data.nmdm.slave[last] = 'B';\n                break;\n            case 'B':\n                chr->source->data.nmdm.slave[last] = 'A';\n                break;\n            default:\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Failed to set slave for %s: last letter not \"\n                                 \"'A' or 'B'\"),\n                               NULLSTR(chr->source->data.nmdm.master));\n                goto error;\n        }\n\n        switch (type[3]-'0') {\n        case 1:\n        case 2:\n            chr->target.port = type[3] - '1';\n            break;\n        default:\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to parse %s: only com1 and com2\"\n                             \" supported.\"), type);\n            goto error;\n            break;\n        }\n\n        if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0) {\n            virDomainChrDefFree(chr);\n            goto error;\n        }\n    }\n\n    VIR_FREE(type);\n    return 0;\n\n error:\n    virDomainChrDefFree(chr);\n    VIR_FREE(type);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "chr"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->serials",
            "def->nserials",
            "chr"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to parse %s: only com1 and com2\"\n                             \" supported.\")",
            "type"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to parse %s: only com1 and com2\"\n                             \" supported.\""
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to set slave for %s: last letter not \"\n                                 \"'A' or 'B'\")",
            "NULLSTR(chr->source->data.nmdm.master)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "chr->source->data.nmdm.master"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chr->source->data.nmdm.master"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to set com port %s: does not start with \"\n                             \"'/dev/nmdm'.\")",
            "type"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "param",
            "\"/dev/nmdm\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "type",
            "\"com\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "arg",
            "separator - arg"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "','"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseBhyveLPCArg(virDomainDefPtr def,\n                      unsigned caps G_GNUC_UNUSED,\n                      const char *arg)\n{\n    /* -l emulation[,config] */\n    const char *separator = NULL;\n    const char *param = NULL;\n    size_t last = 0;\n    virDomainChrDefPtr chr = NULL;\n    char *type = NULL;\n\n    separator = strchr(arg, ',');\n    param = separator + 1;\n\n    if (!separator)\n        goto error;\n\n    type = g_strndup(arg, separator - arg);\n\n    /* Only support com%d */\n    if (STRPREFIX(type, \"com\") && type[4] == 0) {\n        if (!(chr = virDomainChrDefNew(NULL)))\n            goto error;\n\n        chr->source->type = VIR_DOMAIN_CHR_TYPE_NMDM;\n        chr->source->data.nmdm.master = NULL;\n        chr->source->data.nmdm.slave = NULL;\n        chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n        if (!STRPREFIX(param, \"/dev/nmdm\")) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to set com port %s: does not start with \"\n                             \"'/dev/nmdm'.\"), type);\n                goto error;\n        }\n\n        chr->source->data.nmdm.master = g_strdup(param);\n        chr->source->data.nmdm.slave = g_strdup(chr->source->data.file.path);\n\n        /* If the last character of the master is 'A', the slave will be 'B'\n         * and vice versa */\n        last = strlen(chr->source->data.nmdm.master) - 1;\n        switch (chr->source->data.file.path[last]) {\n            case 'A':\n                chr->source->data.nmdm.slave[last] = 'B';\n                break;\n            case 'B':\n                chr->source->data.nmdm.slave[last] = 'A';\n                break;\n            default:\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Failed to set slave for %s: last letter not \"\n                                 \"'A' or 'B'\"),\n                               NULLSTR(chr->source->data.nmdm.master));\n                goto error;\n        }\n\n        switch (type[3]-'0') {\n        case 1:\n        case 2:\n            chr->target.port = type[3] - '1';\n            break;\n        default:\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to parse %s: only com1 and com2\"\n                             \" supported.\"), type);\n            goto error;\n            break;\n        }\n\n        if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0) {\n            virDomainChrDefFree(chr);\n            goto error;\n        }\n    }\n\n    VIR_FREE(type);\n    return 0;\n\n error:\n    virDomainChrDefFree(chr);\n    VIR_FREE(type);\n    return -1;\n}"
  },
  {
    "function_name": "bhyveCommandLineToArgv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "119-265",
    "snippet": "static int\nbhyveCommandLineToArgv(const char *nativeConfig,\n                      int *loader_argc,\n                      char ***loader_argv,\n                      int *bhyve_argc,\n                      char ***bhyve_argv)\n{\n    const char *curr = NULL;\n    char *nativeConfig_unescaped = NULL;\n    const char *start;\n    const char *next;\n    char *line;\n    char **lines = NULL;\n    size_t i;\n    size_t line_count = 0;\n    size_t lines_alloc = 0;\n    char **_bhyve_argv = NULL;\n    char **_loader_argv = NULL;\n\n    nativeConfig_unescaped = bhyveParseCommandLineUnescape(nativeConfig);\n    if (nativeConfig_unescaped == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to unescape command line string\"));\n        goto error;\n    }\n\n    curr = nativeConfig_unescaped;\n\n    /* Iterate over string, splitting on sequences of '\\n' */\n    while (curr && *curr != '\\0') {\n        start = curr;\n        next = strchr(curr, '\\n');\n\n        if (next)\n            line = g_strndup(curr, next - curr);\n        else\n            line = g_strdup(curr);\n\n        if (VIR_RESIZE_N(lines, lines_alloc, line_count, 2) < 0) {\n            VIR_FREE(line);\n            goto error;\n        }\n\n        if (*line)\n            lines[line_count++] = line;\n        lines[line_count] = NULL;\n\n        while (next && (*next == '\\n' || *next == '\\r'\n                        || STRPREFIX(next, \"\\r\\n\")))\n            next++;\n\n        curr = next;\n    }\n\n    for (i = 0; i < line_count; i++) {\n        curr = lines[i];\n        size_t j;\n        char **arglist = NULL;\n        size_t args_count = 0;\n        size_t args_alloc = 0;\n\n        /* iterate over each line, splitting on sequences of ' '. This code is\n         * adapted from qemu/qemu_parse_command.c. */\n        while (curr && *curr != '\\0') {\n            char *arg;\n            start = curr;\n\n            if (*start == '\\'') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\\'');\n            } else if (*start == '\"') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\"');\n            } else {\n                next = strchr(start, ' ');\n            }\n\n            if (next)\n                arg = g_strndup(curr, next - curr);\n            else\n                arg = g_strdup(curr);\n\n            if (next && (*next == '\\'' || *next == '\"'))\n                next++;\n\n            if (VIR_RESIZE_N(arglist, args_alloc, args_count, 2) < 0) {\n                VIR_FREE(arg);\n                goto error;\n            }\n\n            arglist[args_count++] = arg;\n            arglist[args_count] = NULL;\n\n            while (next && g_ascii_isspace(*next))\n                next++;\n\n            curr = next;\n        }\n\n        VIR_FREE(nativeConfig_unescaped);\n\n        /* To prevent a memory leak here, only set the argument lists when\n         * the first matching command is found. This shouldn't really be a\n         * problem, since usually no multiple loaders or bhyverun commands\n         * are specified (this wouldn't really be valid anyways).\n         * Otherwise, later argument lists may be assigned to _argv without\n         * freeing the earlier ones. */\n        if (!_bhyve_argv && STREQ(arglist[0], \"/usr/sbin/bhyve\")) {\n            if ((VIR_REALLOC_N(_bhyve_argv, args_count + 1) < 0)\n                || (!bhyve_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _bhyve_argv[j] = arglist[j];\n            _bhyve_argv[j] = NULL;\n            *bhyve_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else if (!_loader_argv) {\n            if ((VIR_REALLOC_N(_loader_argv, args_count + 1) < 0)\n                || (!loader_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _loader_argv[j] = arglist[j];\n            _loader_argv[j] = NULL;\n            *loader_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else {\n            /* To prevent a use-after-free here, only free the argument list\n             * when it is definitely not going to be used */\n            virStringListFree(arglist);\n        }\n    }\n\n    *loader_argv = _loader_argv;\n    if (!(*bhyve_argv = _bhyve_argv))\n        goto error;\n\n    virStringListFree(lines);\n    return 0;\n\n error:\n    VIR_FREE(_loader_argv);\n    VIR_FREE(_bhyve_argv);\n    virStringListFree(lines);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "lines"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "_bhyve_argv"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "_loader_argv"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arglist"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "_loader_argv",
            "args_count + 1"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arglist"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "_bhyve_argv",
            "args_count + 1"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "arglist[0]",
            "\"/usr/sbin/bhyve\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nativeConfig_unescaped"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*next"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arg"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "arglist",
            "args_alloc",
            "args_count",
            "2"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "curr"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "curr",
            "next - curr"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "start",
            "' '"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "start + 1",
            "'\"'"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "start + 1",
            "'\\''"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "next",
            "\"\\r\\n\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "line"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "lines",
            "lines_alloc",
            "line_count",
            "2"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "curr",
            "next - curr"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "curr",
            "'\\n'"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to unescape command line string\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bhyveParseCommandLineUnescape",
          "args": [
            "nativeConfig"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "bhyveParseCommandLineUnescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
          "lines": "46-84",
          "snippet": "static char *\nbhyveParseCommandLineUnescape(const char *command)\n{\n    size_t len = strlen(command);\n    char *unescaped = NULL;\n    char *curr_src = NULL;\n    char *curr_dst = NULL;\n\n    /* Since we are only removing characters, allocating a buffer of the same\n     * size as command shouldn't be a problem here */\n    if (VIR_ALLOC_N(unescaped, len+1) < 0)\n        return NULL;\n\n    /* Iterate over characters in the command, skipping \"\\\\\\n\", \"\\\\\\r\" as well\n     * as \"\\\\\\r\\n\". */\n    for (curr_src = (char*) command, curr_dst = unescaped; *curr_src != '\\0';\n        curr_src++, curr_dst++) {\n        if (*curr_src == '\\\\') {\n            switch (*(curr_src + 1)) {\n                case '\\n': /* \\LF */\n                    curr_src++;\n                    curr_dst--;\n                    break;\n                case '\\r': /* \\CR */\n                    curr_src++;\n                    curr_dst--;\n                    if (*curr_src == '\\n') /* \\CRLF */\n                        curr_src++;\n                    break;\n                default:\n                    *curr_dst = '\\\\';\n            }\n        } else {\n            *curr_dst = *curr_src;\n        }\n    }\n\n    return unescaped;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"bhyve_parse_command.h\"",
            "#include \"bhyve_command.h\"",
            "#include \"bhyve_capabilities.h\"",
            "#include <libutil.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic char *\nbhyveParseCommandLineUnescape(const char *command)\n{\n    size_t len = strlen(command);\n    char *unescaped = NULL;\n    char *curr_src = NULL;\n    char *curr_dst = NULL;\n\n    /* Since we are only removing characters, allocating a buffer of the same\n     * size as command shouldn't be a problem here */\n    if (VIR_ALLOC_N(unescaped, len+1) < 0)\n        return NULL;\n\n    /* Iterate over characters in the command, skipping \"\\\\\\n\", \"\\\\\\r\" as well\n     * as \"\\\\\\r\\n\". */\n    for (curr_src = (char*) command, curr_dst = unescaped; *curr_src != '\\0';\n        curr_src++, curr_dst++) {\n        if (*curr_src == '\\\\') {\n            switch (*(curr_src + 1)) {\n                case '\\n': /* \\LF */\n                    curr_src++;\n                    curr_dst--;\n                    break;\n                case '\\r': /* \\CR */\n                    curr_src++;\n                    curr_dst--;\n                    if (*curr_src == '\\n') /* \\CRLF */\n                        curr_src++;\n                    break;\n                default:\n                    *curr_dst = '\\\\';\n            }\n        } else {\n            *curr_dst = *curr_src;\n        }\n    }\n\n    return unescaped;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveCommandLineToArgv(const char *nativeConfig,\n                      int *loader_argc,\n                      char ***loader_argv,\n                      int *bhyve_argc,\n                      char ***bhyve_argv)\n{\n    const char *curr = NULL;\n    char *nativeConfig_unescaped = NULL;\n    const char *start;\n    const char *next;\n    char *line;\n    char **lines = NULL;\n    size_t i;\n    size_t line_count = 0;\n    size_t lines_alloc = 0;\n    char **_bhyve_argv = NULL;\n    char **_loader_argv = NULL;\n\n    nativeConfig_unescaped = bhyveParseCommandLineUnescape(nativeConfig);\n    if (nativeConfig_unescaped == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to unescape command line string\"));\n        goto error;\n    }\n\n    curr = nativeConfig_unescaped;\n\n    /* Iterate over string, splitting on sequences of '\\n' */\n    while (curr && *curr != '\\0') {\n        start = curr;\n        next = strchr(curr, '\\n');\n\n        if (next)\n            line = g_strndup(curr, next - curr);\n        else\n            line = g_strdup(curr);\n\n        if (VIR_RESIZE_N(lines, lines_alloc, line_count, 2) < 0) {\n            VIR_FREE(line);\n            goto error;\n        }\n\n        if (*line)\n            lines[line_count++] = line;\n        lines[line_count] = NULL;\n\n        while (next && (*next == '\\n' || *next == '\\r'\n                        || STRPREFIX(next, \"\\r\\n\")))\n            next++;\n\n        curr = next;\n    }\n\n    for (i = 0; i < line_count; i++) {\n        curr = lines[i];\n        size_t j;\n        char **arglist = NULL;\n        size_t args_count = 0;\n        size_t args_alloc = 0;\n\n        /* iterate over each line, splitting on sequences of ' '. This code is\n         * adapted from qemu/qemu_parse_command.c. */\n        while (curr && *curr != '\\0') {\n            char *arg;\n            start = curr;\n\n            if (*start == '\\'') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\\'');\n            } else if (*start == '\"') {\n                if (start == curr)\n                    curr++;\n                next = strchr(start + 1, '\"');\n            } else {\n                next = strchr(start, ' ');\n            }\n\n            if (next)\n                arg = g_strndup(curr, next - curr);\n            else\n                arg = g_strdup(curr);\n\n            if (next && (*next == '\\'' || *next == '\"'))\n                next++;\n\n            if (VIR_RESIZE_N(arglist, args_alloc, args_count, 2) < 0) {\n                VIR_FREE(arg);\n                goto error;\n            }\n\n            arglist[args_count++] = arg;\n            arglist[args_count] = NULL;\n\n            while (next && g_ascii_isspace(*next))\n                next++;\n\n            curr = next;\n        }\n\n        VIR_FREE(nativeConfig_unescaped);\n\n        /* To prevent a memory leak here, only set the argument lists when\n         * the first matching command is found. This shouldn't really be a\n         * problem, since usually no multiple loaders or bhyverun commands\n         * are specified (this wouldn't really be valid anyways).\n         * Otherwise, later argument lists may be assigned to _argv without\n         * freeing the earlier ones. */\n        if (!_bhyve_argv && STREQ(arglist[0], \"/usr/sbin/bhyve\")) {\n            if ((VIR_REALLOC_N(_bhyve_argv, args_count + 1) < 0)\n                || (!bhyve_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _bhyve_argv[j] = arglist[j];\n            _bhyve_argv[j] = NULL;\n            *bhyve_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else if (!_loader_argv) {\n            if ((VIR_REALLOC_N(_loader_argv, args_count + 1) < 0)\n                || (!loader_argc))\n                goto error;\n            for (j = 0; j < args_count; j++)\n                _loader_argv[j] = arglist[j];\n            _loader_argv[j] = NULL;\n            *loader_argc = args_count-1;\n            VIR_FREE(arglist);\n        } else {\n            /* To prevent a use-after-free here, only free the argument list\n             * when it is definitely not going to be used */\n            virStringListFree(arglist);\n        }\n    }\n\n    *loader_argv = _loader_argv;\n    if (!(*bhyve_argv = _bhyve_argv))\n        goto error;\n\n    virStringListFree(lines);\n    return 0;\n\n error:\n    VIR_FREE(_loader_argv);\n    VIR_FREE(_bhyve_argv);\n    virStringListFree(lines);\n    return -1;\n}"
  },
  {
    "function_name": "bhyveParseMemsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "90-114",
    "snippet": "static int\nbhyveParseMemsize(const char *arg, size_t *ret_memsize)\n{\n    size_t val;\n    int error;\n\n    if (virStrToLong_ul(arg, NULL, 10, &val) == 0) {\n        /*\n         * For the sake of backward compatibility if the memory size\n         * specified on the command line is less than a megabyte then\n         * it is interpreted as being in units of MB.\n         */\n        if (val < 1024 * 1024UL)\n            val *= 1024 * 1024UL;\n        *ret_memsize = val;\n        error = 0;\n    } else {\n        error = expand_number(arg, ret_memsize);\n    }\n\n    /* use memory in KiB here */\n    *ret_memsize /= 1024UL;\n\n    return error;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expand_number",
          "args": [
            "arg",
            "ret_memsize"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ul",
          "args": [
            "arg",
            "NULL",
            "10",
            "&val"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic int\nbhyveParseMemsize(const char *arg, size_t *ret_memsize)\n{\n    size_t val;\n    int error;\n\n    if (virStrToLong_ul(arg, NULL, 10, &val) == 0) {\n        /*\n         * For the sake of backward compatibility if the memory size\n         * specified on the command line is less than a megabyte then\n         * it is interpreted as being in units of MB.\n         */\n        if (val < 1024 * 1024UL)\n            val *= 1024 * 1024UL;\n        *ret_memsize = val;\n        error = 0;\n    } else {\n        error = expand_number(arg, ret_memsize);\n    }\n\n    /* use memory in KiB here */\n    *ret_memsize /= 1024UL;\n\n    return error;\n}"
  },
  {
    "function_name": "bhyveParseCommandLineUnescape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/bhyve/bhyve_parse_command.c",
    "lines": "46-84",
    "snippet": "static char *\nbhyveParseCommandLineUnescape(const char *command)\n{\n    size_t len = strlen(command);\n    char *unescaped = NULL;\n    char *curr_src = NULL;\n    char *curr_dst = NULL;\n\n    /* Since we are only removing characters, allocating a buffer of the same\n     * size as command shouldn't be a problem here */\n    if (VIR_ALLOC_N(unescaped, len+1) < 0)\n        return NULL;\n\n    /* Iterate over characters in the command, skipping \"\\\\\\n\", \"\\\\\\r\" as well\n     * as \"\\\\\\r\\n\". */\n    for (curr_src = (char*) command, curr_dst = unescaped; *curr_src != '\\0';\n        curr_src++, curr_dst++) {\n        if (*curr_src == '\\\\') {\n            switch (*(curr_src + 1)) {\n                case '\\n': /* \\LF */\n                    curr_src++;\n                    curr_dst--;\n                    break;\n                case '\\r': /* \\CR */\n                    curr_src++;\n                    curr_dst--;\n                    if (*curr_src == '\\n') /* \\CRLF */\n                        curr_src++;\n                    break;\n                default:\n                    *curr_dst = '\\\\';\n            }\n        } else {\n            *curr_dst = *curr_src;\n        }\n    }\n\n    return unescaped;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"bhyve_parse_command.h\"",
      "#include \"bhyve_command.h\"",
      "#include \"bhyve_capabilities.h\"",
      "#include <libutil.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "unescaped",
            "len+1"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "command"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"bhyve_parse_command.h\"\n#include \"bhyve_command.h\"\n#include \"bhyve_capabilities.h\"\n#include <libutil.h>\n#include <config.h>\n\nstatic char *\nbhyveParseCommandLineUnescape(const char *command)\n{\n    size_t len = strlen(command);\n    char *unescaped = NULL;\n    char *curr_src = NULL;\n    char *curr_dst = NULL;\n\n    /* Since we are only removing characters, allocating a buffer of the same\n     * size as command shouldn't be a problem here */\n    if (VIR_ALLOC_N(unescaped, len+1) < 0)\n        return NULL;\n\n    /* Iterate over characters in the command, skipping \"\\\\\\n\", \"\\\\\\r\" as well\n     * as \"\\\\\\r\\n\". */\n    for (curr_src = (char*) command, curr_dst = unescaped; *curr_src != '\\0';\n        curr_src++, curr_dst++) {\n        if (*curr_src == '\\\\') {\n            switch (*(curr_src + 1)) {\n                case '\\n': /* \\LF */\n                    curr_src++;\n                    curr_dst--;\n                    break;\n                case '\\r': /* \\CR */\n                    curr_src++;\n                    curr_dst--;\n                    if (*curr_src == '\\n') /* \\CRLF */\n                        curr_src++;\n                    break;\n                default:\n                    *curr_dst = '\\\\';\n            }\n        } else {\n            *curr_dst = *curr_src;\n        }\n    }\n\n    return unescaped;\n}"
  }
]