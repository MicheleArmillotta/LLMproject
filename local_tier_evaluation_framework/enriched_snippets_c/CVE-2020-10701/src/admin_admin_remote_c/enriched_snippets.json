[
  {
    "function_name": "remoteAdminConnectGetLoggingFilters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "464-497",
    "snippet": "static int\nremoteAdminConnectGetLoggingFilters(virAdmConnectPtr conn,\n                                    char **filters,\n                                    unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n    admin_connect_get_logging_filters_args args;\n    admin_connect_get_logging_filters_ret ret;\n\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(conn,\n             0,\n             ADMIN_PROC_CONNECT_GET_LOGGING_FILTERS,\n             (xdrproc_t) xdr_admin_connect_get_logging_filters_args,\n             (char *) &args,\n             (xdrproc_t) xdr_admin_connect_get_logging_filters_ret,\n             (char *) &ret) == -1)\n        goto done;\n\n    if (filters)\n        *filters = ret.filters ? *ret.filters : NULL;\n\n    rv = ret.nfilters;\n    VIR_FREE(ret.filters);\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ret.filters"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "conn",
            "0",
            "ADMIN_PROC_CONNECT_GET_LOGGING_FILTERS",
            "(xdrproc_t) xdr_admin_connect_get_logging_filters_args",
            "(char *) &args",
            "(xdrproc_t) xdr_admin_connect_get_logging_filters_ret",
            "(char *) &ret"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminConnectGetLoggingFilters(virAdmConnectPtr conn,\n                                    char **filters,\n                                    unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n    admin_connect_get_logging_filters_args args;\n    admin_connect_get_logging_filters_ret ret;\n\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(conn,\n             0,\n             ADMIN_PROC_CONNECT_GET_LOGGING_FILTERS,\n             (xdrproc_t) xdr_admin_connect_get_logging_filters_args,\n             (char *) &args,\n             (xdrproc_t) xdr_admin_connect_get_logging_filters_ret,\n             (char *) &ret) == -1)\n        goto done;\n\n    if (filters)\n        *filters = ret.filters ? *ret.filters : NULL;\n\n    rv = ret.nfilters;\n    VIR_FREE(ret.filters);\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminConnectGetLoggingOutputs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "429-462",
    "snippet": "static int\nremoteAdminConnectGetLoggingOutputs(virAdmConnectPtr conn,\n                                    char **outputs,\n                                    unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n    admin_connect_get_logging_outputs_args args;\n    admin_connect_get_logging_outputs_ret ret;\n\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(conn,\n             0,\n             ADMIN_PROC_CONNECT_GET_LOGGING_OUTPUTS,\n             (xdrproc_t) xdr_admin_connect_get_logging_outputs_args,\n             (char *) &args,\n             (xdrproc_t) xdr_admin_connect_get_logging_outputs_ret,\n             (char *) &ret) == -1)\n        goto done;\n\n    if (outputs)\n        *outputs = g_steal_pointer(&ret.outputs);\n\n    rv = ret.noutputs;\n    xdr_free((xdrproc_t) xdr_admin_connect_get_logging_outputs_ret, (char *) &ret);\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t) xdr_admin_connect_get_logging_outputs_ret",
            "(char *) &ret"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&ret.outputs"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "conn",
            "0",
            "ADMIN_PROC_CONNECT_GET_LOGGING_OUTPUTS",
            "(xdrproc_t) xdr_admin_connect_get_logging_outputs_args",
            "(char *) &args",
            "(xdrproc_t) xdr_admin_connect_get_logging_outputs_ret",
            "(char *) &ret"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminConnectGetLoggingOutputs(virAdmConnectPtr conn,\n                                    char **outputs,\n                                    unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n    admin_connect_get_logging_outputs_args args;\n    admin_connect_get_logging_outputs_ret ret;\n\n    args.flags = flags;\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(conn,\n             0,\n             ADMIN_PROC_CONNECT_GET_LOGGING_OUTPUTS,\n             (xdrproc_t) xdr_admin_connect_get_logging_outputs_args,\n             (char *) &args,\n             (xdrproc_t) xdr_admin_connect_get_logging_outputs_ret,\n             (char *) &ret) == -1)\n        goto done;\n\n    if (outputs)\n        *outputs = g_steal_pointer(&ret.outputs);\n\n    rv = ret.noutputs;\n    xdr_free((xdrproc_t) xdr_admin_connect_get_logging_outputs_ret, (char *) &ret);\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminServerSetClientLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "393-427",
    "snippet": "static int\nremoteAdminServerSetClientLimits(virAdmServerPtr srv,\n                                 virTypedParameterPtr params,\n                                 int nparams,\n                                 unsigned int flags)\n{\n    int rv = -1;\n    admin_server_set_client_limits_args args;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    virObjectLock(priv);\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_CLIENT_LIMITS_MAX,\n                                (virTypedParameterRemotePtr *) &args.params.params_val,\n                                &args.params.params_len,\n                                0) < 0)\n        goto cleanup;\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_SET_CLIENT_LIMITS,\n             (xdrproc_t) xdr_admin_server_set_client_limits_args,\n             (char *) &args,\n             (xdrproc_t) xdr_void, (char *) NULL) == -1)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    virTypedParamsRemoteFree((virTypedParameterRemotePtr) args.params.params_val,\n                             args.params.params_len);\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsRemoteFree",
          "args": [
            "(virTypedParameterRemotePtr) args.params.params_val",
            "args.params.params_len"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsRemoteFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "482-497",
          "snippet": "void\nvirTypedParamsRemoteFree(virTypedParameterRemotePtr remote_params_val,\n                         unsigned int remote_params_len)\n{\n    size_t i;\n\n    if (!remote_params_val)\n        return;\n\n    for (i = 0; i < remote_params_len; i++) {\n        VIR_FREE(remote_params_val[i].field);\n        if (remote_params_val[i].value.type == VIR_TYPED_PARAM_STRING)\n            VIR_FREE(remote_params_val[i].value.remote_typed_param_value.s);\n    }\n    VIR_FREE(remote_params_val);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsRemoteFree(virTypedParameterRemotePtr remote_params_val,\n                         unsigned int remote_params_len)\n{\n    size_t i;\n\n    if (!remote_params_val)\n        return;\n\n    for (i = 0; i < remote_params_len; i++) {\n        VIR_FREE(remote_params_val[i].field);\n        if (remote_params_val[i].value.type == VIR_TYPED_PARAM_STRING)\n            VIR_FREE(remote_params_val[i].value.remote_typed_param_value.s);\n    }\n    VIR_FREE(remote_params_val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "srv->conn",
            "0",
            "ADMIN_PROC_SERVER_SET_CLIENT_LIMITS",
            "(xdrproc_t) xdr_admin_server_set_client_limits_args",
            "(char *) &args",
            "(xdrproc_t) xdr_void",
            "(char *) NULL"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsSerialize",
          "args": [
            "params",
            "nparams",
            "ADMIN_SERVER_CLIENT_LIMITS_MAX",
            "(virTypedParameterRemotePtr *) &args.params.params_val",
            "&args.params.params_len",
            "0"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsSerialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "644-723",
          "snippet": "int\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_nonnull_server",
          "args": [
            "&args.srv",
            "srv"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "62-66",
          "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminServerSetClientLimits(virAdmServerPtr srv,\n                                 virTypedParameterPtr params,\n                                 int nparams,\n                                 unsigned int flags)\n{\n    int rv = -1;\n    admin_server_set_client_limits_args args;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    virObjectLock(priv);\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_CLIENT_LIMITS_MAX,\n                                (virTypedParameterRemotePtr *) &args.params.params_val,\n                                &args.params.params_len,\n                                0) < 0)\n        goto cleanup;\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_SET_CLIENT_LIMITS,\n             (xdrproc_t) xdr_admin_server_set_client_limits_args,\n             (char *) &args,\n             (xdrproc_t) xdr_void, (char *) NULL) == -1)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    virTypedParamsRemoteFree((virTypedParameterRemotePtr) args.params.params_val,\n                             args.params.params_len);\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminServerGetClientLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "354-391",
    "snippet": "static int\nremoteAdminServerGetClientLimits(virAdmServerPtr srv,\n                                 virTypedParameterPtr *params,\n                                 int *nparams,\n                                 unsigned int flags)\n{\n    int rv = -1;\n    admin_server_get_client_limits_args args;\n    admin_server_get_client_limits_ret ret;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_GET_CLIENT_LIMITS,\n             (xdrproc_t) xdr_admin_server_get_client_limits_args,\n             (char *) &args,\n             (xdrproc_t) xdr_admin_server_get_client_limits_ret,\n             (char *) &ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) ret.params.params_val,\n                                  ret.params.params_len,\n                                  ADMIN_SERVER_CLIENT_LIMITS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n    xdr_free((xdrproc_t) xdr_admin_server_get_client_limits_ret,\n             (char *) &ret);\n\n cleanup:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t) xdr_admin_server_get_client_limits_ret",
            "(char *) &ret"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParamsDeserialize",
          "args": [
            "(virTypedParameterRemotePtr) ret.params.params_val",
            "ret.params.params_len",
            "ADMIN_SERVER_CLIENT_LIMITS_MAX",
            "params",
            "nparams"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsDeserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "527-621",
          "snippet": "int\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "srv->conn",
            "0",
            "ADMIN_PROC_SERVER_GET_CLIENT_LIMITS",
            "(xdrproc_t) xdr_admin_server_get_client_limits_args",
            "(char *) &args",
            "(xdrproc_t) xdr_admin_server_get_client_limits_ret",
            "(char *) &ret"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_nonnull_server",
          "args": [
            "&args.srv",
            "srv"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "62-66",
          "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminServerGetClientLimits(virAdmServerPtr srv,\n                                 virTypedParameterPtr *params,\n                                 int *nparams,\n                                 unsigned int flags)\n{\n    int rv = -1;\n    admin_server_get_client_limits_args args;\n    admin_server_get_client_limits_ret ret;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_GET_CLIENT_LIMITS,\n             (xdrproc_t) xdr_admin_server_get_client_limits_args,\n             (char *) &args,\n             (xdrproc_t) xdr_admin_server_get_client_limits_ret,\n             (char *) &ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) ret.params.params_val,\n                                  ret.params.params_len,\n                                  ADMIN_SERVER_CLIENT_LIMITS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n    xdr_free((xdrproc_t) xdr_admin_server_get_client_limits_ret,\n             (char *) &ret);\n\n cleanup:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminClientGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "317-352",
    "snippet": "static int\nremoteAdminClientGetInfo(virAdmClientPtr client,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = client->srv->conn->privateData;\n    admin_client_get_info_args args;\n    admin_client_get_info_ret ret;\n\n    args.flags = flags;\n    make_nonnull_client(&args.clnt, client);\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(client->srv->conn, 0, ADMIN_PROC_CLIENT_GET_INFO,\n             (xdrproc_t)xdr_admin_client_get_info_args, (char *) &args,\n             (xdrproc_t)xdr_admin_client_get_info_ret, (char *) &ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) ret.params.params_val,\n                                  ret.params.params_len,\n                                  ADMIN_CLIENT_INFO_PARAMETERS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n    xdr_free((xdrproc_t)xdr_admin_client_get_info_ret, (char *) &ret);\n\n cleanup:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t)xdr_admin_client_get_info_ret",
            "(char *) &ret"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParamsDeserialize",
          "args": [
            "(virTypedParameterRemotePtr) ret.params.params_val",
            "ret.params.params_len",
            "ADMIN_CLIENT_INFO_PARAMETERS_MAX",
            "params",
            "nparams"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsDeserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "527-621",
          "snippet": "int\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "client->srv->conn",
            "0",
            "ADMIN_PROC_CLIENT_GET_INFO",
            "(xdrproc_t)xdr_admin_client_get_info_args",
            "(char *) &args",
            "(xdrproc_t)xdr_admin_client_get_info_ret",
            "(char *) &ret"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_nonnull_client",
          "args": [
            "&args.clnt",
            "client"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "68-76",
          "snippet": "static void\nmake_nonnull_client(admin_nonnull_client *client_dst,\n                    virAdmClientPtr client_src)\n{\n    client_dst->id = client_src->id;\n    client_dst->transport = client_src->transport;\n    client_dst->timestamp = client_src->timestamp;\n    make_nonnull_server(&client_dst->srv, client_src->srv);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_client(admin_nonnull_client *client_dst,\n                    virAdmClientPtr client_src)\n{\n    client_dst->id = client_src->id;\n    client_dst->transport = client_src->transport;\n    client_dst->timestamp = client_src->timestamp;\n    make_nonnull_server(&client_dst->srv, client_src->srv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminClientGetInfo(virAdmClientPtr client,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = client->srv->conn->privateData;\n    admin_client_get_info_args args;\n    admin_client_get_info_ret ret;\n\n    args.flags = flags;\n    make_nonnull_client(&args.clnt, client);\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(client->srv->conn, 0, ADMIN_PROC_CLIENT_GET_INFO,\n             (xdrproc_t)xdr_admin_client_get_info_args, (char *) &args,\n             (xdrproc_t)xdr_admin_client_get_info_ret, (char *) &ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) ret.params.params_val,\n                                  ret.params.params_len,\n                                  ADMIN_CLIENT_INFO_PARAMETERS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n    xdr_free((xdrproc_t)xdr_admin_client_get_info_ret, (char *) &ret);\n\n cleanup:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminServerSetThreadPoolParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "281-315",
    "snippet": "static int\nremoteAdminServerSetThreadPoolParameters(virAdmServerPtr srv,\n                                         virTypedParameterPtr params,\n                                         int nparams,\n                                         unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n    admin_server_set_threadpool_parameters_args args;\n\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    virObjectLock(priv);\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                (virTypedParameterRemotePtr *) &args.params.params_val,\n                                &args.params.params_len,\n                                0) < 0)\n        goto cleanup;\n\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_SET_THREADPOOL_PARAMETERS,\n             (xdrproc_t)xdr_admin_server_set_threadpool_parameters_args, (char *) &args,\n             (xdrproc_t)xdr_void, (char *) NULL) == -1)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    virTypedParamsRemoteFree((virTypedParameterRemotePtr) args.params.params_val,\n                             args.params.params_len);\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsRemoteFree",
          "args": [
            "(virTypedParameterRemotePtr) args.params.params_val",
            "args.params.params_len"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsRemoteFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "482-497",
          "snippet": "void\nvirTypedParamsRemoteFree(virTypedParameterRemotePtr remote_params_val,\n                         unsigned int remote_params_len)\n{\n    size_t i;\n\n    if (!remote_params_val)\n        return;\n\n    for (i = 0; i < remote_params_len; i++) {\n        VIR_FREE(remote_params_val[i].field);\n        if (remote_params_val[i].value.type == VIR_TYPED_PARAM_STRING)\n            VIR_FREE(remote_params_val[i].value.remote_typed_param_value.s);\n    }\n    VIR_FREE(remote_params_val);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsRemoteFree(virTypedParameterRemotePtr remote_params_val,\n                         unsigned int remote_params_len)\n{\n    size_t i;\n\n    if (!remote_params_val)\n        return;\n\n    for (i = 0; i < remote_params_len; i++) {\n        VIR_FREE(remote_params_val[i].field);\n        if (remote_params_val[i].value.type == VIR_TYPED_PARAM_STRING)\n            VIR_FREE(remote_params_val[i].value.remote_typed_param_value.s);\n    }\n    VIR_FREE(remote_params_val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "srv->conn",
            "0",
            "ADMIN_PROC_SERVER_SET_THREADPOOL_PARAMETERS",
            "(xdrproc_t)xdr_admin_server_set_threadpool_parameters_args",
            "(char *) &args",
            "(xdrproc_t)xdr_void",
            "(char *) NULL"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsSerialize",
          "args": [
            "params",
            "nparams",
            "ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX",
            "(virTypedParameterRemotePtr *) &args.params.params_val",
            "&args.params.params_len",
            "0"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsSerialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "644-723",
          "snippet": "int\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsSerialize(virTypedParameterPtr params,\n                        int nparams,\n                        int limit,\n                        virTypedParameterRemotePtr *remote_params_val,\n                        unsigned int *remote_params_len,\n                        unsigned int flags)\n{\n    size_t i;\n    size_t j;\n    int rv = -1;\n    virTypedParameterRemotePtr params_val = NULL;\n    int params_len = nparams;\n\n    if (nparams > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%d' for limit '%d'\"),\n                       nparams, limit);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(params_val, nparams) < 0)\n        goto cleanup;\n\n    for (i = 0, j = 0; i < nparams; ++i) {\n        virTypedParameterPtr param = params + i;\n        virTypedParameterRemotePtr val = params_val + j;\n        /* NOTE: Following snippet is relevant to server only, because\n         * virDomainGetCPUStats can return a sparse array; also, we can't pass\n         * back strings to older clients. */\n        if (!param->type ||\n            (!(flags & VIR_TYPED_PARAM_STRING_OKAY) &&\n             param->type == VIR_TYPED_PARAM_STRING)) {\n            --params_len;\n            continue;\n        }\n\n        /* This will be either freed by virNetServerDispatchCall or call(),\n         * depending on the calling side, i.e. server or client */\n        val->field = g_strdup(param->field);\n        val->value.type = param->type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            val->value.remote_typed_param_value.i = param->value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            val->value.remote_typed_param_value.ui = param->value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            val->value.remote_typed_param_value.l = param->value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            val->value.remote_typed_param_value.ul = param->value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            val->value.remote_typed_param_value.d = param->value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            val->value.remote_typed_param_value.b = param->value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            val->value.remote_typed_param_value.s = g_strdup(param->value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n        j++;\n    }\n\n    *remote_params_val = params_val;\n    *remote_params_len = params_len;\n    params_val = NULL;\n    rv = 0;\n\n cleanup:\n    virTypedParamsRemoteFree(params_val, nparams);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_nonnull_server",
          "args": [
            "&args.srv",
            "srv"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "62-66",
          "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminServerSetThreadPoolParameters(virAdmServerPtr srv,\n                                         virTypedParameterPtr params,\n                                         int nparams,\n                                         unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n    admin_server_set_threadpool_parameters_args args;\n\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    virObjectLock(priv);\n\n    if (virTypedParamsSerialize(params, nparams,\n                                ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                (virTypedParameterRemotePtr *) &args.params.params_val,\n                                &args.params.params_len,\n                                0) < 0)\n        goto cleanup;\n\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_SET_THREADPOOL_PARAMETERS,\n             (xdrproc_t)xdr_admin_server_set_threadpool_parameters_args, (char *) &args,\n             (xdrproc_t)xdr_void, (char *) NULL) == -1)\n        goto cleanup;\n\n    rv = 0;\n cleanup:\n    virTypedParamsRemoteFree((virTypedParameterRemotePtr) args.params.params_val,\n                             args.params.params_len);\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminServerGetThreadPoolParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "244-279",
    "snippet": "static int\nremoteAdminServerGetThreadPoolParameters(virAdmServerPtr srv,\n                                         virTypedParameterPtr *params,\n                                         int *nparams,\n                                         unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n    admin_server_get_threadpool_parameters_args args;\n    admin_server_get_threadpool_parameters_ret ret;\n\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_GET_THREADPOOL_PARAMETERS,\n             (xdrproc_t)xdr_admin_server_get_threadpool_parameters_args, (char *) &args,\n             (xdrproc_t)xdr_admin_server_get_threadpool_parameters_ret, (char *) &ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) ret.params.params_val,\n                                  ret.params.params_len,\n                                  ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n    xdr_free((xdrproc_t)xdr_admin_server_get_threadpool_parameters_ret, (char *) &ret);\n\n cleanup:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t)xdr_admin_server_get_threadpool_parameters_ret",
            "(char *) &ret"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParamsDeserialize",
          "args": [
            "(virTypedParameterRemotePtr) ret.params.params_val",
            "ret.params.params_len",
            "ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX",
            "params",
            "nparams"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsDeserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "527-621",
          "snippet": "int\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsDeserialize(virTypedParameterRemotePtr remote_params,\n                          unsigned int remote_params_len,\n                          int limit,\n                          virTypedParameterPtr *params,\n                          int *nparams)\n{\n    size_t i = 0;\n    int rv = -1;\n    bool userAllocated = *params != NULL;\n\n    if (limit && remote_params_len > limit) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"too many parameters '%u' for limit '%d'\"),\n                       remote_params_len, limit);\n        goto cleanup;\n    }\n\n    if (userAllocated) {\n        /* Check the length of the returned list carefully. */\n        if (remote_params_len > *nparams) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"too many parameters '%u' for nparams '%d'\"),\n                           remote_params_len, *nparams);\n            goto cleanup;\n        }\n    } else {\n        if (VIR_ALLOC_N(*params, remote_params_len) < 0)\n            goto cleanup;\n    }\n    *nparams = remote_params_len;\n\n    /* Deserialize the result. */\n    for (i = 0; i < remote_params_len; ++i) {\n        virTypedParameterPtr param = *params + i;\n        virTypedParameterRemotePtr remote_param = remote_params + i;\n\n        if (virStrcpyStatic(param->field,\n                            remote_param->field) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"parameter %s too big for destination\"),\n                           remote_param->field);\n            goto cleanup;\n        }\n\n        param->type = remote_param->value.type;\n        switch (param->type) {\n        case VIR_TYPED_PARAM_INT:\n            param->value.i =\n                remote_param->value.remote_typed_param_value.i;\n            break;\n        case VIR_TYPED_PARAM_UINT:\n            param->value.ui =\n                remote_param->value.remote_typed_param_value.ui;\n            break;\n        case VIR_TYPED_PARAM_LLONG:\n            param->value.l =\n                remote_param->value.remote_typed_param_value.l;\n            break;\n        case VIR_TYPED_PARAM_ULLONG:\n            param->value.ul =\n                remote_param->value.remote_typed_param_value.ul;\n            break;\n        case VIR_TYPED_PARAM_DOUBLE:\n            param->value.d =\n                remote_param->value.remote_typed_param_value.d;\n            break;\n        case VIR_TYPED_PARAM_BOOLEAN:\n            param->value.b =\n                remote_param->value.remote_typed_param_value.b;\n            break;\n        case VIR_TYPED_PARAM_STRING:\n            param->value.s = g_strdup(remote_param->value.remote_typed_param_value.s);\n            break;\n        default:\n            virReportError(VIR_ERR_RPC, _(\"unknown parameter type: %d\"),\n                           param->type);\n            goto cleanup;\n        }\n    }\n\n    rv = 0;\n\n cleanup:\n    if (rv < 0) {\n        if (userAllocated) {\n            virTypedParamsClear(*params, i);\n        } else {\n            virTypedParamsFree(*params, i);\n            *params = NULL;\n            *nparams = 0;\n        }\n    }\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "srv->conn",
            "0",
            "ADMIN_PROC_SERVER_GET_THREADPOOL_PARAMETERS",
            "(xdrproc_t)xdr_admin_server_get_threadpool_parameters_args",
            "(char *) &args",
            "(xdrproc_t)xdr_admin_server_get_threadpool_parameters_ret",
            "(char *) &ret"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_nonnull_server",
          "args": [
            "&args.srv",
            "srv"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "62-66",
          "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminServerGetThreadPoolParameters(virAdmServerPtr srv,\n                                         virTypedParameterPtr *params,\n                                         int *nparams,\n                                         unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = srv->conn->privateData;\n    admin_server_get_threadpool_parameters_args args;\n    admin_server_get_threadpool_parameters_ret ret;\n\n    args.flags = flags;\n    make_nonnull_server(&args.srv, srv);\n\n    memset(&ret, 0, sizeof(ret));\n    virObjectLock(priv);\n\n    if (call(srv->conn, 0, ADMIN_PROC_SERVER_GET_THREADPOOL_PARAMETERS,\n             (xdrproc_t)xdr_admin_server_get_threadpool_parameters_args, (char *) &args,\n             (xdrproc_t)xdr_admin_server_get_threadpool_parameters_ret, (char *) &ret) == -1)\n        goto cleanup;\n\n    if (virTypedParamsDeserialize((virTypedParameterRemotePtr) ret.params.params_val,\n                                  ret.params.params_len,\n                                  ADMIN_SERVER_THREADPOOL_PARAMETERS_MAX,\n                                  params,\n                                  nparams) < 0)\n        goto cleanup;\n\n    rv = 0;\n    xdr_free((xdrproc_t)xdr_admin_server_get_threadpool_parameters_ret, (char *) &ret);\n\n cleanup:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminPrivNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "219-242",
    "snippet": "static remoteAdminPrivPtr\nremoteAdminPrivNew(const char *sock_path)\n{\n    remoteAdminPrivPtr priv = NULL;\n\n    if (!(priv = virObjectLockableNew(remoteAdminPrivClass)))\n        goto error;\n\n    if (!(priv->client = virNetClientNewUNIX(sock_path, false, NULL)))\n        goto error;\n\n    if (!(priv->program = virNetClientProgramNew(ADMIN_PROGRAM,\n                                                 ADMIN_PROTOCOL_VERSION,\n                                                 NULL, 0, NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(priv->client, priv->program) < 0)\n        goto error;\n\n    return priv;\n error:\n    virObjectUnref(priv);\n    return NULL;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr remoteAdminPrivClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "priv"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientAddProgram",
          "args": [
            "priv->client",
            "priv->program"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientAddProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1005-1021",
          "snippet": "int virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramNew",
          "args": [
            "ADMIN_PROGRAM",
            "ADMIN_PROTOCOL_VERSION",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "64-85",
          "snippet": "virNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientProgramClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientProgramClass;\n\nvirNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientNewUNIX",
          "args": [
            "sock_path",
            "false",
            "NULL"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNewUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "367-377",
          "snippet": "virNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "remoteAdminPrivClass"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic virClassPtr remoteAdminPrivClass;\n\nstatic remoteAdminPrivPtr\nremoteAdminPrivNew(const char *sock_path)\n{\n    remoteAdminPrivPtr priv = NULL;\n\n    if (!(priv = virObjectLockableNew(remoteAdminPrivClass)))\n        goto error;\n\n    if (!(priv->client = virNetClientNewUNIX(sock_path, false, NULL)))\n        goto error;\n\n    if (!(priv->program = virNetClientProgramNew(ADMIN_PROGRAM,\n                                                 ADMIN_PROTOCOL_VERSION,\n                                                 NULL, 0, NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(priv->client, priv->program) < 0)\n        goto error;\n\n    return priv;\n error:\n    virObjectUnref(priv);\n    return NULL;\n}"
  },
  {
    "function_name": "remoteAdminPrivFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "210-217",
    "snippet": "static void\nremoteAdminPrivFree(void *opaque)\n{\n    virAdmConnectPtr conn = opaque;\n\n    remoteAdminConnectClose(conn);\n    virObjectUnref(conn->privateData);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn->privateData"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remoteAdminConnectClose",
          "args": [
            "conn"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "remoteAdminConnectClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "185-208",
          "snippet": "static int\nremoteAdminConnectClose(virAdmConnectPtr conn)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n\n    virObjectLock(priv);\n\n    if (call(conn, 0, ADMIN_PROC_CONNECT_CLOSE,\n             (xdrproc_t)xdr_void, (char *)NULL,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    virNetClientSetCloseCallback(priv->client, NULL, conn->closeCallback,\n                                 virObjectFreeCallback);\n    virNetClientClose(priv->client);\n\n    rv = 0;\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminConnectClose(virAdmConnectPtr conn)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n\n    virObjectLock(priv);\n\n    if (call(conn, 0, ADMIN_PROC_CONNECT_CLOSE,\n             (xdrproc_t)xdr_void, (char *)NULL,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    virNetClientSetCloseCallback(priv->client, NULL, conn->closeCallback,\n                                 virObjectFreeCallback);\n    virNetClientClose(priv->client);\n\n    rv = 0;\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nremoteAdminPrivFree(void *opaque)\n{\n    virAdmConnectPtr conn = opaque;\n\n    remoteAdminConnectClose(conn);\n    virObjectUnref(conn->privateData);\n}"
  },
  {
    "function_name": "remoteAdminConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "185-208",
    "snippet": "static int\nremoteAdminConnectClose(virAdmConnectPtr conn)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n\n    virObjectLock(priv);\n\n    if (call(conn, 0, ADMIN_PROC_CONNECT_CLOSE,\n             (xdrproc_t)xdr_void, (char *)NULL,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    virNetClientSetCloseCallback(priv->client, NULL, conn->closeCallback,\n                                 virObjectFreeCallback);\n    virNetClientClose(priv->client);\n\n    rv = 0;\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "priv->client"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSetCloseCallback",
          "args": [
            "priv->client",
            "NULL",
            "conn->closeCallback",
            "virObjectFreeCallback"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSetCloseCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "134-144",
          "snippet": "void virNetClientSetCloseCallback(virNetClientPtr client,\n                                  virNetClientCloseFunc cb,\n                                  void *opaque,\n                                  virFreeCallback ff)\n{\n    virObjectLock(client);\n    client->closeCb = cb;\n    client->closeOpaque = opaque;\n    client->closeFf = ff;\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nvoid virNetClientSetCloseCallback(virNetClientPtr client,\n                                  virNetClientCloseFunc cb,\n                                  void *opaque,\n                                  virFreeCallback ff)\n{\n    virObjectLock(client);\n    client->closeCb = cb;\n    client->closeOpaque = opaque;\n    client->closeFf = ff;\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "conn",
            "0",
            "ADMIN_PROC_CONNECT_CLOSE",
            "(xdrproc_t)xdr_void",
            "(char *)NULL",
            "(xdrproc_t)xdr_void",
            "(char *)NULL"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminConnectClose(virAdmConnectPtr conn)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n\n    virObjectLock(priv);\n\n    if (call(conn, 0, ADMIN_PROC_CONNECT_CLOSE,\n             (xdrproc_t)xdr_void, (char *)NULL,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    virNetClientSetCloseCallback(priv->client, NULL, conn->closeCallback,\n                                 virObjectFreeCallback);\n    virNetClientClose(priv->client);\n\n    rv = 0;\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "150-183",
    "snippet": "static int\nremoteAdminConnectOpen(virAdmConnectPtr conn, unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n    admin_connect_open_args args;\n\n    virObjectLock(priv);\n\n    args.flags = flags & ~VIR_CONNECT_NO_ALIASES;\n\n    if (virNetClientRegisterAsyncIO(priv->client) < 0) {\n        VIR_DEBUG(\"Failed to add event watch, disabling events and support for\"\n                  \" keepalive messages\");\n        virResetLastError();\n    }\n\n    virObjectRef(conn->closeCallback);\n    virNetClientSetCloseCallback(priv->client, remoteAdminClientCloseFunc,\n                                 conn->closeCallback,\n                                 virObjectFreeCallback);\n\n    if (call(conn, 0, ADMIN_PROC_CONNECT_OPEN,\n             (xdrproc_t)xdr_admin_connect_open_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    rv = 0;\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "conn",
            "0",
            "ADMIN_PROC_CONNECT_OPEN",
            "(xdrproc_t)xdr_admin_connect_open_args",
            "(char *)&args",
            "(xdrproc_t)xdr_void",
            "(char *)NULL"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "116-128",
          "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSetCloseCallback",
          "args": [
            "priv->client",
            "remoteAdminClientCloseFunc",
            "conn->closeCallback",
            "virObjectFreeCallback"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSetCloseCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "134-144",
          "snippet": "void virNetClientSetCloseCallback(virNetClientPtr client,\n                                  virNetClientCloseFunc cb,\n                                  void *opaque,\n                                  virFreeCallback ff)\n{\n    virObjectLock(client);\n    client->closeCb = cb;\n    client->closeOpaque = opaque;\n    client->closeFf = ff;\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);",
            "static gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetClientIncomingEvent(virNetSocketPtr sock,\n                                      int events,\n                                      void *opaque);\nstatic gboolean\nvirNetClientIOEventTLS(int fd,\n                       GIOCondition ev,\n                       gpointer opaque);\n\nvoid virNetClientSetCloseCallback(virNetClientPtr client,\n                                  virNetClientCloseFunc cb,\n                                  void *opaque,\n                                  virFreeCallback ff)\n{\n    virObjectLock(client);\n    client->closeCb = cb;\n    client->closeOpaque = opaque;\n    client->closeFf = ff;\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "conn->closeCallback"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to add event watch, disabling events and support for\"\n                  \" keepalive messages\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientRegisterAsyncIO",
          "args": [
            "priv->client"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientRegisterAsyncIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "594-614",
          "snippet": "int virNetClientRegisterAsyncIO(virNetClientPtr client)\n{\n    if (client->asyncIO)\n        return 0;\n\n    /* Set up a callback to listen on the socket data */\n    virObjectRef(client);\n    if (virNetSocketAddIOCallback(client->sock,\n                                  VIR_EVENT_HANDLE_READABLE,\n                                  virNetClientIncomingEvent,\n                                  client,\n                                  virObjectFreeCallback) < 0) {\n        virObjectUnref(client);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to register async IO callback\"));\n        return -1;\n    }\n\n    client->asyncIO = true;\n    return 0;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientRegisterAsyncIO(virNetClientPtr client)\n{\n    if (client->asyncIO)\n        return 0;\n\n    /* Set up a callback to listen on the socket data */\n    virObjectRef(client);\n    if (virNetSocketAddIOCallback(client->sock,\n                                  VIR_EVENT_HANDLE_READABLE,\n                                  virNetClientIncomingEvent,\n                                  client,\n                                  virObjectFreeCallback) < 0) {\n        virObjectUnref(client);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to register async IO callback\"));\n        return -1;\n    }\n\n    client->asyncIO = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\nremoteAdminConnectOpen(virAdmConnectPtr conn, unsigned int flags)\n{\n    int rv = -1;\n    remoteAdminPrivPtr priv = conn->privateData;\n    admin_connect_open_args args;\n\n    virObjectLock(priv);\n\n    args.flags = flags & ~VIR_CONNECT_NO_ALIASES;\n\n    if (virNetClientRegisterAsyncIO(priv->client) < 0) {\n        VIR_DEBUG(\"Failed to add event watch, disabling events and support for\"\n                  \" keepalive messages\");\n        virResetLastError();\n    }\n\n    virObjectRef(conn->closeCallback);\n    virNetClientSetCloseCallback(priv->client, remoteAdminClientCloseFunc,\n                                 conn->closeCallback,\n                                 virObjectFreeCallback);\n\n    if (call(conn, 0, ADMIN_PROC_CONNECT_OPEN,\n             (xdrproc_t)xdr_admin_connect_open_args, (char *)&args,\n             (xdrproc_t)xdr_void, (char *)NULL) == -1) {\n        goto done;\n    }\n\n    rv = 0;\n\n done:\n    virObjectUnlock(priv);\n    return rv;\n}"
  },
  {
    "function_name": "remoteAdminClientCloseFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "132-148",
    "snippet": "static void\nremoteAdminClientCloseFunc(virNetClientPtr client G_GNUC_UNUSED,\n                           int reason,\n                           void *opaque)\n{\n    virAdmConnectCloseCallbackDataPtr cbdata = opaque;\n\n    virObjectLock(cbdata);\n\n    if (cbdata->callback) {\n        VIR_DEBUG(\"Triggering connection close callback %p reason=%d, opaque=%p\",\n                  cbdata->callback, reason, cbdata->opaque);\n        cbdata->callback(cbdata->conn, reason, cbdata->opaque);\n        virAdmConnectCloseCallbackDataReset(cbdata);\n    }\n    virObjectUnlock(cbdata);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "cbdata"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAdmConnectCloseCallbackDataReset",
          "args": [
            "cbdata"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virAdmConnectCloseCallbackDataReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1112-1123",
          "snippet": "void\nvirAdmConnectCloseCallbackDataReset(virAdmConnectCloseCallbackDataPtr cbdata)\n{\n    if (cbdata->freeCallback)\n        cbdata->freeCallback(cbdata->opaque);\n\n    virObjectUnref(cbdata->conn);\n    cbdata->conn = NULL;\n    cbdata->freeCallback = NULL;\n    cbdata->callback = NULL;\n    cbdata->opaque = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirAdmConnectCloseCallbackDataReset(virAdmConnectCloseCallbackDataPtr cbdata)\n{\n    if (cbdata->freeCallback)\n        cbdata->freeCallback(cbdata->opaque);\n\n    virObjectUnref(cbdata->conn);\n    cbdata->conn = NULL;\n    cbdata->freeCallback = NULL;\n    cbdata->callback = NULL;\n    cbdata->opaque = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cbdata->callback",
          "args": [
            "cbdata->conn",
            "reason",
            "cbdata->opaque"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Triggering connection close callback %p reason=%d, opaque=%p\"",
            "cbdata->callback",
            "reason",
            "cbdata->opaque"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "cbdata"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nremoteAdminClientCloseFunc(virNetClientPtr client G_GNUC_UNUSED,\n                           int reason,\n                           void *opaque)\n{\n    virAdmConnectCloseCallbackDataPtr cbdata = opaque;\n\n    virObjectLock(cbdata);\n\n    if (cbdata->callback) {\n        VIR_DEBUG(\"Triggering connection close callback %p reason=%d, opaque=%p\",\n                  cbdata->callback, reason, cbdata->opaque);\n        cbdata->callback(cbdata->conn, reason, cbdata->opaque);\n        virAdmConnectCloseCallbackDataReset(cbdata);\n    }\n    virObjectUnlock(cbdata);\n}"
  },
  {
    "function_name": "call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "116-128",
    "snippet": "static int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "callFull",
          "args": [
            "conn",
            "conn->privateData",
            "NULL",
            "0",
            "NULL",
            "NULL",
            "proc_nr",
            "args_filter",
            "args",
            "ret_filter",
            "ret"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "callFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "78-114",
          "snippet": "static int\ncallFull(virAdmConnectPtr conn G_GNUC_UNUSED,\n         remoteAdminPrivPtr priv,\n         int *fdin,\n         size_t fdinlen,\n         int **fdout,\n         size_t *fdoutlen,\n         int proc_nr,\n         xdrproc_t args_filter, char *args,\n         xdrproc_t ret_filter, char *ret)\n{\n    int rv;\n    virNetClientProgramPtr prog = priv->program;\n    int counter = priv->counter++;\n    virNetClientPtr client = priv->client;\n\n    /* Unlock, so that if we get any async events/stream data\n     * while processing the RPC, we don't deadlock when our\n     * callbacks for those are invoked\n     */\n    virObjectRef(priv);\n    virObjectUnlock(priv);\n\n    rv = virNetClientProgramCall(prog,\n                                 client,\n                                 counter,\n                                 proc_nr,\n                                 fdinlen, fdin,\n                                 fdoutlen, fdout,\n                                 args_filter, args,\n                                 ret_filter, ret);\n\n    virObjectLock(priv);\n    virObjectUnref(priv);\n\n    return rv;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncallFull(virAdmConnectPtr conn G_GNUC_UNUSED,\n         remoteAdminPrivPtr priv,\n         int *fdin,\n         size_t fdinlen,\n         int **fdout,\n         size_t *fdoutlen,\n         int proc_nr,\n         xdrproc_t args_filter, char *args,\n         xdrproc_t ret_filter, char *ret)\n{\n    int rv;\n    virNetClientProgramPtr prog = priv->program;\n    int counter = priv->counter++;\n    virNetClientPtr client = priv->client;\n\n    /* Unlock, so that if we get any async events/stream data\n     * while processing the RPC, we don't deadlock when our\n     * callbacks for those are invoked\n     */\n    virObjectRef(priv);\n    virObjectUnlock(priv);\n\n    rv = virNetClientProgramCall(prog,\n                                 client,\n                                 counter,\n                                 proc_nr,\n                                 fdinlen, fdin,\n                                 fdoutlen, fdout,\n                                 args_filter, args,\n                                 ret_filter, ret);\n\n    virObjectLock(priv);\n    virObjectUnref(priv);\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncall(virAdmConnectPtr conn,\n     unsigned int flags,\n     int proc_nr,\n     xdrproc_t args_filter, char *args,\n     xdrproc_t ret_filter, char *ret)\n{\n    virCheckFlags(0, -1);\n\n    return callFull(conn, conn->privateData,\n                    NULL, 0, NULL, NULL, proc_nr,\n                    args_filter, args, ret_filter, ret);\n}"
  },
  {
    "function_name": "callFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "78-114",
    "snippet": "static int\ncallFull(virAdmConnectPtr conn G_GNUC_UNUSED,\n         remoteAdminPrivPtr priv,\n         int *fdin,\n         size_t fdinlen,\n         int **fdout,\n         size_t *fdoutlen,\n         int proc_nr,\n         xdrproc_t args_filter, char *args,\n         xdrproc_t ret_filter, char *ret)\n{\n    int rv;\n    virNetClientProgramPtr prog = priv->program;\n    int counter = priv->counter++;\n    virNetClientPtr client = priv->client;\n\n    /* Unlock, so that if we get any async events/stream data\n     * while processing the RPC, we don't deadlock when our\n     * callbacks for those are invoked\n     */\n    virObjectRef(priv);\n    virObjectUnlock(priv);\n\n    rv = virNetClientProgramCall(prog,\n                                 client,\n                                 counter,\n                                 proc_nr,\n                                 fdinlen, fdin,\n                                 fdoutlen, fdout,\n                                 args_filter, args,\n                                 ret_filter, ret);\n\n    virObjectLock(priv);\n    virObjectUnref(priv);\n\n    return rv;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "priv"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "priv"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "prog",
            "client",
            "counter",
            "proc_nr",
            "fdinlen",
            "fdin",
            "fdoutlen",
            "fdout",
            "args_filter",
            "args",
            "ret_filter",
            "ret"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "priv"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "priv"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic int\ncallFull(virAdmConnectPtr conn G_GNUC_UNUSED,\n         remoteAdminPrivPtr priv,\n         int *fdin,\n         size_t fdinlen,\n         int **fdout,\n         size_t *fdoutlen,\n         int proc_nr,\n         xdrproc_t args_filter, char *args,\n         xdrproc_t ret_filter, char *ret)\n{\n    int rv;\n    virNetClientProgramPtr prog = priv->program;\n    int counter = priv->counter++;\n    virNetClientPtr client = priv->client;\n\n    /* Unlock, so that if we get any async events/stream data\n     * while processing the RPC, we don't deadlock when our\n     * callbacks for those are invoked\n     */\n    virObjectRef(priv);\n    virObjectUnlock(priv);\n\n    rv = virNetClientProgramCall(prog,\n                                 client,\n                                 counter,\n                                 proc_nr,\n                                 fdinlen, fdin,\n                                 fdoutlen, fdout,\n                                 args_filter, args,\n                                 ret_filter, ret);\n\n    virObjectLock(priv);\n    virObjectUnref(priv);\n\n    return rv;\n}"
  },
  {
    "function_name": "make_nonnull_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "68-76",
    "snippet": "static void\nmake_nonnull_client(admin_nonnull_client *client_dst,\n                    virAdmClientPtr client_src)\n{\n    client_dst->id = client_src->id;\n    client_dst->transport = client_src->transport;\n    client_dst->timestamp = client_src->timestamp;\n    make_nonnull_server(&client_dst->srv, client_src->srv);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_nonnull_server",
          "args": [
            "&client_dst->srv",
            "client_src->srv"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "make_nonnull_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
          "lines": "62-66",
          "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}",
          "includes": [
            "#include \"admin_client.h\"",
            "#include \"admin_protocol.h\"",
            "#include \"virtypedparam.h\"",
            "#include <rpc/rpc.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_client(admin_nonnull_client *client_dst,\n                    virAdmClientPtr client_src)\n{\n    client_dst->id = client_src->id;\n    client_dst->transport = client_src->transport;\n    client_dst->timestamp = client_src->timestamp;\n    make_nonnull_server(&client_dst->srv, client_src->srv);\n}"
  },
  {
    "function_name": "make_nonnull_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "62-66",
    "snippet": "static void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nmake_nonnull_server(admin_nonnull_server *srv_dst, virAdmServerPtr srv_src)\n{\n    srv_dst->name = srv_src->name;\n}"
  },
  {
    "function_name": "get_nonnull_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "56-60",
    "snippet": "static virAdmClientPtr\nget_nonnull_client(virAdmServerPtr srv, admin_nonnull_client client)\n{\n    return virAdmGetClient(srv, client.id, client.timestamp, client.transport);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virAdmGetClient",
          "args": [
            "srv",
            "client.id",
            "client.timestamp",
            "client.transport"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "virAdmGetClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1203-1224",
          "snippet": "virAdmClientPtr\nvirAdmGetClient(virAdmServerPtr srv, const unsigned long long id,\n                unsigned long long timestamp, unsigned int transport)\n{\n    virAdmClientPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        goto error;\n\n    if (!(ret = virObjectNew(virAdmClientClass)))\n        goto error;\n\n    ret->id = id;\n    ret->timestamp = timestamp;\n    ret->transport = transport;\n    ret->srv = virObjectRef(srv);\n\n    return ret;\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virAdmClientClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virAdmClientClass;\n\nvirAdmClientPtr\nvirAdmGetClient(virAdmServerPtr srv, const unsigned long long id,\n                unsigned long long timestamp, unsigned int transport)\n{\n    virAdmClientPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        goto error;\n\n    if (!(ret = virObjectNew(virAdmClientClass)))\n        goto error;\n\n    ret->id = id;\n    ret->timestamp = timestamp;\n    ret->transport = transport;\n    ret->srv = virObjectRef(srv);\n\n    return ret;\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic virAdmClientPtr\nget_nonnull_client(virAdmServerPtr srv, admin_nonnull_client client)\n{\n    return virAdmGetClient(srv, client.id, client.timestamp, client.transport);\n}"
  },
  {
    "function_name": "get_nonnull_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "50-54",
    "snippet": "static virAdmServerPtr\nget_nonnull_server(virAdmConnectPtr conn, admin_nonnull_server server)\n{\n    return virAdmGetServer(conn, server.name);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virAdmGetServer",
          "args": [
            "conn",
            "server.name"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "virAdmGetServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1173-1191",
          "snippet": "virAdmServerPtr\nvirAdmGetServer(virAdmConnectPtr conn, const char *name)\n{\n    virAdmServerPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        goto error;\n\n    if (!(ret = virObjectNew(virAdmServerClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virAdmServerClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virAdmServerClass;\n\nvirAdmServerPtr\nvirAdmGetServer(virAdmConnectPtr conn, const char *name)\n{\n    virAdmServerPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        goto error;\n\n    if (!(ret = virObjectNew(virAdmServerClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic virAdmServerPtr\nget_nonnull_server(virAdmConnectPtr conn, admin_nonnull_server server)\n{\n    return virAdmGetServer(conn, server.name);\n}"
  },
  {
    "function_name": "remoteAdminPrivDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/admin/admin_remote.c",
    "lines": "39-46",
    "snippet": "static void\nremoteAdminPrivDispose(void *opaque)\n{\n    remoteAdminPrivPtr priv = opaque;\n\n    virObjectUnref(priv->program);\n    virObjectUnref(priv->client);\n}",
    "includes": [
      "#include \"admin_client.h\"",
      "#include \"admin_protocol.h\"",
      "#include \"virtypedparam.h\"",
      "#include <rpc/rpc.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "priv->client"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"admin_client.h\"\n#include \"admin_protocol.h\"\n#include \"virtypedparam.h\"\n#include <rpc/rpc.h>\n#include <config.h>\n\nstatic void\nremoteAdminPrivDispose(void *opaque)\n{\n    remoteAdminPrivPtr priv = opaque;\n\n    virObjectUnref(priv->program);\n    virObjectUnref(priv->client);\n}"
  }
]