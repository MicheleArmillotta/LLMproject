[
  {
    "function_name": "virStorageBackendLogicalRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "1007-1011",
    "snippet": "int\nvirStorageBackendLogicalRegister(void)\n{\n    return virStorageBackendRegister(&virStorageBackendLogical);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageBackend virStorageBackendLogical = {\n    .type = VIR_STORAGE_POOL_LOGICAL,\n\n    .findPoolSources = virStorageBackendLogicalFindPoolSources,\n    .checkPool = virStorageBackendLogicalCheckPool,\n    .startPool = virStorageBackendLogicalStartPool,\n    .buildPool = virStorageBackendLogicalBuildPool,\n    .refreshPool = virStorageBackendLogicalRefreshPool,\n    .stopPool = virStorageBackendLogicalStopPool,\n    .deletePool = virStorageBackendLogicalDeletePool,\n    .buildVol = NULL,\n    .buildVolFrom = virStorageBackendLogicalBuildVolFrom,\n    .createVol = virStorageBackendLogicalCreateVol,\n    .deleteVol = virStorageBackendLogicalDeleteVol,\n    .uploadVol = virStorageBackendVolUploadLocal,\n    .downloadVol = virStorageBackendVolDownloadLocal,\n    .wipeVol = virStorageBackendLogicalVolWipe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendRegister",
          "args": [
            "&virStorageBackendLogical"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend.c",
          "lines": "153-169",
          "snippet": "int\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}",
          "includes": [
            "# include \"storage_backend_vstorage.h\"",
            "# include \"storage_backend_zfs.h\"",
            "# include \"storage_backend_gluster.h\"",
            "# include \"storage_backend_sheepdog.h\"",
            "# include \"storage_backend_rbd.h\"",
            "# include \"storage_backend_fs.h\"",
            "# include \"storage_backend_disk.h\"",
            "# include \"storage_backend_mpath.h\"",
            "# include \"storage_backend_scsi.h\"",
            "# include \"storage_backend_iscsi_direct.h\"",
            "# include \"storage_backend_iscsi.h\"",
            "# include \"storage_backend_logical.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_BACKENDS_MAX 20"
          ],
          "globals_used": [
            "static virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];",
            "static size_t virStorageBackendsCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"storage_backend_vstorage.h\"\n# include \"storage_backend_zfs.h\"\n# include \"storage_backend_gluster.h\"\n# include \"storage_backend_sheepdog.h\"\n# include \"storage_backend_rbd.h\"\n# include \"storage_backend_fs.h\"\n# include \"storage_backend_disk.h\"\n# include \"storage_backend_mpath.h\"\n# include \"storage_backend_scsi.h\"\n# include \"storage_backend_iscsi_direct.h\"\n# include \"storage_backend_iscsi.h\"\n# include \"storage_backend_logical.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"virstoragefile.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_BACKENDS_MAX 20\n\nstatic virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];\nstatic size_t virStorageBackendsCount;\n\nint\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvirStorageBackend virStorageBackendLogical = {\n    .type = VIR_STORAGE_POOL_LOGICAL,\n\n    .findPoolSources = virStorageBackendLogicalFindPoolSources,\n    .checkPool = virStorageBackendLogicalCheckPool,\n    .startPool = virStorageBackendLogicalStartPool,\n    .buildPool = virStorageBackendLogicalBuildPool,\n    .refreshPool = virStorageBackendLogicalRefreshPool,\n    .stopPool = virStorageBackendLogicalStopPool,\n    .deletePool = virStorageBackendLogicalDeletePool,\n    .buildVol = NULL,\n    .buildVolFrom = virStorageBackendLogicalBuildVolFrom,\n    .createVol = virStorageBackendLogicalCreateVol,\n    .deleteVol = virStorageBackendLogicalDeleteVol,\n    .uploadVol = virStorageBackendVolUploadLocal,\n    .downloadVol = virStorageBackendVolDownloadLocal,\n    .wipeVol = virStorageBackendLogicalVolWipe,\n};\n\nint\nvirStorageBackendLogicalRegister(void)\n{\n    return virStorageBackendRegister(&virStorageBackendLogical);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalVolWipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "959-985",
    "snippet": "static int\nvirStorageBackendLogicalVolWipe(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                unsigned int algorithm,\n                                unsigned int flags)\n{\n    if (!vol->target.sparse)\n        return virStorageBackendVolWipeLocal(pool, vol, algorithm, flags);\n\n    /* The wiping algorithms will write something to the logical volume.\n     * Writing to a sparse logical volume causes it to be filled resulting\n     * in the volume becoming INACTIVE because there is some amount of\n     * metadata contained within the sparse lv. Choosing to only write\n     * a wipe pattern to the already written portion lv based on what\n     * 'lvs' shows in the \"Data%\" column/field for the sparse lv was\n     * considered. However, there is no guarantee that sparse lv could\n     * grow or shrink outside of libvirt's knowledge and thus still render\n     * the volume INACTIVE. Until there is some sort of wipe function\n     * implemented by lvm for one of these sparse lv, we'll just return\n     * unsupported.\n     */\n    virReportError(VIR_ERR_NO_SUPPORT,\n                   _(\"logical volume '%s' is sparse, volume wipe \"\n                     \"not supported\"),\n                   vol->target.path);\n    return -1;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"logical volume '%s' is sparse, volume wipe \"\n                     \"not supported\")",
            "vol->target.path"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"logical volume '%s' is sparse, volume wipe \"\n                     \"not supported\""
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendVolWipeLocal",
          "args": [
            "pool",
            "vol",
            "algorithm",
            "flags"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendVolWipeLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2695-2716",
          "snippet": "int\nvirStorageBackendVolWipeLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              unsigned int algorithm,\n                              unsigned int flags)\n{\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Wiping volume with path '%s' and algorithm %u\",\n              vol->target.path, algorithm);\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        ret = storageBackendVolWipePloop(vol, algorithm);\n    } else {\n        ret = storageBackendVolWipeLocalFile(vol->target.path, algorithm,\n                                             vol->target.allocation, false);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolWipeLocal(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                              virStorageVolDefPtr vol,\n                              unsigned int algorithm,\n                              unsigned int flags)\n{\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    VIR_DEBUG(\"Wiping volume with path '%s' and algorithm %u\",\n              vol->target.path, algorithm);\n\n    if (vol->target.format == VIR_STORAGE_FILE_PLOOP) {\n        ret = storageBackendVolWipePloop(vol, algorithm);\n    } else {\n        ret = storageBackendVolWipeLocalFile(vol->target.path, algorithm,\n                                             vol->target.allocation, false);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalVolWipe(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol,\n                                unsigned int algorithm,\n                                unsigned int flags)\n{\n    if (!vol->target.sparse)\n        return virStorageBackendVolWipeLocal(pool, vol, algorithm, flags);\n\n    /* The wiping algorithms will write something to the logical volume.\n     * Writing to a sparse logical volume causes it to be filled resulting\n     * in the volume becoming INACTIVE because there is some amount of\n     * metadata contained within the sparse lv. Choosing to only write\n     * a wipe pattern to the already written portion lv based on what\n     * 'lvs' shows in the \"Data%\" column/field for the sparse lv was\n     * considered. However, there is no guarantee that sparse lv could\n     * grow or shrink outside of libvirt's knowledge and thus still render\n     * the volume INACTIVE. Until there is some sort of wipe function\n     * implemented by lvm for one of these sparse lv, we'll just return\n     * unsupported.\n     */\n    virReportError(VIR_ERR_NO_SUPPORT,\n                   _(\"logical volume '%s' is sparse, volume wipe \"\n                     \"not supported\"),\n                   vol->target.path);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalBuildVolFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "944-957",
    "snippet": "static int\nvirStorageBackendLogicalBuildVolFrom(virStoragePoolObjPtr pool,\n                                     virStorageVolDefPtr vol,\n                                     virStorageVolDefPtr inputvol,\n                                     unsigned int flags)\n{\n    virStorageBackendBuildVolFrom build_func;\n\n    build_func = virStorageBackendGetBuildVolFromFunction(vol, inputvol);\n    if (!build_func)\n        return -1;\n\n    return build_func(pool, vol, inputvol, flags);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "build_func",
          "args": [
            "pool",
            "vol",
            "inputvol",
            "flags"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendGetBuildVolFromFunction",
          "args": [
            "vol",
            "inputvol"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGetBuildVolFromFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1387-1412",
          "snippet": "virStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageBackendBuildVolFrom\nvirStorageBackendGetBuildVolFromFunction(virStorageVolDefPtr vol,\n                                         virStorageVolDefPtr inputvol)\n{\n    if (!inputvol)\n        return NULL;\n\n    /* If either volume is a non-raw file vol, or uses encryption,\n     * we need to use an external tool for converting\n     */\n    if ((vol->type == VIR_STORAGE_VOL_FILE &&\n         (vol->target.format != VIR_STORAGE_FILE_RAW ||\n          vol->target.encryption)) ||\n        (inputvol->type == VIR_STORAGE_VOL_FILE &&\n         (inputvol->target.format != VIR_STORAGE_FILE_RAW ||\n          inputvol->target.encryption))) {\n        return storageBackendCreateQemuImg;\n    }\n\n    if (vol->type == VIR_STORAGE_VOL_PLOOP)\n        return storageBackendCreatePloop;\n    if (vol->type == VIR_STORAGE_VOL_BLOCK)\n        return storageBackendCreateBlockFrom;\n    else\n        return storageBackendCreateRaw;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalBuildVolFrom(virStoragePoolObjPtr pool,\n                                     virStorageVolDefPtr vol,\n                                     virStorageVolDefPtr inputvol,\n                                     unsigned int flags)\n{\n    virStorageBackendBuildVolFrom build_func;\n\n    build_func = virStorageBackendGetBuildVolFromFunction(vol, inputvol);\n    if (!build_func)\n        return -1;\n\n    return build_func(pool, vol, inputvol, flags);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalCreateVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "877-942",
    "snippet": "static int\nvirStorageBackendLogicalCreateVol(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virErrorPtr err;\n    struct stat sb;\n    VIR_AUTOCLOSE fd = -1;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    VIR_FREE(vol->target.path);\n    vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n    if (virStorageBackendLogicalLVCreate(vol, def) < 0)\n        return -1;\n\n    if (vol->target.encryption &&\n        virStorageBackendCreateVolUsingQemuImg(pool, vol, NULL, 0) < 0)\n        goto error;\n\n    if ((fd = virStorageBackendVolOpen(vol->target.path, &sb,\n                                       VIR_STORAGE_VOL_OPEN_DEFAULT)) < 0)\n        goto error;\n\n    /* We can only chown/grp if root */\n    if (geteuid() == 0) {\n        if (fchown(fd, vol->target.perms->uid, vol->target.perms->gid) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot set file owner '%s'\"),\n                                 vol->target.path);\n            goto error;\n        }\n    }\n    if (fchmod(fd, (vol->target.perms->mode == (mode_t)-1 ?\n                    VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                    vol->target.perms->mode)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set file mode '%s'\"),\n                             vol->target.path);\n        goto error;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot close file '%s'\"),\n                             vol->target.path);\n        goto error;\n    }\n\n    /* Fill in data about this new vol */\n    if (virStorageBackendLogicalFindLVs(pool, vol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot find newly created volume '%s'\"),\n                             vol->target.path);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&err);\n    virStorageBackendLogicalDeleteVol(pool, vol, 0);\n    virErrorRestore(&err);\n    return -1;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalDeleteVol",
          "args": [
            "pool",
            "vol",
            "0"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalDeleteVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "807-832",
          "snippet": "static int\nvirStorageBackendLogicalDeleteVol(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                  virStorageVolDefPtr vol,\n                                  unsigned int flags)\n{\n    g_autoptr(virCommand) lvchange_cmd = NULL;\n    g_autoptr(virCommand) lvremove_cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    virWaitForDevices();\n\n    lvchange_cmd = virCommandNewArgList(LVCHANGE, \"-aln\", vol->target.path, NULL);\n    lvremove_cmd = virCommandNewArgList(LVREMOVE, \"-f\", vol->target.path, NULL);\n\n    if (virCommandRun(lvremove_cmd, NULL) < 0) {\n        if (virCommandRun(lvchange_cmd, NULL) < 0) {\n            return -1;\n        } else {\n            if (virCommandRun(lvremove_cmd, NULL) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalDeleteVol(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                  virStorageVolDefPtr vol,\n                                  unsigned int flags)\n{\n    g_autoptr(virCommand) lvchange_cmd = NULL;\n    g_autoptr(virCommand) lvremove_cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    virWaitForDevices();\n\n    lvchange_cmd = virCommandNewArgList(LVCHANGE, \"-aln\", vol->target.path, NULL);\n    lvremove_cmd = virCommandNewArgList(LVREMOVE, \"-f\", vol->target.path, NULL);\n\n    if (virCommandRun(lvremove_cmd, NULL) < 0) {\n        if (virCommandRun(lvchange_cmd, NULL) < 0) {\n            return -1;\n        } else {\n            if (virCommandRun(lvremove_cmd, NULL) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot find newly created volume '%s'\")",
            "vol->target.path"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot find newly created volume '%s'\""
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalFindLVs",
          "args": [
            "pool",
            "vol"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalFindLVs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "353-408",
          "snippet": "static int\nvirStorageBackendLogicalFindLVs(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    /*\n     * # lvs --separator # --noheadings --units b --unbuffered --nosuffix --options \\\n     * \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\" VGNAME\n     *\n     * RootLV##06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky#/dev/hda2(0)#linear#1#5234491392#33554432#5234491392#-wi-ao\n     * SwapLV##oHviCK-8Ik0-paqS-V20c-nkhY-Bm1e-zgzU0M#/dev/hda2(156)#linear#1#1040187392#33554432#1040187392#-wi-ao\n     * Test2##3pg3he-mQsA-5Sui-h0i6-HNmc-Cz7W-QSndcR#/dev/hda2(219)#linear#1#1073741824#33554432#1073741824#owi-a-\n     * Test3##UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(251)#linear#1#2181038080#33554432#2181038080#-wi-a-\n     * Test3#Test2#UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(187)#linear#1#1040187392#33554432#1040187392#swi-a-\n     * test_stripes##fSLSZH-zAS2-yAIb-n4mV-Al9u-HA3V-oo9K1B#/dev/sdc1(10240),/dev/sdd1(0)#striped#2#42949672960#4194304#-wi-a-\n     *\n     * Pull out name, origin, & uuid, device, device extent start #,\n     * segment size, extent size, size, attrs\n     *\n     * NB can be multiple rows per volume if they have many extents\n     *\n     * NB lvs from some distros (e.g. SLES10 SP2) outputs trailing \",\"\n     * on each line\n     *\n     * NB Encrypted logical volumes can print ':' in their name, so it is\n     *    not a suitable separator (rhbz 470693).\n     *\n     * NB \"devices\" field has multiple device paths and \",\" if the volume is\n     *    striped, so \",\" is not a suitable separator either (rhbz 727474).\n     */\n    const char *regexes[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX\n    };\n    int vars[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendLogicalPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS,\n                               \"--separator\", \"#\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\",\n                               \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\",\n                               def->source.name,\n                               NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalMakeVol,\n                              &cbdata, \"lvs\", NULL);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_VOL_LOGICAL_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_PREFIX_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_NAME_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_ORIGIN_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_UUID_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_DEVICES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEGTYPE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_STRIPES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEG_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_VG_EXTENT_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_ATTR_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SUFFIX_REGEX",
            "#define VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_VOL_LOGICAL_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_PREFIX_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_NAME_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_ORIGIN_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_UUID_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_DEVICES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEGTYPE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_STRIPES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEG_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_VG_EXTENT_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_ATTR_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SUFFIX_REGEX\n#define VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT 10\n\nstatic int\nvirStorageBackendLogicalFindLVs(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    /*\n     * # lvs --separator # --noheadings --units b --unbuffered --nosuffix --options \\\n     * \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\" VGNAME\n     *\n     * RootLV##06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky#/dev/hda2(0)#linear#1#5234491392#33554432#5234491392#-wi-ao\n     * SwapLV##oHviCK-8Ik0-paqS-V20c-nkhY-Bm1e-zgzU0M#/dev/hda2(156)#linear#1#1040187392#33554432#1040187392#-wi-ao\n     * Test2##3pg3he-mQsA-5Sui-h0i6-HNmc-Cz7W-QSndcR#/dev/hda2(219)#linear#1#1073741824#33554432#1073741824#owi-a-\n     * Test3##UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(251)#linear#1#2181038080#33554432#2181038080#-wi-a-\n     * Test3#Test2#UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(187)#linear#1#1040187392#33554432#1040187392#swi-a-\n     * test_stripes##fSLSZH-zAS2-yAIb-n4mV-Al9u-HA3V-oo9K1B#/dev/sdc1(10240),/dev/sdd1(0)#striped#2#42949672960#4194304#-wi-a-\n     *\n     * Pull out name, origin, & uuid, device, device extent start #,\n     * segment size, extent size, size, attrs\n     *\n     * NB can be multiple rows per volume if they have many extents\n     *\n     * NB lvs from some distros (e.g. SLES10 SP2) outputs trailing \",\"\n     * on each line\n     *\n     * NB Encrypted logical volumes can print ':' in their name, so it is\n     *    not a suitable separator (rhbz 470693).\n     *\n     * NB \"devices\" field has multiple device paths and \",\" if the volume is\n     *    striped, so \",\" is not a suitable separator either (rhbz 727474).\n     */\n    const char *regexes[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX\n    };\n    int vars[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendLogicalPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS,\n                               \"--separator\", \"#\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\",\n                               \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\",\n                               def->source.name,\n                               NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalMakeVol,\n                              &cbdata, \"lvs\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot close file '%s'\")",
            "vol->target.path"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot set file mode '%s'\")",
            "vol->target.path"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fd",
            "(vol->target.perms->mode == (mode_t)-1 ?\n                    VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                    vol->target.perms->mode)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot set file owner '%s'\")",
            "vol->target.path"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "vol->target.perms->uid",
            "vol->target.perms->gid"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendVolOpen",
          "args": [
            "vol->target.path",
            "&sb",
            "VIR_STORAGE_VOL_OPEN_DEFAULT"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendVolOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1518-1656",
          "snippet": "int\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendVolOpen(const char *path, struct stat *sb,\n                         unsigned int flags)\n{\n    int fd, mode = 0;\n    g_autofree char *base = g_path_get_basename(path);\n    bool noerror = (flags & VIR_STORAGE_VOL_OPEN_NOERROR);\n\n    if (g_lstat(path, sb) < 0) {\n        if (errno == ENOENT) {\n            if (noerror) {\n                VIR_WARN(\"ignoring missing file '%s'\", path);\n                return -2;\n            }\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"),\n                           path);\n            return -1;\n        }\n        virReportSystemError(errno,\n                             _(\"cannot stat file '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (S_ISFIFO(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring FIFO '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a FIFO\"), path);\n        return -1;\n    } else if (S_ISSOCK(sb->st_mode)) {\n        if (noerror) {\n            VIR_WARN(\"ignoring socket '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Volume path '%s' is a socket\"), path);\n        return -1;\n    }\n\n    /* O_NONBLOCK should only matter during open() for fifos and\n     * sockets, which we already filtered; but using it prevents a\n     * TOCTTOU race.  However, later on we will want to read() the\n     * header from this fd, and virFileRead* routines require a\n     * blocking fd, so fix it up after verifying we avoided a race.\n     *\n     * Use of virFileOpenAs allows this path to open a file using\n     * the uid and gid as it was created in order to open. Since this\n     * path is not using O_CREAT or O_TMPFILE, mode is meaningless.\n     * Opening under user/group is especially important in an NFS\n     * root-squash environment. If the target path isn't on shared\n     * file system, the open will fail in the OPEN_FORK path.\n     */\n    if ((fd = virFileOpenAs(path, O_RDONLY|O_NONBLOCK|O_NOCTTY,\n                            0, sb->st_uid, sb->st_gid,\n                            VIR_FILE_OPEN_NOFORK|VIR_FILE_OPEN_FORK)) < 0) {\n        if ((errno == ENOENT || errno == ELOOP) &&\n            S_ISLNK(sb->st_mode) && noerror) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", path);\n            return -2;\n        }\n        if (errno == ENOENT && noerror) {\n            VIR_WARN(\"ignoring missing file '%s'\", path);\n            return -2;\n        }\n        if (errno == ENXIO && noerror) {\n            VIR_WARN(\"ignoring missing fifo '%s'\", path);\n            return -2;\n        }\n        if ((errno == EACCES || errno == EPERM) && noerror) {\n            VIR_WARN(\"ignoring permission error for '%s'\", path);\n            return -2;\n        }\n\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), path);\n        return -1;\n    }\n\n    if (fstat(fd, sb) < 0) {\n        virReportSystemError(errno, _(\"cannot stat file '%s'\"), path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (S_ISREG(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_REG;\n    } else if (S_ISCHR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_CHAR;\n    } else if (S_ISBLK(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_BLOCK;\n    } else if (S_ISDIR(sb->st_mode)) {\n        mode = VIR_STORAGE_VOL_OPEN_DIR;\n\n        if (STREQ(base, \".\") ||\n            STREQ(base, \"..\")) {\n            VIR_FORCE_CLOSE(fd);\n            if (noerror) {\n                VIR_INFO(\"Skipping special dir '%s'\", base);\n                return -2;\n            }\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cannot use volume path '%s'\"), path);\n            return -1;\n        }\n    } else {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_WARN(\"ignoring unexpected type for file '%s'\", path);\n            return -2;\n        }\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected type for file '%s'\"), path);\n        return -1;\n    }\n\n    if (virSetBlocking(fd, true) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno, _(\"unable to set blocking mode for '%s'\"),\n                             path);\n        return -1;\n    }\n\n    if (!(mode & flags)) {\n        VIR_FORCE_CLOSE(fd);\n        if (noerror) {\n            VIR_INFO(\"Skipping volume '%s'\", path);\n            return -2;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected storage mode for '%s'\"), path);\n        return -1;\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendCreateVolUsingQemuImg",
          "args": [
            "pool",
            "vol",
            "NULL",
            "0"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendCreateVolUsingQemuImg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1364-1384",
          "snippet": "int\nvirStorageBackendCreateVolUsingQemuImg(virStoragePoolObjPtr pool,\n                                       virStorageVolDefPtr vol,\n                                       virStorageVolDefPtr inputvol,\n                                       unsigned int flags)\n{\n    int ret = -1;\n    bool changeFormat = false;\n\n    if (vol->target.format == VIR_STORAGE_FILE_NONE) {\n        vol->target.format = VIR_STORAGE_FILE_RAW;\n        changeFormat = true;\n    }\n\n    ret = storageBackendCreateQemuImg(pool, vol, inputvol, flags);\n\n    if (changeFormat)\n        vol->target.format = VIR_STORAGE_FILE_NONE;\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendCreateVolUsingQemuImg(virStoragePoolObjPtr pool,\n                                       virStorageVolDefPtr vol,\n                                       virStorageVolDefPtr inputvol,\n                                       unsigned int flags)\n{\n    int ret = -1;\n    bool changeFormat = false;\n\n    if (vol->target.format == VIR_STORAGE_FILE_NONE) {\n        vol->target.format = VIR_STORAGE_FILE_RAW;\n        changeFormat = true;\n    }\n\n    ret = storageBackendCreateQemuImg(pool, vol, inputvol, flags);\n\n    if (changeFormat)\n        vol->target.format = VIR_STORAGE_FILE_NONE;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalLVCreate",
          "args": [
            "vol",
            "def"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalLVCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "835-874",
          "snippet": "static int\nvirStorageBackendLogicalLVCreate(virStorageVolDefPtr vol,\n                                 virStoragePoolDefPtr def)\n{\n    unsigned long long capacity = vol->target.capacity;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (vol->target.encryption &&\n        vol->target.encryption->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool only supports LUKS encrypted volumes\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(LVCREATE,\n                               \"--name\", vol->name,\n                               NULL);\n    virCommandAddArg(cmd, \"-L\");\n    if (capacity != vol->target.allocation) {\n        virCommandAddArgFormat(cmd, \"%lluK\",\n                               VIR_DIV_UP(vol->target.allocation\n                                          ? vol->target.allocation : 1, 1024));\n        virCommandAddArgList(cmd, \"--type\", \"snapshot\", NULL);\n        virCommandAddArg(cmd, \"--virtualsize\");\n        vol->target.sparse = true;\n    }\n\n    /* If we're going to encrypt using LUKS, then we could need up to\n     * an extra 2MB for the LUKS header - so account for that now */\n    if (vol->target.encryption)\n        capacity += 2 * 1024 * 1024;\n    virCommandAddArgFormat(cmd, \"%lluK\", VIR_DIV_UP(capacity, 1024));\n\n    if (virStorageSourceHasBacking(&vol->target))\n        virCommandAddArgList(cmd, \"-s\", vol->target.backingStore->path, NULL);\n    else\n        virCommandAddArg(cmd, def->source.name);\n\n    return virCommandRun(cmd, NULL);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalLVCreate(virStorageVolDefPtr vol,\n                                 virStoragePoolDefPtr def)\n{\n    unsigned long long capacity = vol->target.capacity;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (vol->target.encryption &&\n        vol->target.encryption->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool only supports LUKS encrypted volumes\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(LVCREATE,\n                               \"--name\", vol->name,\n                               NULL);\n    virCommandAddArg(cmd, \"-L\");\n    if (capacity != vol->target.allocation) {\n        virCommandAddArgFormat(cmd, \"%lluK\",\n                               VIR_DIV_UP(vol->target.allocation\n                                          ? vol->target.allocation : 1, 1024));\n        virCommandAddArgList(cmd, \"--type\", \"snapshot\", NULL);\n        virCommandAddArg(cmd, \"--virtualsize\");\n        vol->target.sparse = true;\n    }\n\n    /* If we're going to encrypt using LUKS, then we could need up to\n     * an extra 2MB for the LUKS header - so account for that now */\n    if (vol->target.encryption)\n        capacity += 2 * 1024 * 1024;\n    virCommandAddArgFormat(cmd, \"%lluK\", VIR_DIV_UP(capacity, 1024));\n\n    if (virStorageSourceHasBacking(&vol->target))\n        virCommandAddArgList(cmd, \"-s\", vol->target.backingStore->path, NULL);\n    else\n        virCommandAddArg(cmd, def->source.name);\n\n    return virCommandRun(cmd, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->target.path"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalCreateVol(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virErrorPtr err;\n    struct stat sb;\n    VIR_AUTOCLOSE fd = -1;\n\n    vol->type = VIR_STORAGE_VOL_BLOCK;\n\n    VIR_FREE(vol->target.path);\n    vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n    if (virStorageBackendLogicalLVCreate(vol, def) < 0)\n        return -1;\n\n    if (vol->target.encryption &&\n        virStorageBackendCreateVolUsingQemuImg(pool, vol, NULL, 0) < 0)\n        goto error;\n\n    if ((fd = virStorageBackendVolOpen(vol->target.path, &sb,\n                                       VIR_STORAGE_VOL_OPEN_DEFAULT)) < 0)\n        goto error;\n\n    /* We can only chown/grp if root */\n    if (geteuid() == 0) {\n        if (fchown(fd, vol->target.perms->uid, vol->target.perms->gid) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot set file owner '%s'\"),\n                                 vol->target.path);\n            goto error;\n        }\n    }\n    if (fchmod(fd, (vol->target.perms->mode == (mode_t)-1 ?\n                    VIR_STORAGE_DEFAULT_VOL_PERM_MODE :\n                    vol->target.perms->mode)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot set file mode '%s'\"),\n                             vol->target.path);\n        goto error;\n    }\n\n    if (VIR_CLOSE(fd) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot close file '%s'\"),\n                             vol->target.path);\n        goto error;\n    }\n\n    /* Fill in data about this new vol */\n    if (virStorageBackendLogicalFindLVs(pool, vol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot find newly created volume '%s'\"),\n                             vol->target.path);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&err);\n    virStorageBackendLogicalDeleteVol(pool, vol, 0);\n    virErrorRestore(&err);\n    return -1;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalLVCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "835-874",
    "snippet": "static int\nvirStorageBackendLogicalLVCreate(virStorageVolDefPtr vol,\n                                 virStoragePoolDefPtr def)\n{\n    unsigned long long capacity = vol->target.capacity;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (vol->target.encryption &&\n        vol->target.encryption->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool only supports LUKS encrypted volumes\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(LVCREATE,\n                               \"--name\", vol->name,\n                               NULL);\n    virCommandAddArg(cmd, \"-L\");\n    if (capacity != vol->target.allocation) {\n        virCommandAddArgFormat(cmd, \"%lluK\",\n                               VIR_DIV_UP(vol->target.allocation\n                                          ? vol->target.allocation : 1, 1024));\n        virCommandAddArgList(cmd, \"--type\", \"snapshot\", NULL);\n        virCommandAddArg(cmd, \"--virtualsize\");\n        vol->target.sparse = true;\n    }\n\n    /* If we're going to encrypt using LUKS, then we could need up to\n     * an extra 2MB for the LUKS header - so account for that now */\n    if (vol->target.encryption)\n        capacity += 2 * 1024 * 1024;\n    virCommandAddArgFormat(cmd, \"%lluK\", VIR_DIV_UP(capacity, 1024));\n\n    if (virStorageSourceHasBacking(&vol->target))\n        virCommandAddArgList(cmd, \"-s\", vol->target.backingStore->path, NULL);\n    else\n        virCommandAddArg(cmd, def->source.name);\n\n    return virCommandRun(cmd, NULL);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "def->source.name"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "&vol->target"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%lluK\"",
            "VIR_DIV_UP(capacity, 1024)"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "capacity",
            "1024"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "vol->target.allocation\n                                          ? vol->target.allocation : 1",
            "1024"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "LVCREATE",
            "\"--name\"",
            "vol->name",
            "NULL"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"storage pool only supports LUKS encrypted volumes\")"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"storage pool only supports LUKS encrypted volumes\""
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalLVCreate(virStorageVolDefPtr vol,\n                                 virStoragePoolDefPtr def)\n{\n    unsigned long long capacity = vol->target.capacity;\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (vol->target.encryption &&\n        vol->target.encryption->format != VIR_STORAGE_ENCRYPTION_FORMAT_LUKS) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"storage pool only supports LUKS encrypted volumes\"));\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(LVCREATE,\n                               \"--name\", vol->name,\n                               NULL);\n    virCommandAddArg(cmd, \"-L\");\n    if (capacity != vol->target.allocation) {\n        virCommandAddArgFormat(cmd, \"%lluK\",\n                               VIR_DIV_UP(vol->target.allocation\n                                          ? vol->target.allocation : 1, 1024));\n        virCommandAddArgList(cmd, \"--type\", \"snapshot\", NULL);\n        virCommandAddArg(cmd, \"--virtualsize\");\n        vol->target.sparse = true;\n    }\n\n    /* If we're going to encrypt using LUKS, then we could need up to\n     * an extra 2MB for the LUKS header - so account for that now */\n    if (vol->target.encryption)\n        capacity += 2 * 1024 * 1024;\n    virCommandAddArgFormat(cmd, \"%lluK\", VIR_DIV_UP(capacity, 1024));\n\n    if (virStorageSourceHasBacking(&vol->target))\n        virCommandAddArgList(cmd, \"-s\", vol->target.backingStore->path, NULL);\n    else\n        virCommandAddArg(cmd, def->source.name);\n\n    return virCommandRun(cmd, NULL);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalDeleteVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "807-832",
    "snippet": "static int\nvirStorageBackendLogicalDeleteVol(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                  virStorageVolDefPtr vol,\n                                  unsigned int flags)\n{\n    g_autoptr(virCommand) lvchange_cmd = NULL;\n    g_autoptr(virCommand) lvremove_cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    virWaitForDevices();\n\n    lvchange_cmd = virCommandNewArgList(LVCHANGE, \"-aln\", vol->target.path, NULL);\n    lvremove_cmd = virCommandNewArgList(LVREMOVE, \"-f\", vol->target.path, NULL);\n\n    if (virCommandRun(lvremove_cmd, NULL) < 0) {\n        if (virCommandRun(lvchange_cmd, NULL) < 0) {\n            return -1;\n        } else {\n            if (virCommandRun(lvremove_cmd, NULL) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "lvremove_cmd",
            "NULL"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "LVREMOVE",
            "\"-f\"",
            "vol->target.path",
            "NULL"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalDeleteVol(virStoragePoolObjPtr pool G_GNUC_UNUSED,\n                                  virStorageVolDefPtr vol,\n                                  unsigned int flags)\n{\n    g_autoptr(virCommand) lvchange_cmd = NULL;\n    g_autoptr(virCommand) lvremove_cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    virWaitForDevices();\n\n    lvchange_cmd = virCommandNewArgList(LVCHANGE, \"-aln\", vol->target.path, NULL);\n    lvremove_cmd = virCommandNewArgList(LVREMOVE, \"-f\", vol->target.path, NULL);\n\n    if (virCommandRun(lvremove_cmd, NULL) < 0) {\n        if (virCommandRun(lvchange_cmd, NULL) < 0) {\n            return -1;\n        } else {\n            if (virCommandRun(lvremove_cmd, NULL) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalDeletePool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "782-804",
    "snippet": "static int\nvirStorageBackendLogicalDeletePool(virStoragePoolObjPtr pool,\n                                   unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    size_t i;\n    g_autoptr(virCommand) cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    /* first remove the volume group */\n    cmd = virCommandNewArgList(VGREMOVE,\n                               \"-f\", def->source.name,\n                               NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* now remove the pv devices and clear them out */\n    for (i = 0; i < def->source.ndevice; i++)\n        virStorageBackendLogicalRemoveDevice(def->source.devices[i].path);\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendLogicalRemoveDevice",
          "args": [
            "def->source.devices[i].path"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalRemoveDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "70-78",
          "snippet": "static void\nvirStorageBackendLogicalRemoveDevice(const char *path)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PVREMOVE, path, NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_INFO(\"Failed to pvremove logical device '%s'\", path);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendLogicalRemoveDevice(const char *path)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PVREMOVE, path, NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_INFO(\"Failed to pvremove logical device '%s'\", path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "VGREMOVE",
            "\"-f\"",
            "def->source.name",
            "NULL"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalDeletePool(virStoragePoolObjPtr pool,\n                                   unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    size_t i;\n    g_autoptr(virCommand) cmd = NULL;\n\n    virCheckFlags(0, -1);\n\n    /* first remove the volume group */\n    cmd = virCommandNewArgList(VGREMOVE,\n                               \"-f\", def->source.name,\n                               NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    /* now remove the pv devices and clear them out */\n    for (i = 0; i < def->source.ndevice; i++)\n        virStorageBackendLogicalRemoveDevice(def->source.devices[i].path);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalStopPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "773-780",
    "snippet": "static int\nvirStorageBackendLogicalStopPool(virStoragePoolObjPtr pool)\n{\n    if (virStorageBackendLogicalSetActive(pool, false) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendLogicalSetActive",
          "args": [
            "pool",
            "false"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalSetActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "46-61",
          "snippet": "static int\nvirStorageBackendLogicalSetActive(virStoragePoolObjPtr pool,\n                                  bool on)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n    int ret;\n\n    cmd = virStorageBackendLogicalChangeCmd(VGCHANGE, def, on);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalSetActive(virStoragePoolObjPtr pool,\n                                  bool on)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n    int ret;\n\n    cmd = virStorageBackendLogicalChangeCmd(VGCHANGE, def, on);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalStopPool(virStoragePoolObjPtr pool)\n{\n    if (virStorageBackendLogicalSetActive(pool, false) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalRefreshPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "718-766",
    "snippet": "static int\nvirStorageBackendLogicalRefreshPool(virStoragePoolObjPtr pool)\n{\n    /*\n     *  # vgs --separator : --noheadings --units b --unbuffered --nosuffix --options \"vg_size,vg_free\" VGNAME\n     *    10603200512:4328521728\n     *\n     * Pull out size & free\n     *\n     * NB vgs from some distros (e.g. SLES10 SP2) outputs trailing \":\" on each line\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+):([0-9]+):?\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n\n    virWaitForDevices();\n\n    /* Get list of all logical volumes */\n    if (virStorageBackendLogicalFindLVs(pool, NULL) < 0)\n        return -1;\n\n    cmd = virCommandNewArgList(VGS,\n                               \"--separator\", \":\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\", \"vg_size,vg_free\",\n                               def->source.name,\n                               NULL);\n\n    /* Now get basic volgrp metadata */\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virStorageBackendLogicalRefreshPoolFunc,\n                           pool,\n                           \"vgs\",\n                           NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRunRegex",
          "args": [
            "cmd",
            "1",
            "regexes",
            "vars",
            "virStorageBackendLogicalRefreshPoolFunc",
            "pool",
            "\"vgs\"",
            "NULL"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunRegex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3341-3354",
          "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "VGS",
            "\"--separator\"",
            "\":\"",
            "\"--noheadings\"",
            "\"--units\"",
            "\"b\"",
            "\"--unbuffered\"",
            "\"--nosuffix\"",
            "\"--options\"",
            "\"vg_size,vg_free\"",
            "def->source.name",
            "NULL"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalFindLVs",
          "args": [
            "pool",
            "NULL"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalFindLVs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "353-408",
          "snippet": "static int\nvirStorageBackendLogicalFindLVs(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    /*\n     * # lvs --separator # --noheadings --units b --unbuffered --nosuffix --options \\\n     * \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\" VGNAME\n     *\n     * RootLV##06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky#/dev/hda2(0)#linear#1#5234491392#33554432#5234491392#-wi-ao\n     * SwapLV##oHviCK-8Ik0-paqS-V20c-nkhY-Bm1e-zgzU0M#/dev/hda2(156)#linear#1#1040187392#33554432#1040187392#-wi-ao\n     * Test2##3pg3he-mQsA-5Sui-h0i6-HNmc-Cz7W-QSndcR#/dev/hda2(219)#linear#1#1073741824#33554432#1073741824#owi-a-\n     * Test3##UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(251)#linear#1#2181038080#33554432#2181038080#-wi-a-\n     * Test3#Test2#UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(187)#linear#1#1040187392#33554432#1040187392#swi-a-\n     * test_stripes##fSLSZH-zAS2-yAIb-n4mV-Al9u-HA3V-oo9K1B#/dev/sdc1(10240),/dev/sdd1(0)#striped#2#42949672960#4194304#-wi-a-\n     *\n     * Pull out name, origin, & uuid, device, device extent start #,\n     * segment size, extent size, size, attrs\n     *\n     * NB can be multiple rows per volume if they have many extents\n     *\n     * NB lvs from some distros (e.g. SLES10 SP2) outputs trailing \",\"\n     * on each line\n     *\n     * NB Encrypted logical volumes can print ':' in their name, so it is\n     *    not a suitable separator (rhbz 470693).\n     *\n     * NB \"devices\" field has multiple device paths and \",\" if the volume is\n     *    striped, so \",\" is not a suitable separator either (rhbz 727474).\n     */\n    const char *regexes[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX\n    };\n    int vars[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendLogicalPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS,\n                               \"--separator\", \"#\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\",\n                               \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\",\n                               def->source.name,\n                               NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalMakeVol,\n                              &cbdata, \"lvs\", NULL);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_VOL_LOGICAL_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_PREFIX_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_NAME_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_ORIGIN_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_UUID_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_DEVICES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEGTYPE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_STRIPES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEG_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_VG_EXTENT_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_ATTR_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SUFFIX_REGEX",
            "#define VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_VOL_LOGICAL_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_PREFIX_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_NAME_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_ORIGIN_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_UUID_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_DEVICES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEGTYPE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_STRIPES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEG_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_VG_EXTENT_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_ATTR_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SUFFIX_REGEX\n#define VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT 10\n\nstatic int\nvirStorageBackendLogicalFindLVs(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    /*\n     * # lvs --separator # --noheadings --units b --unbuffered --nosuffix --options \\\n     * \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\" VGNAME\n     *\n     * RootLV##06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky#/dev/hda2(0)#linear#1#5234491392#33554432#5234491392#-wi-ao\n     * SwapLV##oHviCK-8Ik0-paqS-V20c-nkhY-Bm1e-zgzU0M#/dev/hda2(156)#linear#1#1040187392#33554432#1040187392#-wi-ao\n     * Test2##3pg3he-mQsA-5Sui-h0i6-HNmc-Cz7W-QSndcR#/dev/hda2(219)#linear#1#1073741824#33554432#1073741824#owi-a-\n     * Test3##UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(251)#linear#1#2181038080#33554432#2181038080#-wi-a-\n     * Test3#Test2#UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(187)#linear#1#1040187392#33554432#1040187392#swi-a-\n     * test_stripes##fSLSZH-zAS2-yAIb-n4mV-Al9u-HA3V-oo9K1B#/dev/sdc1(10240),/dev/sdd1(0)#striped#2#42949672960#4194304#-wi-a-\n     *\n     * Pull out name, origin, & uuid, device, device extent start #,\n     * segment size, extent size, size, attrs\n     *\n     * NB can be multiple rows per volume if they have many extents\n     *\n     * NB lvs from some distros (e.g. SLES10 SP2) outputs trailing \",\"\n     * on each line\n     *\n     * NB Encrypted logical volumes can print ':' in their name, so it is\n     *    not a suitable separator (rhbz 470693).\n     *\n     * NB \"devices\" field has multiple device paths and \",\" if the volume is\n     *    striped, so \",\" is not a suitable separator either (rhbz 727474).\n     */\n    const char *regexes[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX\n    };\n    int vars[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendLogicalPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS,\n                               \"--separator\", \"#\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\",\n                               \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\",\n                               def->source.name,\n                               NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalMakeVol,\n                              &cbdata, \"lvs\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virWaitForDevices",
          "args": [],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "virWaitForDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1324-1341",
          "snippet": "void virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virWaitForDevices(void)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *udev = NULL;\n    int exitstatus;\n\n    if (!(udev = virFindFileInPath(UDEVADM)))\n        return;\n\n    if (!(cmd = virCommandNewArgList(udev, \"settle\", NULL)))\n        return;\n\n    /*\n     * NOTE: we ignore errors here; this is just to make sure that any device\n     * nodes that are being created finish before we try to scan them.\n     */\n    ignore_value(virCommandRun(cmd, &exitstatus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalRefreshPool(virStoragePoolObjPtr pool)\n{\n    /*\n     *  # vgs --separator : --noheadings --units b --unbuffered --nosuffix --options \"vg_size,vg_free\" VGNAME\n     *    10603200512:4328521728\n     *\n     * Pull out size & free\n     *\n     * NB vgs from some distros (e.g. SLES10 SP2) outputs trailing \":\" on each line\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+):([0-9]+):?\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n\n    virWaitForDevices();\n\n    /* Get list of all logical volumes */\n    if (virStorageBackendLogicalFindLVs(pool, NULL) < 0)\n        return -1;\n\n    cmd = virCommandNewArgList(VGS,\n                               \"--separator\", \":\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\", \"vg_size,vg_free\",\n                               def->source.name,\n                               NULL);\n\n    /* Now get basic volgrp metadata */\n    if (virCommandRunRegex(cmd,\n                           1,\n                           regexes,\n                           vars,\n                           virStorageBackendLogicalRefreshPoolFunc,\n                           pool,\n                           \"vgs\",\n                           NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalBuildPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "666-715",
    "snippet": "static int\nvirStorageBackendLogicalBuildPool(virStoragePoolObjPtr pool,\n                                  unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int ret = -1;\n    size_t i = 0;\n    g_autoptr(virCommand) vgcmd = NULL;\n\n    virCheckFlags(VIR_STORAGE_POOL_BUILD_OVERWRITE |\n                  VIR_STORAGE_POOL_BUILD_NO_OVERWRITE, ret);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_STORAGE_POOL_BUILD_OVERWRITE,\n                             VIR_STORAGE_POOL_BUILD_NO_OVERWRITE,\n                             cleanup);\n\n    vgcmd = virCommandNewArgList(VGCREATE, def->source.name, NULL);\n\n    for (i = 0; i < def->source.ndevice; i++) {\n        const char *path = def->source.devices[i].path;\n\n        /* The blkid FS and Part probing code doesn't know \"lvm2\" (this\n         * pool's only format type), but it does know \"LVM2_member\", so\n         * we'll pass that here */\n        if (!(flags & VIR_STORAGE_POOL_BUILD_OVERWRITE) &&\n            !virStorageBackendDeviceIsEmpty(path, \"LVM2_member\", true))\n            goto cleanup;\n\n        if (virStorageBackendLogicalInitializeDevice(path) < 0)\n            goto cleanup;\n\n        virCommandAddArg(vgcmd, path);\n    }\n\n    virObjectUnlock(pool);\n    /* Now create the volume group itself */\n    ret = virCommandRun(vgcmd, NULL);\n    virObjectLock(pool);\n\n cleanup:\n    /* On any failure, run through the devices that had pvcreate run in\n     * in order to run pvremove on the device; otherwise, subsequent build\n     * will fail if a pvcreate had been run already. */\n    if (ret < 0) {\n        size_t j;\n        for (j = 0; j < i; j++)\n            virStorageBackendLogicalRemoveDevice(def->source.devices[j].path);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendLogicalRemoveDevice",
          "args": [
            "def->source.devices[j].path"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalRemoveDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "70-78",
          "snippet": "static void\nvirStorageBackendLogicalRemoveDevice(const char *path)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PVREMOVE, path, NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_INFO(\"Failed to pvremove logical device '%s'\", path);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendLogicalRemoveDevice(const char *path)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PVREMOVE, path, NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_INFO(\"Failed to pvremove logical device '%s'\", path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "pool"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "vgcmd",
            "NULL"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "pool"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "vgcmd",
            "path"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalInitializeDevice",
          "args": [
            "path"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalInitializeDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "88-107",
          "snippet": "static int\nvirStorageBackendLogicalInitializeDevice(const char *path)\n{\n    g_autoptr(virCommand) pvcmd = NULL;\n\n    /*\n     * LVM requires that the first sector is blanked if using\n     * a whole disk as a PV. So we just blank them out regardless\n     * rather than trying to figure out if we're a disk or partition\n     */\n    if (virStorageBackendZeroPartitionTable(path, 1024 * 1024) < 0)\n        return -1;\n\n    /*\n     * Initialize the physical volume because vgcreate is not\n     * clever enough todo this for us :-(\n     */\n    pvcmd = virCommandNewArgList(PVCREATE, path, NULL);\n    return virCommandRun(pvcmd, NULL);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalInitializeDevice(const char *path)\n{\n    g_autoptr(virCommand) pvcmd = NULL;\n\n    /*\n     * LVM requires that the first sector is blanked if using\n     * a whole disk as a PV. So we just blank them out regardless\n     * rather than trying to figure out if we're a disk or partition\n     */\n    if (virStorageBackendZeroPartitionTable(path, 1024 * 1024) < 0)\n        return -1;\n\n    /*\n     * Initialize the physical volume because vgcreate is not\n     * clever enough todo this for us :-(\n     */\n    pvcmd = virCommandNewArgList(PVCREATE, path, NULL);\n    return virCommandRun(pvcmd, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendDeviceIsEmpty",
          "args": [
            "path",
            "\"LVM2_member\"",
            "true"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendDeviceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "3304-3326",
          "snippet": "bool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirStorageBackendDeviceIsEmpty(const char *devpath,\n                               const char *format,\n                               bool writelabel)\n{\n    int ret;\n\n    if ((ret = virStorageBackendBLKIDFindEmpty(devpath, format,\n                                               writelabel)) == -2)\n        ret = virStorageBackendPARTEDValidLabel(devpath, format, writelabel);\n\n    if (ret == -2 && !writelabel)\n        ret = 0;\n\n    if (ret == -2) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Unable to probe '%s' for existing data, \"\n                         \"forced overwrite is necessary\"),\n                       devpath);\n    }\n\n    return ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "VGCREATE",
            "def->source.name",
            "NULL"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXCLUSIVE_FLAGS_GOTO",
          "args": [
            "VIR_STORAGE_POOL_BUILD_OVERWRITE",
            "VIR_STORAGE_POOL_BUILD_NO_OVERWRITE",
            "cleanup"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STORAGE_POOL_BUILD_OVERWRITE |\n                  VIR_STORAGE_POOL_BUILD_NO_OVERWRITE",
            "ret"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalBuildPool(virStoragePoolObjPtr pool,\n                                  unsigned int flags)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    int ret = -1;\n    size_t i = 0;\n    g_autoptr(virCommand) vgcmd = NULL;\n\n    virCheckFlags(VIR_STORAGE_POOL_BUILD_OVERWRITE |\n                  VIR_STORAGE_POOL_BUILD_NO_OVERWRITE, ret);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_STORAGE_POOL_BUILD_OVERWRITE,\n                             VIR_STORAGE_POOL_BUILD_NO_OVERWRITE,\n                             cleanup);\n\n    vgcmd = virCommandNewArgList(VGCREATE, def->source.name, NULL);\n\n    for (i = 0; i < def->source.ndevice; i++) {\n        const char *path = def->source.devices[i].path;\n\n        /* The blkid FS and Part probing code doesn't know \"lvm2\" (this\n         * pool's only format type), but it does know \"LVM2_member\", so\n         * we'll pass that here */\n        if (!(flags & VIR_STORAGE_POOL_BUILD_OVERWRITE) &&\n            !virStorageBackendDeviceIsEmpty(path, \"LVM2_member\", true))\n            goto cleanup;\n\n        if (virStorageBackendLogicalInitializeDevice(path) < 0)\n            goto cleanup;\n\n        virCommandAddArg(vgcmd, path);\n    }\n\n    virObjectUnlock(pool);\n    /* Now create the volume group itself */\n    ret = virCommandRun(vgcmd, NULL);\n    virObjectLock(pool);\n\n cleanup:\n    /* On any failure, run through the devices that had pvcreate run in\n     * in order to run pvremove on the device; otherwise, subsequent build\n     * will fail if a pvcreate had been run already. */\n    if (ret < 0) {\n        size_t j;\n        for (j = 0; j < i; j++)\n            virStorageBackendLogicalRemoveDevice(def->source.devices[j].path);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalStartPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "652-663",
    "snippet": "static int\nvirStorageBackendLogicalStartPool(virStoragePoolObjPtr pool)\n{\n    /* Let's make sure that the pool's name matches the pvs output and\n     * that the pool's source devices match the pvs output.\n     */\n    if (!virStorageBackendLogicalMatchPoolSource(pool) ||\n        virStorageBackendLogicalSetActive(pool, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendLogicalSetActive",
          "args": [
            "pool",
            "true"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalSetActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "46-61",
          "snippet": "static int\nvirStorageBackendLogicalSetActive(virStoragePoolObjPtr pool,\n                                  bool on)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n    int ret;\n\n    cmd = virStorageBackendLogicalChangeCmd(VGCHANGE, def, on);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalSetActive(virStoragePoolObjPtr pool,\n                                  bool on)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n    int ret;\n\n    cmd = virStorageBackendLogicalChangeCmd(VGCHANGE, def, on);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalMatchPoolSource",
          "args": [
            "pool"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalMatchPoolSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "559-635",
          "snippet": "static bool\nvirStorageBackendLogicalMatchPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceList sourceList;\n    virStoragePoolSource *thisSource = NULL;\n    size_t i, j;\n    int matchcount = 0;\n    bool ret = false;\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    /* Search the pvs output for this pool's source.name */\n    for (i = 0; i < sourceList.nsources; i++) {\n        thisSource = &sourceList.sources[i];\n        if (STREQ(thisSource->name, def->source.name))\n            break;\n    }\n\n    if (i == sourceList.nsources) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find logical volume group name '%s'\"),\n                       def->source.name);\n        goto cleanup;\n    }\n\n    /* If the pool has defined source device(s), then let's make sure\n     * they match as well; otherwise, matching can only occur on the\n     * pool's name.\n     */\n   if (!def->source.ndevice) {\n        ret = true;\n        goto cleanup;\n    }\n\n    /* Let's make sure the pool's device(s) match what the pvs output has\n     * for volume group devices.\n     */\n    for (i = 0; i < def->source.ndevice; i++) {\n        for (j = 0; j < thisSource->ndevice; j++) {\n            if (STREQ(def->source.devices[i].path,\n                      thisSource->devices[j].path))\n                matchcount++;\n        }\n    }\n\n    /* If we didn't find any matches, then this pool has listed (a) source\n     * device path(s) that don't/doesn't match what was created for the pool\n     */\n    if (matchcount == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\"), def->source.name);\n        goto cleanup;\n    }\n\n    /* Either there's more devices in the pool source device list or there's\n     * more devices in the pvs output. Could easily happen if someone decides\n     * to 'add' to or 'remove' from the volume group outside of libvirt's\n     * knowledge. Rather than fail on that, provide a warning and move on.\n     */\n    if (matchcount != def->source.ndevice)\n        VIR_WARN(\"pool device list count doesn't match pvs device list count\");\n\n    ret = true;\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return ret;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool\nvirStorageBackendLogicalMatchPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceList sourceList;\n    virStoragePoolSource *thisSource = NULL;\n    size_t i, j;\n    int matchcount = 0;\n    bool ret = false;\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    /* Search the pvs output for this pool's source.name */\n    for (i = 0; i < sourceList.nsources; i++) {\n        thisSource = &sourceList.sources[i];\n        if (STREQ(thisSource->name, def->source.name))\n            break;\n    }\n\n    if (i == sourceList.nsources) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find logical volume group name '%s'\"),\n                       def->source.name);\n        goto cleanup;\n    }\n\n    /* If the pool has defined source device(s), then let's make sure\n     * they match as well; otherwise, matching can only occur on the\n     * pool's name.\n     */\n   if (!def->source.ndevice) {\n        ret = true;\n        goto cleanup;\n    }\n\n    /* Let's make sure the pool's device(s) match what the pvs output has\n     * for volume group devices.\n     */\n    for (i = 0; i < def->source.ndevice; i++) {\n        for (j = 0; j < thisSource->ndevice; j++) {\n            if (STREQ(def->source.devices[i].path,\n                      thisSource->devices[j].path))\n                matchcount++;\n        }\n    }\n\n    /* If we didn't find any matches, then this pool has listed (a) source\n     * device path(s) that don't/doesn't match what was created for the pool\n     */\n    if (matchcount == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\"), def->source.name);\n        goto cleanup;\n    }\n\n    /* Either there's more devices in the pool source device list or there's\n     * more devices in the pvs output. Could easily happen if someone decides\n     * to 'add' to or 'remove' from the volume group outside of libvirt's\n     * knowledge. Rather than fail on that, provide a warning and move on.\n     */\n    if (matchcount != def->source.ndevice)\n        VIR_WARN(\"pool device list count doesn't match pvs device list count\");\n\n    ret = true;\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalStartPool(virStoragePoolObjPtr pool)\n{\n    /* Let's make sure that the pool's name matches the pvs output and\n     * that the pool's source devices match the pvs output.\n     */\n    if (!virStorageBackendLogicalMatchPoolSource(pool) ||\n        virStorageBackendLogicalSetActive(pool, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalCheckPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "638-650",
    "snippet": "static int\nvirStorageBackendLogicalCheckPool(virStoragePoolObjPtr pool,\n                                  bool *isActive)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    /* If we can find the target.path as well as ensure that the\n     * pool's def source\n     */\n    *isActive = virFileExists(def->target.path) &&\n                virStorageBackendLogicalMatchPoolSource(pool);\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendLogicalMatchPoolSource",
          "args": [
            "pool"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalMatchPoolSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "559-635",
          "snippet": "static bool\nvirStorageBackendLogicalMatchPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceList sourceList;\n    virStoragePoolSource *thisSource = NULL;\n    size_t i, j;\n    int matchcount = 0;\n    bool ret = false;\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    /* Search the pvs output for this pool's source.name */\n    for (i = 0; i < sourceList.nsources; i++) {\n        thisSource = &sourceList.sources[i];\n        if (STREQ(thisSource->name, def->source.name))\n            break;\n    }\n\n    if (i == sourceList.nsources) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find logical volume group name '%s'\"),\n                       def->source.name);\n        goto cleanup;\n    }\n\n    /* If the pool has defined source device(s), then let's make sure\n     * they match as well; otherwise, matching can only occur on the\n     * pool's name.\n     */\n   if (!def->source.ndevice) {\n        ret = true;\n        goto cleanup;\n    }\n\n    /* Let's make sure the pool's device(s) match what the pvs output has\n     * for volume group devices.\n     */\n    for (i = 0; i < def->source.ndevice; i++) {\n        for (j = 0; j < thisSource->ndevice; j++) {\n            if (STREQ(def->source.devices[i].path,\n                      thisSource->devices[j].path))\n                matchcount++;\n        }\n    }\n\n    /* If we didn't find any matches, then this pool has listed (a) source\n     * device path(s) that don't/doesn't match what was created for the pool\n     */\n    if (matchcount == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\"), def->source.name);\n        goto cleanup;\n    }\n\n    /* Either there's more devices in the pool source device list or there's\n     * more devices in the pvs output. Could easily happen if someone decides\n     * to 'add' to or 'remove' from the volume group outside of libvirt's\n     * knowledge. Rather than fail on that, provide a warning and move on.\n     */\n    if (matchcount != def->source.ndevice)\n        VIR_WARN(\"pool device list count doesn't match pvs device list count\");\n\n    ret = true;\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return ret;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool\nvirStorageBackendLogicalMatchPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceList sourceList;\n    virStoragePoolSource *thisSource = NULL;\n    size_t i, j;\n    int matchcount = 0;\n    bool ret = false;\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    /* Search the pvs output for this pool's source.name */\n    for (i = 0; i < sourceList.nsources; i++) {\n        thisSource = &sourceList.sources[i];\n        if (STREQ(thisSource->name, def->source.name))\n            break;\n    }\n\n    if (i == sourceList.nsources) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find logical volume group name '%s'\"),\n                       def->source.name);\n        goto cleanup;\n    }\n\n    /* If the pool has defined source device(s), then let's make sure\n     * they match as well; otherwise, matching can only occur on the\n     * pool's name.\n     */\n   if (!def->source.ndevice) {\n        ret = true;\n        goto cleanup;\n    }\n\n    /* Let's make sure the pool's device(s) match what the pvs output has\n     * for volume group devices.\n     */\n    for (i = 0; i < def->source.ndevice; i++) {\n        for (j = 0; j < thisSource->ndevice; j++) {\n            if (STREQ(def->source.devices[i].path,\n                      thisSource->devices[j].path))\n                matchcount++;\n        }\n    }\n\n    /* If we didn't find any matches, then this pool has listed (a) source\n     * device path(s) that don't/doesn't match what was created for the pool\n     */\n    if (matchcount == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\"), def->source.name);\n        goto cleanup;\n    }\n\n    /* Either there's more devices in the pool source device list or there's\n     * more devices in the pvs output. Could easily happen if someone decides\n     * to 'add' to or 'remove' from the volume group outside of libvirt's\n     * knowledge. Rather than fail on that, provide a warning and move on.\n     */\n    if (matchcount != def->source.ndevice)\n        VIR_WARN(\"pool device list count doesn't match pvs device list count\");\n\n    ret = true;\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "def->target.path"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalCheckPool(virStoragePoolObjPtr pool,\n                                  bool *isActive)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    /* If we can find the target.path as well as ensure that the\n     * pool's def source\n     */\n    *isActive = virFileExists(def->target.path) &&\n                virStorageBackendLogicalMatchPoolSource(pool);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalMatchPoolSource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "559-635",
    "snippet": "static bool\nvirStorageBackendLogicalMatchPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceList sourceList;\n    virStoragePoolSource *thisSource = NULL;\n    size_t i, j;\n    int matchcount = 0;\n    bool ret = false;\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    /* Search the pvs output for this pool's source.name */\n    for (i = 0; i < sourceList.nsources; i++) {\n        thisSource = &sourceList.sources[i];\n        if (STREQ(thisSource->name, def->source.name))\n            break;\n    }\n\n    if (i == sourceList.nsources) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find logical volume group name '%s'\"),\n                       def->source.name);\n        goto cleanup;\n    }\n\n    /* If the pool has defined source device(s), then let's make sure\n     * they match as well; otherwise, matching can only occur on the\n     * pool's name.\n     */\n   if (!def->source.ndevice) {\n        ret = true;\n        goto cleanup;\n    }\n\n    /* Let's make sure the pool's device(s) match what the pvs output has\n     * for volume group devices.\n     */\n    for (i = 0; i < def->source.ndevice; i++) {\n        for (j = 0; j < thisSource->ndevice; j++) {\n            if (STREQ(def->source.devices[i].path,\n                      thisSource->devices[j].path))\n                matchcount++;\n        }\n    }\n\n    /* If we didn't find any matches, then this pool has listed (a) source\n     * device path(s) that don't/doesn't match what was created for the pool\n     */\n    if (matchcount == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\"), def->source.name);\n        goto cleanup;\n    }\n\n    /* Either there's more devices in the pool source device list or there's\n     * more devices in the pvs output. Could easily happen if someone decides\n     * to 'add' to or 'remove' from the volume group outside of libvirt's\n     * knowledge. Rather than fail on that, provide a warning and move on.\n     */\n    if (matchcount != def->source.ndevice)\n        VIR_WARN(\"pool device list count doesn't match pvs device list count\");\n\n    ret = true;\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sourceList.sources"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceClear",
          "args": [
            "&sourceList.sources[i]"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "471-493",
          "snippet": "void\nvirStoragePoolSourceClear(virStoragePoolSourcePtr source)\n{\n    size_t i;\n\n    if (!source)\n        return;\n\n    for (i = 0; i < source->nhost; i++)\n        VIR_FREE(source->hosts[i].name);\n    VIR_FREE(source->hosts);\n\n    for (i = 0; i < source->ndevice; i++)\n        virStoragePoolSourceDeviceClear(&source->devices[i]);\n    VIR_FREE(source->devices);\n    VIR_FREE(source->dir);\n    VIR_FREE(source->name);\n    virStorageAdapterClear(&source->adapter);\n    virStorageSourceInitiatorClear(&source->initiator);\n    virStorageAuthDefFree(source->auth);\n    VIR_FREE(source->vendor);\n    VIR_FREE(source->product);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirStoragePoolSourceClear(virStoragePoolSourcePtr source)\n{\n    size_t i;\n\n    if (!source)\n        return;\n\n    for (i = 0; i < source->nhost; i++)\n        VIR_FREE(source->hosts[i].name);\n    VIR_FREE(source->hosts);\n\n    for (i = 0; i < source->ndevice; i++)\n        virStoragePoolSourceDeviceClear(&source->devices[i]);\n    VIR_FREE(source->devices);\n    VIR_FREE(source->dir);\n    VIR_FREE(source->name);\n    virStorageAdapterClear(&source->adapter);\n    virStorageSourceInitiatorClear(&source->initiator);\n    virStorageAuthDefFree(source->auth);\n    VIR_FREE(source->vendor);\n    VIR_FREE(source->product);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"pool device list count doesn't match pvs device list count\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\")",
            "def->source.name"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\""
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->source.devices[i].path",
            "thisSource->devices[j].path"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"cannot find logical volume group name '%s'\")",
            "def->source.name"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "thisSource->name",
            "def->source.name"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalGetPoolSources",
          "args": [
            "&sourceList"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalGetPoolSources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "477-510",
          "snippet": "static int\nvirStorageBackendLogicalGetPoolSources(virStoragePoolSourceListPtr sourceList)\n{\n    /*\n     * # pvs --noheadings -o pv_name,vg_name\n     *   /dev/sdb\n     *   /dev/sdc VolGroup00\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    /*\n     * NOTE: ignoring errors here; this is just to \"touch\" any logical volumes\n     * that might be hanging around, so if this fails for some reason, the\n     * worst that happens is that scanning doesn't pick everything up\n     */\n    cmd = virCommandNew(VGSCAN);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_WARN(\"Failure when running vgscan to refresh physical volumes\");\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(PVS,\n                               \"--noheadings\",\n                               \"-o\", \"pv_name,vg_name\",\n                               NULL, NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalFindPoolSourcesFunc,\n                              sourceList, \"pvs\", NULL);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalGetPoolSources(virStoragePoolSourceListPtr sourceList)\n{\n    /*\n     * # pvs --noheadings -o pv_name,vg_name\n     *   /dev/sdb\n     *   /dev/sdc VolGroup00\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    /*\n     * NOTE: ignoring errors here; this is just to \"touch\" any logical volumes\n     * that might be hanging around, so if this fails for some reason, the\n     * worst that happens is that scanning doesn't pick everything up\n     */\n    cmd = virCommandNew(VGSCAN);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_WARN(\"Failure when running vgscan to refresh physical volumes\");\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(PVS,\n                               \"--noheadings\",\n                               \"-o\", \"pv_name,vg_name\",\n                               NULL, NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalFindPoolSourcesFunc,\n                              sourceList, \"pvs\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sourceList",
            "0",
            "sizeof(sourceList)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool\nvirStorageBackendLogicalMatchPoolSource(virStoragePoolObjPtr pool)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStoragePoolSourceList sourceList;\n    virStoragePoolSource *thisSource = NULL;\n    size_t i, j;\n    int matchcount = 0;\n    bool ret = false;\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    /* Search the pvs output for this pool's source.name */\n    for (i = 0; i < sourceList.nsources; i++) {\n        thisSource = &sourceList.sources[i];\n        if (STREQ(thisSource->name, def->source.name))\n            break;\n    }\n\n    if (i == sourceList.nsources) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find logical volume group name '%s'\"),\n                       def->source.name);\n        goto cleanup;\n    }\n\n    /* If the pool has defined source device(s), then let's make sure\n     * they match as well; otherwise, matching can only occur on the\n     * pool's name.\n     */\n   if (!def->source.ndevice) {\n        ret = true;\n        goto cleanup;\n    }\n\n    /* Let's make sure the pool's device(s) match what the pvs output has\n     * for volume group devices.\n     */\n    for (i = 0; i < def->source.ndevice; i++) {\n        for (j = 0; j < thisSource->ndevice; j++) {\n            if (STREQ(def->source.devices[i].path,\n                      thisSource->devices[j].path))\n                matchcount++;\n        }\n    }\n\n    /* If we didn't find any matches, then this pool has listed (a) source\n     * device path(s) that don't/doesn't match what was created for the pool\n     */\n    if (matchcount == 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"cannot find any matching source devices for logical \"\n                         \"volume group '%s'\"), def->source.name);\n        goto cleanup;\n    }\n\n    /* Either there's more devices in the pool source device list or there's\n     * more devices in the pvs output. Could easily happen if someone decides\n     * to 'add' to or 'remove' from the volume group outside of libvirt's\n     * knowledge. Rather than fail on that, provide a warning and move on.\n     */\n    if (matchcount != def->source.ndevice)\n        VIR_WARN(\"pool device list count doesn't match pvs device list count\");\n\n    ret = true;\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalFindPoolSources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "513-542",
    "snippet": "static char *\nvirStorageBackendLogicalFindPoolSources(const char *srcSpec G_GNUC_UNUSED,\n                                        unsigned int flags)\n{\n    virStoragePoolSourceList sourceList;\n    size_t i;\n    char *retval = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    retval = virStoragePoolSourceListFormat(&sourceList);\n    if (retval == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to get source from sourceList\"));\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return retval;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sourceList.sources"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceClear",
          "args": [
            "&sourceList.sources[i]"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "471-493",
          "snippet": "void\nvirStoragePoolSourceClear(virStoragePoolSourcePtr source)\n{\n    size_t i;\n\n    if (!source)\n        return;\n\n    for (i = 0; i < source->nhost; i++)\n        VIR_FREE(source->hosts[i].name);\n    VIR_FREE(source->hosts);\n\n    for (i = 0; i < source->ndevice; i++)\n        virStoragePoolSourceDeviceClear(&source->devices[i]);\n    VIR_FREE(source->devices);\n    VIR_FREE(source->dir);\n    VIR_FREE(source->name);\n    virStorageAdapterClear(&source->adapter);\n    virStorageSourceInitiatorClear(&source->initiator);\n    virStorageAuthDefFree(source->auth);\n    VIR_FREE(source->vendor);\n    VIR_FREE(source->product);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirStoragePoolSourceClear(virStoragePoolSourcePtr source)\n{\n    size_t i;\n\n    if (!source)\n        return;\n\n    for (i = 0; i < source->nhost; i++)\n        VIR_FREE(source->hosts[i].name);\n    VIR_FREE(source->hosts);\n\n    for (i = 0; i < source->ndevice; i++)\n        virStoragePoolSourceDeviceClear(&source->devices[i]);\n    VIR_FREE(source->devices);\n    VIR_FREE(source->dir);\n    VIR_FREE(source->name);\n    virStorageAdapterClear(&source->adapter);\n    virStorageSourceInitiatorClear(&source->initiator);\n    virStorageAuthDefFree(source->auth);\n    VIR_FREE(source->vendor);\n    VIR_FREE(source->product);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to get source from sourceList\")"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to get source from sourceList\""
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceListFormat",
          "args": [
            "&sourceList"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceListFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1744-1777",
          "snippet": "char *\nvirStoragePoolSourceListFormat(virStoragePoolSourceListPtr def)\n{\n    virStoragePoolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *type;\n    size_t i;\n\n    options = virStoragePoolOptionsForPoolType(def->type);\n    if (options == NULL)\n        return NULL;\n\n    type = virStoragePoolTypeToString(def->type);\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unexpected pool type\"));\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<sources>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    for (i = 0; i < def->nsources; i++)\n        virStoragePoolSourceFormat(&buf, options, &def->sources[i]);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</sources>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStoragePoolSourceListFormat(virStoragePoolSourceListPtr def)\n{\n    virStoragePoolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *type;\n    size_t i;\n\n    options = virStoragePoolOptionsForPoolType(def->type);\n    if (options == NULL)\n        return NULL;\n\n    type = virStoragePoolTypeToString(def->type);\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unexpected pool type\"));\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<sources>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    for (i = 0; i < def->nsources; i++)\n        virStoragePoolSourceFormat(&buf, options, &def->sources[i]);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</sources>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalGetPoolSources",
          "args": [
            "&sourceList"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalGetPoolSources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "477-510",
          "snippet": "static int\nvirStorageBackendLogicalGetPoolSources(virStoragePoolSourceListPtr sourceList)\n{\n    /*\n     * # pvs --noheadings -o pv_name,vg_name\n     *   /dev/sdb\n     *   /dev/sdc VolGroup00\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    /*\n     * NOTE: ignoring errors here; this is just to \"touch\" any logical volumes\n     * that might be hanging around, so if this fails for some reason, the\n     * worst that happens is that scanning doesn't pick everything up\n     */\n    cmd = virCommandNew(VGSCAN);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_WARN(\"Failure when running vgscan to refresh physical volumes\");\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(PVS,\n                               \"--noheadings\",\n                               \"-o\", \"pv_name,vg_name\",\n                               NULL, NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalFindPoolSourcesFunc,\n                              sourceList, \"pvs\", NULL);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalGetPoolSources(virStoragePoolSourceListPtr sourceList)\n{\n    /*\n     * # pvs --noheadings -o pv_name,vg_name\n     *   /dev/sdb\n     *   /dev/sdc VolGroup00\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    /*\n     * NOTE: ignoring errors here; this is just to \"touch\" any logical volumes\n     * that might be hanging around, so if this fails for some reason, the\n     * worst that happens is that scanning doesn't pick everything up\n     */\n    cmd = virCommandNew(VGSCAN);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_WARN(\"Failure when running vgscan to refresh physical volumes\");\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(PVS,\n                               \"--noheadings\",\n                               \"-o\", \"pv_name,vg_name\",\n                               NULL, NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalFindPoolSourcesFunc,\n                              sourceList, \"pvs\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sourceList",
            "0",
            "sizeof(sourceList)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic char *\nvirStorageBackendLogicalFindPoolSources(const char *srcSpec G_GNUC_UNUSED,\n                                        unsigned int flags)\n{\n    virStoragePoolSourceList sourceList;\n    size_t i;\n    char *retval = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&sourceList, 0, sizeof(sourceList));\n    sourceList.type = VIR_STORAGE_POOL_LOGICAL;\n\n    if (virStorageBackendLogicalGetPoolSources(&sourceList) < 0)\n        goto cleanup;\n\n    retval = virStoragePoolSourceListFormat(&sourceList);\n    if (retval == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to get source from sourceList\"));\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < sourceList.nsources; i++)\n        virStoragePoolSourceClear(&sourceList.sources[i]);\n    VIR_FREE(sourceList.sources);\n\n    return retval;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalGetPoolSources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "477-510",
    "snippet": "static int\nvirStorageBackendLogicalGetPoolSources(virStoragePoolSourceListPtr sourceList)\n{\n    /*\n     * # pvs --noheadings -o pv_name,vg_name\n     *   /dev/sdb\n     *   /dev/sdc VolGroup00\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    /*\n     * NOTE: ignoring errors here; this is just to \"touch\" any logical volumes\n     * that might be hanging around, so if this fails for some reason, the\n     * worst that happens is that scanning doesn't pick everything up\n     */\n    cmd = virCommandNew(VGSCAN);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_WARN(\"Failure when running vgscan to refresh physical volumes\");\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(PVS,\n                               \"--noheadings\",\n                               \"-o\", \"pv_name,vg_name\",\n                               NULL, NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalFindPoolSourcesFunc,\n                              sourceList, \"pvs\", NULL);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRunRegex",
          "args": [
            "cmd",
            "1",
            "regexes",
            "vars",
            "virStorageBackendLogicalFindPoolSourcesFunc",
            "sourceList",
            "\"pvs\"",
            "NULL"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunRegex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3341-3354",
          "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "PVS",
            "\"--noheadings\"",
            "\"-o\"",
            "\"pv_name,vg_name\"",
            "NULL",
            "NULL"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failure when running vgscan to refresh physical volumes\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalGetPoolSources(virStoragePoolSourceListPtr sourceList)\n{\n    /*\n     * # pvs --noheadings -o pv_name,vg_name\n     *   /dev/sdb\n     *   /dev/sdc VolGroup00\n     */\n    const char *regexes[] = {\n        \"^\\\\s*(\\\\S+)\\\\s+(\\\\S+)\\\\s*$\"\n    };\n    int vars[] = {\n        2\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    /*\n     * NOTE: ignoring errors here; this is just to \"touch\" any logical volumes\n     * that might be hanging around, so if this fails for some reason, the\n     * worst that happens is that scanning doesn't pick everything up\n     */\n    cmd = virCommandNew(VGSCAN);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_WARN(\"Failure when running vgscan to refresh physical volumes\");\n    virCommandFree(cmd);\n\n    cmd = virCommandNewArgList(PVS,\n                               \"--noheadings\",\n                               \"-o\", \"pv_name,vg_name\",\n                               NULL, NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalFindPoolSourcesFunc,\n                              sourceList, \"pvs\", NULL);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalFindPoolSourcesFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "427-467",
    "snippet": "static int\nvirStorageBackendLogicalFindPoolSourcesFunc(char **const groups,\n                                            void *data)\n{\n    virStoragePoolSourceListPtr sourceList = data;\n    size_t i;\n    virStoragePoolSourceDevicePtr dev;\n    virStoragePoolSource *thisSource;\n    g_autofree char *pvname = NULL;\n    g_autofree char *vgname = NULL;\n\n    pvname = g_strdup(groups[0]);\n    vgname = g_strdup(groups[1]);\n\n    thisSource = NULL;\n    for (i = 0; i < sourceList->nsources; i++) {\n        if (STREQ(sourceList->sources[i].name, vgname)) {\n            thisSource = &sourceList->sources[i];\n            break;\n        }\n    }\n\n    if (thisSource == NULL) {\n        if (!(thisSource = virStoragePoolSourceListNewSource(sourceList)))\n            return -1;\n\n        thisSource->name = g_steal_pointer(&vgname);\n    }\n\n    if (VIR_REALLOC_N(thisSource->devices, thisSource->ndevice + 1) != 0)\n        return -1;\n\n    dev = &thisSource->devices[thisSource->ndevice];\n    thisSource->ndevice++;\n    thisSource->format = VIR_STORAGE_POOL_LOGICAL_LVM2;\n\n    memset(dev, 0, sizeof(*dev));\n    dev->path = g_steal_pointer(&pvname);\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&pvname"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dev",
            "0",
            "sizeof(*dev)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "thisSource->devices",
            "thisSource->ndevice + 1"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&vgname"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceListNewSource",
          "args": [
            "sourceList"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceListNewSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1729-1741",
          "snippet": "virStoragePoolSourcePtr\nvirStoragePoolSourceListNewSource(virStoragePoolSourceListPtr list)\n{\n    virStoragePoolSourcePtr source;\n\n    if (VIR_REALLOC_N(list->sources, list->nsources + 1) < 0)\n        return NULL;\n\n    source = &list->sources[list->nsources++];\n    memset(source, 0, sizeof(*source));\n\n    return source;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStoragePoolSourcePtr\nvirStoragePoolSourceListNewSource(virStoragePoolSourceListPtr list)\n{\n    virStoragePoolSourcePtr source;\n\n    if (VIR_REALLOC_N(list->sources, list->nsources + 1) < 0)\n        return NULL;\n\n    source = &list->sources[list->nsources++];\n    memset(source, 0, sizeof(*source));\n\n    return source;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "sourceList->sources[i].name",
            "vgname"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "groups[1]"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalFindPoolSourcesFunc(char **const groups,\n                                            void *data)\n{\n    virStoragePoolSourceListPtr sourceList = data;\n    size_t i;\n    virStoragePoolSourceDevicePtr dev;\n    virStoragePoolSource *thisSource;\n    g_autofree char *pvname = NULL;\n    g_autofree char *vgname = NULL;\n\n    pvname = g_strdup(groups[0]);\n    vgname = g_strdup(groups[1]);\n\n    thisSource = NULL;\n    for (i = 0; i < sourceList->nsources; i++) {\n        if (STREQ(sourceList->sources[i].name, vgname)) {\n            thisSource = &sourceList->sources[i];\n            break;\n        }\n    }\n\n    if (thisSource == NULL) {\n        if (!(thisSource = virStoragePoolSourceListNewSource(sourceList)))\n            return -1;\n\n        thisSource->name = g_steal_pointer(&vgname);\n    }\n\n    if (VIR_REALLOC_N(thisSource->devices, thisSource->ndevice + 1) != 0)\n        return -1;\n\n    dev = &thisSource->devices[thisSource->ndevice];\n    thisSource->ndevice++;\n    thisSource->format = VIR_STORAGE_POOL_LOGICAL_LVM2;\n\n    memset(dev, 0, sizeof(*dev));\n    dev->path = g_steal_pointer(&pvname);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalRefreshPoolFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "410-424",
    "snippet": "static int\nvirStorageBackendLogicalRefreshPoolFunc(char **const groups,\n                                        void *data)\n{\n    virStoragePoolObjPtr pool = data;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (virStrToLong_ull(groups[0], NULL, 10, &def->capacity) < 0)\n        return -1;\n    if (virStrToLong_ull(groups[1], NULL, 10, &def->available) < 0)\n        return -1;\n    def->allocation = def->capacity - def->available;\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "groups[1]",
            "NULL",
            "10",
            "&def->available"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalRefreshPoolFunc(char **const groups,\n                                        void *data)\n{\n    virStoragePoolObjPtr pool = data;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    if (virStrToLong_ull(groups[0], NULL, 10, &def->capacity) < 0)\n        return -1;\n    if (virStrToLong_ull(groups[1], NULL, 10, &def->available) < 0)\n        return -1;\n    def->allocation = def->capacity - def->available;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalFindLVs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "353-408",
    "snippet": "static int\nvirStorageBackendLogicalFindLVs(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    /*\n     * # lvs --separator # --noheadings --units b --unbuffered --nosuffix --options \\\n     * \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\" VGNAME\n     *\n     * RootLV##06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky#/dev/hda2(0)#linear#1#5234491392#33554432#5234491392#-wi-ao\n     * SwapLV##oHviCK-8Ik0-paqS-V20c-nkhY-Bm1e-zgzU0M#/dev/hda2(156)#linear#1#1040187392#33554432#1040187392#-wi-ao\n     * Test2##3pg3he-mQsA-5Sui-h0i6-HNmc-Cz7W-QSndcR#/dev/hda2(219)#linear#1#1073741824#33554432#1073741824#owi-a-\n     * Test3##UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(251)#linear#1#2181038080#33554432#2181038080#-wi-a-\n     * Test3#Test2#UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(187)#linear#1#1040187392#33554432#1040187392#swi-a-\n     * test_stripes##fSLSZH-zAS2-yAIb-n4mV-Al9u-HA3V-oo9K1B#/dev/sdc1(10240),/dev/sdd1(0)#striped#2#42949672960#4194304#-wi-a-\n     *\n     * Pull out name, origin, & uuid, device, device extent start #,\n     * segment size, extent size, size, attrs\n     *\n     * NB can be multiple rows per volume if they have many extents\n     *\n     * NB lvs from some distros (e.g. SLES10 SP2) outputs trailing \",\"\n     * on each line\n     *\n     * NB Encrypted logical volumes can print ':' in their name, so it is\n     *    not a suitable separator (rhbz 470693).\n     *\n     * NB \"devices\" field has multiple device paths and \",\" if the volume is\n     *    striped, so \",\" is not a suitable separator either (rhbz 727474).\n     */\n    const char *regexes[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX\n    };\n    int vars[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendLogicalPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS,\n                               \"--separator\", \"#\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\",\n                               \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\",\n                               def->source.name,\n                               NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalMakeVol,\n                              &cbdata, \"lvs\", NULL);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_STORAGE_VOL_LOGICAL_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_PREFIX_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_NAME_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_ORIGIN_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_UUID_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_DEVICES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEGTYPE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_STRIPES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEG_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_VG_EXTENT_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_ATTR_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SUFFIX_REGEX",
      "#define VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRunRegex",
          "args": [
            "cmd",
            "1",
            "regexes",
            "vars",
            "virStorageBackendLogicalMakeVol",
            "&cbdata",
            "\"lvs\"",
            "NULL"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunRegex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3341-3354",
          "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "LVS",
            "\"--separator\"",
            "\"#\"",
            "\"--noheadings\"",
            "\"--units\"",
            "\"b\"",
            "\"--unbuffered\"",
            "\"--nosuffix\"",
            "\"--options\"",
            "\"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\"",
            "def->source.name",
            "NULL"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_VOL_LOGICAL_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_PREFIX_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_NAME_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_ORIGIN_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_UUID_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_DEVICES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEGTYPE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_STRIPES_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SEG_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_VG_EXTENT_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SIZE_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_LV_ATTR_REGEX \\\n           VIR_STORAGE_VOL_LOGICAL_SUFFIX_REGEX\n#define VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT 10\n\nstatic int\nvirStorageBackendLogicalFindLVs(virStoragePoolObjPtr pool,\n                                virStorageVolDefPtr vol)\n{\n    /*\n     * # lvs --separator # --noheadings --units b --unbuffered --nosuffix --options \\\n     * \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\" VGNAME\n     *\n     * RootLV##06UgP5-2rhb-w3Bo-3mdR-WeoL-pytO-SAa2ky#/dev/hda2(0)#linear#1#5234491392#33554432#5234491392#-wi-ao\n     * SwapLV##oHviCK-8Ik0-paqS-V20c-nkhY-Bm1e-zgzU0M#/dev/hda2(156)#linear#1#1040187392#33554432#1040187392#-wi-ao\n     * Test2##3pg3he-mQsA-5Sui-h0i6-HNmc-Cz7W-QSndcR#/dev/hda2(219)#linear#1#1073741824#33554432#1073741824#owi-a-\n     * Test3##UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(251)#linear#1#2181038080#33554432#2181038080#-wi-a-\n     * Test3#Test2#UB5hFw-kmlm-LSoX-EI1t-ioVd-h7GL-M0W8Ht#/dev/hda2(187)#linear#1#1040187392#33554432#1040187392#swi-a-\n     * test_stripes##fSLSZH-zAS2-yAIb-n4mV-Al9u-HA3V-oo9K1B#/dev/sdc1(10240),/dev/sdd1(0)#striped#2#42949672960#4194304#-wi-a-\n     *\n     * Pull out name, origin, & uuid, device, device extent start #,\n     * segment size, extent size, size, attrs\n     *\n     * NB can be multiple rows per volume if they have many extents\n     *\n     * NB lvs from some distros (e.g. SLES10 SP2) outputs trailing \",\"\n     * on each line\n     *\n     * NB Encrypted logical volumes can print ':' in their name, so it is\n     *    not a suitable separator (rhbz 470693).\n     *\n     * NB \"devices\" field has multiple device paths and \",\" if the volume is\n     *    striped, so \",\" is not a suitable separator either (rhbz 727474).\n     */\n    const char *regexes[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX\n    };\n    int vars[] = {\n        VIR_STORAGE_VOL_LOGICAL_REGEX_COUNT\n    };\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct virStorageBackendLogicalPoolVolData cbdata = {\n        .pool = pool,\n        .vol = vol,\n    };\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(LVS,\n                               \"--separator\", \"#\",\n                               \"--noheadings\",\n                               \"--units\", \"b\",\n                               \"--unbuffered\",\n                               \"--nosuffix\",\n                               \"--options\",\n                               \"lv_name,origin,uuid,devices,segtype,stripes,seg_size,vg_extent_size,size,lv_attr\",\n                               def->source.name,\n                               NULL);\n    return virCommandRunRegex(cmd, 1, regexes, vars,\n                              virStorageBackendLogicalMakeVol,\n                              &cbdata, \"lvs\", NULL);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalMakeVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "220-323",
    "snippet": "static int\nvirStorageBackendLogicalMakeVol(char **const groups,\n                                void *opaque)\n{\n    struct virStorageBackendLogicalPoolVolData *data = opaque;\n    virStoragePoolObjPtr pool = data->pool;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStorageVolDefPtr vol = NULL;\n    bool is_new_vol = false;\n    int ret = -1;\n    const char *attrs = groups[9];\n\n    /* Skip inactive volume */\n    if (attrs[4] != 'a')\n        return 0;\n\n    /*\n     * Skip thin pools(t). These show up in normal lvs output\n     * but do not have a corresponding /dev/$vg/$lv device that\n     * is created by udev. This breaks assumptions in later code.\n     */\n    if (attrs[0] == 't')\n        return 0;\n\n    /* See if we're only looking for a specific volume */\n    if (data->vol != NULL) {\n        vol = data->vol;\n        if (STRNEQ(vol->name, groups[0]))\n            return 0;\n    }\n\n    /* Or filling in more data on an existing volume */\n    if (vol == NULL)\n        vol = virStorageVolDefFindByName(pool, groups[0]);\n\n    /* Or a completely new volume */\n    if (vol == NULL) {\n        if (VIR_ALLOC(vol) < 0)\n            return -1;\n\n        is_new_vol = true;\n        vol->type = VIR_STORAGE_VOL_BLOCK;\n\n        vol->name = g_strdup(groups[0]);\n\n    }\n\n    if (vol->target.path == NULL)\n        vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n    /* Mark the (s) sparse/snapshot lv, e.g. the lv created using\n     * the --virtualsize/-V option. We've already ignored the (t)hin\n     * pool definition. In the manner libvirt defines these, the\n     * thin pool is hidden to the lvs output, except as the name\n     * in brackets [] described for the groups[1] (backingStore).\n     */\n    if (attrs[0] == 's')\n        vol->target.sparse = true;\n\n    /* Skips the backingStore of lv created with \"--virtualsize\",\n     * its original device \"/dev/$vgname/$lvname_vorigin\" is\n     * just for lvm internal use, one should never use it.\n     *\n     * (lvs outputs \"[$lvname_vorigin] for field \"origin\" if the\n     *  lv is created with \"--virtualsize\").\n     */\n    if (groups[1] && STRNEQ(groups[1], \"\") && (groups[1][0] != '[')) {\n        if (!(vol->target.backingStore = virStorageSourceNew()))\n            goto cleanup;\n\n        vol->target.backingStore->path = g_strdup_printf(\"%s/%s\",\n                                                         def->target.path, groups[1]);\n\n        vol->target.backingStore->format = VIR_STORAGE_POOL_LOGICAL_LVM2;\n        vol->target.backingStore->type = VIR_STORAGE_TYPE_BLOCK;\n    }\n\n    if (!vol->key)\n        vol->key = g_strdup(groups[2]);\n\n    if (virStorageBackendUpdateVolInfo(vol, false,\n                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0) < 0)\n        goto cleanup;\n\n    if (virStrToLong_ull(groups[8], NULL, 10, &vol->target.allocation) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume allocation value\"));\n        goto cleanup;\n    }\n\n    if (virStorageBackendLogicalParseVolExtents(vol, groups) < 0)\n        goto cleanup;\n\n    if (is_new_vol && virStoragePoolObjAddVol(pool, vol) < 0)\n        goto cleanup;\n    vol = NULL;\n\n    ret = 0;\n\n cleanup:\n    if (is_new_vol)\n        virStorageVolDefFree(vol);\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageVolDefFree",
          "args": [
            "vol"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "443-460",
          "snippet": "void\nvirStorageVolDefFree(virStorageVolDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->key);\n\n    for (i = 0; i < def->source.nextent; i++)\n        VIR_FREE(def->source.extents[i].path);\n    VIR_FREE(def->source.extents);\n\n    virStorageSourceClear(&def->target);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirStorageVolDefFree(virStorageVolDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->key);\n\n    for (i = 0; i < def->source.nextent; i++)\n        VIR_FREE(def->source.extents[i].path);\n    VIR_FREE(def->source.extents);\n\n    virStorageSourceClear(&def->target);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjAddVol",
          "args": [
            "pool",
            "vol"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjAddVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "641-679",
          "snippet": "int\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalParseVolExtents",
          "args": [
            "vol",
            "groups"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalParseVolExtents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
          "lines": "119-217",
          "snippet": "static int\nvirStorageBackendLogicalParseVolExtents(virStorageVolDefPtr vol,\n                                        char **const groups)\n{\n    g_autoptr(GRegex) re = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    int nextents, ret = -1;\n    const char *regex_unit = \"(\\\\S+)\\\\((\\\\S+)\\\\)\";\n    size_t i;\n    unsigned long long offset, size, length;\n    virStorageVolSourceExtent extent;\n    g_autofree char *regex = NULL;\n\n    memset(&extent, 0, sizeof(extent));\n\n    /* Assume 1 extent (the regex for 'devices' is \"(\\\\S+)\") and only\n     * check the 'stripes' field if we have a striped, mirror, or one of\n     * the raid (raid1, raid4, raid5*, raid6*, or raid10) segtypes in which\n     * case the stripes field will denote the number of lv's within the\n     * 'devices' field in order to generate the proper regex to decode\n     * the field\n     */\n    nextents = 1;\n    if (STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED) ||\n        STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR) ||\n        STRPREFIX(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID)) {\n        if (virStrToLong_i(groups[5], NULL, 10, &nextents) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent stripes value\"));\n            goto cleanup;\n        }\n    }\n\n    if (virStrToLong_ull(groups[6], NULL, 10, &length) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent length value\"));\n        goto cleanup;\n    }\n\n    if (virStrToLong_ull(groups[7], NULL, 10, &size) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent size value\"));\n        goto cleanup;\n    }\n\n    /* Allocate space for 'nextents' regex_unit strings plus a comma for each */\n    if (VIR_ALLOC_N(regex, nextents * (strlen(regex_unit) + 1) + 1) < 0)\n        goto cleanup;\n    strcat(regex, regex_unit);\n    for (i = 1; i < nextents; i++) {\n        /* \",\" is the separator of \"devices\" field */\n        strcat(regex, \",\");\n        strcat(regex, regex_unit);\n    }\n\n    re = g_regex_new(regex, 0, 0, &err);\n    if (!re) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(re, groups[3], 0, &info)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"malformed volume extent devices value\"));\n        goto cleanup;\n    }\n\n    /* Each extent has a \"path:offset\" pair, and match #0\n     * is the whole matched string.\n     */\n    for (i = 0; i < nextents; i++) {\n        size_t j;\n        g_autofree char *offset_str = NULL;\n\n        j = (i * 2) + 1;\n        extent.path = g_match_info_fetch(info, j);\n        offset_str = g_match_info_fetch(info, j + 1);\n\n        if (virStrToLong_ull(offset_str, NULL, 10, &offset) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent offset value\"));\n            goto cleanup;\n        }\n        extent.start = offset * size;\n        extent.end = (offset * size) + length;\n\n        if (VIR_APPEND_ELEMENT(vol->source.extents, vol->source.nextent,\n                               extent) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(extent.path);\n    return ret;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_logical.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID    \"raid\"",
            "#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR  \"mirror\"",
            "#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED \"striped\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID    \"raid\"\n#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR  \"mirror\"\n#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED \"striped\"\n\nstatic int\nvirStorageBackendLogicalParseVolExtents(virStorageVolDefPtr vol,\n                                        char **const groups)\n{\n    g_autoptr(GRegex) re = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    int nextents, ret = -1;\n    const char *regex_unit = \"(\\\\S+)\\\\((\\\\S+)\\\\)\";\n    size_t i;\n    unsigned long long offset, size, length;\n    virStorageVolSourceExtent extent;\n    g_autofree char *regex = NULL;\n\n    memset(&extent, 0, sizeof(extent));\n\n    /* Assume 1 extent (the regex for 'devices' is \"(\\\\S+)\") and only\n     * check the 'stripes' field if we have a striped, mirror, or one of\n     * the raid (raid1, raid4, raid5*, raid6*, or raid10) segtypes in which\n     * case the stripes field will denote the number of lv's within the\n     * 'devices' field in order to generate the proper regex to decode\n     * the field\n     */\n    nextents = 1;\n    if (STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED) ||\n        STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR) ||\n        STRPREFIX(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID)) {\n        if (virStrToLong_i(groups[5], NULL, 10, &nextents) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent stripes value\"));\n            goto cleanup;\n        }\n    }\n\n    if (virStrToLong_ull(groups[6], NULL, 10, &length) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent length value\"));\n        goto cleanup;\n    }\n\n    if (virStrToLong_ull(groups[7], NULL, 10, &size) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent size value\"));\n        goto cleanup;\n    }\n\n    /* Allocate space for 'nextents' regex_unit strings plus a comma for each */\n    if (VIR_ALLOC_N(regex, nextents * (strlen(regex_unit) + 1) + 1) < 0)\n        goto cleanup;\n    strcat(regex, regex_unit);\n    for (i = 1; i < nextents; i++) {\n        /* \",\" is the separator of \"devices\" field */\n        strcat(regex, \",\");\n        strcat(regex, regex_unit);\n    }\n\n    re = g_regex_new(regex, 0, 0, &err);\n    if (!re) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(re, groups[3], 0, &info)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"malformed volume extent devices value\"));\n        goto cleanup;\n    }\n\n    /* Each extent has a \"path:offset\" pair, and match #0\n     * is the whole matched string.\n     */\n    for (i = 0; i < nextents; i++) {\n        size_t j;\n        g_autofree char *offset_str = NULL;\n\n        j = (i * 2) + 1;\n        extent.path = g_match_info_fetch(info, j);\n        offset_str = g_match_info_fetch(info, j + 1);\n\n        if (virStrToLong_ull(offset_str, NULL, 10, &offset) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent offset value\"));\n            goto cleanup;\n        }\n        extent.start = offset * size;\n        extent.end = (offset * size) + length;\n\n        if (VIR_APPEND_ELEMENT(vol->source.extents, vol->source.nextent,\n                               extent) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(extent.path);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed volume allocation value\")"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed volume allocation value\""
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "groups[8]",
            "NULL",
            "10",
            "&vol->target.allocation"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolInfo",
          "args": [
            "vol",
            "false",
            "VIR_STORAGE_VOL_OPEN_DEFAULT",
            "0"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1781-1805",
          "snippet": "int\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolInfo(virStorageVolDefPtr vol,\n                               bool withBlockVolFormat,\n                               unsigned int openflags,\n                               unsigned int readflags)\n{\n    int ret;\n\n    if ((ret = storageBackendUpdateVolTargetInfo(vol->type,\n                                                 &vol->target,\n                                                 withBlockVolFormat,\n                                                 openflags, readflags)) < 0)\n        return ret;\n\n    if (virStorageSourceHasBacking(&vol->target) &&\n        (ret = storageBackendUpdateVolTargetInfo(VIR_STORAGE_VOL_FILE,\n                                                 vol->target.backingStore,\n                                                 withBlockVolFormat,\n                                                 VIR_STORAGE_VOL_OPEN_DEFAULT |\n                                                 VIR_STORAGE_VOL_OPEN_NOERROR,\n                                                 readflags)) == -1)\n        return ret;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "groups[1]",
            "\"\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefFindByName",
          "args": [
            "pool",
            "groups[0]"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "841-854",
          "snippet": "virStorageVolDefPtr\nvirStorageVolDefFindByName(virStoragePoolObjPtr obj,\n                           const char *name)\n{\n    virStorageVolObjPtr volobj;\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashLookup(obj->volumes->objsName, name);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n    return NULL;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStorageVolDefPtr\nvirStorageVolDefFindByName(virStoragePoolObjPtr obj,\n                           const char *name)\n{\n    virStorageVolObjPtr volobj;\n\n    virObjectRWLockRead(obj->volumes);\n    volobj = virHashLookup(obj->volumes->objsName, name);\n    virObjectRWUnlock(obj->volumes);\n\n    if (volobj)\n        return volobj->voldef;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vol->name",
            "groups[0]"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalMakeVol(char **const groups,\n                                void *opaque)\n{\n    struct virStorageBackendLogicalPoolVolData *data = opaque;\n    virStoragePoolObjPtr pool = data->pool;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStorageVolDefPtr vol = NULL;\n    bool is_new_vol = false;\n    int ret = -1;\n    const char *attrs = groups[9];\n\n    /* Skip inactive volume */\n    if (attrs[4] != 'a')\n        return 0;\n\n    /*\n     * Skip thin pools(t). These show up in normal lvs output\n     * but do not have a corresponding /dev/$vg/$lv device that\n     * is created by udev. This breaks assumptions in later code.\n     */\n    if (attrs[0] == 't')\n        return 0;\n\n    /* See if we're only looking for a specific volume */\n    if (data->vol != NULL) {\n        vol = data->vol;\n        if (STRNEQ(vol->name, groups[0]))\n            return 0;\n    }\n\n    /* Or filling in more data on an existing volume */\n    if (vol == NULL)\n        vol = virStorageVolDefFindByName(pool, groups[0]);\n\n    /* Or a completely new volume */\n    if (vol == NULL) {\n        if (VIR_ALLOC(vol) < 0)\n            return -1;\n\n        is_new_vol = true;\n        vol->type = VIR_STORAGE_VOL_BLOCK;\n\n        vol->name = g_strdup(groups[0]);\n\n    }\n\n    if (vol->target.path == NULL)\n        vol->target.path = g_strdup_printf(\"%s/%s\", def->target.path, vol->name);\n\n    /* Mark the (s) sparse/snapshot lv, e.g. the lv created using\n     * the --virtualsize/-V option. We've already ignored the (t)hin\n     * pool definition. In the manner libvirt defines these, the\n     * thin pool is hidden to the lvs output, except as the name\n     * in brackets [] described for the groups[1] (backingStore).\n     */\n    if (attrs[0] == 's')\n        vol->target.sparse = true;\n\n    /* Skips the backingStore of lv created with \"--virtualsize\",\n     * its original device \"/dev/$vgname/$lvname_vorigin\" is\n     * just for lvm internal use, one should never use it.\n     *\n     * (lvs outputs \"[$lvname_vorigin] for field \"origin\" if the\n     *  lv is created with \"--virtualsize\").\n     */\n    if (groups[1] && STRNEQ(groups[1], \"\") && (groups[1][0] != '[')) {\n        if (!(vol->target.backingStore = virStorageSourceNew()))\n            goto cleanup;\n\n        vol->target.backingStore->path = g_strdup_printf(\"%s/%s\",\n                                                         def->target.path, groups[1]);\n\n        vol->target.backingStore->format = VIR_STORAGE_POOL_LOGICAL_LVM2;\n        vol->target.backingStore->type = VIR_STORAGE_TYPE_BLOCK;\n    }\n\n    if (!vol->key)\n        vol->key = g_strdup(groups[2]);\n\n    if (virStorageBackendUpdateVolInfo(vol, false,\n                                       VIR_STORAGE_VOL_OPEN_DEFAULT, 0) < 0)\n        goto cleanup;\n\n    if (virStrToLong_ull(groups[8], NULL, 10, &vol->target.allocation) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume allocation value\"));\n        goto cleanup;\n    }\n\n    if (virStorageBackendLogicalParseVolExtents(vol, groups) < 0)\n        goto cleanup;\n\n    if (is_new_vol && virStoragePoolObjAddVol(pool, vol) < 0)\n        goto cleanup;\n    vol = NULL;\n\n    ret = 0;\n\n cleanup:\n    if (is_new_vol)\n        virStorageVolDefFree(vol);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalParseVolExtents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "119-217",
    "snippet": "static int\nvirStorageBackendLogicalParseVolExtents(virStorageVolDefPtr vol,\n                                        char **const groups)\n{\n    g_autoptr(GRegex) re = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    int nextents, ret = -1;\n    const char *regex_unit = \"(\\\\S+)\\\\((\\\\S+)\\\\)\";\n    size_t i;\n    unsigned long long offset, size, length;\n    virStorageVolSourceExtent extent;\n    g_autofree char *regex = NULL;\n\n    memset(&extent, 0, sizeof(extent));\n\n    /* Assume 1 extent (the regex for 'devices' is \"(\\\\S+)\") and only\n     * check the 'stripes' field if we have a striped, mirror, or one of\n     * the raid (raid1, raid4, raid5*, raid6*, or raid10) segtypes in which\n     * case the stripes field will denote the number of lv's within the\n     * 'devices' field in order to generate the proper regex to decode\n     * the field\n     */\n    nextents = 1;\n    if (STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED) ||\n        STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR) ||\n        STRPREFIX(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID)) {\n        if (virStrToLong_i(groups[5], NULL, 10, &nextents) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent stripes value\"));\n            goto cleanup;\n        }\n    }\n\n    if (virStrToLong_ull(groups[6], NULL, 10, &length) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent length value\"));\n        goto cleanup;\n    }\n\n    if (virStrToLong_ull(groups[7], NULL, 10, &size) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent size value\"));\n        goto cleanup;\n    }\n\n    /* Allocate space for 'nextents' regex_unit strings plus a comma for each */\n    if (VIR_ALLOC_N(regex, nextents * (strlen(regex_unit) + 1) + 1) < 0)\n        goto cleanup;\n    strcat(regex, regex_unit);\n    for (i = 1; i < nextents; i++) {\n        /* \",\" is the separator of \"devices\" field */\n        strcat(regex, \",\");\n        strcat(regex, regex_unit);\n    }\n\n    re = g_regex_new(regex, 0, 0, &err);\n    if (!re) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(re, groups[3], 0, &info)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"malformed volume extent devices value\"));\n        goto cleanup;\n    }\n\n    /* Each extent has a \"path:offset\" pair, and match #0\n     * is the whole matched string.\n     */\n    for (i = 0; i < nextents; i++) {\n        size_t j;\n        g_autofree char *offset_str = NULL;\n\n        j = (i * 2) + 1;\n        extent.path = g_match_info_fetch(info, j);\n        offset_str = g_match_info_fetch(info, j + 1);\n\n        if (virStrToLong_ull(offset_str, NULL, 10, &offset) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent offset value\"));\n            goto cleanup;\n        }\n        extent.start = offset * size;\n        extent.end = (offset * size) + length;\n\n        if (VIR_APPEND_ELEMENT(vol->source.extents, vol->source.nextent,\n                               extent) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(extent.path);\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID    \"raid\"",
      "#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR  \"mirror\"",
      "#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED \"striped\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "extent.path"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "vol->source.extents",
            "vol->source.nextent",
            "extent"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed volume extent offset value\")"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed volume extent offset value\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "offset_str",
            "NULL",
            "10",
            "&offset"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_match_info_fetch",
          "args": [
            "info",
            "j + 1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_match_info_fetch",
          "args": [
            "info",
            "j"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed volume extent devices value\")"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_match",
          "args": [
            "re",
            "groups[3]",
            "0",
            "&info"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to compile regex %s\")",
            "err->message"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_new",
          "args": [
            "regex",
            "0",
            "0",
            "&err"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "regex",
            "regex_unit"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "regex",
            "\",\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "regex",
            "regex_unit"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "regex",
            "nextents * (strlen(regex_unit) + 1) + 1"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "regex_unit"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed volume extent size value\")"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed volume extent length value\")"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed volume extent stripes value\")"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "groups[5]",
            "NULL",
            "10",
            "&nextents"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "groups[4]",
            "VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[4]",
            "VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "groups[4]",
            "VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&extent",
            "0",
            "sizeof(extent)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID    \"raid\"\n#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR  \"mirror\"\n#define VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED \"striped\"\n\nstatic int\nvirStorageBackendLogicalParseVolExtents(virStorageVolDefPtr vol,\n                                        char **const groups)\n{\n    g_autoptr(GRegex) re = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    int nextents, ret = -1;\n    const char *regex_unit = \"(\\\\S+)\\\\((\\\\S+)\\\\)\";\n    size_t i;\n    unsigned long long offset, size, length;\n    virStorageVolSourceExtent extent;\n    g_autofree char *regex = NULL;\n\n    memset(&extent, 0, sizeof(extent));\n\n    /* Assume 1 extent (the regex for 'devices' is \"(\\\\S+)\") and only\n     * check the 'stripes' field if we have a striped, mirror, or one of\n     * the raid (raid1, raid4, raid5*, raid6*, or raid10) segtypes in which\n     * case the stripes field will denote the number of lv's within the\n     * 'devices' field in order to generate the proper regex to decode\n     * the field\n     */\n    nextents = 1;\n    if (STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_STRIPED) ||\n        STREQ(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_MIRROR) ||\n        STRPREFIX(groups[4], VIR_STORAGE_VOL_LOGICAL_SEGTYPE_RAID)) {\n        if (virStrToLong_i(groups[5], NULL, 10, &nextents) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent stripes value\"));\n            goto cleanup;\n        }\n    }\n\n    if (virStrToLong_ull(groups[6], NULL, 10, &length) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent length value\"));\n        goto cleanup;\n    }\n\n    if (virStrToLong_ull(groups[7], NULL, 10, &size) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed volume extent size value\"));\n        goto cleanup;\n    }\n\n    /* Allocate space for 'nextents' regex_unit strings plus a comma for each */\n    if (VIR_ALLOC_N(regex, nextents * (strlen(regex_unit) + 1) + 1) < 0)\n        goto cleanup;\n    strcat(regex, regex_unit);\n    for (i = 1; i < nextents; i++) {\n        /* \",\" is the separator of \"devices\" field */\n        strcat(regex, \",\");\n        strcat(regex, regex_unit);\n    }\n\n    re = g_regex_new(regex, 0, 0, &err);\n    if (!re) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(re, groups[3], 0, &info)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"malformed volume extent devices value\"));\n        goto cleanup;\n    }\n\n    /* Each extent has a \"path:offset\" pair, and match #0\n     * is the whole matched string.\n     */\n    for (i = 0; i < nextents; i++) {\n        size_t j;\n        g_autofree char *offset_str = NULL;\n\n        j = (i * 2) + 1;\n        extent.path = g_match_info_fetch(info, j);\n        offset_str = g_match_info_fetch(info, j + 1);\n\n        if (virStrToLong_ull(offset_str, NULL, 10, &offset) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed volume extent offset value\"));\n            goto cleanup;\n        }\n        extent.start = offset * size;\n        extent.end = (offset * size) + length;\n\n        if (VIR_APPEND_ELEMENT(vol->source.extents, vol->source.nextent,\n                               extent) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(extent.path);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendLogicalInitializeDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "88-107",
    "snippet": "static int\nvirStorageBackendLogicalInitializeDevice(const char *path)\n{\n    g_autoptr(virCommand) pvcmd = NULL;\n\n    /*\n     * LVM requires that the first sector is blanked if using\n     * a whole disk as a PV. So we just blank them out regardless\n     * rather than trying to figure out if we're a disk or partition\n     */\n    if (virStorageBackendZeroPartitionTable(path, 1024 * 1024) < 0)\n        return -1;\n\n    /*\n     * Initialize the physical volume because vgcreate is not\n     * clever enough todo this for us :-(\n     */\n    pvcmd = virCommandNewArgList(PVCREATE, path, NULL);\n    return virCommandRun(pvcmd, NULL);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "pvcmd",
            "NULL"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "PVCREATE",
            "path",
            "NULL"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendZeroPartitionTable",
          "args": [
            "path",
            "1024 * 1024"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendZeroPartitionTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4014-4024",
          "snippet": "int\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendZeroPartitionTable(const char *path,\n                                    unsigned long long size)\n{\n    if (storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                       size, false) < 0)\n        return -1;\n\n    return storageBackendVolWipeLocalFile(path, VIR_STORAGE_VOL_WIPE_ALG_ZERO,\n                                          size, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalInitializeDevice(const char *path)\n{\n    g_autoptr(virCommand) pvcmd = NULL;\n\n    /*\n     * LVM requires that the first sector is blanked if using\n     * a whole disk as a PV. So we just blank them out regardless\n     * rather than trying to figure out if we're a disk or partition\n     */\n    if (virStorageBackendZeroPartitionTable(path, 1024 * 1024) < 0)\n        return -1;\n\n    /*\n     * Initialize the physical volume because vgcreate is not\n     * clever enough todo this for us :-(\n     */\n    pvcmd = virCommandNewArgList(PVCREATE, path, NULL);\n    return virCommandRun(pvcmd, NULL);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalRemoveDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "70-78",
    "snippet": "static void\nvirStorageBackendLogicalRemoveDevice(const char *path)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PVREMOVE, path, NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_INFO(\"Failed to pvremove logical device '%s'\", path);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Failed to pvremove logical device '%s'\"",
            "path"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "PVREMOVE",
            "path",
            "NULL"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendLogicalRemoveDevice(const char *path)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    cmd = virCommandNewArgList(PVREMOVE, path, NULL);\n    if (virCommandRun(cmd, NULL) < 0)\n        VIR_INFO(\"Failed to pvremove logical device '%s'\", path);\n}"
  },
  {
    "function_name": "virStorageBackendLogicalSetActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_logical.c",
    "lines": "46-61",
    "snippet": "static int\nvirStorageBackendLogicalSetActive(virStoragePoolObjPtr pool,\n                                  bool on)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n    int ret;\n\n    cmd = virStorageBackendLogicalChangeCmd(VGCHANGE, def, on);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_logical.h\"",
      "#include \"virerror.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "pool"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "pool"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendLogicalChangeCmd",
          "args": [
            "VGCHANGE",
            "def",
            "on"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendLogicalChangeCmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "4177-4186",
          "snippet": "virCommandPtr\nvirStorageBackendLogicalChangeCmd(const char *cmdstr,\n                                  virStoragePoolDefPtr def,\n                                  bool on)\n{\n    return virCommandNewArgList(cmdstr,\n                                on ? \"-aly\" : \"-aln\",\n                                def->source.name,\n                                NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirCommandPtr\nvirStorageBackendLogicalChangeCmd(const char *cmdstr,\n                                  virStoragePoolDefPtr def,\n                                  bool on)\n{\n    return virCommandNewArgList(cmdstr,\n                                on ? \"-aly\" : \"-aln\",\n                                def->source.name,\n                                NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_logical.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendLogicalSetActive(virStoragePoolObjPtr pool,\n                                  bool on)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    g_autoptr(virCommand) cmd = NULL;\n    int ret;\n\n    cmd = virStorageBackendLogicalChangeCmd(VGCHANGE, def, on);\n\n    virObjectUnlock(pool);\n    ret = virCommandRun(cmd, NULL);\n    virObjectLock(pool);\n\n    return ret;\n}"
  }
]